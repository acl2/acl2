(UNSET-WATERFALL-PARALLELISM)
(ASSIGN SCRIPT-MODE T)
 T
(SET-LD-PROMPT T STATE)
 T
ACL2 !>>(SET-INHIBITED-SUMMARY-TYPES '(TIME STEPS))
 (TIME STEPS)
ACL2 !>>(SET-INHIBIT-OUTPUT-LST '(PROOF-TREE))
 (PROOF-TREE)
ACL2 !>>(SET-GAG-MODE NIL)
<state>
ACL2 !>>(SET-GUARD-CHECKING NIL)
ACL2 >>'(END OF SETUP)
(END OF SETUP)
ACL2 >>(CONS 2 NIL)
(2)
ACL2 >>(CONS 1 (CONS 2 NIL))
(1 2)
ACL2 >>(IF T 1 2)
1
ACL2 >>(IF NIL 1 2)
2
ACL2 >>(NTH 2 '(A B C D E))
C
ACL2 >>(UPDATE-NTH 2 'H '(A B C D E))
(A B H D E)
ACL2 >>(DEFUN APP (X Y)
              (IF (ENDP X)
                  Y (CONS (CAR X) (APP (CDR X) Y))))

The admission of APP is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of APP is described by the
theorem (OR (CONSP (APP X Y)) (EQUAL (APP X Y) Y)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN APP ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 APP
ACL2 >>(APP '(1 2 3) '(4 5 6))
(1 2 3 4 5 6)
ACL2 >>(DEFTHM APP-IS-ASSOCIATIVE
               (EQUAL (APP (APP A B) C)
                      (APP A (APP B C))))

Name the formula above *1.

Perhaps we can prove *1 by induction.  Three induction schemes are
suggested by this conjecture.  Subsumption reduces that number to two.
However, one of these is flawed and so we are left with one viable
candidate.  

We will induct according to a scheme suggested by (APP A B).  This
suggestion was produced using the :induction rule APP.  If we let (:P A B C)
denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP A)) (:P (CDR A) B C))
              (:P A B C))
     (IMPLIES (ENDP A) (:P A B C))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP A))
              (EQUAL (APP (APP (CDR A) B) C)
                     (APP (CDR A) (APP B C))))
         (EQUAL (APP (APP A B) C)
                (APP A (APP B C)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (EQUAL (APP (APP (CDR A) B) C)
                     (APP (CDR A) (APP B C))))
         (EQUAL (APP (APP A B) C)
                (APP A (APP B C)))).

But simplification reduces this to T, using the :definition APP, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (ENDP A)
         (EQUAL (APP (APP A B) C)
                (APP A (APP B C)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP A))
         (EQUAL (APP (APP A B) C)
                (APP A (APP B C)))).

But simplification reduces this to T, using the :definition APP and
primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM APP-IS-ASSOCIATIVE ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION ENDP)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
 APP-IS-ASSOCIATIVE
ACL2 >>'(END OF DEMO 1)
(END OF DEMO 1)
ACL2 >>(DEFUN INSERT (E X)
              (IF (ENDP X)
                  (CONS E X)
                  (IF (LEXORDER E (CAR X))
                      (CONS E X)
                      (CONS (CAR X) (INSERT E (CDR X))))))

The admission of INSERT is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of INSERT is described by
the theorem (CONSP (INSERT E X)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN INSERT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 INSERT
ACL2 >>(INSERT 3 '(1 2 4 5))
(1 2 3 4 5)
ACL2 >>(INSERT 'BRAVO '(ALPHA CHARLIE DOG))
(ALPHA BRAVO CHARLIE DOG)
ACL2 >>(DEFUN ISORT (X)
              (IF (ENDP X)
                  X (INSERT (CAR X) (ISORT (CDR X)))))

The admission of ISORT is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We could deduce no constraints on the type of ISORT.

Summary
Form:  ( DEFUN ISORT ...)
Rules: NIL
 ISORT
ACL2 >>(ISORT '(5 1 3 2 4))
(1 2 3 4 5)
ACL2 >>(ISORT '(CHARLIE ALPHA DOG BRAVO))
(ALPHA BRAVO CHARLIE DOG)
ACL2 >>(DEFUN ORDEREDP (X)
              (IF (ENDP X)
                  T
                  (IF (ENDP (CDR X))
                      T
                      (AND (LEXORDER (CAR X) (CAR (CDR X)))
                           (ORDEREDP (CDR X))))))

The admission of ORDEREDP is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We observe that the type of ORDEREDP is described
by the theorem (OR (EQUAL (ORDEREDP X) T) (EQUAL (ORDEREDP X) NIL)).

Summary
Form:  ( DEFUN ORDEREDP ...)
Rules: NIL
 ORDEREDP
ACL2 >>(ORDEREDP '(1 2 3 3 4 5))
T
ACL2 >>(ORDEREDP '(1 2 3 4 3 5))
NIL
ACL2 >>(DEFTHM ORDEREDP-ISORT (ORDEREDP (ISORT X)))

Name the formula above *1.

Perhaps we can prove *1 by induction.  One induction scheme is suggested
by this conjecture.  

We will induct according to a scheme suggested by (ISORT X).  This
suggestion was produced using the :induction rule ISORT.  If we let
(:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP X)) (:P (CDR X)))
              (:P X))
     (IMPLIES (ENDP X) (:P X))).
This induction is justified by the same argument used to admit ISORT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (ORDEREDP (ISORT (CDR X))))
         (ORDEREDP (ISORT X))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (ORDEREDP (ISORT (CDR X))))
         (ORDEREDP (ISORT X))).

This simplifies, using the :definition ISORT, to

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (ORDEREDP (ISORT (CDR X))))
         (ORDEREDP (INSERT (CAR X) (ISORT (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2'''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (ORDEREDP (ISORT X2)))
         (ORDEREDP (INSERT X1 (ISORT X2)))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2'4'
(IMPLIES (ORDEREDP (ISORT X2))
         (ORDEREDP (INSERT X1 (ISORT X2)))).

We generalize this conjecture, replacing (ISORT X2) by IT.  This produces

Subgoal *1/2'5'
(IMPLIES (ORDEREDP IT)
         (ORDEREDP (INSERT X1 IT))).

Name the formula above *1.1.

Subgoal *1/1
(IMPLIES (ENDP X) (ORDEREDP (ISORT X))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (ORDEREDP (ISORT X))).

But simplification reduces this to T, using the :definitions ISORT
and ORDEREDP.

So we now return to *1.1, which is

(IMPLIES (ORDEREDP IT)
         (ORDEREDP (INSERT X1 IT))).

Perhaps we can prove *1.1 by induction.  Two induction schemes are
suggested by this conjecture.  These merge into one derived induction
scheme.  

We will induct according to a scheme suggested by (INSERT X1 IT). 
This suggestion was produced using the :induction rules INSERT and
ORDEREDP.  If we let (:P IT X1) denote *1.1 above then the induction
scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT))
                   (NOT (LEXORDER X1 (CAR IT)))
                   (:P (CDR IT) X1))
              (:P IT X1))
     (IMPLIES (AND (NOT (ENDP IT))
                   (LEXORDER X1 (CAR IT)))
              (:P IT X1))
     (IMPLIES (ENDP IT) (:P IT X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.1/4
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER X1 (CAR IT)))
              (ORDEREDP (INSERT X1 (CDR IT)))
              (ORDEREDP IT))
         (ORDEREDP (INSERT X1 IT))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/4'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (ORDEREDP (INSERT X1 (CDR IT)))
              (ORDEREDP IT))
         (ORDEREDP (INSERT X1 IT))).

This simplifies, using the :definitions INSERT and ORDEREDP (if-intro),
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rules INSERT, LEXORDER and ORDEREDP, to
the following two conjectures.

Subgoal *1.1/4.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (ORDEREDP (INSERT X1 (CDR IT)))
              (NOT (CONSP (CDR IT))))
         (LEXORDER (CAR IT)
                   (CAR (INSERT X1 (CDR IT))))).

But simplification reduces this to T, using the :definitions INSERT
and ORDEREDP, primitive type reasoning, the :forward-chaining rule
LEXORDER-TOTAL, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1/4.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (ORDEREDP (INSERT X1 (CDR IT)))
              (LEXORDER (CAR IT) (CADR IT))
              (ORDEREDP (CDR IT)))
         (LEXORDER (CAR IT)
                   (CAR (INSERT X1 (CDR IT))))).

The destructor terms (CAR IT) and (CDR IT) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace IT by (CONS IT1 IT2),
(CAR IT) by IT1 and (CDR IT) by IT2.  (2) Use CAR-CDR-ELIM, again,
to replace IT2 by (CONS IT3 IT4), (CAR IT2) by IT3 and (CDR IT2) by
IT4.  These steps produce the following two goals.

Subgoal *1.1/4.1.2
(IMPLIES (AND (NOT (CONSP IT2))
              (CONSP (CONS IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (ORDEREDP (INSERT X1 IT2))
              (LEXORDER IT1 (CAR IT2))
              (ORDEREDP IT2))
         (LEXORDER IT1 (CAR (INSERT X1 IT2)))).

But simplification reduces this to T, using the :definitions INSERT
and ORDEREDP, primitive type reasoning, the :forward-chaining rule
LEXORDER-TOTAL, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

Subgoal *1.1/4.1.1
(IMPLIES (AND (CONSP (CONS IT3 IT4))
              (CONSP (LIST* IT1 IT3 IT4))
              (NOT (LEXORDER X1 IT1))
              (ORDEREDP (INSERT X1 (CONS IT3 IT4)))
              (LEXORDER IT1 IT3)
              (ORDEREDP (CONS IT3 IT4)))
         (LEXORDER IT1 (CAR (INSERT X1 (CONS IT3 IT4))))).

But simplification reduces this to T, using the :definitions INSERT
and ORDEREDP, primitive type reasoning, the :forward-chaining rule
LEXORDER-TOTAL, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1/3
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER X1 (CAR IT)))
              (NOT (ORDEREDP (CDR IT)))
              (ORDEREDP IT))
         (ORDEREDP (INSERT X1 IT))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/3'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (NOT (ORDEREDP (CDR IT)))
              (ORDEREDP IT))
         (ORDEREDP (INSERT X1 IT))).

This simplifies, using the :definitions INSERT and ORDEREDP (if-intro),
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule INSERT, to the following two conjectures.

Subgoal *1.1/3.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (NOT (ORDEREDP (CDR IT)))
              (NOT (CONSP (CDR IT))))
         (LEXORDER (CAR IT)
                   (CAR (INSERT X1 (CDR IT))))).

But simplification reduces this to T, using the :definition ORDEREDP.

Subgoal *1.1/3.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (NOT (ORDEREDP (CDR IT)))
              (NOT (CONSP (CDR IT))))
         (ORDEREDP (INSERT X1 (CDR IT)))).

But simplification reduces this to T, using the :definition ORDEREDP.

Subgoal *1.1/2
(IMPLIES (AND (NOT (ENDP IT))
              (LEXORDER X1 (CAR IT))
              (ORDEREDP IT))
         (ORDEREDP (INSERT X1 IT))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/2'
(IMPLIES (AND (CONSP IT)
              (LEXORDER X1 (CAR IT))
              (ORDEREDP IT))
         (ORDEREDP (INSERT X1 IT))).

But simplification reduces this to T, using the :definitions INSERT
and ORDEREDP, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-
prescription rules LEXORDER and ORDEREDP.

Subgoal *1.1/1
(IMPLIES (AND (ENDP IT) (ORDEREDP IT))
         (ORDEREDP (INSERT X1 IT))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/1'
(IMPLIES (AND (NOT (CONSP IT)) (ORDEREDP IT))
         (ORDEREDP (INSERT X1 IT))).

But simplification reduces this to T, using the :definitions INSERT
and ORDEREDP, primitive type reasoning and the :rewrite rule CDR-CONS.

That completes the proofs of *1.1 and *1.

Q.E.D.

The storage of ORDEREDP-ISORT depends upon the :type-prescription rule
ORDEREDP.

Summary
Form:  ( DEFTHM ORDEREDP-ISORT ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION INSERT)
        (:DEFINITION ISORT)
        (:DEFINITION NOT)
        (:DEFINITION ORDEREDP)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:INDUCTION INSERT)
        (:INDUCTION ISORT)
        (:INDUCTION ORDEREDP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION INSERT)
        (:TYPE-PRESCRIPTION LEXORDER)
        (:TYPE-PRESCRIPTION ORDEREDP))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ORDEREDP))
 ORDEREDP-ISORT
ACL2 >>(DEFTHM ISORT-ISORT
               (EQUAL (ISORT (ISORT X)) (ISORT X)))

Name the formula above *1.

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (ISORT X).  This
suggestion was produced using the :induction rule ISORT.  If we let
(:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP X)) (:P (CDR X)))
              (:P X))
     (IMPLIES (ENDP X) (:P X))).
This induction is justified by the same argument used to admit ISORT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (EQUAL (ISORT (ISORT (CDR X)))
                     (ISORT (CDR X))))
         (EQUAL (ISORT (ISORT X)) (ISORT X))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL (ISORT (ISORT (CDR X)))
                     (ISORT (CDR X))))
         (EQUAL (ISORT (ISORT X)) (ISORT X))).

This simplifies, using the :definition ISORT, to

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (EQUAL (ISORT (ISORT (CDR X)))
                     (ISORT (CDR X))))
         (EQUAL (ISORT (INSERT (CAR X) (ISORT (CDR X))))
                (INSERT (CAR X) (ISORT (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2'''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (ISORT (ISORT X2)) (ISORT X2)))
         (EQUAL (ISORT (INSERT X1 (ISORT X2)))
                (INSERT X1 (ISORT X2)))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2'4'
(IMPLIES (EQUAL (ISORT (ISORT X2)) (ISORT X2))
         (EQUAL (ISORT (INSERT X1 (ISORT X2)))
                (INSERT X1 (ISORT X2)))).

We now use the hypothesis by cross-fertilizing (ISORT (ISORT X2)) for
(ISORT X2) and throwing away the hypothesis.  This produces

Subgoal *1/2'5'
(EQUAL (ISORT (INSERT X1 (ISORT X2)))
       (INSERT X1 (ISORT (ISORT X2)))).

We generalize this conjecture, replacing (ISORT X2) by IT.  This produces

Subgoal *1/2'6'
(EQUAL (ISORT (INSERT X1 IT))
       (INSERT X1 (ISORT IT))).

Name the formula above *1.1.

Subgoal *1/1
(IMPLIES (ENDP X)
         (EQUAL (ISORT (ISORT X)) (ISORT X))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (EQUAL (ISORT (ISORT X)) (ISORT X))).

But simplification reduces this to T, using the :definition ISORT and
primitive type reasoning.

So we now return to *1.1, which is

(EQUAL (ISORT (INSERT X1 IT))
       (INSERT X1 (ISORT IT))).

Perhaps we can prove *1.1 by induction.  Two induction schemes are
suggested by this conjecture.  Subsumption reduces that number to one.

We will induct according to a scheme suggested by (INSERT X1 IT). 
This suggestion was produced using the :induction rules INSERT and
ISORT.  If we let (:P IT X1) denote *1.1 above then the induction scheme
we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT))
                   (NOT (LEXORDER X1 (CAR IT)))
                   (:P (CDR IT) X1))
              (:P IT X1))
     (IMPLIES (AND (NOT (ENDP IT))
                   (LEXORDER X1 (CAR IT)))
              (:P IT X1))
     (IMPLIES (ENDP IT) (:P IT X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1.1/3
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER X1 (CAR IT)))
              (EQUAL (ISORT (INSERT X1 (CDR IT)))
                     (INSERT X1 (ISORT (CDR IT)))))
         (EQUAL (ISORT (INSERT X1 IT))
                (INSERT X1 (ISORT IT)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/3'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (EQUAL (ISORT (INSERT X1 (CDR IT)))
                     (INSERT X1 (ISORT (CDR IT)))))
         (EQUAL (ISORT (INSERT X1 IT))
                (INSERT X1 (ISORT IT)))).

This simplifies, using the :definitions INSERT and ISORT, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1.1/3''
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (EQUAL (ISORT (INSERT X1 (CDR IT)))
                     (INSERT X1 (ISORT (CDR IT)))))
         (EQUAL (INSERT (CAR IT)
                        (INSERT X1 (ISORT (CDR IT))))
                (INSERT X1
                        (INSERT (CAR IT) (ISORT (CDR IT)))))).

The destructor terms (CAR IT) and (CDR IT) can be eliminated by using
CAR-CDR-ELIM to replace IT by (CONS IT1 IT2), (CAR IT) by IT1 and (CDR IT)
by IT2.  This produces the following goal.

Subgoal *1.1/3'''
(IMPLIES (AND (CONSP (CONS IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (EQUAL (ISORT (INSERT X1 IT2))
                     (INSERT X1 (ISORT IT2))))
         (EQUAL (INSERT IT1 (INSERT X1 (ISORT IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1/3'4'
(IMPLIES (AND (NOT (LEXORDER X1 IT1))
              (EQUAL (ISORT (INSERT X1 IT2))
                     (INSERT X1 (ISORT IT2))))
         (EQUAL (INSERT IT1 (INSERT X1 (ISORT IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

We now use the second hypothesis by substituting (ISORT (INSERT X1 IT2))
for (INSERT X1 (ISORT IT2)) and throwing away the hypothesis.  This
produces

Subgoal *1.1/3'5'
(IMPLIES (NOT (LEXORDER X1 IT1))
         (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

Name the formula above *1.1.1.

Subgoal *1.1/2
(IMPLIES (AND (NOT (ENDP IT))
              (LEXORDER X1 (CAR IT)))
         (EQUAL (ISORT (INSERT X1 IT))
                (INSERT X1 (ISORT IT)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/2'
(IMPLIES (AND (CONSP IT) (LEXORDER X1 (CAR IT)))
         (EQUAL (ISORT (INSERT X1 IT))
                (INSERT X1 (ISORT IT)))).

This simplifies, using the :definitions INSERT and ISORT, the :rewrite
rules LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to

Subgoal *1.1/2''
(IMPLIES (AND (CONSP IT) (LEXORDER X1 (CAR IT)))
         (EQUAL (ISORT (CONS X1 IT))
                (INSERT X1
                        (INSERT (CAR IT) (ISORT (CDR IT)))))).

But simplification reduces this to T, using the :definition ISORT,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1.1/1
(IMPLIES (ENDP IT)
         (EQUAL (ISORT (INSERT X1 IT))
                (INSERT X1 (ISORT IT)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/1'
(IMPLIES (NOT (CONSP IT))
         (EQUAL (ISORT (INSERT X1 IT))
                (INSERT X1 (ISORT IT)))).

But simplification reduces this to T, using the :definitions INSERT
and ISORT, primitive type reasoning and the :rewrite rules CAR-CONS
and CDR-CONS.

So we now return to *1.1.1, which is

(IMPLIES (NOT (LEXORDER X1 IT1))
         (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

Perhaps we can prove *1.1.1 by induction.  Two induction schemes are
suggested by this conjecture.  Subsumption reduces that number to one.

We will induct according to a scheme suggested by (INSERT X1 IT2).
This suggestion was produced using the :induction rules INSERT and
ISORT.  If we let (:P IT1 IT2 X1) denote *1.1.1 above then the induction
scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT2))
                   (NOT (LEXORDER X1 (CAR IT2)))
                   (:P IT1 (CDR IT2) X1))
              (:P IT1 IT2 X1))
     (IMPLIES (AND (NOT (ENDP IT2))
                   (LEXORDER X1 (CAR IT2)))
              (:P IT1 IT2 X1))
     (IMPLIES (ENDP IT2) (:P IT1 IT2 X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1.1.1/3
(IMPLIES (AND (NOT (ENDP IT2))
              (NOT (LEXORDER X1 (CAR IT2)))
              (EQUAL (INSERT IT1 (ISORT (INSERT X1 (CDR IT2))))
                     (INSERT X1 (INSERT IT1 (ISORT (CDR IT2)))))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1/3'
(IMPLIES (AND (CONSP IT2)
              (NOT (LEXORDER X1 (CAR IT2)))
              (EQUAL (INSERT IT1 (ISORT (INSERT X1 (CDR IT2))))
                     (INSERT X1 (INSERT IT1 (ISORT (CDR IT2)))))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

This simplifies, using the :definitions INSERT and ISORT, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1.1.1/3''
(IMPLIES (AND (CONSP IT2)
              (NOT (LEXORDER X1 (CAR IT2)))
              (EQUAL (INSERT IT1 (ISORT (INSERT X1 (CDR IT2))))
                     (INSERT X1 (INSERT IT1 (ISORT (CDR IT2)))))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1
                        (INSERT (CAR IT2)
                                (ISORT (INSERT X1 (CDR IT2)))))
                (INSERT X1
                        (INSERT IT1
                                (INSERT (CAR IT2)
                                        (ISORT (CDR IT2))))))).

The destructor terms (CAR IT2) and (CDR IT2) can be eliminated by using
CAR-CDR-ELIM to replace IT2 by (CONS IT3 IT4), (CAR IT2) by IT3 and
(CDR IT2) by IT4.  This produces the following goal.

Subgoal *1.1.1/3'''
(IMPLIES (AND (CONSP (CONS IT3 IT4))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT4)))
                     (INSERT X1 (INSERT IT1 (ISORT IT4))))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1
                        (INSERT IT3 (ISORT (INSERT X1 IT4))))
                (INSERT X1
                        (INSERT IT1 (INSERT IT3 (ISORT IT4)))))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1/3'4'
(IMPLIES (AND (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT4)))
                     (INSERT X1 (INSERT IT1 (ISORT IT4))))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1
                        (INSERT IT3 (ISORT (INSERT X1 IT4))))
                (INSERT X1
                        (INSERT IT1 (INSERT IT3 (ISORT IT4)))))).

We generalize this conjecture, replacing (ISORT IT4) by IT and 
(INSERT X1 IT4) by L and restricting the type of the new variable L
to be that of the term it replaces, as established by INSERT.  This
produces

Subgoal *1.1.1/3'5'
(IMPLIES (AND (CONSP L)
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 (ISORT L))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 (ISORT L)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

We generalize this conjecture, replacing (ISORT L) by IT0.  This produces

Subgoal *1.1.1/3'6'
(IMPLIES (AND (CONSP L)
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

We suspect that the term (CONSP L) is irrelevant to the truth of this
conjecture and throw it out.  We will thus try to prove

Subgoal *1.1.1/3'7'
(IMPLIES (AND (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.

Subgoal *1.1.1/2
(IMPLIES (AND (NOT (ENDP IT2))
              (LEXORDER X1 (CAR IT2))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1/2'
(IMPLIES (AND (CONSP IT2)
              (LEXORDER X1 (CAR IT2))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

This simplifies, using the :definitions INSERT and ISORT, the :rewrite
rules LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to

Subgoal *1.1.1/2''
(IMPLIES (AND (CONSP IT2)
              (LEXORDER X1 (CAR IT2))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (ISORT (CONS X1 IT2)))
                (INSERT X1
                        (INSERT IT1
                                (INSERT (CAR IT2)
                                        (ISORT (CDR IT2))))))).

This simplifies, using the :definition ISORT, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1.1.1/2'''
(IMPLIES (AND (CONSP IT2)
              (LEXORDER X1 (CAR IT2))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1
                        (INSERT X1
                                (INSERT (CAR IT2) (ISORT (CDR IT2)))))
                (INSERT X1
                        (INSERT IT1
                                (INSERT (CAR IT2)
                                        (ISORT (CDR IT2))))))).

The destructor terms (CAR IT2) and (CDR IT2) can be eliminated by using
CAR-CDR-ELIM to replace IT2 by (CONS IT3 IT4), (CAR IT2) by IT3 and
(CDR IT2) by IT4.  This produces the following goal.

Subgoal *1.1.1/2'4'
(IMPLIES (AND (CONSP (CONS IT3 IT4))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1
                        (INSERT X1 (INSERT IT3 (ISORT IT4))))
                (INSERT X1
                        (INSERT IT1 (INSERT IT3 (ISORT IT4)))))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1/2'5'
(IMPLIES (AND (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1
                        (INSERT X1 (INSERT IT3 (ISORT IT4))))
                (INSERT X1
                        (INSERT IT1 (INSERT IT3 (ISORT IT4)))))).

We generalize this conjecture, replacing (ISORT IT4) by IT.  This produces

Subgoal *1.1.1/2'6'
(IMPLIES (AND (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 (INSERT IT3 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

We generalize this conjecture, replacing (INSERT IT3 IT) by L and restricting
the type of the new variable L to be that of the term it replaces,
as established by INSERT.  This produces

Subgoal *1.1.1/2'7'
(IMPLIES (AND (CONSP L)
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

Name the formula above *1.1.1.2.

Subgoal *1.1.1/1
(IMPLIES (AND (ENDP IT2) (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1/1'
(IMPLIES (AND (NOT (CONSP IT2))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (ISORT (INSERT X1 IT2)))
                (INSERT X1 (INSERT IT1 (ISORT IT2))))).

But simplification reduces this to T, using the :definitions INSERT
and ISORT, primitive type reasoning, the :forward-chaining rule 
LEXORDER-TOTAL, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

So we now return to *1.1.1.2, which is

(IMPLIES (AND (CONSP L)
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

Perhaps we can prove *1.1.1.2 by induction.  Two induction schemes
are suggested by this conjecture.  These merge into one derived induction
scheme.  

We will induct according to a scheme suggested by (INSERT IT1 L), but
modified to accommodate (INSERT X1 L).  These suggestions were produced
using the :induction rule INSERT.  If we let (:P IT1 IT3 L X1) denote
*1.1.1.2 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP L))
                   (NOT (LEXORDER IT1 (CAR L)))
                   (:P IT1 IT3 (CDR L) X1))
              (:P IT1 IT3 L X1))
     (IMPLIES (AND (NOT (ENDP L))
                   (LEXORDER IT1 (CAR L)))
              (:P IT1 IT3 L X1))
     (IMPLIES (ENDP L) (:P IT1 IT3 L X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.1.1.2/4
(IMPLIES (AND (NOT (ENDP L))
              (NOT (LEXORDER IT1 (CAR L)))
              (EQUAL (INSERT IT1 (INSERT X1 (CDR L)))
                     (INSERT X1 (INSERT IT1 (CDR L))))
              (CONSP L)
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.2/4'
(IMPLIES (AND (CONSP L)
              (NOT (LEXORDER IT1 (CAR L)))
              (EQUAL (INSERT IT1 (INSERT X1 (CDR L)))
                     (INSERT X1 (INSERT IT1 (CDR L))))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the
following two conjectures.

Subgoal *1.1.1.2/4.2
(IMPLIES (AND (CONSP L)
              (NOT (LEXORDER IT1 (CAR L)))
              (EQUAL (INSERT IT1 (INSERT X1 (CDR L)))
                     (INSERT X1 (INSERT IT1 (CDR L))))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1))
              (LEXORDER X1 (CAR L)))
         (EQUAL (INSERT IT1 (CONS X1 L))
                (LIST* X1 (CAR L)
                       (INSERT IT1 (CDR L))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.2/4.1
(IMPLIES (AND (CONSP L)
              (NOT (LEXORDER IT1 (CAR L)))
              (EQUAL (INSERT IT1 (INSERT X1 (CDR L)))
                     (INSERT X1 (INSERT IT1 (CDR L))))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER X1 (CAR L))))
         (EQUAL (INSERT IT1 (CONS (CAR L) (INSERT X1 (CDR L))))
                (CONS (CAR L)
                      (INSERT IT1 (INSERT X1 (CDR L)))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1.1.1.2/3
(IMPLIES (AND (NOT (ENDP L))
              (NOT (LEXORDER IT1 (CAR L)))
              (NOT (CONSP (CDR L)))
              (CONSP L)
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.2/3'
(IMPLIES (AND (CONSP L)
              (NOT (LEXORDER IT1 (CAR L)))
              (NOT (CONSP (CDR L)))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the
following two conjectures.

Subgoal *1.1.1.2/3.2
(IMPLIES (AND (CONSP L)
              (NOT (LEXORDER IT1 (CAR L)))
              (NOT (CONSP (CDR L)))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1))
              (LEXORDER X1 (CAR L)))
         (EQUAL (INSERT IT1 (CONS X1 L))
                (LIST* X1 (CAR L)
                       (INSERT IT1 (CDR L))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.2/3.1
(IMPLIES (AND (CONSP L)
              (NOT (LEXORDER IT1 (CAR L)))
              (NOT (CONSP (CDR L)))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER X1 (CAR L))))
         (EQUAL (INSERT IT1 (CONS (CAR L) (INSERT X1 (CDR L))))
                (CONS (CAR L)
                      (INSERT X1 (INSERT IT1 (CDR L)))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :forward-chaining rule LEXORDER-TOTAL,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.2/2
(IMPLIES (AND (NOT (ENDP L))
              (LEXORDER IT1 (CAR L))
              (CONSP L)
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.2/2'
(IMPLIES (AND (CONSP L)
              (LEXORDER IT1 (CAR L))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

This simplifies, using the :definition INSERT (if-intro), the :rewrite
rules LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to the following two conjectures.

Subgoal *1.1.1.2/2.2
(IMPLIES (AND (CONSP L)
              (LEXORDER IT1 (CAR L))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1))
              (LEXORDER X1 (CAR L)))
         (EQUAL (INSERT IT1 (CONS X1 L))
                (INSERT X1 (CONS IT1 L)))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :forward-chaining rule LEXORDER-TOTAL,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.2/2.1
(IMPLIES (AND (CONSP L)
              (LEXORDER IT1 (CAR L))
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER X1 (CAR L))))
         (EQUAL (INSERT IT1 (CONS (CAR L) (INSERT X1 (CDR L))))
                (INSERT X1 (CONS IT1 L)))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, 
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

Subgoal *1.1.1.2/1
(IMPLIES (AND (ENDP L)
              (CONSP L)
              (LEXORDER X1 IT3)
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT X1 L))
                (INSERT X1 (INSERT IT1 L)))).

But we reduce the conjecture to T, by case analysis.

That completes the proof of *1.1.1.2.

We therefore turn our attention to *1.1.1.1, which is

(IMPLIES (AND (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Perhaps we can prove *1.1.1.1 by induction.  Four induction schemes
are suggested by this conjecture.  These merge into two derived induction
schemes.  We will choose arbitrarily among these.  

We will induct according to a scheme suggested by (INSERT IT3 IT0),
but modified to accommodate (INSERT IT1 IT0).  These suggestions were
produced using the :induction rule INSERT.  If we let (:P IT IT0 IT1 IT3 X1)
denote *1.1.1.1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT0))
                   (NOT (LEXORDER IT3 (CAR IT0)))
                   (:P IT (CDR IT0) IT1 IT3 X1))
              (:P IT IT0 IT1 IT3 X1))
     (IMPLIES (AND (NOT (ENDP IT0))
                   (LEXORDER IT3 (CAR IT0)))
              (:P IT IT0 IT1 IT3 X1))
     (IMPLIES (ENDP IT0)
              (:P IT IT0 IT1 IT3 X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.1.1.1/4
(IMPLIES (AND (NOT (ENDP IT0))
              (NOT (LEXORDER IT3 (CAR IT0)))
              (EQUAL (INSERT IT1 (INSERT IT3 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1/4'
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER IT3 (CAR IT0)))
              (EQUAL (INSERT IT1 (INSERT IT3 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER, to
the following two conjectures.

Subgoal *1.1.1.1/4.2
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER IT3 (CAR IT0)))
              (EQUAL (INSERT IT1 (INSERT IT3 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT0))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (LIST* IT1 (CAR IT0)
                       (INSERT IT3 (CDR IT0)))
                (INSERT IT1 (INSERT IT3 (CDR IT0))))).

The destructor terms (CAR IT0) and (CDR IT0) can be eliminated by using
CAR-CDR-ELIM to replace IT0 by (CONS IT2 IT4), (CAR IT0) by IT2 and
(CDR IT0) by IT4.  This produces the following goal.

Subgoal *1.1.1.1/4.2'
(IMPLIES (AND (CONSP (CONS IT2 IT4))
              (NOT (LEXORDER IT3 IT2))
              (EQUAL (INSERT IT1 (INSERT IT3 IT4))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 IT2)
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (LIST* IT1 IT2 (INSERT IT3 IT4))
                (INSERT IT1 (INSERT IT3 IT4)))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1/4.2''
(IMPLIES (AND (NOT (LEXORDER IT3 IT2))
              (EQUAL (INSERT IT1 (INSERT IT3 IT4))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 IT2)
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (LIST* IT1 IT2 (INSERT IT3 IT4))
                (INSERT IT1 (INSERT IT3 IT4)))).

We now use the second hypothesis by substituting 
(INSERT X1 (INSERT IT1 (INSERT IT3 IT))) for (INSERT IT1 (INSERT IT3 IT4))
and throwing away the hypothesis.  This produces

Subgoal *1.1.1.1/4.2'''
(IMPLIES (AND (NOT (LEXORDER IT3 IT2))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 IT2)
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (LIST* IT1 IT2 (INSERT IT3 IT4))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.1.

Subgoal *1.1.1.1/4.1
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER IT3 (CAR IT0)))
              (EQUAL (INSERT IT1 (INSERT IT3 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT0)))
              (EQUAL (CONS (CAR IT0) (INSERT IT1 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 IT))))
         (LEXORDER X1 IT1)).

The destructor terms (CAR IT0) and (CDR IT0) can be eliminated by using
CAR-CDR-ELIM to replace IT0 by (CONS IT2 IT4), (CAR IT0) by IT2 and
(CDR IT0) by IT4.  This produces the following goal.

Subgoal *1.1.1.1/4.1'
(IMPLIES (AND (CONSP (CONS IT2 IT4))
              (NOT (LEXORDER IT3 IT2))
              (EQUAL (INSERT IT1 (INSERT IT3 IT4))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (EQUAL (CONS IT2 (INSERT IT1 IT4))
                     (INSERT X1 (INSERT IT1 IT))))
         (LEXORDER X1 IT1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1/4.1''
(IMPLIES (AND (NOT (LEXORDER IT3 IT2))
              (EQUAL (INSERT IT1 (INSERT IT3 IT4))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (EQUAL (CONS IT2 (INSERT IT1 IT4))
                     (INSERT X1 (INSERT IT1 IT))))
         (LEXORDER X1 IT1)).

Name the formula above *1.1.1.1.2.

Subgoal *1.1.1.1/3
(IMPLIES (AND (NOT (ENDP IT0))
              (NOT (LEXORDER IT3 (CAR IT0)))
              (NOT (EQUAL (INSERT IT1 (CDR IT0))
                          (INSERT X1 (INSERT IT1 IT))))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1/3'
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER IT3 (CAR IT0)))
              (NOT (EQUAL (INSERT IT1 (CDR IT0))
                          (INSERT X1 (INSERT IT1 IT))))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER, to
the following two conjectures.

Subgoal *1.1.1.1/3.2
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER IT3 (CAR IT0)))
              (NOT (EQUAL (INSERT IT1 (CDR IT0))
                          (INSERT IT1 IT0)))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT0))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (LIST* IT1 (CAR IT0)
                       (INSERT IT3 (CDR IT0)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT, the :rewrite rules 
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to

Subgoal *1.1.1.1/3.2'
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER IT3 (CAR IT0)))
              (NOT (EQUAL (INSERT IT1 (CDR IT0))
                          (CONS IT1 IT0)))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT0))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (LIST* IT1 (CAR IT0)
                       (INSERT IT3 (CDR IT0)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

The destructor terms (CAR IT0) and (CDR IT0) can be eliminated by using
CAR-CDR-ELIM to replace IT0 by (CONS IT2 IT4), (CAR IT0) by IT2 and
(CDR IT0) by IT4.  This produces the following goal.

Subgoal *1.1.1.1/3.2''
(IMPLIES (AND (CONSP (CONS IT2 IT4))
              (NOT (LEXORDER IT3 IT2))
              (NOT (EQUAL (INSERT IT1 IT4)
                          (LIST* IT1 IT2 IT4)))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 IT2)
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (LIST* IT1 IT2 (INSERT IT3 IT4))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1/3.2'''
(IMPLIES (AND (NOT (LEXORDER IT3 IT2))
              (NOT (EQUAL (INSERT IT1 IT4)
                          (LIST* IT1 IT2 IT4)))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 IT2)
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (LIST* IT1 IT2 (INSERT IT3 IT4))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.3.

Subgoal *1.1.1.1/3.1
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER IT3 (CAR IT0)))
              (NOT (EQUAL (INSERT IT1 (CDR IT0))
                          (INSERT IT1 IT0)))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT0)))
              (EQUAL (CONS (CAR IT0) (INSERT IT1 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (CONS (CAR IT0)
                      (INSERT IT1 (INSERT IT3 (CDR IT0))))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT, to

Subgoal *1.1.1.1/3.1'
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER IT3 (CAR IT0)))
              (NOT (EQUAL (INSERT IT1 (CDR IT0))
                          (INSERT X1 (INSERT IT1 IT))))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT0)))
              (EQUAL (CONS (CAR IT0) (INSERT IT1 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (CONS (CAR IT0)
                      (INSERT IT1 (INSERT IT3 (CDR IT0))))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

The destructor terms (CAR IT0) and (CDR IT0) can be eliminated by using
CAR-CDR-ELIM to replace IT0 by (CONS IT2 IT4), (CAR IT0) by IT2 and
(CDR IT0) by IT4.  This produces the following goal.

Subgoal *1.1.1.1/3.1''
(IMPLIES (AND (CONSP (CONS IT2 IT4))
              (NOT (LEXORDER IT3 IT2))
              (NOT (EQUAL (INSERT IT1 IT4)
                          (INSERT X1 (INSERT IT1 IT))))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (EQUAL (CONS IT2 (INSERT IT1 IT4))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (CONS IT2 (INSERT IT1 (INSERT IT3 IT4)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1/3.1'''
(IMPLIES (AND (NOT (LEXORDER IT3 IT2))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (EQUAL (CONS IT2 (INSERT IT1 IT4))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (CONS IT2 (INSERT IT1 (INSERT IT3 IT4)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.4.

Subgoal *1.1.1.1/2
(IMPLIES (AND (NOT (ENDP IT0))
              (LEXORDER IT3 (CAR IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1/2'
(IMPLIES (AND (CONSP IT0)
              (LEXORDER IT3 (CAR IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER, to
the following four conjectures.

Subgoal *1.1.1.1/2.4
(IMPLIES (AND (CONSP IT0)
              (LEXORDER IT3 (CAR IT0))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT0))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :rewrite rule LEXORDER-TRANSITIVE and the
:type-prescription rule LEXORDER, to

Subgoal *1.1.1.1/2.4'
(IMPLIES (AND (CONSP IT0)
              (LEXORDER IT3 (CAR IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

The destructor terms (CAR IT0) and (CDR IT0) can be eliminated by using
CAR-CDR-ELIM to replace IT0 by (CONS IT2 IT4), (CAR IT0) by IT2 and
(CDR IT0) by IT4.  This produces the following goal.

Subgoal *1.1.1.1/2.4''
(IMPLIES (AND (CONSP (CONS IT2 IT4))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT2 IT4)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1/2.4'''
(IMPLIES (AND (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT2 IT4)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.5.

Subgoal *1.1.1.1/2.3
(IMPLIES (AND (CONSP IT0)
              (LEXORDER IT3 (CAR IT0))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT0))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using primitive type reasoning, the :forward-chaining
rule LEXORDER-TOTAL, the :rewrite rule LEXORDER-TRANSITIVE and the
:type-prescription rule LEXORDER, to

Subgoal *1.1.1.1/2.3'
(IMPLIES (AND (CONSP IT0)
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT0))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

The destructor terms (CAR IT0) and (CDR IT0) can be eliminated by using
CAR-CDR-ELIM to replace IT0 by (CONS IT2 IT4), (CAR IT0) by IT2 and
(CDR IT0) by IT4.  This produces the following goal.

Subgoal *1.1.1.1/2.3''
(IMPLIES (AND (CONSP (CONS IT2 IT4))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 IT2)
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT2 IT4)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1/2.3'''
(IMPLIES (AND (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 IT2)
              (EQUAL (LIST* IT1 IT2 IT4)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT2 IT4)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.6.

Subgoal *1.1.1.1/2.2
(IMPLIES (AND (CONSP IT0)
              (LEXORDER IT3 (CAR IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT0)))
              (EQUAL (CONS (CAR IT0) (INSERT IT1 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

But simplification reduces this to T, using the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1/2.1
(IMPLIES (AND (CONSP IT0)
              (LEXORDER IT3 (CAR IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT0)))
              (EQUAL (CONS (CAR IT0) (INSERT IT1 (CDR IT0)))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

The destructor terms (CAR IT0) and (CDR IT0) can be eliminated by using
CAR-CDR-ELIM to replace IT0 by (CONS IT2 IT4), (CAR IT0) by IT2 and
(CDR IT0) by IT4.  This produces the following goal.

Subgoal *1.1.1.1/2.1'
(IMPLIES (AND (CONSP (CONS IT2 IT4))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (EQUAL (CONS IT2 (INSERT IT1 IT4))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1/2.1''
(IMPLIES (AND (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (EQUAL (CONS IT2 (INSERT IT1 IT4))
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT2 (INSERT IT1 IT4))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

We now use the fourth hypothesis by substituting (INSERT X1 (INSERT IT1 IT))
for (CONS IT2 (INSERT IT1 IT4)) and throwing away the hypothesis. 
This produces

Subgoal *1.1.1.1/2.1'''
(IMPLIES (AND (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.7.

Subgoal *1.1.1.1/1
(IMPLIES (AND (ENDP IT0)
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1/1'
(IMPLIES (AND (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (INSERT IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1)))
         (EQUAL (INSERT IT1 (INSERT IT3 IT0))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the
following two conjectures.

Subgoal *1.1.1.1/1.2
(IMPLIES (AND (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.8.

Subgoal *1.1.1.1/1.1
(IMPLIES (AND (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Name the formula above *1.1.1.1.9.

Perhaps we can prove *1.1.1.1.9 by induction.  Two induction schemes
are suggested by this conjecture.  These merge into one derived induction
scheme.  

We will induct according to a scheme suggested by (INSERT IT3 IT),
but modified to accommodate (INSERT IT1 IT).  These suggestions were
produced using the :induction rule INSERT.  If we let (:P IT IT0 IT1 IT3 X1)
denote *1.1.1.1.9 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT))
                   (NOT (LEXORDER IT3 (CAR IT)))
                   (:P (CDR IT) IT0 IT1 IT3 X1))
              (:P IT IT0 IT1 IT3 X1))
     (IMPLIES (AND (NOT (ENDP IT))
                   (LEXORDER IT3 (CAR IT)))
              (:P IT IT0 IT1 IT3 X1))
     (IMPLIES (ENDP IT)
              (:P IT IT0 IT1 IT3 X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.1.1.1.9/4
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT3 IT1 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.9/4'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT3 IT1 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning, the :forward-chaining rule LEXORDER-TOTAL, the :rewrite
rules CAR-CONS, CDR-CONS and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to the following two conjectures.

Subgoal *1.1.1.1.9/4.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT3 IT1 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (LEXORDER X1 (CAR IT)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (LIST* X1 (CAR IT)
                       (INSERT IT1 (INSERT IT3 (CDR IT)))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.9/4.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT3 IT1 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER X1 (CAR IT))))
         (EQUAL (LIST* IT3 IT1 IT0)
                (LIST* (CAR IT) IT3 IT1 IT0))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule INSERT.

Subgoal *1.1.1.1.9/3
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.9/3'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning, the :forward-chaining rule LEXORDER-TOTAL, the :rewrite
rules CAR-CONS, CDR-CONS and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to the following two conjectures.

Subgoal *1.1.1.1.9/3.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (LEXORDER X1 (CAR IT)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (LIST* X1 (CAR IT)
                       (INSERT IT1 (INSERT IT3 (CDR IT)))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.9/3.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER X1 (CAR IT))))
         (EQUAL (LIST* IT3 IT1 IT0)
                (CONS (CAR IT)
                      (INSERT X1
                              (INSERT IT1 (INSERT IT3 (CDR IT))))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule INSERT.

Subgoal *1.1.1.1.9/2
(IMPLIES (AND (NOT (ENDP IT))
              (LEXORDER IT3 (CAR IT))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.9/2'
(IMPLIES (AND (CONSP IT)
              (LEXORDER IT3 (CAR IT))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT, primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rules CAR-CONS,
CDR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-
prescription rule LEXORDER, to

Subgoal *1.1.1.1.9/2''
(IMPLIES (AND (CONSP IT)
              (LEXORDER IT3 (CAR IT))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (CONS IT3 IT))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :forward-chaining rule LEXORDER-TOTAL,
the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-TRANSITIVE and the
:type-prescription rule LEXORDER.

Subgoal *1.1.1.1.9/1
(IMPLIES (AND (ENDP IT)
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.9/1'
(IMPLIES (AND (NOT (CONSP IT))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (LIST* IT3 IT1 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

That completes the proof of *1.1.1.1.9.

We therefore turn our attention to *1.1.1.1.8, which is

(IMPLIES (AND (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Perhaps we can prove *1.1.1.1.8 by induction.  Two induction schemes
are suggested by this conjecture.  These merge into one derived induction
scheme.  

We will induct according to a scheme suggested by (INSERT IT3 IT),
but modified to accommodate (INSERT IT1 IT).  These suggestions were
produced using the :induction rule INSERT.  If we let (:P IT IT0 IT1 IT3 X1)
denote *1.1.1.1.8 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT))
                   (NOT (LEXORDER IT3 (CAR IT)))
                   (:P (CDR IT) IT0 IT1 IT3 X1))
              (:P IT IT0 IT1 IT3 X1))
     (IMPLIES (AND (NOT (ENDP IT))
                   (LEXORDER IT3 (CAR IT)))
              (:P IT IT0 IT1 IT3 X1))
     (IMPLIES (ENDP IT)
              (:P IT IT0 IT1 IT3 X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.1.1.1.8/4
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT1 IT3 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.8/4'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT1 IT3 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning, the :forward-chaining rule LEXORDER-TOTAL, the :rewrite
rules CAR-CONS, CDR-CONS, CONS-EQUAL (if-intro), LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER, to
the following four conjectures.

Subgoal *1.1.1.1.8/4.4
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT1 IT3 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (CONS IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER X1 (CAR IT)))
         (EQUAL (CONS IT3 IT0)
                (LIST* X1 (CAR IT)
                       (INSERT IT3 (CDR IT))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.8/4.3
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT1 IT3 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (CONS IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER X1 (CAR IT))))
         (EQUAL (CONS IT3 IT0)
                (CONS (CAR IT)
                      (INSERT X1 (INSERT IT3 (CDR IT)))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1.1.1.1.8/4.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT1 IT3 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3)
              (LEXORDER X1 (CAR IT)))
         (EQUAL (LIST* IT1 IT3 IT0)
                (LIST* X1 (CAR IT)
                       (INSERT IT1 (INSERT IT3 (CDR IT)))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.8/4.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (LIST* IT1 IT3 IT0)
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3)
              (NOT (LEXORDER X1 (CAR IT))))
         (EQUAL (LIST* IT1 IT3 IT0)
                (LIST* (CAR IT) IT1 IT3 IT0))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule INSERT.

Subgoal *1.1.1.1.8/3
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.8/3'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning, the :forward-chaining rule LEXORDER-TOTAL, the :rewrite
rules CAR-CONS, CDR-CONS, CONS-EQUAL (if-intro), LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER, to
the following four conjectures.

Subgoal *1.1.1.1.8/3.4
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (CONS IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER X1 (CAR IT)))
         (EQUAL (CONS IT3 IT0)
                (LIST* X1 (CAR IT)
                       (INSERT IT3 (CDR IT))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.8/3.3
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (LEXORDER IT1 (CAR IT))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (CONS IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER X1 (CAR IT))))
         (EQUAL (CONS IT3 IT0)
                (CONS (CAR IT)
                      (INSERT X1 (INSERT IT3 (CDR IT)))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1.1.1.1.8/3.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3)
              (LEXORDER X1 (CAR IT)))
         (EQUAL (LIST* IT1 IT3 IT0)
                (LIST* X1 (CAR IT)
                       (INSERT IT1 (INSERT IT3 (CDR IT)))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.8/3.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (NOT (EQUAL (CONS IT1 IT0)
                          (INSERT X1 (INSERT IT1 (CDR IT)))))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1
                             (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3)
              (NOT (LEXORDER X1 (CAR IT))))
         (EQUAL (LIST* IT1 IT3 IT0)
                (CONS (CAR IT)
                      (INSERT X1
                              (INSERT IT1 (INSERT IT3 (CDR IT))))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule INSERT.

Subgoal *1.1.1.1.8/2
(IMPLIES (AND (NOT (ENDP IT))
              (LEXORDER IT3 (CAR IT))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.8/2'
(IMPLIES (AND (CONSP IT)
              (LEXORDER IT3 (CAR IT))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and
LEXORDER-TRANSITIVE and the :type-prescription rules INSERT and LEXORDER.

Subgoal *1.1.1.1.8/1
(IMPLIES (AND (ENDP IT)
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.8/1'
(IMPLIES (AND (NOT (CONSP IT))
              (NOT (CONSP IT0))
              (NOT (LEXORDER X1 IT3))
              (EQUAL (CONS IT1 IT0)
                     (INSERT X1 (INSERT IT1 IT)))
              (NOT (LEXORDER X1 IT1))
              (LEXORDER IT1 IT3))
         (EQUAL (LIST* IT1 IT3 IT0)
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

That completes the proof of *1.1.1.1.8.

We therefore turn our attention to *1.1.1.1.7, which is

(IMPLIES (AND (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

Perhaps we can prove *1.1.1.1.7 by induction.  Two induction schemes
are suggested by this conjecture.  These merge into one derived induction
scheme.  

We will induct according to a scheme suggested by (INSERT IT3 IT),
but modified to accommodate (INSERT IT1 IT).  These suggestions were
produced using the :induction rule INSERT.  If we let (:P IT IT1 IT2 IT3 X1)
denote *1.1.1.1.7 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT))
                   (NOT (LEXORDER IT3 (CAR IT)))
                   (:P (CDR IT) IT1 IT2 IT3 X1))
              (:P IT IT1 IT2 IT3 X1))
     (IMPLIES (AND (NOT (ENDP IT))
                   (LEXORDER IT3 (CAR IT)))
              (:P IT IT1 IT2 IT3 X1))
     (IMPLIES (ENDP IT)
              (:P IT IT1 IT2 IT3 X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1.1.1.1.7/3
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT))))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.7/3'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT))))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the
following two conjectures.

Subgoal *1.1.1.1.7/3.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT))))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (LEXORDER IT1 (CAR IT)))
         (EQUAL (CONS IT3 (INSERT X1 (CONS IT1 IT)))
                (INSERT X1
                        (LIST* IT1 (CAR IT)
                               (INSERT IT3 (CDR IT)))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.7/3.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT))))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 (CAR IT))))
         (EQUAL (CONS IT3
                      (INSERT X1
                              (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
                (INSERT X1
                        (CONS (CAR IT)
                              (INSERT IT1 (INSERT IT3 (CDR IT))))))).

This simplifies, using the :definition INSERT (if-intro), primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the
following two conjectures.

Subgoal *1.1.1.1.7/3.1.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT))))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (LEXORDER X1 (CAR IT)))
         (EQUAL (LIST* IT3 X1 (CAR IT)
                       (INSERT IT1 (CDR IT)))
                (LIST* X1 (CAR IT)
                       (INSERT IT1 (INSERT IT3 (CDR IT)))))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.7/3.1.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT))))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (NOT (LEXORDER X1 (CAR IT))))
         (EQUAL (LIST* IT3 (CAR IT)
                       (INSERT X1 (INSERT IT1 (CDR IT))))
                (LIST* (CAR IT)
                       IT3
                       (INSERT X1 (INSERT IT1 (CDR IT)))))).

This simplifies, using primitive type reasoning and the :rewrite rules
CAR-CONS, CDR-CONS and CONS-EQUAL, to

Subgoal *1.1.1.1.7/3.1.1'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER IT3 (CAR IT)))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT))))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT)))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 (CAR IT)))
              (NOT (LEXORDER X1 (CAR IT))))
         (EQUAL IT3 (CAR IT))).

The destructor terms (CAR IT) and (CDR IT) can be eliminated by using
CAR-CDR-ELIM to replace IT by (CONS IT4 IT5), (CAR IT) by IT4 and (CDR IT)
by IT5.  This produces the following goal.

Subgoal *1.1.1.1.7/3.1.1''
(IMPLIES (AND (CONSP (CONS IT4 IT5))
              (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1.7/3.1.1'''
(IMPLIES (AND (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

Name the formula above *1.1.1.1.7.1.

Subgoal *1.1.1.1.7/2
(IMPLIES (AND (NOT (ENDP IT))
              (LEXORDER IT3 (CAR IT))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.7/2'
(IMPLIES (AND (CONSP IT)
              (LEXORDER IT3 (CAR IT))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

This simplifies, using the :definition INSERT (if-intro), the :rewrite
rules LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to the following two conjectures.

Subgoal *1.1.1.1.7/2.2
(IMPLIES (AND (CONSP IT)
              (LEXORDER IT3 (CAR IT))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (LEXORDER IT1 (CAR IT)))
         (EQUAL (CONS IT3 (INSERT X1 (CONS IT1 IT)))
                (INSERT X1 (INSERT IT1 (CONS IT3 IT))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning, the :forward-chaining rule LEXORDER-TOTAL,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1.1.1.1.7/2.1
(IMPLIES (AND (CONSP IT)
              (LEXORDER IT3 (CAR IT))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 (CAR IT))))
         (EQUAL (CONS IT3
                      (INSERT X1
                              (CONS (CAR IT) (INSERT IT1 (CDR IT)))))
                (INSERT X1 (INSERT IT1 (CONS IT3 IT))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1.1.1.1.7/1
(IMPLIES (AND (ENDP IT)
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.7/1'
(IMPLIES (AND (NOT (CONSP IT))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3)))
         (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT)))
                (INSERT X1 (INSERT IT1 (INSERT IT3 IT))))).

But simplification reduces this to T, using the :definition INSERT,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

So we now return to *1.1.1.1.7.1, which is

(IMPLIES (AND (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

Perhaps we can prove *1.1.1.1.7.1 by induction.  Two induction schemes
are suggested by this conjecture.  These merge into one derived induction
scheme.  

We will induct according to a scheme suggested by (INSERT IT3 IT5),
but modified to accommodate (INSERT IT1 IT5).  These suggestions were
produced using the :induction rule INSERT.  If we let 
(:P IT1 IT2 IT3 IT4 IT5 X1) denote *1.1.1.1.7.1 above then the induction
scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT5))
                   (NOT (LEXORDER IT3 (CAR IT5)))
                   (:P IT1 IT2 IT3 IT4 (CDR IT5) X1))
              (:P IT1 IT2 IT3 IT4 IT5 X1))
     (IMPLIES (AND (NOT (ENDP IT5))
                   (LEXORDER IT3 (CAR IT5)))
              (:P IT1 IT2 IT3 IT4 IT5 X1))
     (IMPLIES (ENDP IT5)
              (:P IT1 IT2 IT3 IT4 IT5 X1))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1.1.1.1.7.1/3
(IMPLIES (AND (NOT (ENDP IT5))
              (NOT (LEXORDER IT3 (CAR IT5)))
              (NOT (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT5))))
                          (INSERT X1
                                  (INSERT IT1 (INSERT IT3 (CDR IT5))))))
              (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.7.1/3'
(IMPLIES (AND (CONSP IT5)
              (NOT (LEXORDER IT3 (CAR IT5)))
              (NOT (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT5))))
                          (INSERT X1
                                  (INSERT IT1 (INSERT IT3 (CDR IT5))))))
              (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using the :definition INSERT, primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rules CAR-CONS,
CDR-CONS and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER,
to

Subgoal *1.1.1.1.7.1/3''
(IMPLIES (AND (CONSP IT5)
              (NOT (LEXORDER IT3 (CAR IT5)))
              (NOT (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT5))))
                          (INSERT X1
                                  (INSERT IT1 (INSERT IT3 (CDR IT5))))))
              (NOT (LEXORDER IT3 IT4))
              (NOT (LEXORDER IT1 (CAR IT5)))
              (EQUAL (CONS IT3
                           (INSERT X1
                                   (CONS (CAR IT5)
                                         (INSERT IT1 (CDR IT5)))))
                     (INSERT X1
                             (CONS (CAR IT5)
                                   (INSERT IT1 (INSERT IT3 (CDR IT5))))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using the :definition INSERT, primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rules CAR-CONS,
CDR-CONS and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER,
to

Subgoal *1.1.1.1.7.1/3'''
(IMPLIES (AND (CONSP IT5)
              (NOT (LEXORDER IT3 (CAR IT5)))
              (NOT (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT5))))
                          (INSERT X1
                                  (INSERT IT1 (INSERT IT3 (CDR IT5))))))
              (NOT (LEXORDER IT3 IT4))
              (NOT (LEXORDER IT1 (CAR IT5)))
              (NOT (LEXORDER X1 (CAR IT5)))
              (EQUAL (LIST* IT3 (CAR IT5)
                            (INSERT X1 (INSERT IT1 (CDR IT5))))
                     (CONS (CAR IT5)
                           (INSERT X1
                                   (INSERT IT1 (INSERT IT3 (CDR IT5))))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

By the simple :rewrite rule CONS-EQUAL we reduce the conjecture to

Subgoal *1.1.1.1.7.1/3'4'
(IMPLIES (AND (CONSP IT5)
              (NOT (LEXORDER IT3 (CAR IT5)))
              (NOT (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 (CDR IT5))))
                          (INSERT X1
                                  (INSERT IT1 (INSERT IT3 (CDR IT5))))))
              (NOT (LEXORDER IT3 IT4))
              (NOT (LEXORDER IT1 (CAR IT5)))
              (NOT (LEXORDER X1 (CAR IT5)))
              (EQUAL IT3 (CAR IT5))
              (EQUAL (CONS (CAR IT5)
                           (INSERT X1 (INSERT IT1 (CDR IT5))))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 (CDR IT5)))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

But simplification reduces this to T, using trivial observations.

Subgoal *1.1.1.1.7.1/2
(IMPLIES (AND (NOT (ENDP IT5))
              (LEXORDER IT3 (CAR IT5))
              (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.7.1/2'
(IMPLIES (AND (CONSP IT5)
              (LEXORDER IT3 (CAR IT5))
              (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using the :definition INSERT (if-intro), the :rewrite
rules LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to the following two conjectures.

Subgoal *1.1.1.1.7.1/2.2
(IMPLIES (AND (CONSP IT5)
              (LEXORDER IT3 (CAR IT5))
              (NOT (LEXORDER IT3 IT4))
              (LEXORDER IT1 (CAR IT5))
              (EQUAL (CONS IT3 (INSERT X1 (CONS IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (CONS IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using the :definition INSERT, primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rules CAR-CONS,
CDR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-
prescription rule LEXORDER, to

Subgoal *1.1.1.1.7.1/2.2'
(IMPLIES (AND (CONSP IT5)
              (NOT (LEXORDER IT3 IT4))
              (LEXORDER IT1 (CAR IT5))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

The destructor terms (CAR IT5) and (CDR IT5) can be eliminated by using
CAR-CDR-ELIM to replace IT5 by (CONS IT6 IT7), (CAR IT5) by IT6 and
(CDR IT5) by IT7.  This produces the following goal.

Subgoal *1.1.1.1.7.1/2.2''
(IMPLIES (AND (CONSP (CONS IT6 IT7))
              (NOT (LEXORDER IT3 IT4))
              (LEXORDER IT1 IT6)
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1.7.1/2.2'''
(IMPLIES (AND (NOT (LEXORDER IT3 IT4))
              (LEXORDER IT1 IT6)
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

Name the formula above *1.1.1.1.7.1.1.

Subgoal *1.1.1.1.7.1/2.1
(IMPLIES (AND (CONSP IT5)
              (LEXORDER IT3 (CAR IT5))
              (NOT (LEXORDER IT3 IT4))
              (NOT (LEXORDER IT1 (CAR IT5)))
              (EQUAL (CONS IT3
                           (INSERT X1
                                   (CONS (CAR IT5)
                                         (INSERT IT1 (CDR IT5)))))
                     (INSERT X1 (INSERT IT1 (CONS IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using the :definition INSERT, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1.1.1.1.7.1/2.1'
(IMPLIES (AND (CONSP IT5)
              (LEXORDER IT3 (CAR IT5))
              (NOT (LEXORDER IT3 IT4))
              (NOT (LEXORDER IT1 (CAR IT5)))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

The destructor terms (CAR IT5) and (CDR IT5) can be eliminated by using
CAR-CDR-ELIM to replace IT5 by (CONS IT6 IT7), (CAR IT5) by IT6 and
(CDR IT5) by IT7.  This produces the following goal.

Subgoal *1.1.1.1.7.1/2.1''
(IMPLIES (AND (CONSP (CONS IT6 IT7))
              (LEXORDER IT3 IT6)
              (NOT (LEXORDER IT3 IT4))
              (NOT (LEXORDER IT1 IT6))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using primitive type reasoning, to

Subgoal *1.1.1.1.7.1/2.1'''
(IMPLIES (AND (LEXORDER IT3 IT6)
              (NOT (LEXORDER IT3 IT4))
              (NOT (LEXORDER IT1 IT6))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

Name the formula above *1.1.1.1.7.1.2.

Subgoal *1.1.1.1.7.1/1
(IMPLIES (AND (ENDP IT5)
              (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1.1.1.7.1/1'
(IMPLIES (AND (NOT (CONSP IT5))
              (NOT (LEXORDER IT3 IT4))
              (EQUAL (CONS IT3 (INSERT X1 (INSERT IT1 IT5)))
                     (INSERT X1 (INSERT IT1 (INSERT IT3 IT5))))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

This simplifies, using the :definition INSERT, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1.1.1.1.7.1/1''
(IMPLIES (AND (NOT (CONSP IT5))
              (NOT (LEXORDER IT3 IT4))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

We suspect that the term (NOT (CONSP IT5)) is irrelevant to the truth
of this conjecture and throw it out.  We will thus try to prove

Subgoal *1.1.1.1.7.1/1'''
(IMPLIES (AND (NOT (LEXORDER IT3 IT4))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

Name the formula above *1.1.1.1.7.1.3.

But the formula above is subsumed by *1.1.1.1.7.1.2, which we'll try
to prove later.  We therefore regard *1.1.1.1.7.1.3 as proved (pending
the proof of the more general *1.1.1.1.7.1.2).

We next consider *1.1.1.1.7.1.2, which is

(IMPLIES (AND (LEXORDER IT3 IT6)
              (NOT (LEXORDER IT3 IT4))
              (NOT (LEXORDER IT1 IT6))
              (LEXORDER IT3 IT2)
              (NOT (LEXORDER X1 IT3))
              (NOT (LEXORDER IT1 IT2))
              (NOT (LEXORDER X1 IT1))
              (NOT (LEXORDER IT1 IT3))
              (NOT (LEXORDER IT1 IT4))
              (NOT (LEXORDER X1 IT4)))
         (EQUAL IT3 IT4)).

No induction schemes are suggested by *1.1.1.1.7.1.2.  Consequently,
the proof attempt has failed.

Summary
Form:  ( DEFTHM ISORT-ISORT ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION INSERT)
        (:DEFINITION ISORT)
        (:DEFINITION NOT)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:INDUCTION INSERT)
        (:INDUCTION ISORT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE CONS-EQUAL)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION INSERT)
        (:TYPE-PRESCRIPTION LEXORDER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION INSERT)
             (:REWRITE CONS-EQUAL))

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(EQUAL (ISORT (ISORT X)) (ISORT X))

*** Key checkpoint under a top-level induction: ***

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (EQUAL (ISORT (ISORT (CDR X)))
                     (ISORT (CDR X))))
         (EQUAL (ISORT (INSERT (CAR X) (ISORT (CDR X))))
                (INSERT (CAR X) (ISORT (CDR X)))))

ACL2 Error in ( DEFTHM ISORT-ISORT ...):  See :DOC failure.

******** FAILED ********
ACL2 >>(PE 'ORDEREDP-ISORT)
           7:x(DEFTHM ORDEREDP-ISORT (ORDEREDP (ISORT X)))
ACL2 >>(DEFTHM KEY-LEMMA
               (IMPLIES (ORDEREDP A)
                        (EQUAL (ISORT A) A)))

Name the formula above *1.

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (ORDEREDP A).  This
suggestion was produced using the :induction rules ISORT and ORDEREDP.
If we let (:P A) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP A))
                   (NOT (ENDP (CDR A)))
                   (NOT (LEXORDER (CAR A) (CADR A))))
              (:P A))
     (IMPLIES (AND (NOT (ENDP A))
                   (NOT (ENDP (CDR A)))
                   (LEXORDER (CAR A) (CADR A))
                   (:P (CDR A)))
              (:P A))
     (IMPLIES (AND (NOT (ENDP A)) (ENDP (CDR A)))
              (:P A))
     (IMPLIES (ENDP A) (:P A))).
This induction is justified by the same argument used to admit ORDEREDP.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.

Subgoal *1/5
(IMPLIES (AND (NOT (ENDP A))
              (NOT (ENDP (CDR A)))
              (NOT (LEXORDER (CAR A) (CADR A)))
              (ORDEREDP A))
         (EQUAL (ISORT A) A)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/5'
(IMPLIES (AND (CONSP A)
              (CONSP (CDR A))
              (NOT (LEXORDER (CAR A) (CADR A)))
              (ORDEREDP A))
         (EQUAL (ISORT A) A)).

But simplification reduces this to T, using the :definition ORDEREDP.

Subgoal *1/4
(IMPLIES (AND (NOT (ENDP A))
              (NOT (ENDP (CDR A)))
              (LEXORDER (CAR A) (CADR A))
              (EQUAL (ISORT (CDR A)) (CDR A))
              (ORDEREDP A))
         (EQUAL (ISORT A) A)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/4'
(IMPLIES (AND (CONSP A)
              (CONSP (CDR A))
              (LEXORDER (CAR A) (CADR A))
              (EQUAL (ISORT (CDR A)) (CDR A))
              (ORDEREDP A))
         (EQUAL (ISORT A) A)).

But simplification reduces this to T, using the :definitions INSERT,
ISORT and ORDEREDP, primitive type reasoning, the :rewrite rules 
CONS-CAR-CDR, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-
prescription rule LEXORDER.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP A))
              (NOT (ENDP (CDR A)))
              (LEXORDER (CAR A) (CADR A))
              (NOT (ORDEREDP (CDR A)))
              (ORDEREDP A))
         (EQUAL (ISORT A) A)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP A)
              (CONSP (CDR A))
              (LEXORDER (CAR A) (CADR A))
              (NOT (ORDEREDP (CDR A)))
              (ORDEREDP A))
         (EQUAL (ISORT A) A)).

But simplification reduces this to T, using the :definition ORDEREDP,
the :rewrite rules LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the
:type-prescription rule LEXORDER.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP A))
              (ENDP (CDR A))
              (ORDEREDP A))
         (EQUAL (ISORT A) A)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (NOT (CONSP (CDR A)))
              (ORDEREDP A))
         (EQUAL (ISORT A) A)).

This simplifies, using the :definitions ISORT and ORDEREDP, to

Subgoal *1/2''
(IMPLIES (AND (CONSP A) (NOT (CONSP (CDR A))))
         (EQUAL (INSERT (CAR A) (ISORT (CDR A)))
                A)).

But simplification reduces this to T, using the :definitions INSERT
and ISORT, primitive type reasoning and the :rewrite rule CONS-CAR-CDR.

Subgoal *1/1
(IMPLIES (AND (ENDP A) (ORDEREDP A))
         (EQUAL (ISORT A) A)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP A)) (ORDEREDP A))
         (EQUAL (ISORT A) A)).

But simplification reduces this to T, using the :definitions ISORT
and ORDEREDP and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM KEY-LEMMA ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION INSERT)
        (:DEFINITION ISORT)
        (:DEFINITION NOT)
        (:DEFINITION ORDEREDP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ISORT)
        (:INDUCTION ORDEREDP)
        (:REWRITE CONS-CAR-CDR)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION LEXORDER))
 KEY-LEMMA
ACL2 >>(DEFTHM ISORT-ISORT
               (EQUAL (ISORT (ISORT X)) (ISORT X)))

But simplification reduces this to T, using primitive type reasoning
and the :rewrite rules KEY-LEMMA and ORDEREDP-ISORT.

Q.E.D.

Summary
Form:  ( DEFTHM ISORT-ISORT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE KEY-LEMMA)
        (:REWRITE ORDEREDP-ISORT))
 ISORT-ISORT
ACL2 >>(INCLUDE-BOOK "perm")

Summary
Form:  ( INCLUDE-BOOK "perm" ...)
Rules: NIL
 "perm.lisp"
ACL2 >>(PE 'PERM)
          10:x(INCLUDE-BOOK "perm")
              \
              [Included books, outermost to innermost:
               "[books]/demos/marktoberdorf-08/perm.lisp"
              ]
              \
>L             (DEFUN PERM (X Y)
                      (IF (CONSP X)
                          (AND (MEMBER (CAR X) Y)
                               (PERM (CDR X) (RM (CAR X) Y)))
                          (NOT (CONSP Y))))
ACL2 >>(PERM '(1 2 3) '(3 1 2))
T
ACL2 >>(PERM '(1 2 3) '(1 3 4))
NIL
ACL2 >>(DEFTHM PERM-ISORT (PERM (ISORT X) X))

ACL2 Warning [Double-rewrite] in ( DEFTHM PERM-ISORT ...):  In a :REWRITE
rule generated from PERM-ISORT, equivalence relation PERM is maintained
at one problematic occurrence of variable X in the right-hand side,
but not at any binding occurrence of X.  Consider replacing that occurrence
of X in the right-hand side with (DOUBLE-REWRITE X).  See :doc double-
rewrite for more information on this issue.


Name the formula above *1.

Perhaps we can prove *1 by induction.  One induction scheme is suggested
by this conjecture.  

We will induct according to a scheme suggested by (ISORT X).  This
suggestion was produced using the :induction rule ISORT.  If we let
(:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP X)) (:P (CDR X)))
              (:P X))
     (IMPLIES (ENDP X) (:P X))).
This induction is justified by the same argument used to admit ISORT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (PERM (ISORT (CDR X)) (CDR X)))
         (PERM (ISORT X) X)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (PERM (ISORT (CDR X)) (CDR X)))
         (PERM (ISORT X) X)).

This simplifies, using the :definition ISORT, to

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (PERM (ISORT (CDR X)) (CDR X)))
         (PERM (INSERT (CAR X) (ISORT (CDR X)))
               X)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2'''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (PERM (ISORT X2) X2))
         (PERM (INSERT X1 (ISORT X2))
               (CONS X1 X2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2'4'
(IMPLIES (PERM (ISORT X2) X2)
         (PERM (INSERT X1 (ISORT X2))
               (CONS X1 X2))).

We generalize this conjecture, replacing (ISORT X2) by IT.  This produces

Subgoal *1/2'5'
(IMPLIES (PERM IT X2)
         (PERM (INSERT X1 IT) (CONS X1 X2))).

Name the formula above *1.1.

Subgoal *1/1
(IMPLIES (ENDP X) (PERM (ISORT X) X)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (PERM (ISORT X) X)).

But simplification reduces this to T, using the :definitions ORDEREDP
and PERM and the :rewrite rule KEY-LEMMA.

So we now return to *1.1, which is

(IMPLIES (PERM IT X2)
         (PERM (INSERT X1 IT) (CONS X1 X2))).

Perhaps we can prove *1.1 by induction.  Two induction schemes are
suggested by this conjecture.  These merge into one derived induction
scheme.  

We will induct according to a scheme suggested by (INSERT X1 IT), but
modified to accommodate (PERM IT X2).  These suggestions were produced
using the :induction rules INSERT and PERM.  If we let (:P IT X1 X2)
denote *1.1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP IT))
                   (NOT (LEXORDER X1 (CAR IT)))
                   (:P (CDR IT) X1 (RM (CAR IT) X2)))
              (:P IT X1 X2))
     (IMPLIES (AND (NOT (ENDP IT))
                   (LEXORDER X1 (CAR IT)))
              (:P IT X1 X2))
     (IMPLIES (ENDP IT) (:P IT X1 X2))).
This induction is justified by the same argument used to admit INSERT.
Note, however, that the unmeasured variable X2 is being instantiated.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.1/4
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER X1 (CAR IT)))
              (PERM (INSERT X1 (CDR IT))
                    (CONS X1 (RM (CAR IT) X2)))
              (PERM IT X2))
         (PERM (INSERT X1 IT) (CONS X1 X2))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/4'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (PERM (INSERT X1 (CDR IT))
                    (CONS X1 (RM (CAR IT) X2)))
              (PERM IT X2))
         (PERM (INSERT X1 IT) (CONS X1 X2))).

This simplifies, using the :definitions INSERT, MEMBER-EQUAL (if-intro),
PERM (if-intro) and RM (if-intro), the :equivalence rule 
PERM-IS-AN-EQUIVALENCE, primitive type reasoning, the :rewrite rules
CAR-CONS and CDR-CONS and the :type-prescription rule MEMBER-EQUAL,
to the following two conjectures.

Subgoal *1.1/4.2
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (PERM (INSERT X1 (CDR IT))
                    (CONS X1 (RM (CAR IT) X2)))
              (MEMBER-EQUAL (CAR IT) X2)
              (PERM (CDR IT) (RM (CAR IT) X2))
              (EQUAL (CAR IT) X1))
         (PERM (INSERT X1 (CDR IT)) X2)).

But simplification reduces this to T, using primitive type reasoning
and the :forward-chaining rule LEXORDER-TOTAL.

Subgoal *1.1/4.1
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (PERM (INSERT X1 (CDR IT))
                    (CONS X1 (RM (CAR IT) X2)))
              (MEMBER-EQUAL (CAR IT) X2)
              (PERM (CDR IT) (RM (CAR IT) X2))
              (NOT (EQUAL (CAR IT) X1)))
         (PERM (INSERT X1 (CDR IT))
               (INSERT X1 (CDR IT)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1.1/3
(IMPLIES (AND (NOT (ENDP IT))
              (NOT (LEXORDER X1 (CAR IT)))
              (NOT (PERM (CDR IT) (RM (CAR IT) X2)))
              (PERM IT X2))
         (PERM (INSERT X1 IT) (CONS X1 X2))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/3'
(IMPLIES (AND (CONSP IT)
              (NOT (LEXORDER X1 (CAR IT)))
              (NOT (PERM (CDR IT) (RM (CAR IT) X2)))
              (PERM IT X2))
         (PERM (INSERT X1 IT) (CONS X1 X2))).

But simplification reduces this to T, using the :definition PERM and
primitive type reasoning.

Subgoal *1.1/2
(IMPLIES (AND (NOT (ENDP IT))
              (LEXORDER X1 (CAR IT))
              (PERM IT X2))
         (PERM (INSERT X1 IT) (CONS X1 X2))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/2'
(IMPLIES (AND (CONSP IT)
              (LEXORDER X1 (CAR IT))
              (PERM IT X2))
         (PERM (INSERT X1 IT) (CONS X1 X2))).

But simplification reduces this to T, using the :definitions INSERT,
MEMBER-EQUAL, PERM and RM, primitive type reasoning, the :rewrite rules
CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and
the :type-prescription rules LEXORDER and MEMBER-EQUAL.

Subgoal *1.1/1
(IMPLIES (AND (ENDP IT) (PERM IT X2))
         (PERM (INSERT X1 IT) (CONS X1 X2))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.1/1'
(IMPLIES (AND (NOT (CONSP IT)) (PERM IT X2))
         (PERM (INSERT X1 IT) (CONS X1 X2))).

But simplification reduces this to T, using the :definitions INSERT,
MEMBER-EQUAL, PERM and RM, primitive type reasoning and the :rewrite
rules CAR-CONS and CDR-CONS.

That completes the proofs of *1.1 and *1.

Q.E.D.

Summary
Form:  ( DEFTHM PERM-ISORT ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION INSERT)
        (:DEFINITION ISORT)
        (:DEFINITION MEMBER-EQUAL)
        (:DEFINITION NOT)
        (:DEFINITION ORDEREDP)
        (:DEFINITION PERM)
        (:DEFINITION RM)
        (:ELIM CAR-CDR-ELIM)
        (:EQUIVALENCE PERM-IS-AN-EQUIVALENCE)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:INDUCTION INSERT)
        (:INDUCTION ISORT)
        (:INDUCTION PERM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE KEY-LEMMA)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION LEXORDER)
        (:TYPE-PRESCRIPTION MEMBER-EQUAL))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION MEMBER-EQUAL)
             (:DEFINITION PERM)
             (:DEFINITION RM))
Warnings:  Double-rewrite
 PERM-ISORT
ACL2 >>'(END OF DEMO 2)
(END OF DEMO 2)
ACL2 >>(DEFUN MEMBER! (E X)
              (AND (MEMBER E X)
                   (NOT (MEMBER E (CDR (MEMBER E X))))))

Since MEMBER! is non-recursive, its admission is trivial.  We observe
that the type of MEMBER! is described by the theorem 
(OR (EQUAL (MEMBER! E X) T) (EQUAL (MEMBER! E X) NIL)).  

Summary
Form:  ( DEFUN MEMBER! ...)
Rules: NIL
 MEMBER!
ACL2 >>(DEFUN RM* (E X)
              (IF (CONSP X)
                  (IF (EQUAL E (CAR X))
                      (RM* E (CDR X))
                      (CONS (CAR X) (RM* E (CDR X))))
                  NIL))

The admission of RM* is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of RM* is described by the
theorem (TRUE-LISTP (RM* E X)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN RM* ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 RM*
ACL2 >>(DEFUN TWINS (X)
              (DECLARE (XARGS :MEASURE (LEN X)))
              (IF (CONSP X)
                  (IF (MEMBER! (CAR X) (CDR X))
                      (CONS (CAR X)
                            (TWINS (RM* (CAR X) (CDR X))))
                      (TWINS (RM* (CAR X) (CDR X))))
                  NIL))

For the admission of TWINS we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(LEN X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (LEN X))
     (IMPLIES (CONSP X)
              (O< (LEN (RM* (CAR X) (CDR X)))
                  (LEN X)))).

By case analysis we reduce the conjecture to the following two conjectures.

Subgoal 2
(O-P (LEN X)).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions O-FINP and O-P and
the :type-prescription rule LEN.

Subgoal 1
(IMPLIES (CONSP X)
         (O< (LEN (RM* (CAR X) (CDR X)))
             (LEN X))).

This simplifies, using the :definitions LEN, O-FINP and O<, primitive
type reasoning and the :type-prescription rule LEN, to

Subgoal 1'
(IMPLIES (CONSP X)
         (< (LEN (RM* (CAR X) (CDR X)))
            (+ 1 (LEN (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal 1''
(IMPLIES (CONSP (CONS X1 X2))
         (< (LEN (RM* X1 X2)) (+ 1 (LEN X2)))).

This simplifies, using primitive type reasoning, to

Subgoal 1'''
(< (LEN (RM* X1 X2)) (+ 1 (LEN X2))).

Name the formula above *1.

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (RM* X1 X2).  This
suggestion was produced using the :induction rules LEN and RM*.  If
we let (:P X1 X2) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X2)) (:P X1 X2))
     (IMPLIES (AND (CONSP X2)
                   (NOT (EQUAL X1 (CAR X2)))
                   (:P X1 (CDR X2)))
              (:P X1 X2))
     (IMPLIES (AND (CONSP X2)
                   (EQUAL X1 (CAR X2))
                   (:P X1 (CDR X2)))
              (:P X1 X2))).
This induction is justified by the same argument used to admit RM*.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X2))
         (< (LEN (RM* X1 X2)) (+ 1 (LEN X2)))).

But simplification reduces this to T, using the :definitions LEN and
RM* and the :executable-counterparts of <, BINARY-+ and LEN.

Subgoal *1/2
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL X1 (CAR X2)))
              (< (LEN (RM* X1 (CDR X2)))
                 (+ 1 (LEN (CDR X2)))))
         (< (LEN (RM* X1 X2)) (+ 1 (LEN X2)))).

This simplifies, using the :definitions LEN, RM* and SYNP, the :executable-
counterpart of BINARY-+, primitive type reasoning, the :rewrite rules
CDR-CONS and FOLD-CONSTS-IN-+ and the :type-prescription rule RM*,
to

Subgoal *1/2'
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL X1 (CAR X2)))
              (< (LEN (RM* X1 (CDR X2)))
                 (+ 1 (LEN (CDR X2)))))
         (< (+ 1 (LEN (RM* X1 (CDR X2))))
            (+ 2 (LEN (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X2)
              (EQUAL X1 (CAR X2))
              (< (LEN (RM* X1 (CDR X2)))
                 (+ 1 (LEN (CDR X2)))))
         (< (LEN (RM* X1 X2)) (+ 1 (LEN X2)))).

This simplifies, using the :definitions LEN, RM* and SYNP, the :executable-
counterpart of BINARY-+, primitive type reasoning and the :rewrite
rule FOLD-CONSTS-IN-+, to

Subgoal *1/1'
(IMPLIES (AND (CONSP X2)
              (< (LEN (RM* (CAR X2) (CDR X2)))
                 (+ 1 (LEN (CDR X2)))))
         (< (LEN (RM* (CAR X2) (CDR X2)))
            (+ 2 (LEN (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

That completes the proof of the measure theorem for TWINS.  Thus, we
admit this function under the principle of definition.  We observe
that the type of TWINS is described by the theorem (TRUE-LISTP (TWINS X)).
We used primitive type reasoning.

Summary
Form:  ( DEFUN TWINS ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION LEN)
        (:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O-P)
        (:DEFINITION O<)
        (:DEFINITION RM*)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART LEN)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN)
        (:INDUCTION RM*)
        (:REWRITE CDR-CONS)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:TYPE-PRESCRIPTION LEN)
        (:TYPE-PRESCRIPTION RM*))
 TWINS
ACL2 >>(DEFUN HOW-MANY (E X)
              (IF (CONSP X)
                  (IF (EQUAL E (CAR X))
                      (+ 1 (HOW-MANY E (CDR X)))
                      (HOW-MANY E (CDR X)))
                  0))

The admission of HOW-MANY is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We observe that the type of HOW-MANY is described
by the theorem (AND (INTEGERP (HOW-MANY E X)) (<= 0 (HOW-MANY E X))).
We used primitive type reasoning.

Summary
Form:  ( DEFUN HOW-MANY ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 HOW-MANY
ACL2 >>(DEFTHM TWINS-CORRECT
               (IFF (MEMBER E (TWINS X))
                    (EQUAL (HOW-MANY E X) 2)))

By the simple :definitions MEMBER-EQL-EXEC$GUARD-CHECK and RETURN-LAST
we reduce the conjecture to

Goal'
(COND ((MEMBER-EQUAL E (TWINS X))
       (EQUAL (HOW-MANY E X) 2))
      ((EQUAL (HOW-MANY E X) 2) NIL)
      (T T)).

This simplifies, using trivial observations, to the following two conjectures.

Subgoal 2
(IMPLIES (NOT (MEMBER-EQUAL E (TWINS X)))
         (NOT (EQUAL (HOW-MANY E X) 2))).

Name the formula above *1.

Subgoal 1
(IMPLIES (MEMBER-EQUAL E (TWINS X))
         (EQUAL (HOW-MANY E X) 2)).

Normally we would attempt to prove Subgoal 1 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  By considering those suggested by the largest
number of non-primitive recursive functions, we narrow the field to
one.  

We will induct according to a scheme suggested by (TWINS X).  This
suggestion was produced using the :induction rule TWINS.  If we let
(:P E X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (MEMBER! (CAR X) (CDR X)))
                   (:P E (RM* (CAR X) (CDR X))))
              (:P E X))
     (IMPLIES (AND (CONSP X)
                   (MEMBER! (CAR X) (CDR X))
                   (:P E (RM* (CAR X) (CDR X))))
              (:P E X))).
This induction is justified by the same argument used to admit TWINS.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (NOT (CONSP X))
         (COND ((MEMBER-EQUAL E (TWINS X))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

But simplification reduces this to T, using the :definitions HOW-MANY,
MEMBER-EQUAL and TWINS and the :executable-counterparts of CONSP and
EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER! (CAR X) (CDR X)))
              (IFF (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                   (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2)))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER! (CAR X) (CDR X)))
              (COND ((MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((MEMBER-EQUAL E (TWINS X))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
(if-intro) and TWINS and the :type-prescription rule MEMBER-EQUAL,
to the following eight conjectures.

Subgoal *1/2.8
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (EQUAL E (CAR X)))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

This simplifies, using trivial observations, to

Subgoal *1/2.8'
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                          2)))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.8''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (MEMBER-EQUAL X1 X2))
              (NOT (MEMBER-EQUAL X1 (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.8'''
(IMPLIES (AND (NOT (MEMBER-EQUAL X1 X2))
              (NOT (MEMBER-EQUAL X1 (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.8'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (NOT (MEMBER-EQUAL X1 X2))
              (NOT (MEMBER-EQUAL X1 (TWINS R*)))
              (NOT (EQUAL (HOW-MANY X1 R*) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

Name the formula above *1.1.

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.7'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (MEMBER-EQUAL X1 X2))
              (NOT (MEMBER-EQUAL E (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.7''
(IMPLIES (AND (NOT (MEMBER-EQUAL X1 X2))
              (NOT (MEMBER-EQUAL E (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.7'''
(IMPLIES (AND (TRUE-LISTP R*)
              (NOT (MEMBER-EQUAL X1 X2))
              (NOT (MEMBER-EQUAL E (TWINS R*)))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

Name the formula above *1.2.

Subgoal *1/2.6
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using trivial observations, to

Subgoal *1/2.6'
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (MEMBER-EQUAL (CAR X)
                            (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                     2))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.6''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (MEMBER-EQUAL X1 X2))
              (MEMBER-EQUAL X1 (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.6'''
(IMPLIES (AND (NOT (MEMBER-EQUAL X1 X2))
              (MEMBER-EQUAL X1 (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.6'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (NOT (MEMBER-EQUAL X1 X2))
              (MEMBER-EQUAL X1 (TWINS R*))
              (EQUAL (HOW-MANY X1 R*) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

Name the formula above *1.3.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (NOT (EQUAL E (CAR X))))
         (EQUAL (HOW-MANY E (CDR X)) 2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.5'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (MEMBER-EQUAL X1 X2))
              (MEMBER-EQUAL E (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.5''
(IMPLIES (AND (NOT (MEMBER-EQUAL X1 X2))
              (MEMBER-EQUAL E (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.5'''
(IMPLIES (AND (TRUE-LISTP R*)
              (NOT (MEMBER-EQUAL X1 X2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

Name the formula above *1.4.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (EQUAL E (CAR X)))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

This simplifies, using trivial observations, to

Subgoal *1/2.4'
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                          2)))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.4''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (NOT (MEMBER-EQUAL X1 (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.4'''
(IMPLIES (AND (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (NOT (MEMBER-EQUAL X1 (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.4'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (NOT (MEMBER-EQUAL X1 (TWINS R*)))
              (NOT (EQUAL (HOW-MANY X1 R*) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

Name the formula above *1.5.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.3'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (NOT (MEMBER-EQUAL E (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.3''
(IMPLIES (AND (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (NOT (MEMBER-EQUAL E (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.3'''
(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (NOT (MEMBER-EQUAL E (TWINS R*)))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

Name the formula above *1.6.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
              (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using trivial observations, to

Subgoal *1/2.2'
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
              (MEMBER-EQUAL (CAR X)
                            (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                     2))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.2''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (MEMBER-EQUAL X1 (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.2'''
(IMPLIES (AND (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (MEMBER-EQUAL X1 (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.2'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (MEMBER-EQUAL X1 (TWINS R*))
              (EQUAL (HOW-MANY X1 R*) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

Name the formula above *1.7.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
              (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (NOT (EQUAL E (CAR X))))
         (EQUAL (HOW-MANY E (CDR X)) 2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.1'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (MEMBER-EQUAL E (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.1''
(IMPLIES (AND (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (MEMBER-EQUAL E (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2)))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

Name the formula above *1.8.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEMBER! (CAR X) (CDR X))
              (IFF (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                   (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2)))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the simple :definition MEMBER! we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (COND ((MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((MEMBER-EQUAL E (TWINS X))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!,
MEMBER-EQUAL (if-intro) and TWINS, primitive type reasoning, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rules MEMBER-EQUAL
and TWINS, to the following five conjectures.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.5'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEMBER-EQUAL X1 X2)
              (NOT (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.5''
(IMPLIES (AND (MEMBER-EQUAL X1 X2)
              (NOT (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and 
(MEMBER-EQUAL X1 X2) by L and restricting the types of the new variables
R* and L to be those of the terms they replace, as established by RM*
and MEMBER-EQUAL.  This produces

Subgoal *1/1.5'''
(IMPLIES (AND (TRUE-LISTP R*)
              (CONSP L)
              L (NOT (MEMBER-EQUAL X1 (CDR L)))
              (NOT (MEMBER-EQUAL E (TWINS R*)))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

The destructor terms (CAR L) and (CDR L) can be eliminated by using
CAR-CDR-ELIM to replace L by (CONS L1 L2), (CAR L) by L1 and (CDR L)
by L2.  This produces the following goal.

Subgoal *1/1.5'4'
(IMPLIES (AND (CONSP (CONS L1 L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (NOT (MEMBER-EQUAL E (TWINS R*)))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.5'5'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (NOT (MEMBER-EQUAL E (TWINS R*)))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

Name the formula above *1.9.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (EQUAL E (CAR X))
              (CONS (CAR X)
                    (TWINS (RM* (CAR X) (CDR X)))))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using trivial observations, to

Subgoal *1/1.4'
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                          2))
              (CONS (CAR X)
                    (TWINS (RM* (CAR X) (CDR X)))))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.4''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEMBER-EQUAL X1 X2)
              (NOT (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (MEMBER-EQUAL X1 (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
              (CONS X1 (TWINS (RM* X1 X2))))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.4'''
(IMPLIES (AND (MEMBER-EQUAL X1 X2)
              (NOT (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (MEMBER-EQUAL X1 (TWINS (RM* X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
              (CONS X1 (TWINS (RM* X1 X2))))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and 
(MEMBER-EQUAL X1 X2) by L and restricting the types of the new variables
R* and L to be those of the terms they replace, as established by RM*
and MEMBER-EQUAL.  This produces

Subgoal *1/1.4'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONSP L)
              L (NOT (MEMBER-EQUAL X1 (CDR L)))
              (NOT (MEMBER-EQUAL X1 (TWINS R*)))
              (NOT (EQUAL (HOW-MANY X1 R*) 2))
              (CONS X1 (TWINS R*)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

The destructor terms (CAR L) and (CDR L) can be eliminated by using
CAR-CDR-ELIM to replace L by (CONS L1 L2), (CAR L) by L1 and (CDR L)
by L2.  This produces the following goal.

Subgoal *1/1.4'5'
(IMPLIES (AND (CONSP (CONS L1 L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (NOT (MEMBER-EQUAL X1 (TWINS R*)))
              (NOT (EQUAL (HOW-MANY X1 R*) 2))
              (CONS X1 (TWINS R*)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.4'6'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (NOT (MEMBER-EQUAL X1 (TWINS R*)))
              (NOT (EQUAL (HOW-MANY X1 R*) 2))
              (CONS X1 (TWINS R*)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (TWINS R*) by TS and restricting
the type of the new variable TS to be that of the term it replaces,
as established by TWINS.  This produces

Subgoal *1/1.4'7'
(IMPLIES (AND (TRUE-LISTP TS)
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (NOT (MEMBER-EQUAL X1 TS))
              (NOT (EQUAL (HOW-MANY X1 R*) 2))
              (CONS X1 TS))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

Name the formula above *1.10.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (CONS (CAR X)
                         (TWINS (RM* (CAR X) (CDR X))))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using trivial observations, to

Subgoal *1/1.2'
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (MEMBER-EQUAL (CAR X)
                            (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                     2))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.2''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEMBER-EQUAL X1 X2)
              (NOT (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2))))
              (MEMBER-EQUAL X1 (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.2'''
(IMPLIES (AND (MEMBER-EQUAL X1 X2)
              (NOT (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2))))
              (MEMBER-EQUAL X1 (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and 
(MEMBER-EQUAL X1 X2) by L and restricting the types of the new variables
R* and L to be those of the terms they replace, as established by RM*
and MEMBER-EQUAL.  This produces

Subgoal *1/1.2'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONSP L)
              L (NOT (MEMBER-EQUAL X1 (CDR L)))
              (MEMBER-EQUAL X1 (TWINS R*))
              (EQUAL (HOW-MANY X1 R*) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

The destructor terms (CAR L) and (CDR L) can be eliminated by using
CAR-CDR-ELIM to replace L by (CONS L1 L2), (CAR L) by L1 and (CDR L)
by L2.  This produces the following goal.

Subgoal *1/1.2'5'
(IMPLIES (AND (CONSP (CONS L1 L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL X1 (TWINS R*))
              (EQUAL (HOW-MANY X1 R*) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.2'6'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL X1 (TWINS R*))
              (EQUAL (HOW-MANY X1 R*) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

Name the formula above *1.11.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (NOT (EQUAL E (CAR X))))
         (EQUAL (HOW-MANY E (CDR X)) 2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.1'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEMBER-EQUAL X1 X2)
              (NOT (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2))))
              (MEMBER-EQUAL E (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.1''
(IMPLIES (AND (MEMBER-EQUAL X1 X2)
              (NOT (MEMBER-EQUAL X1 (CDR (MEMBER-EQUAL X1 X2))))
              (MEMBER-EQUAL E (TWINS (RM* X1 X2)))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and 
(MEMBER-EQUAL X1 X2) by L and restricting the types of the new variables
R* and L to be those of the terms they replace, as established by RM*
and MEMBER-EQUAL.  This produces

Subgoal *1/1.1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (CONSP L)
              L (NOT (MEMBER-EQUAL X1 (CDR L)))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

The destructor terms (CAR L) and (CDR L) can be eliminated by using
CAR-CDR-ELIM to replace L by (CONS L1 L2), (CAR L) by L1 and (CDR L)
by L2.  This produces the following goal.

Subgoal *1/1.1'4'
(IMPLIES (AND (CONSP (CONS L1 L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.1'5'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

Name the formula above *1.12.

Perhaps we can prove *1.12 by induction.  Five induction schemes are
suggested by this conjecture.  Subsumption reduces that number to four.
However, two of these are flawed and so we are left with two viable
candidates.  We will choose arbitrarily among these.  

We will induct according to a scheme suggested by (MEMBER-EQUAL X1 L2).
This suggestion was produced using the :induction rule MEMBER-EQUAL.
If we let (:P E L1 L2 R* X1 X2) denote *1.12 above then the induction
scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP L2))
                   (NOT (EQUAL X1 (CAR L2)))
                   (:P E L1 (CDR L2) R* X1 X2))
              (:P E L1 L2 R* X1 X2))
     (IMPLIES (AND (NOT (ENDP L2))
                   (EQUAL X1 (CAR L2)))
              (:P E L1 L2 R* X1 X2))
     (IMPLIES (ENDP L2)
              (:P E L1 L2 R* X1 X2))).
This induction is justified by the same argument used to admit MEMBER-EQUAL.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.12/4
(IMPLIES (AND (NOT (ENDP L2))
              (NOT (EQUAL X1 (CAR L2)))
              (MEMBER-EQUAL X1 (CDR L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12/4'
(IMPLIES (AND (CONSP L2)
              (NOT (EQUAL X1 (CAR L2)))
              (MEMBER-EQUAL X1 (CDR L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

But simplification reduces this to T, using the :definition MEMBER-EQUAL,
primitive type reasoning and the :type-prescription rule MEMBER-EQUAL.

Subgoal *1.12/3
(IMPLIES (AND (NOT (ENDP L2))
              (NOT (EQUAL X1 (CAR L2)))
              (NOT (CONS L1 (CDR L2)))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1.12/2
(IMPLIES (AND (NOT (ENDP L2))
              (EQUAL X1 (CAR L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12/2'
(IMPLIES (AND (CONSP L2)
              (EQUAL X1 (CAR L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

But simplification reduces this to T, using the :definition MEMBER-EQUAL
and primitive type reasoning.

Subgoal *1.12/1
(IMPLIES (AND (ENDP L2)
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12/1'
(IMPLIES (AND (NOT (CONSP L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL X1 L2))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using the :definition MEMBER-EQUAL, to

Subgoal *1.12/1''
(IMPLIES (AND (NOT (CONSP L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

We suspect that the terms (NOT (CONSP L2)) and (CONS L1 L2) are irrelevant
to the truth of this conjecture and throw them out.  We will thus try
to prove

Subgoal *1.12/1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

Name the formula above *1.12.1.

Perhaps we can prove *1.12.1 by induction.  Four induction schemes
are suggested by this conjecture.  Subsumption reduces that number
to three.  However, two of these are flawed and so we are left with
one viable candidate.  

We will induct according to a scheme suggested by (HOW-MANY E X2).
This suggestion was produced using the :induction rule HOW-MANY.  If
we let (:P E R* X1 X2) denote *1.12.1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP X2))
              (:P E R* X1 X2))
     (IMPLIES (AND (CONSP X2)
                   (NOT (EQUAL E (CAR X2)))
                   (:P E R* X1 (CDR X2)))
              (:P E R* X1 X2))
     (IMPLIES (AND (CONSP X2)
                   (EQUAL E (CAR X2))
                   (:P E R* X1 (CDR X2)))
              (:P E R* X1 X2))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1.12.1/3
(IMPLIES (AND (NOT (CONSP X2))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using the :definition HOW-MANY and the :executable-
counterpart of EQUAL, to

Subgoal *1.12.1/3'
(IMPLIES (AND (NOT (CONSP X2))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

We suspect that the term (NOT (CONSP X2)) is irrelevant to the truth
of this conjecture and throw it out.  We will thus try to prove

Subgoal *1.12.1/3''
(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

Name the formula above *1.12.1.1.

Subgoal *1.12.1/2
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (EQUAL (HOW-MANY E (CDR X2)) 2)
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

But simplification reduces this to T, using the :definition HOW-MANY,
the :executable-counterpart of EQUAL and primitive type reasoning.

Subgoal *1.12.1/1
(IMPLIES (AND (CONSP X2)
              (EQUAL E (CAR X2))
              (EQUAL (HOW-MANY E (CDR X2)) 2)
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using the :definition HOW-MANY, the :executable-counterparts
of BINARY-+ and EQUAL and primitive type reasoning, to

Subgoal *1.12.1/1'
(IMPLIES (AND (CONSP X2)
              (EQUAL (HOW-MANY (CAR X2) (CDR X2)) 2)
              (TRUE-LISTP R*)
              (MEMBER-EQUAL (CAR X2) (TWINS R*))
              (EQUAL (HOW-MANY (CAR X2) R*) 2))
         (EQUAL (CAR X2) X1)).

The destructor terms (CAR X2) and (CDR X2) can be eliminated by using
CAR-CDR-ELIM to replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2)
by X4.  This produces the following goal.

Subgoal *1.12.1/1''
(IMPLIES (AND (CONSP (CONS X3 X4))
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (MEMBER-EQUAL X3 (TWINS R*))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1/1'''
(IMPLIES (AND (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (MEMBER-EQUAL X3 (TWINS R*))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

Name the formula above *1.12.1.2.

But the formula above is subsumed by *1.12.1.1, which we'll try to
prove later.  We therefore regard *1.12.1.2 as proved (pending the
proof of the more general *1.12.1.1).

We next consider *1.12.1.1, which is

(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

Perhaps we can prove *1.12.1.1 by induction.  Three induction schemes
are suggested by this conjecture.  Subsumption reduces that number
to two.  By considering those suggested by the largest number of non-
primitive recursive functions, we narrow the field to one.  

We will induct according to a scheme suggested by (TWINS R*).  This
suggestion was produced using the :induction rules TRUE-LISTP and TWINS.
If we let (:P E R* X1) denote *1.12.1.1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP R*)) (:P E R* X1))
     (IMPLIES (AND (CONSP R*)
                   (NOT (MEMBER! (CAR R*) (CDR R*)))
                   (:P E (RM* (CAR R*) (CDR R*)) X1))
              (:P E R* X1))
     (IMPLIES (AND (CONSP R*)
                   (MEMBER! (CAR R*) (CDR R*))
                   (:P E (RM* (CAR R*) (CDR R*)) X1))
              (:P E R* X1))).
This induction is justified by the same argument used to admit TWINS.
When applied to the goal at hand the above induction scheme produces
seven nontautological subgoals.

Subgoal *1.12.1.1/7
(IMPLIES (AND (NOT (CONSP R*))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

But simplification reduces this to T, using the :definitions MEMBER-EQUAL
and TRUE-LISTP, the :executable-counterparts of CONSP and TWINS and
primitive type reasoning.

Subgoal *1.12.1.1/6
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER! (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
(if-intro), TRUE-LISTP and TWINS and the :type-prescription rule MEMBER-EQUAL,
to the following four conjectures.

Subgoal *1.12.1.1/6.4
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER-EQUAL (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL E (CAR R*))
              (EQUAL (+ 1 (HOW-MANY E (CDR R*))) 2))
         (EQUAL E X1)).

This simplifies, using trivial observations, to

Subgoal *1.12.1.1/6.4'
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER-EQUAL (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY (CAR R*)
                                    (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (MEMBER-EQUAL (CAR R*)
                            (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL (+ 1 (HOW-MANY (CAR R*) (CDR R*)))
                     2))
         (EQUAL (CAR R*) X1)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.12.1.1/6.4''
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (NOT (MEMBER-EQUAL R*1 R*2))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL R*1 (TWINS (RM* R*1 R*2)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/6.4'''
(IMPLIES (AND (NOT (MEMBER-EQUAL R*1 R*2))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL R*1 (TWINS (RM* R*1 R*2)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.12.1.1/6.4'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (NOT (MEMBER-EQUAL R*1 R*2))
              (NOT (EQUAL (HOW-MANY R*1 R*) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL R*1 (TWINS R*))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

Name the formula above *1.12.1.1.1.

Subgoal *1.12.1.1/6.3
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER-EQUAL (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*))))
              (NOT (EQUAL E (CAR R*)))
              (EQUAL (HOW-MANY E (CDR R*)) 2))
         (EQUAL E X1)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.12.1.1/6.3'
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (NOT (MEMBER-EQUAL R*1 R*2))
              (NOT (EQUAL (HOW-MANY E (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL E (TWINS (RM* R*1 R*2)))
              (NOT (EQUAL E R*1))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/6.3''
(IMPLIES (AND (NOT (MEMBER-EQUAL R*1 R*2))
              (NOT (EQUAL (HOW-MANY E (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL E (TWINS (RM* R*1 R*2)))
              (NOT (EQUAL E R*1))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.12.1.1/6.3'''
(IMPLIES (AND (TRUE-LISTP R*)
              (NOT (MEMBER-EQUAL R*1 R*2))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL E (TWINS R*))
              (NOT (EQUAL E R*1))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

Name the formula above *1.12.1.1.2.

Subgoal *1.12.1.1/6.2
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*)
                            (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL E (CAR R*))
              (EQUAL (+ 1 (HOW-MANY E (CDR R*))) 2))
         (EQUAL E X1)).

This simplifies, using trivial observations, to

Subgoal *1.12.1.1/6.2'
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*)
                            (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
              (NOT (EQUAL (HOW-MANY (CAR R*)
                                    (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (MEMBER-EQUAL (CAR R*)
                            (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL (+ 1 (HOW-MANY (CAR R*) (CDR R*)))
                     2))
         (EQUAL (CAR R*) X1)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.12.1.1/6.2''
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL R*1 (TWINS (RM* R*1 R*2)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/6.2'''
(IMPLIES (AND (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL R*1 (TWINS (RM* R*1 R*2)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.12.1.1/6.2'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
              (NOT (EQUAL (HOW-MANY R*1 R*) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL R*1 (TWINS R*))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

Name the formula above *1.12.1.1.3.

Subgoal *1.12.1.1/6.1
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*)
                            (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*))))
              (NOT (EQUAL E (CAR R*)))
              (EQUAL (HOW-MANY E (CDR R*)) 2))
         (EQUAL E X1)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.12.1.1/6.1'
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
              (NOT (EQUAL (HOW-MANY E (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL E (TWINS (RM* R*1 R*2)))
              (NOT (EQUAL E R*1))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/6.1''
(IMPLIES (AND (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
              (NOT (EQUAL (HOW-MANY E (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL E (TWINS (RM* R*1 R*2)))
              (NOT (EQUAL E R*1))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.12.1.1/6.1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (TRUE-LISTP R*2)
              (MEMBER-EQUAL E (TWINS R*))
              (NOT (EQUAL E R*1))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

Name the formula above *1.12.1.1.4.

Subgoal *1.12.1.1/5
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER! (CAR R*) (CDR R*)))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*)))))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

But simplification reduces this to T, using the :definitions MEMBER!,
TRUE-LISTP and TWINS and the :type-prescription rule MEMBER-EQUAL.

Subgoal *1.12.1.1/4
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER! (CAR R*) (CDR R*)))
              (NOT (TRUE-LISTP (RM* (CAR R*) (CDR R*))))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

But we reduce the conjecture to T, by the :type-prescription rule RM*.

Subgoal *1.12.1.1/3
(IMPLIES (AND (CONSP R*)
              (MEMBER! (CAR R*) (CDR R*))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

By the simple :definition MEMBER! we reduce the conjecture to

Subgoal *1.12.1.1/3'
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*) (CDR R*))
              (NOT (MEMBER-EQUAL (CAR R*)
                                 (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

This simplifies, using the :definitions HOW-MANY, MEMBER!, MEMBER-EQUAL
(if-intro), TRUE-LISTP and TWINS, primitive type reasoning, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rules MEMBER-EQUAL
and TWINS, to the following two conjectures.

Subgoal *1.12.1.1/3.2
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*) (CDR R*))
              (NOT (MEMBER-EQUAL (CAR R*)
                                 (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (EQUAL E (CAR R*))
              (CONS E (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL (+ 1 (HOW-MANY E (CDR R*))) 2))
         (EQUAL E X1)).

This simplifies, using trivial observations, to

Subgoal *1.12.1.1/3.2'
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*) (CDR R*))
              (NOT (MEMBER-EQUAL (CAR R*)
                                 (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (EQUAL (HOW-MANY (CAR R*)
                                    (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (CONS (CAR R*)
                    (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL (+ 1 (HOW-MANY (CAR R*) (CDR R*)))
                     2))
         (EQUAL (CAR R*) X1)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.12.1.1/3.2''
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (MEMBER-EQUAL R*1 R*2)
              (NOT (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS (RM* R*1 R*2)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/3.2'''
(IMPLIES (AND (MEMBER-EQUAL R*1 R*2)
              (NOT (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS (RM* R*1 R*2)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and 
(MEMBER-EQUAL R*1 R*2) by L and restricting the types of the new variables
R* and L to be those of the terms they replace, as established by RM*
and MEMBER-EQUAL.  This produces

Subgoal *1.12.1.1/3.2'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONSP L)
              L (NOT (MEMBER-EQUAL R*1 (CDR L)))
              (NOT (EQUAL (HOW-MANY R*1 R*) 2))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS R*))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

The destructor terms (CAR L) and (CDR L) can be eliminated by using
CAR-CDR-ELIM to replace L by (CONS L1 L2), (CAR L) by L1 and (CDR L)
by L2.  This produces the following goal.

Subgoal *1.12.1.1/3.2'5'
(IMPLIES (AND (CONSP (CONS L1 L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (EQUAL (HOW-MANY R*1 R*) 2))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS R*))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/3.2'6'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (EQUAL (HOW-MANY R*1 R*) 2))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS R*))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

Name the formula above *1.12.1.1.5.

Subgoal *1.12.1.1/3.1
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*) (CDR R*))
              (NOT (MEMBER-EQUAL (CAR R*)
                                 (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (NOT (EQUAL E (CAR R*)))
              (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL (HOW-MANY E (CDR R*)) 2))
         (EQUAL E X1)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.12.1.1/3.1'
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (MEMBER-EQUAL R*1 R*2)
              (NOT (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY E (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (NOT (EQUAL E R*1))
              (MEMBER-EQUAL E (TWINS (RM* R*1 R*2)))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/3.1''
(IMPLIES (AND (MEMBER-EQUAL R*1 R*2)
              (NOT (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY E (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (NOT (EQUAL E R*1))
              (MEMBER-EQUAL E (TWINS (RM* R*1 R*2)))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and 
(MEMBER-EQUAL R*1 R*2) by L and restricting the types of the new variables
R* and L to be those of the terms they replace, as established by RM*
and MEMBER-EQUAL.  This produces

Subgoal *1.12.1.1/3.1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (CONSP L)
              L (NOT (MEMBER-EQUAL R*1 (CDR L)))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (TRUE-LISTP R*2)
              (NOT (EQUAL E R*1))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

The destructor terms (CAR L) and (CDR L) can be eliminated by using
CAR-CDR-ELIM to replace L by (CONS L1 L2), (CAR L) by L1 and (CDR L)
by L2.  This produces the following goal.

Subgoal *1.12.1.1/3.1'4'
(IMPLIES (AND (CONSP (CONS L1 L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (TRUE-LISTP R*2)
              (NOT (EQUAL E R*1))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/3.1'5'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (TRUE-LISTP R*2)
              (NOT (EQUAL E R*1))
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*2) 2))
         (EQUAL E X1)).

Name the formula above *1.12.1.1.6.

Subgoal *1.12.1.1/2
(IMPLIES (AND (CONSP R*)
              (MEMBER! (CAR R*) (CDR R*))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*)))))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

By the simple :definition MEMBER! we reduce the conjecture to

Subgoal *1.12.1.1/2'
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*) (CDR R*))
              (NOT (MEMBER-EQUAL (CAR R*)
                                 (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*)))))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

This simplifies, using the :definitions HOW-MANY, MEMBER!, MEMBER-EQUAL,
TRUE-LISTP and TWINS, primitive type reasoning, the :rewrite rules
CAR-CONS and CDR-CONS and the :type-prescription rules MEMBER-EQUAL
and TWINS, to

Subgoal *1.12.1.1/2''
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*) (CDR R*))
              (NOT (MEMBER-EQUAL (CAR R*)
                                 (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR R*) (CDR R*)))))
              (TRUE-LISTP (CDR R*))
              (EQUAL E (CAR R*))
              (CONS (CAR R*)
                    (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL (+ 1 (HOW-MANY E (CDR R*))) 2))
         (EQUAL E X1)).

This simplifies, using trivial observations, to

Subgoal *1.12.1.1/2'''
(IMPLIES (AND (CONSP R*)
              (MEMBER-EQUAL (CAR R*) (CDR R*))
              (NOT (MEMBER-EQUAL (CAR R*)
                                 (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (MEMBER-EQUAL (CAR R*)
                                 (TWINS (RM* (CAR R*) (CDR R*)))))
              (TRUE-LISTP (CDR R*))
              (CONS (CAR R*)
                    (TWINS (RM* (CAR R*) (CDR R*))))
              (EQUAL (+ 1 (HOW-MANY (CAR R*) (CDR R*)))
                     2))
         (EQUAL (CAR R*) X1)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.12.1.1/2'4'
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (MEMBER-EQUAL R*1 R*2)
              (NOT (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (MEMBER-EQUAL R*1 (TWINS (RM* R*1 R*2))))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS (RM* R*1 R*2)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/2'5'
(IMPLIES (AND (MEMBER-EQUAL R*1 R*2)
              (NOT (MEMBER-EQUAL R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (MEMBER-EQUAL R*1 (TWINS (RM* R*1 R*2))))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS (RM* R*1 R*2)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and 
(MEMBER-EQUAL R*1 R*2) by L and restricting the types of the new variables
R* and L to be those of the terms they replace, as established by RM*
and MEMBER-EQUAL.  This produces

Subgoal *1.12.1.1/2'6'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONSP L)
              L (NOT (MEMBER-EQUAL R*1 (CDR L)))
              (NOT (MEMBER-EQUAL R*1 (TWINS R*)))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS R*))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

The destructor terms (CAR L) and (CDR L) can be eliminated by using
CAR-CDR-ELIM to replace L by (CONS L1 L2), (CAR L) by L1 and (CDR L)
by L2.  This produces the following goal.

Subgoal *1.12.1.1/2'7'
(IMPLIES (AND (CONSP (CONS L1 L2))
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 (TWINS R*)))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS R*))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1/2'8'
(IMPLIES (AND (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 (TWINS R*)))
              (TRUE-LISTP R*2)
              (CONS R*1 (TWINS R*))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

We generalize this conjecture, replacing (TWINS R*) by TS and restricting
the type of the new variable TS to be that of the term it replaces,
as established by TWINS.  This produces

Subgoal *1.12.1.1/2'9'
(IMPLIES (AND (TRUE-LISTP TS)
              (TRUE-LISTP R*)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

We suspect that the term (TRUE-LISTP R*) is irrelevant to the truth
of this conjecture and throw it out.  We will thus try to prove

Subgoal *1.12.1.1/2'10'
(IMPLIES (AND (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

Name the formula above *1.12.1.1.7.

Subgoal *1.12.1.1/1
(IMPLIES (AND (CONSP R*)
              (MEMBER! (CAR R*) (CDR R*))
              (NOT (TRUE-LISTP (RM* (CAR R*) (CDR R*))))
              (TRUE-LISTP R*)
              (MEMBER-EQUAL E (TWINS R*))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL E X1)).

But we reduce the conjecture to T, by the :type-prescription rule RM*.

So we now return to *1.12.1.1.7, which is

(IMPLIES (AND (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

Perhaps we can prove *1.12.1.1.7 by induction.  Five induction schemes
are suggested by this conjecture.  Subsumption reduces that number
to four.  These merge into three derived induction schemes.  Two of
these are tied for the highest score.  We will choose arbitrarily among
these.  

We will induct according to a scheme suggested by (MEMBER-EQUAL R*1 TS).
This suggestion was produced using the :induction rules MEMBER-EQUAL
and TRUE-LISTP.  If we let (:P L1 L2 R*1 R*2 TS X1) denote *1.12.1.1.7
above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP TS))
                   (NOT (EQUAL R*1 (CAR TS)))
                   (:P L1 L2 R*1 R*2 (CDR TS) X1))
              (:P L1 L2 R*1 R*2 TS X1))
     (IMPLIES (AND (NOT (ENDP TS))
                   (EQUAL R*1 (CAR TS)))
              (:P L1 L2 R*1 R*2 TS X1))
     (IMPLIES (ENDP TS)
              (:P L1 L2 R*1 R*2 TS X1))).
This induction is justified by the same argument used to admit MEMBER-EQUAL.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.

Subgoal *1.12.1.1.7/5
(IMPLIES (AND (NOT (ENDP TS))
              (NOT (EQUAL R*1 (CAR TS)))
              (NOT (CONS R*1 (CDR TS)))
              (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1.12.1.1.7/4
(IMPLIES (AND (NOT (ENDP TS))
              (NOT (EQUAL R*1 (CAR TS)))
              (MEMBER-EQUAL R*1 (CDR TS))
              (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12.1.1.7/4'
(IMPLIES (AND (CONSP TS)
              (NOT (EQUAL R*1 (CAR TS)))
              (MEMBER-EQUAL R*1 (CDR TS))
              (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

But simplification reduces this to T, using the :definitions MEMBER-EQUAL
and TRUE-LISTP, primitive type reasoning and the :type-prescription
rule MEMBER-EQUAL.

Subgoal *1.12.1.1.7/3
(IMPLIES (AND (NOT (ENDP TS))
              (NOT (EQUAL R*1 (CAR TS)))
              (NOT (TRUE-LISTP (CDR TS)))
              (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1.12.1.1.7/2
(IMPLIES (AND (NOT (ENDP TS))
              (EQUAL R*1 (CAR TS))
              (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12.1.1.7/2'
(IMPLIES (AND (CONSP TS)
              (EQUAL R*1 (CAR TS))
              (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

But simplification reduces this to T, using the :definitions MEMBER-EQUAL
and TRUE-LISTP and primitive type reasoning.

Subgoal *1.12.1.1.7/1
(IMPLIES (AND (ENDP TS)
              (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12.1.1.7/1'
(IMPLIES (AND (NOT (CONSP TS))
              (TRUE-LISTP TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (NOT (MEMBER-EQUAL R*1 TS))
              (TRUE-LISTP R*2)
              (CONS R*1 TS)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using the :definitions MEMBER-EQUAL and TRUE-LISTP,
the :executable-counterpart of CONSP and primitive type reasoning,
to

Subgoal *1.12.1.1.7/1''
(IMPLIES (AND (NOT TS)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (TRUE-LISTP R*2)
              (LIST R*1)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using trivial observations, to

Subgoal *1.12.1.1.7/1'''
(IMPLIES (AND (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (TRUE-LISTP R*2)
              (LIST R*1)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

Name the formula above *1.12.1.1.7.1.

Perhaps we can prove *1.12.1.1.7.1 by induction.  Three induction schemes
are suggested by this conjecture.  Subsumption reduces that number
to two.  One of these has a score higher than the other.  

We will induct according to a scheme suggested by (HOW-MANY R*1 R*2).
This suggestion was produced using the :induction rules HOW-MANY and
TRUE-LISTP.  If we let (:P L1 L2 R*1 R*2 X1) denote *1.12.1.1.7.1 above
then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP R*2))
              (:P L1 L2 R*1 R*2 X1))
     (IMPLIES (AND (CONSP R*2)
                   (NOT (EQUAL R*1 (CAR R*2)))
                   (:P L1 L2 R*1 (CDR R*2) X1))
              (:P L1 L2 R*1 R*2 X1))
     (IMPLIES (AND (CONSP R*2)
                   (EQUAL R*1 (CAR R*2))
                   (:P L1 L2 R*1 (CDR R*2) X1))
              (:P L1 L2 R*1 R*2 X1))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.

Subgoal *1.12.1.1.7.1/5
(IMPLIES (AND (NOT (CONSP R*2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (TRUE-LISTP R*2)
              (LIST R*1)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

But simplification reduces this to T, using the :definitions HOW-MANY
and TRUE-LISTP, the :executable-counterparts of BINARY-+, CONSP and
EQUAL and primitive type reasoning.

Subgoal *1.12.1.1.7.1/4
(IMPLIES (AND (CONSP R*2)
              (NOT (EQUAL R*1 (CAR R*2)))
              (NOT (EQUAL (+ 1 (HOW-MANY R*1 (CDR R*2)))
                          2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (TRUE-LISTP R*2)
              (LIST R*1)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

But simplification reduces this to T, using the :definitions HOW-MANY
and TRUE-LISTP and primitive type reasoning.

Subgoal *1.12.1.1.7.1/3
(IMPLIES (AND (CONSP R*2)
              (NOT (EQUAL R*1 (CAR R*2)))
              (NOT (TRUE-LISTP (CDR R*2)))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (TRUE-LISTP R*2)
              (LIST R*1)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1.12.1.1.7.1/2
(IMPLIES (AND (CONSP R*2)
              (EQUAL R*1 (CAR R*2))
              (NOT (EQUAL (+ 1 (HOW-MANY R*1 (CDR R*2)))
                          2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (TRUE-LISTP R*2)
              (LIST R*1)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

This simplifies, using the :definitions HOW-MANY, SYNP and TRUE-LISTP,
the :executable-counterpart of BINARY-+, primitive type reasoning and
the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal *1.12.1.1.7.1/2'
(IMPLIES (AND (CONSP R*2)
              (NOT (EQUAL (+ 1 (HOW-MANY (CAR R*2) (CDR R*2)))
                          2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL (CAR R*2) L2))
              (TRUE-LISTP (CDR R*2))
              (LIST (CAR R*2))
              (EQUAL (+ 2 (HOW-MANY (CAR R*2) (CDR R*2)))
                     2))
         (EQUAL (CAR R*2) X1)).

This simplifies, using the :executable-counterparts of BINARY-+, EQUAL
and NOT, linear arithmetic, primitive type reasoning and the :type-
prescription rule HOW-MANY, to

Subgoal *1.12.1.1.7.1/2''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*2) (CDR R*2)) 0)
              (CONSP R*2)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL (CAR R*2) L2))
              (TRUE-LISTP (CDR R*2))
              (LIST (CAR R*2)))
         (EQUAL (CAR R*2) X1)).

The destructor terms (CAR R*2) and (CDR R*2) can be eliminated by using
CAR-CDR-ELIM to replace R*2 by (CONS R*3 R*4), (CAR R*2) by R*3 and
(CDR R*2) by R*4.  This produces the following goal.

Subgoal *1.12.1.1.7.1/2'''
(IMPLIES (AND (CONSP (CONS R*3 R*4))
              (EQUAL (HOW-MANY R*3 R*4) 0)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (TRUE-LISTP R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.12.1.1.7.1/2'4'
(IMPLIES (AND (EQUAL (HOW-MANY R*3 R*4) 0)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (TRUE-LISTP R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

Name the formula above *1.12.1.1.7.1.1.

Subgoal *1.12.1.1.7.1/1
(IMPLIES (AND (CONSP R*2)
              (EQUAL R*1 (CAR R*2))
              (NOT (TRUE-LISTP (CDR R*2)))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*1 L2))
              (TRUE-LISTP R*2)
              (LIST R*1)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X1)).

But we reduce the conjecture to T, by primitive type reasoning.

So we now return to *1.12.1.1.7.1.1, which is

(IMPLIES (AND (EQUAL (HOW-MANY R*3 R*4) 0)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (TRUE-LISTP R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

Perhaps we can prove *1.12.1.1.7.1.1 by induction.  Three induction
schemes are suggested by this conjecture.  Subsumption reduces that
number to two.  One of these has a score higher than the other.  

We will induct according to a scheme suggested by (HOW-MANY R*3 R*4).
This suggestion was produced using the :induction rules HOW-MANY and
TRUE-LISTP.  If we let (:P L1 L2 R*3 R*4 X1) denote *1.12.1.1.7.1.1
above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP R*4))
              (:P L1 L2 R*3 R*4 X1))
     (IMPLIES (AND (CONSP R*4)
                   (NOT (EQUAL R*3 (CAR R*4)))
                   (:P L1 L2 R*3 (CDR R*4) X1))
              (:P L1 L2 R*3 R*4 X1))
     (IMPLIES (AND (CONSP R*4)
                   (EQUAL R*3 (CAR R*4))
                   (:P L1 L2 R*3 (CDR R*4) X1))
              (:P L1 L2 R*3 R*4 X1))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.

Subgoal *1.12.1.1.7.1.1/5
(IMPLIES (AND (NOT (CONSP R*4))
              (EQUAL (HOW-MANY R*3 R*4) 0)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (TRUE-LISTP R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

This simplifies, using the :definitions HOW-MANY and TRUE-LISTP, the
:executable-counterparts of CONSP and EQUAL and primitive type reasoning,
to

Subgoal *1.12.1.1.7.1.1/5'
(IMPLIES (AND (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (NOT R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

This simplifies, using trivial observations, to

Subgoal *1.12.1.1.7.1.1/5''
(IMPLIES (AND (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

Name the formula above *1.12.1.1.7.1.1.1.

Subgoal *1.12.1.1.7.1.1/4
(IMPLIES (AND (CONSP R*4)
              (NOT (EQUAL R*3 (CAR R*4)))
              (NOT (TRUE-LISTP (CDR R*4)))
              (EQUAL (HOW-MANY R*3 R*4) 0)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (TRUE-LISTP R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1.12.1.1.7.1.1/3
(IMPLIES (AND (CONSP R*4)
              (NOT (EQUAL R*3 (CAR R*4)))
              (NOT (EQUAL (HOW-MANY R*3 (CDR R*4)) 0))
              (EQUAL (HOW-MANY R*3 R*4) 0)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (TRUE-LISTP R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

But simplification reduces this to T, using the :definition HOW-MANY
and primitive type reasoning.

Subgoal *1.12.1.1.7.1.1/2
(IMPLIES (AND (CONSP R*4)
              (EQUAL R*3 (CAR R*4))
              (NOT (TRUE-LISTP (CDR R*4)))
              (EQUAL (HOW-MANY R*3 R*4) 0)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (TRUE-LISTP R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1.12.1.1.7.1.1/1
(IMPLIES (AND (CONSP R*4)
              (EQUAL R*3 (CAR R*4))
              (NOT (EQUAL (HOW-MANY R*3 (CDR R*4)) 0))
              (EQUAL (HOW-MANY R*3 R*4) 0)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (TRUE-LISTP R*4)
              (LIST R*3))
         (EQUAL R*3 X1)).

But simplification reduces this to T, using the :definition HOW-MANY,
primitive type reasoning and the :type-prescription rule HOW-MANY.

So we now return to *1.12.1.1.7.1.1.1, which is

(IMPLIES (AND (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

Perhaps we can prove *1.12.1.1.7.1.1.1 by induction.  One induction
scheme is suggested by this conjecture.  

We will induct according to a scheme suggested by (MEMBER-EQUAL R*3 L2).
This suggestion was produced using the :induction rule MEMBER-EQUAL.
If we let (:P L1 L2 R*3 X1) denote *1.12.1.1.7.1.1.1 above then the
induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP L2))
                   (NOT (EQUAL R*3 (CAR L2)))
                   (:P L1 (CDR L2) R*3 X1))
              (:P L1 L2 R*3 X1))
     (IMPLIES (AND (NOT (ENDP L2))
                   (EQUAL R*3 (CAR L2)))
              (:P L1 L2 R*3 X1))
     (IMPLIES (ENDP L2) (:P L1 L2 R*3 X1))).
This induction is justified by the same argument used to admit MEMBER-EQUAL.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.12.1.1.7.1.1.1/4
(IMPLIES (AND (NOT (ENDP L2))
              (NOT (EQUAL R*3 (CAR L2)))
              (MEMBER-EQUAL R*3 (CDR L2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12.1.1.7.1.1.1/4'
(IMPLIES (AND (CONSP L2)
              (NOT (EQUAL R*3 (CAR L2)))
              (MEMBER-EQUAL R*3 (CDR L2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

But simplification reduces this to T, using the :definition MEMBER-EQUAL,
primitive type reasoning and the :type-prescription rule MEMBER-EQUAL.

Subgoal *1.12.1.1.7.1.1.1/3
(IMPLIES (AND (NOT (ENDP L2))
              (NOT (EQUAL R*3 (CAR L2)))
              (NOT (CONS L1 (CDR L2)))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

But we reduce the conjecture to T, by primitive type reasoning.

Subgoal *1.12.1.1.7.1.1.1/2
(IMPLIES (AND (NOT (ENDP L2))
              (EQUAL R*3 (CAR L2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12.1.1.7.1.1.1/2'
(IMPLIES (AND (CONSP L2)
              (EQUAL R*3 (CAR L2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

But simplification reduces this to T, using the :definition MEMBER-EQUAL
and primitive type reasoning.

Subgoal *1.12.1.1.7.1.1.1/1
(IMPLIES (AND (ENDP L2)
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.12.1.1.7.1.1.1/1'
(IMPLIES (AND (NOT (CONSP L2))
              (CONS L1 L2)
              (NOT (MEMBER-EQUAL R*3 L2))
              (LIST R*3))
         (EQUAL R*3 X1)).

This simplifies, using the :definition MEMBER-EQUAL, to

Subgoal *1.12.1.1.7.1.1.1/1''
(IMPLIES (AND (NOT (CONSP L2))
              (CONS L1 L2)
              (LIST R*3))
         (EQUAL R*3 X1)).

We suspect that this conjecture is not a theorem.  We might as well
be trying to prove

Subgoal *1.12.1.1.7.1.1.1/1'''
NIL.


Summary
Form:  ( DEFTHM TWINS-CORRECT ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION HOW-MANY)
        (:DEFINITION IFF)
        (:DEFINITION MEMBER!)
        (:DEFINITION MEMBER-EQL-EXEC$GUARD-CHECK)
        (:DEFINITION MEMBER-EQUAL)
        (:DEFINITION NOT)
        (:DEFINITION RETURN-LAST)
        (:DEFINITION SYNP)
        (:DEFINITION TRUE-LISTP)
        (:DEFINITION TWINS)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART TWINS)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION HOW-MANY)
        (:INDUCTION MEMBER-EQUAL)
        (:INDUCTION TRUE-LISTP)
        (:INDUCTION TWINS)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:TYPE-PRESCRIPTION HOW-MANY)
        (:TYPE-PRESCRIPTION MEMBER-EQUAL)
        (:TYPE-PRESCRIPTION RM*)
        (:TYPE-PRESCRIPTION TWINS))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION HOW-MANY)
             (:DEFINITION MEMBER!)
             (:DEFINITION MEMBER-EQUAL))

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
<GOAL>

*** Key checkpoints under a top-level induction
    before generating a goal of NIL (see :DOC nil-goal): ***

Subgoal *1/2.8'
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (NOT (MEMBER-EQUAL (CAR X)
                                 (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                          2)))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2)))

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (NOT (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2)))

Subgoal *1/2.6'
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER-EQUAL (CAR X) (CDR X)))
              (MEMBER-EQUAL (CAR X)
                            (TWINS (RM* (CAR X) (CDR X))))
              (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                     2))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2))

Note: There are nine additional key checkpoints under a top-level induction.
See :DOC set-checkpoint-summary-limit to change the number printed.

ACL2 Error in ( DEFTHM TWINS-CORRECT ...):  See :DOC failure.

******** FAILED ********
ACL2 >>(DEFTHM MEMBER-HOW-MANY
               (IFF (MEMBER E X) (< 0 (HOW-MANY E X))))

By the simple :definitions MEMBER-EQL-EXEC$GUARD-CHECK and RETURN-LAST
we reduce the conjecture to

Goal'
(COND ((MEMBER-EQUAL E X)
       (< 0 (HOW-MANY E X)))
      ((< 0 (HOW-MANY E X)) NIL)
      (T T)).

This simplifies, using trivial observations, to the following two conjectures.

Subgoal 2
(IMPLIES (NOT (MEMBER-EQUAL E X))
         (<= (HOW-MANY E X) 0)).

Name the formula above *1.

Subgoal 1
(IMPLIES (MEMBER-EQUAL E X)
         (< 0 (HOW-MANY E X))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal 1'
(IMPLIES (EQUAL (HOW-MANY E X) 0)
         (NOT (MEMBER-EQUAL E X))).

Normally we would attempt to prove Subgoal 1' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  These merge into one derived induction scheme.

We will induct according to a scheme suggested by (HOW-MANY E X). 
This suggestion was produced using the :induction rules HOW-MANY and
MEMBER-EQUAL.  If we let (:P E X) denote *1 above then the induction
scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL E (CAR X)))
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (AND (CONSP X)
                   (EQUAL E (CAR X))
                   (:P E (CDR X)))
              (:P E X))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IFF (MEMBER-EQUAL E X)
              (< 0 (HOW-MANY E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (NOT (CONSP X))
         (COND ((MEMBER-EQUAL E X)
                (< 0 (HOW-MANY E X)))
               ((< 0 (HOW-MANY E X)) NIL)
               (T T))).

But simplification reduces this to T, using the :definitions HOW-MANY
and MEMBER-EQUAL and the :executable-counterpart of <.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (IFF (MEMBER-EQUAL E (CDR X))
                   (< 0 (HOW-MANY E (CDR X)))))
         (IFF (MEMBER-EQUAL E X)
              (< 0 (HOW-MANY E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (COND ((MEMBER-EQUAL E (CDR X))
                     (< 0 (HOW-MANY E (CDR X))))
                    ((< 0 (HOW-MANY E (CDR X))) NIL)
                    (T T)))
         (COND ((MEMBER-EQUAL E X)
                (< 0 (HOW-MANY E X)))
               ((< 0 (HOW-MANY E X)) NIL)
               (T T))).

But simplification reduces this to T, using the :definitions HOW-MANY
and MEMBER-EQUAL, the :executable-counterpart of <, primitive type
reasoning and the :type-prescription rules HOW-MANY and MEMBER-EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL E (CAR X))
              (IFF (MEMBER-EQUAL E (CDR X))
                   (< 0 (HOW-MANY E (CDR X)))))
         (IFF (MEMBER-EQUAL E X)
              (< 0 (HOW-MANY E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL E (CAR X))
              (COND ((MEMBER-EQUAL E (CDR X))
                     (< 0 (HOW-MANY E (CDR X))))
                    ((< 0 (HOW-MANY E (CDR X))) NIL)
                    (T T)))
         (COND ((MEMBER-EQUAL E X)
                (< 0 (HOW-MANY E X)))
               ((< 0 (HOW-MANY E X)) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY and MEMBER-EQUAL,
the :executable-counterparts of < and BINARY-+, primitive type reasoning
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1''
(IMPLIES (AND (CONSP X)
              (MEMBER-EQUAL (CAR X) (CDR X))
              (< 0 (HOW-MANY (CAR X) (CDR X))))
         (< 0 (+ 1 (HOW-MANY (CAR X) (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM MEMBER-HOW-MANY ...)
Rules: ((:DEFINITION HOW-MANY)
        (:DEFINITION IFF)
        (:DEFINITION MEMBER-EQUAL)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION HOW-MANY)
        (:INDUCTION MEMBER-EQUAL)
        (:TYPE-PRESCRIPTION HOW-MANY)
        (:TYPE-PRESCRIPTION MEMBER-EQUAL))
 MEMBER-HOW-MANY
ACL2 >>(DEFTHM TWINS-CORRECT
               (IFF (MEMBER E (TWINS X))
                    (EQUAL (HOW-MANY E X) 2)))

ACL2 Warning [Subsume] in ( DEFTHM TWINS-CORRECT ...):  The previously
added rule MEMBER-HOW-MANY subsumes a newly proposed :REWRITE rule
generated from TWINS-CORRECT, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.


By the simple :definitions MEMBER-EQL-EXEC$GUARD-CHECK and RETURN-LAST,
the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Goal'
(COND ((< 0 (HOW-MANY E (TWINS X)))
       (EQUAL (HOW-MANY E X) 2))
      ((EQUAL (HOW-MANY E X) 2) NIL)
      (T T)).

This simplifies, using trivial observations, to the following two conjectures.

Subgoal 2
(IMPLIES (<= (HOW-MANY E (TWINS X)) 0)
         (NOT (EQUAL (HOW-MANY E X) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal 2'
(IMPLIES (EQUAL (HOW-MANY E (TWINS X)) 0)
         (NOT (EQUAL (HOW-MANY E X) 2))).

Name the formula above *1.

Subgoal 1
(IMPLIES (< 0 (HOW-MANY E (TWINS X)))
         (EQUAL (HOW-MANY E X) 2)).

Normally we would attempt to prove Subgoal 1 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  By considering those suggested by the largest
number of non-primitive recursive functions, we narrow the field to
one.  

We will induct according to a scheme suggested by (TWINS X).  This
suggestion was produced using the :induction rule TWINS.  If we let
(:P E X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (MEMBER! (CAR X) (CDR X)))
                   (:P E (RM* (CAR X) (CDR X))))
              (:P E X))
     (IMPLIES (AND (CONSP X)
                   (MEMBER! (CAR X) (CDR X))
                   (:P E (RM* (CAR X) (CDR X))))
              (:P E X))).
This induction is justified by the same argument used to admit TWINS.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (NOT (CONSP X))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

But simplification reduces this to T, using the :definitions HOW-MANY
and TWINS and the :executable-counterparts of <, CONSP and EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER! (CAR X) (CDR X)))
              (IFF (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                   (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2)))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER! (CAR X) (CDR X)))
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
(if-intro) and TWINS, the :executable-counterpart of <, the :rewrite
rule MEMBER-HOW-MANY and the :type-prescription rule HOW-MANY, to the
following eight conjectures.

Subgoal *1/2.8
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (EQUAL E (CAR X)))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule HOW-MANY.

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/2.7'
(IMPLIES (AND (EQUAL (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X) (CDR X)) 0)
              (CONSP X)
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.7''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY E (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 X2) 0)
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.7'''
(IMPLIES (AND (EQUAL (HOW-MANY E (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 X2) 0)
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.7'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY E (TWINS R*)) 0)
              (EQUAL (HOW-MANY X1 X2) 0)
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

Name the formula above *1.1.

Subgoal *1/2.6
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (< 0
                 (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using the :executable-counterparts of <, BINARY-+
and EQUAL, linear arithmetic and the :type-prescription rule HOW-MANY,
to

Subgoal *1/2.6'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X) (CDR X)) 0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (TWINS (RM* (CAR X) (CDR X))))))
         (NOT (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                     2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.6''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 X2) 0)
              (< 0 (HOW-MANY X1 (TWINS (RM* X1 X2)))))
         (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.6'''
(IMPLIES (AND (EQUAL (HOW-MANY X1 X2) 0)
              (< 0 (HOW-MANY X1 (TWINS (RM* X1 X2)))))
         (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.6'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 X2) 0)
              (< 0 (HOW-MANY X1 (TWINS R*))))
         (NOT (EQUAL (HOW-MANY X1 R*) 2))).

Name the formula above *1.2.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (< 0
                 (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (NOT (EQUAL E (CAR X))))
         (EQUAL (HOW-MANY E (CDR X)) 2)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/2.5'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X) (CDR X)) 0)
              (CONSP X)
              (< 0
                 (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (NOT (EQUAL E (CAR X))))
         (EQUAL (HOW-MANY E (CDR X)) 2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.5''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 X2) 0)
              (< 0 (HOW-MANY E (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.5'''
(IMPLIES (AND (EQUAL (HOW-MANY X1 X2) 0)
              (< 0 (HOW-MANY E (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.5'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 X2) 0)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

Name the formula above *1.3.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (EQUAL E (CAR X)))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/2.4'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                          2)))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.4''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.4'''
(IMPLIES (AND (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.4'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (TWINS R*)) 0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 R*) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

Name the formula above *1.4.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/2.3'
(IMPLIES (AND (EQUAL (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.3''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY E (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.3'''
(IMPLIES (AND (EQUAL (HOW-MANY E (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.3'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY E (TWINS R*)) 0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

Name the formula above *1.5.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (< 0
                 (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using trivial observations, to

Subgoal *1/2.2'
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (< 0
                 (HOW-MANY (CAR X)
                           (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                     2))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.2''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (< 0 (HOW-MANY X1 (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.2'''
(IMPLIES (AND (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (< 0 (HOW-MANY X1 (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.2'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (< 0 (HOW-MANY X1 (TWINS R*)))
              (EQUAL (HOW-MANY X1 R*) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

Name the formula above *1.6.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (< 0
                 (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (NOT (EQUAL E (CAR X))))
         (EQUAL (HOW-MANY E (CDR X)) 2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.1'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (< 0 (HOW-MANY E (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.1''
(IMPLIES (AND (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (< 0 (HOW-MANY E (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/2.1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

Name the formula above *1.7.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEMBER! (CAR X) (CDR X))
              (IFF (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                   (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2)))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the simple :definition MEMBER!, the :equivalence rule 
IFF-IS-AN-EQUIVALENCE and the simple :rewrite rule MEMBER-HOW-MANY
we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                  0)
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
and TWINS, the :executable-counterparts of < and BINARY-+, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and MEMBER-HOW-MANY
and the :type-prescription rules HOW-MANY and TWINS, to the following
four conjectures.

Subgoal *1/1.4
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1.4'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (NOT (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                          2)))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.4''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.4'''
(IMPLIES (AND (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (NOT (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (HOW-MANY X1 X2) by I and
(RM* X1 X2) by R* and restricting the types of the new variables I
and R* to be those of the terms they replace, as established by HOW-MANY
and RM*.  This produces

Subgoal *1/1.4'4'
(IMPLIES (AND (INTEGERP I)
              (< 0 I)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (TWINS R*)) 0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (NOT (EQUAL (HOW-MANY X1 R*) 2)))
         (EQUAL (+ 1 I) 2)).

We suspect that the terms (INTEGERP I), (< 0 I) and (EQUAL (+ 1 I) 2)
are irrelevant to the truth of this conjecture and throw them out.
We will thus try to prove

Subgoal *1/1.4'5'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (TWINS R*)) 0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))
         (EQUAL (HOW-MANY X1 R*) 2)).

Name the formula above *1.8.

Subgoal *1/1.3
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1.3'
(IMPLIES (AND (EQUAL (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.3''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY E (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.3'''
(IMPLIES (AND (EQUAL (HOW-MANY E (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (NOT (EQUAL (HOW-MANY E (RM* X1 X2)) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/1.3'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY E (TWINS R*)) 0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (NOT (EQUAL (HOW-MANY E R*) 2))
              (NOT (EQUAL E X1)))
         (NOT (EQUAL (HOW-MANY E X2) 2))).

Name the formula above *1.9.

Subgoal *1/1.2
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (< 0
                 (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using trivial observations, to

Subgoal *1/1.2'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (< 0
                 (HOW-MANY (CAR X)
                           (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                     2))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.2''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY X1 (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.2'''
(IMPLIES (AND (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY X1 (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY X1 (RM* X1 X2)) 2))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and 
(HOW-MANY X1 X2) by I and restricting the types of the new variables
R* and I to be those of the terms they replace, as established by RM*
and HOW-MANY.  This produces

Subgoal *1/1.2'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (INTEGERP I)
              (< 0 I)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 (TWINS R*)))
              (EQUAL (HOW-MANY X1 R*) 2))
         (EQUAL (+ 1 I) 2)).

We suspect that the terms (INTEGERP I), (< 0 I) and (EQUAL (+ 1 I) 2)
are irrelevant to the truth of this conjecture and throw them out.
We will thus try to prove

Subgoal *1/1.2'5'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 (TWINS R*))))
         (NOT (EQUAL (HOW-MANY X1 R*) 2))).

Name the formula above *1.10.

Subgoal *1/1.1
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (< 0
                 (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (NOT (EQUAL E (CAR X))))
         (EQUAL (HOW-MANY E (CDR X)) 2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.1'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.1''
(IMPLIES (AND (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS (RM* X1 X2))))
              (EQUAL (HOW-MANY E (RM* X1 X2)) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

We generalize this conjecture, replacing (RM* X1 X2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1/1.1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

Name the formula above *1.11.

Perhaps we can prove *1.11 by induction.  Six induction schemes are
suggested by this conjecture.  Subsumption reduces that number to five.
These merge into three derived induction schemes.  However, two of
these are flawed and so we are left with one viable candidate.  

We will induct according to a scheme suggested by (HOW-MANY E X2),
but modified to accommodate (HOW-MANY X1 X2).  These suggestions were
produced using the :induction rules HOW-MANY and MEMBER-EQUAL.  If
we let (:P E R* X1 X2) denote *1.11 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP X2))
              (:P E R* X1 X2))
     (IMPLIES (AND (CONSP X2)
                   (NOT (EQUAL E (CAR X2)))
                   (:P E R* X1 (CDR X2)))
              (:P E R* X1 X2))
     (IMPLIES (AND (CONSP X2)
                   (EQUAL E (CAR X2))
                   (:P E R* X1 (CDR X2)))
              (:P E R* X1 X2))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
seven nontautological subgoals.

Subgoal *1.11/7
(IMPLIES (AND (NOT (CONSP X2))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

But simplification reduces this to T, using the :definitions HOW-MANY
and MEMBER-EQUAL and the :executable-counterparts of <, CDR, CONSP
and EQUAL.

Subgoal *1.11/6
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (EQUAL (HOW-MANY E (CDR X2)) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

But simplification reduces this to T, using the :definitions HOW-MANY
and MEMBER-EQUAL, the :executable-counterparts of <, BINARY-+ and EQUAL
and primitive type reasoning.

Subgoal *1.11/5
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (<= (HOW-MANY X1 (CDR X2)) 0)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1.11/5'
(IMPLIES (AND (EQUAL (HOW-MANY X1 (CDR X2)) 0)
              (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using the :definitions HOW-MANY (if-intro) and MEMBER-EQUAL
(if-intro), the :executable-counterparts of < and BINARY-+ and primitive
type reasoning, to the following two conjectures.

Subgoal *1.11/5.2
(IMPLIES (AND (EQUAL (HOW-MANY X1 (CDR X2)) 0)
              (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (TRUE-LISTP R*)
              (EQUAL X1 (CAR X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E (CDR X2)) 2)).

This simplifies, using trivial observations, to

Subgoal *1.11/5.2'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X2) (CDR X2)) 0)
              (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E (CDR X2)) 2)).

The destructor terms (CAR X2) and (CDR X2) can be eliminated by using
CAR-CDR-ELIM to replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2)
by X4.  This produces the following goal.

Subgoal *1.11/5.2''
(IMPLIES (AND (CONSP (CONS X3 X4))
              (EQUAL (HOW-MANY X3 X4) 0)
              (NOT (EQUAL E X3))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E X4) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11/5.2'''
(IMPLIES (AND (EQUAL (HOW-MANY X3 X4) 0)
              (NOT (EQUAL E X3))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E X4) 2)).

Name the formula above *1.11.1.

Subgoal *1.11/5.1
(IMPLIES (AND (EQUAL (HOW-MANY X1 (CDR X2)) 0)
              (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X2))))
                     0)
              (EQUAL X1 (CAR X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E (CDR X2)) 2)).

This simplifies, using trivial observations, to

Subgoal *1.11/5.1'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X2) (CDR X2)) 0)
              (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY (CAR X2)
                               (CDR (MEMBER-EQUAL (CAR X2) (CDR X2))))
                     0)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E (CDR X2)) 2)).

The destructor terms (CAR X2) and (CDR X2) can be eliminated by using
CAR-CDR-ELIM to replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2)
by X4.  This produces the following goal.

Subgoal *1.11/5.1''
(IMPLIES (AND (CONSP (CONS X3 X4))
              (EQUAL (HOW-MANY X3 X4) 0)
              (NOT (EQUAL E X3))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X3 (CDR (MEMBER-EQUAL X3 X4)))
                     0)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E X4) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11/5.1'''
(IMPLIES (AND (EQUAL (HOW-MANY X3 X4) 0)
              (NOT (EQUAL E X3))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X3 (CDR (MEMBER-EQUAL X3 X4)))
                     0)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E X4) 2)).

Name the formula above *1.11.2.

Subgoal *1.11/4
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X2))))
                          0))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using the :definitions HOW-MANY and MEMBER-EQUAL,
the :executable-counterparts of < and BINARY-+ and primitive type reasoning,
to

Subgoal *1.11/4'
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X2))))
                          0))
              (TRUE-LISTP R*)
              (EQUAL X1 (CAR X2))
              (EQUAL (HOW-MANY X1 (CDR X2)) 0)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E (CDR X2)) 2)).

This simplifies, using trivial observations, to

Subgoal *1.11/4''
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL E (CAR X2)))
              (NOT (EQUAL (HOW-MANY (CAR X2)
                                    (CDR (MEMBER-EQUAL (CAR X2) (CDR X2))))
                          0))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY (CAR X2) (CDR X2)) 0)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E (CDR X2)) 2)).

The destructor terms (CAR X2) and (CDR X2) can be eliminated by using
CAR-CDR-ELIM to replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2)
by X4.  This produces the following goal.

Subgoal *1.11/4'''
(IMPLIES (AND (CONSP (CONS X3 X4))
              (NOT (EQUAL E X3))
              (NOT (EQUAL (HOW-MANY X3 (CDR (MEMBER-EQUAL X3 X4)))
                          0))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X3 X4) 0)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E X4) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11/4'4'
(IMPLIES (AND (NOT (EQUAL E X3))
              (NOT (EQUAL (HOW-MANY X3 (CDR (MEMBER-EQUAL X3 X4)))
                          0))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X3 X4) 0)
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2))
         (EQUAL (HOW-MANY E X4) 2)).

Name the formula above *1.11.3.

Subgoal *1.11/3
(IMPLIES (AND (CONSP X2)
              (EQUAL E (CAR X2))
              (EQUAL (HOW-MANY E (CDR X2)) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using the :definitions HOW-MANY and MEMBER-EQUAL,
the :executable-counterparts of BINARY-+ and EQUAL and primitive type
reasoning, to

Subgoal *1.11/3'
(IMPLIES (AND (CONSP X2)
              (EQUAL (HOW-MANY (CAR X2) (CDR X2)) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X2))))
                     0)
              (< 0 (HOW-MANY X1 (CDR X2)))
              (< 0 (HOW-MANY (CAR X2) (TWINS R*)))
              (EQUAL (HOW-MANY (CAR X2) R*) 2))
         (EQUAL (CAR X2) X1)).

The destructor terms (CAR X2) and (CDR X2) can be eliminated by using
CAR-CDR-ELIM to replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2)
by X4.  This produces the following goal.

Subgoal *1.11/3''
(IMPLIES (AND (CONSP (CONS X3 X4))
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11/3'''
(IMPLIES (AND (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

Name the formula above *1.11.4.

Subgoal *1.11/2
(IMPLIES (AND (CONSP X2)
              (EQUAL E (CAR X2))
              (<= (HOW-MANY X1 (CDR X2)) 0)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1.11/2'
(IMPLIES (AND (EQUAL (HOW-MANY X1 (CDR X2)) 0)
              (CONSP X2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY (CAR X2) (TWINS R*)))
              (EQUAL (HOW-MANY (CAR X2) R*) 2)
              (NOT (EQUAL (CAR X2) X1)))
         (EQUAL (HOW-MANY (CAR X2) X2) 2)).

But simplification reduces this to T, using the :definitions HOW-MANY
and MEMBER-EQUAL and the :executable-counterpart of <.

Subgoal *1.11/1
(IMPLIES (AND (CONSP X2)
              (EQUAL E (CAR X2))
              (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X2))))
                          0))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (< 0 (HOW-MANY E (TWINS R*)))
              (EQUAL (HOW-MANY E R*) 2)
              (NOT (EQUAL E X1)))
         (EQUAL (HOW-MANY E X2) 2)).

But simplification reduces this to T, using the :definition MEMBER-EQUAL.

So we now return to *1.11.4, which is

(IMPLIES (AND (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

Perhaps we can prove *1.11.4 by induction.  Six induction schemes are
suggested by this conjecture.  Subsumption reduces that number to five.
These merge into three derived induction schemes.  However, two of
these are flawed and so we are left with one viable candidate.  

We will induct according to a scheme suggested by (HOW-MANY X1 X4),
but modified to accommodate (MEMBER-EQUAL X1 X4) and (HOW-MANY X3 X4).
These suggestions were produced using the :induction rules HOW-MANY
and MEMBER-EQUAL.  If we let (:P R* X1 X3 X4) denote *1.11.4 above
then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X4))
              (:P R* X1 X3 X4))
     (IMPLIES (AND (CONSP X4)
                   (NOT (EQUAL X1 (CAR X4)))
                   (:P R* X1 X3 (CDR X4)))
              (:P R* X1 X3 X4))
     (IMPLIES (AND (CONSP X4)
                   (EQUAL X1 (CAR X4))
                   (:P R* X1 X3 (CDR X4)))
              (:P R* X1 X3 X4))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
seven nontautological subgoals.

Subgoal *1.11.4/7
(IMPLIES (AND (NOT (CONSP X4))
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

But simplification reduces this to T, using the :definition HOW-MANY
and the :executable-counterpart of EQUAL.

Subgoal *1.11.4/6
(IMPLIES (AND (CONSP X4)
              (NOT (EQUAL X1 (CAR X4)))
              (<= (HOW-MANY X1 (CDR X4)) 0)
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1.11.4/6'
(IMPLIES (AND (EQUAL (HOW-MANY X1 (CDR X4)) 0)
              (CONSP X4)
              (NOT (EQUAL X1 (CAR X4)))
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

But simplification reduces this to T, using the :definitions HOW-MANY
and MEMBER-EQUAL, the :executable-counterpart of < and primitive type
reasoning.

Subgoal *1.11.4/5
(IMPLIES (AND (CONSP X4)
              (NOT (EQUAL X1 (CAR X4)))
              (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X4))))
                          0))
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

But simplification reduces this to T, using the :definitions HOW-MANY
and MEMBER-EQUAL and primitive type reasoning.

Subgoal *1.11.4/4
(IMPLIES (AND (CONSP X4)
              (NOT (EQUAL X1 (CAR X4)))
              (NOT (EQUAL (HOW-MANY X3 (CDR X4)) 2))
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

This simplifies, using the :definitions HOW-MANY and MEMBER-EQUAL and
primitive type reasoning, to

Subgoal *1.11.4/4'
(IMPLIES (AND (CONSP X4)
              (NOT (EQUAL X1 (CAR X4)))
              (NOT (EQUAL (HOW-MANY X3 (CDR X4)) 2))
              (EQUAL X3 (CAR X4))
              (EQUAL (+ 1 (HOW-MANY X3 (CDR X4))) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X4))))
                     0)
              (< 0 (HOW-MANY X1 (CDR X4)))
              (< 0 (HOW-MANY X3 (TWINS R*))))
         (NOT (EQUAL (HOW-MANY X3 R*) 2))).

This simplifies, using trivial observations, to

Subgoal *1.11.4/4''
(IMPLIES (AND (CONSP X4)
              (NOT (EQUAL X1 (CAR X4)))
              (NOT (EQUAL (HOW-MANY (CAR X4) (CDR X4)) 2))
              (EQUAL (+ 1 (HOW-MANY (CAR X4) (CDR X4)))
                     2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X4))))
                     0)
              (< 0 (HOW-MANY X1 (CDR X4)))
              (< 0 (HOW-MANY (CAR X4) (TWINS R*))))
         (NOT (EQUAL (HOW-MANY (CAR X4) R*) 2))).

The destructor terms (CAR X4) and (CDR X4) can be eliminated by using
CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and (CDR X4)
by X6.  This produces the following goal.

Subgoal *1.11.4/4'''
(IMPLIES (AND (CONSP (CONS X5 X6))
              (NOT (EQUAL X1 X5))
              (NOT (EQUAL (HOW-MANY X5 X6) 2))
              (EQUAL (+ 1 (HOW-MANY X5 X6)) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X6)))
                     0)
              (< 0 (HOW-MANY X1 X6))
              (< 0 (HOW-MANY X5 (TWINS R*))))
         (NOT (EQUAL (HOW-MANY X5 R*) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4/4'4'
(IMPLIES (AND (NOT (EQUAL X1 X5))
              (NOT (EQUAL (HOW-MANY X5 X6) 2))
              (EQUAL (+ 1 (HOW-MANY X5 X6)) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X6)))
                     0)
              (< 0 (HOW-MANY X1 X6))
              (< 0 (HOW-MANY X5 (TWINS R*))))
         (NOT (EQUAL (HOW-MANY X5 R*) 2))).

We generalize this conjecture, replacing (HOW-MANY X5 X6) by I and
restricting the type of the new variable I to be that of the term it
replaces, as established by HOW-MANY.  This produces

Subgoal *1.11.4/4'5'
(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (NOT (EQUAL X1 X5))
              (NOT (EQUAL I 2))
              (EQUAL (+ 1 I) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X6)))
                     0)
              (< 0 (HOW-MANY X1 X6))
              (< 0 (HOW-MANY X5 (TWINS R*))))
         (NOT (EQUAL (HOW-MANY X5 R*) 2))).

By case analysis we reduce the conjecture to

Subgoal *1.11.4/4'6'
(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (NOT (EQUAL X1 X5))
              (NOT (EQUAL I 2))
              (EQUAL (+ 1 I) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X6)))
                     0)
              (< 0 (HOW-MANY X1 X6))
              (< 0 (HOW-MANY X5 (TWINS R*))))
         (NOT (EQUAL (HOW-MANY X5 R*) 2))).

We suspect that the terms (INTEGERP I), (<= 0 I), (NOT (EQUAL I 2))
and (EQUAL (+ 1 I) 2) are irrelevant to the truth of this conjecture
and throw them out.  We will thus try to prove

Subgoal *1.11.4/4'7'
(IMPLIES (AND (NOT (EQUAL X1 X5))
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X6)))
                     0)
              (< 0 (HOW-MANY X1 X6))
              (< 0 (HOW-MANY X5 (TWINS R*))))
         (NOT (EQUAL (HOW-MANY X5 R*) 2))).

Name the formula above *1.11.4.1.

Subgoal *1.11.4/3
(IMPLIES (AND (CONSP X4)
              (EQUAL X1 (CAR X4))
              (<= (HOW-MANY X1 (CDR X4)) 0)
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1.11.4/3'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X4) (CDR X4)) 0)
              (CONSP X4)
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY (CAR X4)
                               (CDR (MEMBER-EQUAL (CAR X4) X4)))
                     0)
              (< 0 (HOW-MANY (CAR X4) X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 (CAR X4))).

This simplifies, using the :definitions HOW-MANY and MEMBER-EQUAL,
the :executable-counterparts of <, BINARY-+ and EQUAL and primitive
type reasoning, to

Subgoal *1.11.4/3''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X4) (CDR X4)) 0)
              (CONSP X4)
              (EQUAL (HOW-MANY X3 (CDR X4)) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 (CAR X4))).

The destructor terms (CAR X4) and (CDR X4) can be eliminated by using
CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and (CDR X4)
by X6.  This produces the following goal.

Subgoal *1.11.4/3'''
(IMPLIES (AND (CONSP (CONS X5 X6))
              (EQUAL (HOW-MANY X5 X6) 0)
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4/3'4'
(IMPLIES (AND (EQUAL (HOW-MANY X5 X6) 0)
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

Name the formula above *1.11.4.2.

Subgoal *1.11.4/2
(IMPLIES (AND (CONSP X4)
              (EQUAL X1 (CAR X4))
              (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X4))))
                          0))
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

This simplifies, using the :definitions HOW-MANY and MEMBER-EQUAL,
the :executable-counterparts of < and BINARY-+ and primitive type reasoning,
to

Subgoal *1.11.4/2'
(IMPLIES (AND (CONSP X4)
              (NOT (EQUAL (HOW-MANY (CAR X4)
                                    (CDR (MEMBER-EQUAL (CAR X4) (CDR X4))))
                          0))
              (EQUAL (HOW-MANY X3 (CDR X4)) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY (CAR X4) (CDR X4)) 0)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 (CAR X4))).

The destructor terms (CAR X4) and (CDR X4) can be eliminated by using
CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and (CDR X4)
by X6.  This produces the following goal.

Subgoal *1.11.4/2''
(IMPLIES (AND (CONSP (CONS X5 X6))
              (NOT (EQUAL (HOW-MANY X5 (CDR (MEMBER-EQUAL X5 X6)))
                          0))
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X5 X6) 0)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4/2'''
(IMPLIES (AND (NOT (EQUAL (HOW-MANY X5 (CDR (MEMBER-EQUAL X5 X6)))
                          0))
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X5 X6) 0)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

Name the formula above *1.11.4.3.

Subgoal *1.11.4/1
(IMPLIES (AND (CONSP X4)
              (EQUAL X1 (CAR X4))
              (NOT (EQUAL (HOW-MANY X3 (CDR X4)) 2))
              (EQUAL (HOW-MANY X3 X4) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0)
              (< 0 (HOW-MANY X1 X4))
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X1)).

But simplification reduces this to T, using the :definition HOW-MANY
and primitive type reasoning.

So we now return to *1.11.4.3, which is

(IMPLIES (AND (NOT (EQUAL (HOW-MANY X5 (CDR (MEMBER-EQUAL X5 X6)))
                          0))
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (EQUAL (HOW-MANY X5 X6) 0)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

But the formula above is subsumed by *1.11.4.2, which we'll try to
prove later.  We therefore regard *1.11.4.3 as proved (pending the
proof of the more general *1.11.4.2).

We next consider *1.11.4.2, which is

(IMPLIES (AND (EQUAL (HOW-MANY X5 X6) 0)
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

Perhaps we can prove *1.11.4.2 by induction.  Five induction schemes
are suggested by this conjecture.  Subsumption reduces that number
to four.  These merge into three derived induction schemes.  However,
two of these are flawed and so we are left with one viable candidate.

We will induct according to a scheme suggested by (HOW-MANY X3 X6),
but modified to accommodate (HOW-MANY X5 X6).  These suggestions were
produced using the :induction rule HOW-MANY.  If we let (:P R* X3 X5 X6)
denote *1.11.4.2 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X6))
              (:P R* X3 X5 X6))
     (IMPLIES (AND (CONSP X6)
                   (NOT (EQUAL X3 (CAR X6)))
                   (:P R* X3 X5 (CDR X6)))
              (:P R* X3 X5 X6))
     (IMPLIES (AND (CONSP X6)
                   (EQUAL X3 (CAR X6))
                   (:P R* X3 X5 (CDR X6)))
              (:P R* X3 X5 X6))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.

Subgoal *1.11.4.2/5
(IMPLIES (AND (NOT (CONSP X6))
              (EQUAL (HOW-MANY X5 X6) 0)
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

But simplification reduces this to T, using the :definition HOW-MANY
and the :executable-counterpart of EQUAL.

Subgoal *1.11.4.2/4
(IMPLIES (AND (CONSP X6)
              (NOT (EQUAL X3 (CAR X6)))
              (NOT (EQUAL (HOW-MANY X3 (CDR X6)) 2))
              (EQUAL (HOW-MANY X5 X6) 0)
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

But simplification reduces this to T, using the :definition HOW-MANY,
primitive type reasoning and the :type-prescription rule HOW-MANY.

Subgoal *1.11.4.2/3
(IMPLIES (AND (CONSP X6)
              (NOT (EQUAL X3 (CAR X6)))
              (NOT (EQUAL (HOW-MANY X5 (CDR X6)) 0))
              (EQUAL (HOW-MANY X5 X6) 0)
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

But simplification reduces this to T, using the :definition HOW-MANY,
primitive type reasoning and the :type-prescription rule HOW-MANY.

Subgoal *1.11.4.2/2
(IMPLIES (AND (CONSP X6)
              (EQUAL X3 (CAR X6))
              (NOT (EQUAL (HOW-MANY X3 (CDR X6)) 2))
              (EQUAL (HOW-MANY X5 X6) 0)
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

This simplifies, using the :definition HOW-MANY and primitive type
reasoning, to

Subgoal *1.11.4.2/2'
(IMPLIES (AND (CONSP X6)
              (NOT (EQUAL (HOW-MANY (CAR X6) (CDR X6)) 2))
              (EQUAL (HOW-MANY X5 (CDR X6)) 0)
              (EQUAL (+ 1 (HOW-MANY (CAR X6) (CDR X6)))
                     2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY (CAR X6) (TWINS R*)))
              (EQUAL (HOW-MANY (CAR X6) R*) 2))
         (EQUAL (CAR X6) X5)).

The destructor terms (CAR X6) and (CDR X6) can be eliminated by using
CAR-CDR-ELIM to replace X6 by (CONS X7 X8), (CAR X6) by X7 and (CDR X6)
by X8.  This produces the following goal.

Subgoal *1.11.4.2/2''
(IMPLIES (AND (CONSP (CONS X7 X8))
              (NOT (EQUAL (HOW-MANY X7 X8) 2))
              (EQUAL (HOW-MANY X5 X8) 0)
              (EQUAL (+ 1 (HOW-MANY X7 X8)) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4.2/2'''
(IMPLIES (AND (NOT (EQUAL (HOW-MANY X7 X8) 2))
              (EQUAL (HOW-MANY X5 X8) 0)
              (EQUAL (+ 1 (HOW-MANY X7 X8)) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

We generalize this conjecture, replacing (HOW-MANY X7 X8) by I and
restricting the type of the new variable I to be that of the term it
replaces, as established by HOW-MANY.  This produces

Subgoal *1.11.4.2/2'4'
(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (NOT (EQUAL I 2))
              (EQUAL (HOW-MANY X5 X8) 0)
              (EQUAL (+ 1 I) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

By case analysis we reduce the conjecture to

Subgoal *1.11.4.2/2'5'
(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (NOT (EQUAL I 2))
              (EQUAL (HOW-MANY X5 X8) 0)
              (EQUAL (+ 1 I) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

We suspect that the terms (INTEGERP I), (<= 0 I), (NOT (EQUAL I 2))
and (EQUAL (+ 1 I) 2) are irrelevant to the truth of this conjecture
and throw them out.  We will thus try to prove

Subgoal *1.11.4.2/2'6'
(IMPLIES (AND (EQUAL (HOW-MANY X5 X8) 0)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

Name the formula above *1.11.4.2.1.

Subgoal *1.11.4.2/1
(IMPLIES (AND (CONSP X6)
              (EQUAL X3 (CAR X6))
              (NOT (EQUAL (HOW-MANY X5 (CDR X6)) 0))
              (EQUAL (HOW-MANY X5 X6) 0)
              (EQUAL (HOW-MANY X3 X6) 2)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X3 (TWINS R*)))
              (EQUAL (HOW-MANY X3 R*) 2))
         (EQUAL X3 X5)).

But simplification reduces this to T, using the :definition HOW-MANY.

So we now return to *1.11.4.2.1, which is

(IMPLIES (AND (EQUAL (HOW-MANY X5 X8) 0)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

Perhaps we can prove *1.11.4.2.1 by induction.  Four induction schemes
are suggested by this conjecture.  Subsumption reduces that number
to three.  However, two of these are flawed and so we are left with
one viable candidate.  

We will induct according to a scheme suggested by (HOW-MANY X5 X8).
This suggestion was produced using the :induction rule HOW-MANY.  If
we let (:P R* X5 X7 X8) denote *1.11.4.2.1 above then the induction
scheme we'll use is
(AND (IMPLIES (NOT (CONSP X8))
              (:P R* X5 X7 X8))
     (IMPLIES (AND (CONSP X8)
                   (NOT (EQUAL X5 (CAR X8)))
                   (:P R* X5 X7 (CDR X8)))
              (:P R* X5 X7 X8))
     (IMPLIES (AND (CONSP X8)
                   (EQUAL X5 (CAR X8))
                   (:P R* X5 X7 (CDR X8)))
              (:P R* X5 X7 X8))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1.11.4.2.1/3
(IMPLIES (AND (NOT (CONSP X8))
              (EQUAL (HOW-MANY X5 X8) 0)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

This simplifies, using the :definition HOW-MANY and the :executable-
counterpart of EQUAL, to

Subgoal *1.11.4.2.1/3'
(IMPLIES (AND (NOT (CONSP X8))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

We suspect that the term (NOT (CONSP X8)) is irrelevant to the truth
of this conjecture and throw it out.  We will thus try to prove

Subgoal *1.11.4.2.1/3''
(IMPLIES (AND (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

Name the formula above *1.11.4.2.1.1.

Subgoal *1.11.4.2.1/2
(IMPLIES (AND (CONSP X8)
              (NOT (EQUAL X5 (CAR X8)))
              (NOT (EQUAL (HOW-MANY X5 (CDR X8)) 0))
              (EQUAL (HOW-MANY X5 X8) 0)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

But simplification reduces this to T, using the :definition HOW-MANY
and primitive type reasoning.

Subgoal *1.11.4.2.1/1
(IMPLIES (AND (CONSP X8)
              (EQUAL X5 (CAR X8))
              (NOT (EQUAL (HOW-MANY X5 (CDR X8)) 0))
              (EQUAL (HOW-MANY X5 X8) 0)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

But simplification reduces this to T, using the :definition HOW-MANY,
primitive type reasoning and the :type-prescription rule HOW-MANY.

So we now return to *1.11.4.2.1.1, which is

(IMPLIES (AND (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

Perhaps we can prove *1.11.4.2.1.1 by induction.  Three induction schemes
are suggested by this conjecture.  Subsumption reduces that number
to two.  By considering those suggested by the largest number of non-
primitive recursive functions, we narrow the field to one.  

We will induct according to a scheme suggested by (TWINS R*).  This
suggestion was produced using the :induction rules TRUE-LISTP and TWINS.
If we let (:P R* X5 X7) denote *1.11.4.2.1.1 above then the induction
scheme we'll use is
(AND (IMPLIES (NOT (CONSP R*)) (:P R* X5 X7))
     (IMPLIES (AND (CONSP R*)
                   (NOT (MEMBER! (CAR R*) (CDR R*)))
                   (:P (RM* (CAR R*) (CDR R*)) X5 X7))
              (:P R* X5 X7))
     (IMPLIES (AND (CONSP R*)
                   (MEMBER! (CAR R*) (CDR R*))
                   (:P (RM* (CAR R*) (CDR R*)) X5 X7))
              (:P R* X5 X7))).
This induction is justified by the same argument used to admit TWINS.
When applied to the goal at hand the above induction scheme produces
seven nontautological subgoals.

Subgoal *1.11.4.2.1.1/7
(IMPLIES (AND (NOT (CONSP R*))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

But simplification reduces this to T, using the :definitions HOW-MANY
and TRUE-LISTP, the :executable-counterparts of <, CONSP, EQUAL, NOT
and TWINS and primitive type reasoning.

Subgoal *1.11.4.2.1.1/6
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER! (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
(if-intro), TRUE-LISTP and TWINS, the :executable-counterpart of <,
the :rewrite rule MEMBER-HOW-MANY and the :type-prescription rule HOW-MANY,
to the following four conjectures.

Subgoal *1.11.4.2.1.1/6.4
(IMPLIES (AND (CONSP R*)
              (<= (HOW-MANY (CAR R*) (CDR R*)) 0)
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (< 0
                 (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*)))))
              (EQUAL X7 (CAR R*))
              (EQUAL (+ 1 (HOW-MANY X7 (CDR R*))) 2))
         (EQUAL X7 X5)).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule HOW-MANY.

Subgoal *1.11.4.2.1.1/6.3
(IMPLIES (AND (CONSP R*)
              (<= (HOW-MANY (CAR R*) (CDR R*)) 0)
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (< 0
                 (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*)))))
              (NOT (EQUAL X7 (CAR R*)))
              (EQUAL (HOW-MANY X7 (CDR R*)) 2))
         (EQUAL X7 X5)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1.11.4.2.1.1/6.3'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*) (CDR R*)) 0)
              (CONSP R*)
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (< 0
                 (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*)))))
              (NOT (EQUAL X7 (CAR R*)))
              (EQUAL (HOW-MANY X7 (CDR R*)) 2))
         (EQUAL X7 X5)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.11.4.2.1.1/6.3''
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (EQUAL (HOW-MANY R*1 R*2) 0)
              (NOT (EQUAL (HOW-MANY X7 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY X7 (TWINS (RM* R*1 R*2))))
              (NOT (EQUAL X7 R*1))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4.2.1.1/6.3'''
(IMPLIES (AND (EQUAL (HOW-MANY R*1 R*2) 0)
              (NOT (EQUAL (HOW-MANY X7 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY X7 (TWINS (RM* R*1 R*2))))
              (NOT (EQUAL X7 R*1))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.11.4.2.1.1/6.3'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY R*1 R*2) 0)
              (NOT (EQUAL (HOW-MANY X7 R*) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (NOT (EQUAL X7 R*1))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

Name the formula above *1.11.4.2.1.1.1.

Subgoal *1.11.4.2.1.1/6.2
(IMPLIES (AND (CONSP R*)
              (< 0
                 (HOW-MANY (CAR R*)
                           (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (< 0
                 (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*)))))
              (EQUAL X7 (CAR R*))
              (EQUAL (+ 1 (HOW-MANY X7 (CDR R*))) 2))
         (EQUAL X7 X5)).

This simplifies, using trivial observations, to

Subgoal *1.11.4.2.1.1/6.2'
(IMPLIES (AND (CONSP R*)
              (< 0
                 (HOW-MANY (CAR R*)
                           (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (EQUAL (HOW-MANY (CAR R*)
                                    (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (< 0
                 (HOW-MANY (CAR R*)
                           (TWINS (RM* (CAR R*) (CDR R*)))))
              (EQUAL (+ 1 (HOW-MANY (CAR R*) (CDR R*)))
                     2))
         (EQUAL (CAR R*) X5)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.11.4.2.1.1/6.2''
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (< 0
                 (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY R*1 (TWINS (RM* R*1 R*2))))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4.2.1.1/6.2'''
(IMPLIES (AND (< 0
                 (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY R*1 (TWINS (RM* R*1 R*2))))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X5)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.11.4.2.1.1/6.2'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (< 0
                 (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY R*1 R*) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY R*1 (TWINS R*)))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X5)).

Name the formula above *1.11.4.2.1.1.2.

Subgoal *1.11.4.2.1.1/6.1
(IMPLIES (AND (CONSP R*)
              (< 0
                 (HOW-MANY (CAR R*)
                           (CDR (MEMBER-EQUAL (CAR R*) (CDR R*)))))
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (< 0
                 (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*)))))
              (NOT (EQUAL X7 (CAR R*)))
              (EQUAL (HOW-MANY X7 (CDR R*)) 2))
         (EQUAL X7 X5)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.11.4.2.1.1/6.1'
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (< 0
                 (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY X7 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY X7 (TWINS (RM* R*1 R*2))))
              (NOT (EQUAL X7 R*1))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4.2.1.1/6.1''
(IMPLIES (AND (< 0
                 (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY X7 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY X7 (TWINS (RM* R*1 R*2))))
              (NOT (EQUAL X7 R*1))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.11.4.2.1.1/6.1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (< 0
                 (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2))))
              (NOT (EQUAL (HOW-MANY X7 R*) 2))
              (TRUE-LISTP R*2)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (NOT (EQUAL X7 R*1))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

Name the formula above *1.11.4.2.1.1.3.

Subgoal *1.11.4.2.1.1/5
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER! (CAR R*) (CDR R*)))
              (<= (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*))))
                  0)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1.11.4.2.1.1/5'
(IMPLIES (AND (EQUAL (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*))))
                     0)
              (CONSP R*)
              (NOT (MEMBER! (CAR R*) (CDR R*)))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

But simplification reduces this to T, using the :definitions MEMBER!,
TRUE-LISTP and TWINS, the :executable-counterpart of <, the :rewrite
rule MEMBER-HOW-MANY and the :type-prescription rule HOW-MANY.

Subgoal *1.11.4.2.1.1/4
(IMPLIES (AND (CONSP R*)
              (NOT (MEMBER! (CAR R*) (CDR R*)))
              (NOT (TRUE-LISTP (RM* (CAR R*) (CDR R*))))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

But we reduce the conjecture to T, by the :type-prescription rule RM*.

Subgoal *1.11.4.2.1.1/3
(IMPLIES (AND (CONSP R*)
              (MEMBER! (CAR R*) (CDR R*))
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

By the simple :definition MEMBER! and the simple :rewrite rule 
MEMBER-HOW-MANY we reduce the conjecture to

Subgoal *1.11.4.2.1.1/3'
(IMPLIES (AND (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (<= (HOW-MANY (CAR R*)
                            (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                  0)
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1.11.4.2.1.1/3''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*)
                               (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                     0)
              (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!,
TRUE-LISTP and TWINS, the :executable-counterpart of <, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS and MEMBER-HOW-MANY
and the :type-prescription rules HOW-MANY and TWINS, to the following
two conjectures.

Subgoal *1.11.4.2.1.1/3.2
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*)
                               (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                     0)
              (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (EQUAL X7 (CAR R*))
              (< 0
                 (+ 1
                    (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*))))))
              (EQUAL (+ 1 (HOW-MANY X7 (CDR R*))) 2))
         (EQUAL X7 X5)).

This simplifies, using trivial observations, to

Subgoal *1.11.4.2.1.1/3.2'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*)
                               (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                     0)
              (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY (CAR R*)
                                    (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (< 0
                 (+ 1
                    (HOW-MANY (CAR R*)
                              (TWINS (RM* (CAR R*) (CDR R*))))))
              (EQUAL (+ 1 (HOW-MANY (CAR R*) (CDR R*)))
                     2))
         (EQUAL (CAR R*) X5)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.11.4.2.1.1/3.2''
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (< 0 (HOW-MANY R*1 R*2))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (< 0
                 (+ 1 (HOW-MANY R*1 (TWINS (RM* R*1 R*2)))))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4.2.1.1/3.2'''
(IMPLIES (AND (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (< 0 (HOW-MANY R*1 R*2))
              (NOT (EQUAL (HOW-MANY R*1 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (< 0
                 (+ 1 (HOW-MANY R*1 (TWINS (RM* R*1 R*2)))))
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X5)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and 
(HOW-MANY R*1 R*2) by I and restricting the types of the new variables
R* and I to be those of the terms they replace, as established by RM*
and HOW-MANY.  This produces

Subgoal *1.11.4.2.1.1/3.2'4'
(IMPLIES (AND (TRUE-LISTP R*)
              (INTEGERP I)
              (< 0 I)
              (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (NOT (EQUAL (HOW-MANY R*1 R*) 2))
              (TRUE-LISTP R*2)
              (< 0 (+ 1 (HOW-MANY R*1 (TWINS R*))))
              (EQUAL (+ 1 I) 2))
         (EQUAL R*1 X5)).

We suspect that the terms (INTEGERP I), (< 0 I) and (EQUAL (+ 1 I) 2)
are irrelevant to the truth of this conjecture and throw them out.
We will thus try to prove

Subgoal *1.11.4.2.1.1/3.2'5'
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (NOT (EQUAL (HOW-MANY R*1 R*) 2))
              (TRUE-LISTP R*2)
              (< 0 (+ 1 (HOW-MANY R*1 (TWINS R*)))))
         (EQUAL R*1 X5)).

Name the formula above *1.11.4.2.1.1.4.

Subgoal *1.11.4.2.1.1/3.1
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*)
                               (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                     0)
              (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (NOT (EQUAL (HOW-MANY X7 (RM* (CAR R*) (CDR R*)))
                          2))
              (TRUE-LISTP (CDR R*))
              (NOT (EQUAL X7 (CAR R*)))
              (< 0
                 (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*)))))
              (EQUAL (HOW-MANY X7 (CDR R*)) 2))
         (EQUAL X7 X5)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.11.4.2.1.1/3.1'
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (< 0 (HOW-MANY R*1 R*2))
              (NOT (EQUAL (HOW-MANY X7 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (NOT (EQUAL X7 R*1))
              (< 0 (HOW-MANY X7 (TWINS (RM* R*1 R*2))))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4.2.1.1/3.1''
(IMPLIES (AND (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (< 0 (HOW-MANY R*1 R*2))
              (NOT (EQUAL (HOW-MANY X7 (RM* R*1 R*2)) 2))
              (TRUE-LISTP R*2)
              (NOT (EQUAL X7 R*1))
              (< 0 (HOW-MANY X7 (TWINS (RM* R*1 R*2))))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

We generalize this conjecture, replacing (RM* R*1 R*2) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.11.4.2.1.1/3.1'''
(IMPLIES (AND (TRUE-LISTP R*)
              (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (< 0 (HOW-MANY R*1 R*2))
              (NOT (EQUAL (HOW-MANY X7 R*) 2))
              (TRUE-LISTP R*2)
              (NOT (EQUAL X7 R*1))
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*2) 2))
         (EQUAL X7 X5)).

Name the formula above *1.11.4.2.1.1.5.

Subgoal *1.11.4.2.1.1/2
(IMPLIES (AND (CONSP R*)
              (MEMBER! (CAR R*) (CDR R*))
              (<= (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*))))
                  0)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

By the simple :definition MEMBER! and the simple :rewrite rule 
MEMBER-HOW-MANY we reduce the conjecture to

Subgoal *1.11.4.2.1.1/2'
(IMPLIES (AND (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (<= (HOW-MANY (CAR R*)
                            (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                  0)
              (<= (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*))))
                  0)
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1.11.4.2.1.1/2''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*)
                               (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                     0)
              (EQUAL (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*))))
                     0)
              (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

This simplifies, using the :definitions HOW-MANY, MEMBER!, TRUE-LISTP
and TWINS, the :executable-counterparts of < and BINARY-+, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and MEMBER-HOW-MANY
and the :type-prescription rules HOW-MANY and TWINS, to

Subgoal *1.11.4.2.1.1/2'''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*)
                               (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                     0)
              (EQUAL (HOW-MANY X7 (TWINS (RM* (CAR R*) (CDR R*))))
                     0)
              (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (TRUE-LISTP (CDR R*))
              (EQUAL X7 (CAR R*))
              (EQUAL (+ 1 (HOW-MANY X7 (CDR R*))) 2))
         (EQUAL X7 X5)).

This simplifies, using trivial observations, to

Subgoal *1.11.4.2.1.1/2'4'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR R*)
                               (CDR (MEMBER-EQUAL (CAR R*) (CDR R*))))
                     0)
              (EQUAL (HOW-MANY (CAR R*)
                               (TWINS (RM* (CAR R*) (CDR R*))))
                     0)
              (CONSP R*)
              (< 0 (HOW-MANY (CAR R*) (CDR R*)))
              (TRUE-LISTP (CDR R*))
              (EQUAL (+ 1 (HOW-MANY (CAR R*) (CDR R*)))
                     2))
         (EQUAL (CAR R*) X5)).

The destructor terms (CAR R*) and (CDR R*) can be eliminated by using
CAR-CDR-ELIM to replace R* by (CONS R*1 R*2), (CAR R*) by R*1 and (CDR R*)
by R*2.  This produces the following goal.

Subgoal *1.11.4.2.1.1/2'5'
(IMPLIES (AND (CONSP (CONS R*1 R*2))
              (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (EQUAL (HOW-MANY R*1 (TWINS (RM* R*1 R*2)))
                     0)
              (< 0 (HOW-MANY R*1 R*2))
              (TRUE-LISTP R*2)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X5)).

This simplifies, using primitive type reasoning, to

Subgoal *1.11.4.2.1.1/2'6'
(IMPLIES (AND (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (EQUAL (HOW-MANY R*1 (TWINS (RM* R*1 R*2)))
                     0)
              (< 0 (HOW-MANY R*1 R*2))
              (TRUE-LISTP R*2)
              (EQUAL (+ 1 (HOW-MANY R*1 R*2)) 2))
         (EQUAL R*1 X5)).

We generalize this conjecture, replacing (HOW-MANY R*1 R*2) by I and
restricting the type of the new variable I to be that of the term it
replaces, as established by HOW-MANY.  This produces

Subgoal *1.11.4.2.1.1/2'7'
(IMPLIES (AND (INTEGERP I)
              (< 0 I)
              (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (EQUAL (HOW-MANY R*1 (TWINS (RM* R*1 R*2)))
                     0)
              (TRUE-LISTP R*2)
              (EQUAL (+ 1 I) 2))
         (EQUAL R*1 X5)).

We suspect that the terms (INTEGERP I), (< 0 I) and (EQUAL (+ 1 I) 2)
are irrelevant to the truth of this conjecture and throw them out.
We will thus try to prove

Subgoal *1.11.4.2.1.1/2'8'
(IMPLIES (AND (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (EQUAL (HOW-MANY R*1 (TWINS (RM* R*1 R*2)))
                     0)
              (TRUE-LISTP R*2))
         (EQUAL R*1 X5)).

Name the formula above *1.11.4.2.1.1.6.

Subgoal *1.11.4.2.1.1/1
(IMPLIES (AND (CONSP R*)
              (MEMBER! (CAR R*) (CDR R*))
              (NOT (TRUE-LISTP (RM* (CAR R*) (CDR R*))))
              (TRUE-LISTP R*)
              (< 0 (HOW-MANY X7 (TWINS R*)))
              (EQUAL (HOW-MANY X7 R*) 2))
         (EQUAL X7 X5)).

But we reduce the conjecture to T, by the :type-prescription rule RM*.

So we now return to *1.11.4.2.1.1.6, which is

(IMPLIES (AND (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (EQUAL (HOW-MANY R*1 (TWINS (RM* R*1 R*2)))
                     0)
              (TRUE-LISTP R*2))
         (EQUAL R*1 X5)).

Perhaps we can prove *1.11.4.2.1.1.6 by induction.  Three induction
schemes are suggested by this conjecture.  Subsumption reduces that
number to two.  These merge into one derived induction scheme.  

We will induct according to a scheme suggested by (RM* R*1 R*2).  This
suggestion was produced using the :induction rules MEMBER-EQUAL, RM*
and TRUE-LISTP.  If we let (:P R*1 R*2 X5) denote *1.11.4.2.1.1.6 above
then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP R*2))
              (:P R*1 R*2 X5))
     (IMPLIES (AND (CONSP R*2)
                   (NOT (EQUAL R*1 (CAR R*2)))
                   (:P R*1 (CDR R*2) X5))
              (:P R*1 R*2 X5))
     (IMPLIES (AND (CONSP R*2)
                   (EQUAL R*1 (CAR R*2))
                   (:P R*1 (CDR R*2) X5))
              (:P R*1 R*2 X5))).
This induction is justified by the same argument used to admit RM*.
When applied to the goal at hand the above induction scheme produces
seven nontautological subgoals.

Subgoal *1.11.4.2.1.1.6/7
(IMPLIES (AND (NOT (CONSP R*2))
              (EQUAL (HOW-MANY R*1 (CDR (MEMBER-EQUAL R*1 R*2)))
                     0)
              (EQUAL (HOW-MANY R*1 (TWINS (RM* R*1 R*2)))
                     0)
              (TRUE-LISTP R*2))
         (EQUAL R*1 X5)).

This simplifies, using the :definitions HOW-MANY, MEMBER-EQUAL, RM*
and TRUE-LISTP, the :executable-counterparts of CDR, CONSP, EQUAL and
TWINS and primitive type reasoning, to

Subgoal *1.11.4.2.1.1.6/7'
(IMPLIES (NOT R*2) (EQUAL R*1 X5)).

This simplifies, using trivial observations, to

Subgoal *1.11.4.2.1.1.6/7''
(EQUAL R*1 X5).

We suspect that this conjecture is not a theorem.  We might as well
be trying to prove

Subgoal *1.11.4.2.1.1.6/7'''
NIL.


Summary
Form:  ( DEFTHM TWINS-CORRECT ...)
Rules: ((:DEFINITION HOW-MANY)
        (:DEFINITION IFF)
        (:DEFINITION MEMBER!)
        (:DEFINITION MEMBER-EQL-EXEC$GUARD-CHECK)
        (:DEFINITION MEMBER-EQUAL)
        (:DEFINITION NOT)
        (:DEFINITION RETURN-LAST)
        (:DEFINITION RM*)
        (:DEFINITION TRUE-LISTP)
        (:DEFINITION TWINS)
        (:ELIM CAR-CDR-ELIM)
        (:EQUIVALENCE IFF-IS-AN-EQUIVALENCE)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TWINS)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION HOW-MANY)
        (:INDUCTION MEMBER-EQUAL)
        (:INDUCTION RM*)
        (:INDUCTION TRUE-LISTP)
        (:INDUCTION TWINS)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE MEMBER-HOW-MANY)
        (:TYPE-PRESCRIPTION HOW-MANY)
        (:TYPE-PRESCRIPTION RM*)
        (:TYPE-PRESCRIPTION TWINS))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION HOW-MANY)
             (:DEFINITION MEMBER!)
             (:DEFINITION MEMBER-EQUAL))
Warnings:  Subsume

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
<GOAL>

*** Key checkpoints under a top-level induction
    before generating a goal of NIL (see :DOC nil-goal): ***

Subgoal *1/2.7'
(IMPLIES (AND (EQUAL (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X) (CDR X)) 0)
              (CONSP X)
              (NOT (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2))
              (NOT (EQUAL E (CAR X))))
         (NOT (EQUAL (HOW-MANY E (CDR X)) 2)))

Subgoal *1/2.6'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X) (CDR X)) 0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (TWINS (RM* (CAR X) (CDR X))))))
         (NOT (EQUAL (HOW-MANY (CAR X) (RM* (CAR X) (CDR X)))
                     2)))

Subgoal *1/2.5'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X) (CDR X)) 0)
              (CONSP X)
              (< 0
                 (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
              (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                     2)
              (NOT (EQUAL E (CAR X))))
         (EQUAL (HOW-MANY E (CDR X)) 2))

Note: There are eight additional key checkpoints under a top-level
induction.  See :DOC set-checkpoint-summary-limit to change the number
printed.

ACL2 Error in ( DEFTHM TWINS-CORRECT ...):  See :DOC failure.

******** FAILED ********
ACL2 >>(DEFTHM HOW-MANY-RM*
               (EQUAL (HOW-MANY E (RM* D X))
                      (IF (EQUAL E D) 0 (HOW-MANY E X))))

This simplifies, using trivial observations, to the following two conjectures.

Subgoal 2
(IMPLIES (EQUAL E D)
         (EQUAL (HOW-MANY E (RM* D X)) 0)).

This simplifies, using trivial observations, to

Subgoal 2'
(EQUAL (HOW-MANY D (RM* D X)) 0).

Name the formula above *1.

Subgoal 1
(IMPLIES (NOT (EQUAL E D))
         (EQUAL (HOW-MANY E (RM* D X))
                (HOW-MANY E X))).

Normally we would attempt to prove Subgoal 1 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  These merge into one derived induction scheme.

We will induct according to a scheme suggested by (HOW-MANY E X), but
modified to accommodate (RM* D X).  These suggestions were produced
using the :induction rules HOW-MANY and RM*.  If we let (:P D E X)
denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P D E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL E (CAR X)))
                   (:P D E (CDR X)))
              (:P D E X))
     (IMPLIES (AND (CONSP X)
                   (EQUAL E (CAR X))
                   (:P D E (CDR X)))
              (:P D E X))).
This induction is justified by the same argument used to admit HOW-MANY.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (EQUAL (HOW-MANY E (RM* D X))
                (IF (EQUAL E D) 0 (HOW-MANY E X)))).

But simplification reduces this to T, using the :definitions HOW-MANY
and RM* and the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (EQUAL (HOW-MANY E (RM* D (CDR X)))
                     (IF (EQUAL E D)
                         0 (HOW-MANY E (CDR X)))))
         (EQUAL (HOW-MANY E (RM* D X))
                (IF (EQUAL E D) 0 (HOW-MANY E X)))).

This simplifies, using the :definitions HOW-MANY and RM* (if-intro),
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule RM*, to the following two conjectures.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (EQUAL E D)
              (EQUAL (HOW-MANY E (RM* D (CDR X))) 0))
         (EQUAL (HOW-MANY D (RM* D (CDR X))) 0)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (NOT (EQUAL E D))
              (EQUAL (HOW-MANY E (RM* D (CDR X)))
                     (HOW-MANY E (CDR X)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (HOW-MANY E (CONS (CAR X) (RM* D (CDR X))))
                (HOW-MANY E (CDR X)))).

But simplification reduces this to T, using the :definition HOW-MANY,
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule RM*.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL E (CAR X))
              (EQUAL (HOW-MANY E (RM* D (CDR X)))
                     (IF (EQUAL E D)
                         0 (HOW-MANY E (CDR X)))))
         (EQUAL (HOW-MANY E (RM* D X))
                (IF (EQUAL E D) 0 (HOW-MANY E X)))).

This simplifies, using the :definitions HOW-MANY and RM*, primitive
type reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rule RM*, to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) D)
              (EQUAL (HOW-MANY (CAR X) (RM* D (CDR X)))
                     0))
         (EQUAL (HOW-MANY D (RM* D (CDR X))) 0)).

But simplification reduces this to T, using trivial observations.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM HOW-MANY-RM* ...)
Rules: ((:DEFINITION HOW-MANY)
        (:DEFINITION RM*)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION HOW-MANY)
        (:INDUCTION RM*)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION RM*))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION RM*))
 HOW-MANY-RM*
ACL2 >>(DEFTHM TWINS-CORRECT
               (IFF (MEMBER E (TWINS X))
                    (EQUAL (HOW-MANY E X) 2)))

ACL2 Warning [Subsume] in ( DEFTHM TWINS-CORRECT ...):  The previously
added rule MEMBER-HOW-MANY subsumes a newly proposed :REWRITE rule
generated from TWINS-CORRECT, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.


By the simple :definitions MEMBER-EQL-EXEC$GUARD-CHECK and RETURN-LAST,
the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Goal'
(COND ((< 0 (HOW-MANY E (TWINS X)))
       (EQUAL (HOW-MANY E X) 2))
      ((EQUAL (HOW-MANY E X) 2) NIL)
      (T T)).

This simplifies, using trivial observations, to the following two conjectures.

Subgoal 2
(IMPLIES (<= (HOW-MANY E (TWINS X)) 0)
         (NOT (EQUAL (HOW-MANY E X) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal 2'
(IMPLIES (EQUAL (HOW-MANY E (TWINS X)) 0)
         (NOT (EQUAL (HOW-MANY E X) 2))).

Name the formula above *1.

Subgoal 1
(IMPLIES (< 0 (HOW-MANY E (TWINS X)))
         (EQUAL (HOW-MANY E X) 2)).

Normally we would attempt to prove Subgoal 1 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  By considering those suggested by the largest
number of non-primitive recursive functions, we narrow the field to
one.  

We will induct according to a scheme suggested by (TWINS X).  This
suggestion was produced using the :induction rule TWINS.  If we let
(:P E X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (MEMBER! (CAR X) (CDR X)))
                   (:P E (RM* (CAR X) (CDR X))))
              (:P E X))
     (IMPLIES (AND (CONSP X)
                   (MEMBER! (CAR X) (CDR X))
                   (:P E (RM* (CAR X) (CDR X))))
              (:P E X))).
This induction is justified by the same argument used to admit TWINS.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (NOT (CONSP X))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

But simplification reduces this to T, using the :definitions HOW-MANY
and TWINS and the :executable-counterparts of <, CONSP and EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER! (CAR X) (CDR X)))
              (IFF (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                   (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2)))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER! (CAR X) (CDR X)))
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
(if-intro) and TWINS (if-intro), the :executable-counterparts of <
and EQUAL, primitive type reasoning, the :rewrite rules HOW-MANY-RM*
(if-intro) and MEMBER-HOW-MANY and the :type-prescription rule HOW-MANY,
to the following ten conjectures.

Subgoal *1/2.10
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (CDR X)) 2))
              (EQUAL E (CAR X)))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule HOW-MANY.

Subgoal *1/2.9
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (HOW-MANY E (CDR X)))
              (<= (HOW-MANY E (CDR (MEMBER-EQUAL E (CDR X))))
                  0)
              (< 0
                 (HOW-MANY E
                           (CONS E (TWINS (RM* (CAR X) (CDR X)))))))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.8
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0
                 (HOW-MANY E (CDR (MEMBER-EQUAL E (CDR X))))))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule HOW-MANY.

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E (CDR X)) 0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.6
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E
                            (CONS E (TWINS (RM* (CAR X) (CDR X)))))
                  0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule HOW-MANY.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (CDR X)) 2))
              (EQUAL E (CAR X)))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/2.5'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY (CAR X) (CDR X)) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.5''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 X2) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.5'''
(IMPLIES (AND (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL (HOW-MANY X1 X2) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

We generalize this conjecture, replacing (HOW-MANY X1 X2) by I and
restricting the type of the new variable I to be that of the term it
replaces, as established by HOW-MANY.  This produces

Subgoal *1/2.5'4'
(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL I 2)))
         (NOT (EQUAL (+ 1 I) 2))).

By case analysis we reduce the conjecture to

Subgoal *1/2.5'5'
(IMPLIES (AND (INTEGERP I)
              (<= 0 I)
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2))))
              (NOT (EQUAL I 2)))
         (NOT (EQUAL (+ 1 I) 2))).

We suspect that the terms (INTEGERP I), (<= 0 I), (NOT (EQUAL I 2))
and (NOT (EQUAL (+ 1 I) 2)) are irrelevant to the truth of this conjecture
and throw them out.  We will thus try to prove

Subgoal *1/2.5'6'
(IMPLIES (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                0)
         (<= (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
             0)).

Name the formula above *1.1.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (HOW-MANY E (CDR X)))
              (<= (HOW-MANY E (CDR (MEMBER-EQUAL E (CDR X))))
                  0)
              (< 0
                 (HOW-MANY E
                           (CONS E (TWINS (RM* (CAR X) (CDR X)))))))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0
                 (HOW-MANY E (CDR (MEMBER-EQUAL E (CDR X))))))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/2.3'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X))))))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2.3''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

This simplifies, using primitive type reasoning, to

Subgoal *1/2.3'''
(IMPLIES (AND (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (< 0
                 (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))))
         (NOT (EQUAL (+ 1 (HOW-MANY X1 X2)) 2))).

Name the formula above *1.2.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E (CDR X)) 0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E
                            (CONS E (TWINS (RM* (CAR X) (CDR X)))))
                  0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/2.1'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CONS (CAR X)
                                     (TWINS (RM* (CAR X) (CDR X)))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X))))))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2))).

But simplification reduces this to T, using the :definition HOW-MANY,
the :executable-counterparts of BINARY-+ and EQUAL, primitive type
reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rule TWINS.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEMBER! (CAR X) (CDR X))
              (IFF (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                   (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2)))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the simple :definition MEMBER!, the :equivalence rule 
IFF-IS-AN-EQUIVALENCE and the simple :rewrite rule MEMBER-HOW-MANY
we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                  0)
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
(if-intro) and TWINS (if-intro), the :executable-counterparts of <,
BINARY-+ and EQUAL, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, HOW-MANY-RM* (if-intro) and MEMBER-HOW-MANY and the :type-
prescription rules HOW-MANY and TWINS, to the following five conjectures.

Subgoal *1/1.5
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (CDR X)) 2))
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1.5'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (NOT (EQUAL (HOW-MANY (CAR X) (CDR X)) 2)))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.5''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (NOT (EQUAL (HOW-MANY X1 X2) 2)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.5'''
(IMPLIES (AND (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2))
              (NOT (EQUAL (HOW-MANY X1 X2) 2)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (HOW-MANY X1 X2) by I and
restricting the type of the new variable I to be that of the term it
replaces, as established by HOW-MANY.  This produces

Subgoal *1/1.5'4'
(IMPLIES (AND (INTEGERP I)
              (< 0 I)
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (NOT (EQUAL I 2)))
         (EQUAL (+ 1 I) 2)).

We suspect that the terms (INTEGERP I), (< 0 I), (NOT (EQUAL I 2))
and (EQUAL (+ 1 I) 2) are irrelevant to the truth of this conjecture
and throw them out.  We will thus try to prove

Subgoal *1/1.5'5'
(IMPLIES (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                0)
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

Name the formula above *1.3.

Subgoal *1/1.4
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (HOW-MANY E (CDR X)))
              (<= (HOW-MANY E (CDR (MEMBER-EQUAL E (CDR X))))
                  0)
              (< 0
                 (HOW-MANY E
                           (CONS E (TWINS (RM* (CAR X) (CDR X)))))))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1.4'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (< 0
                 (HOW-MANY (CAR X)
                           (CONS (CAR X)
                                 (TWINS (RM* (CAR X) (CDR X)))))))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

This simplifies, using the :definition HOW-MANY, the :executable-counterparts
of < and BINARY-+, primitive type reasoning, the :rewrite rules CAR-CONS
and CDR-CONS and the :type-prescription rule TWINS, to

Subgoal *1/1.4''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X))))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.4'''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.4'4'
(IMPLIES (AND (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0)
              (< 0 (HOW-MANY X1 X2)))
         (EQUAL (+ 1 (HOW-MANY X1 X2)) 2)).

We generalize this conjecture, replacing (HOW-MANY X1 X2) by I and
restricting the type of the new variable I to be that of the term it
replaces, as established by HOW-MANY.  This produces

Subgoal *1/1.4'5'
(IMPLIES (AND (INTEGERP I)
              (< 0 I)
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0)
              (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))
         (EQUAL (+ 1 I) 2)).

We suspect that the terms (INTEGERP I), (< 0 I) and (EQUAL (+ 1 I) 2)
are irrelevant to the truth of this conjecture and throw them out.
We will thus try to prove

Subgoal *1/1.4'6'
(IMPLIES (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                0)
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

Name the formula above *1.4.

Subgoal *1/1.3
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0
                 (HOW-MANY E (CDR (MEMBER-EQUAL E (CDR X))))))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using the :executable-counterparts
of < and NOT.

Subgoal *1/1.2
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E (CDR X)) 0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.1
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E
                            (CONS E (TWINS (RM* (CAR X) (CDR X)))))
                  0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1.1'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CONS (CAR X)
                                     (TWINS (RM* (CAR X) (CDR X)))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X))))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2))).

But simplification reduces this to T, using the :definition HOW-MANY,
the :executable-counterparts of BINARY-+ and EQUAL, primitive type
reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rule TWINS.

So we now return to *1.4, which is

(IMPLIES (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                0)
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

But the formula above is subsumed by *1.3, which we'll try to prove
later.  We therefore regard *1.4 as proved (pending the proof of the
more general *1.3).

We next consider *1.3, which is

(IMPLIES (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                0)
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

Perhaps we can prove *1.3 by induction.  Two induction schemes are
suggested by this conjecture.  These merge into one derived induction
scheme.  

We will induct according to a scheme suggested by (MEMBER-EQUAL X1 X2).
This suggestion was produced using the :induction rules MEMBER-EQUAL
and RM*.  If we let (:P X1 X2) denote *1.3 above then the induction
scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP X2))
                   (NOT (EQUAL X1 (CAR X2)))
                   (:P X1 (CDR X2)))
              (:P X1 X2))
     (IMPLIES (AND (NOT (ENDP X2))
                   (EQUAL X1 (CAR X2)))
              (:P X1 X2))
     (IMPLIES (ENDP X2) (:P X1 X2))).
This induction is justified by the same argument used to admit MEMBER-EQUAL.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1.3/4
(IMPLIES (AND (NOT (ENDP X2))
              (NOT (EQUAL X1 (CAR X2)))
              (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X2))))
                          0))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.3/4'
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL X1 (CAR X2)))
              (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X2))))
                          0))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

But simplification reduces this to T, using the :definitions MEMBER-EQUAL
and RM* and primitive type reasoning.

Subgoal *1.3/3
(IMPLIES (AND (NOT (ENDP X2))
              (NOT (EQUAL X1 (CAR X2)))
              (NOT (EQUAL (HOW-MANY X1 (TWINS (RM* X1 (CDR X2))))
                          0))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.3/3'
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL X1 (CAR X2)))
              (NOT (EQUAL (HOW-MANY X1 (TWINS (RM* X1 (CDR X2))))
                          0))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

This simplifies, using the :definitions MEMBER-EQUAL and RM* and primitive
type reasoning, to

Subgoal *1.3/3''
(IMPLIES (AND (CONSP X2)
              (NOT (EQUAL X1 (CAR X2)))
              (NOT (EQUAL (HOW-MANY X1 (TWINS (RM* X1 (CDR X2))))
                          0))
              (EQUAL (HOW-MANY X1
                               (TWINS (CONS (CAR X2) (RM* X1 (CDR X2)))))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 (CDR X2))))
                     0))).

The destructor terms (CAR X2) and (CDR X2) can be eliminated by using
CAR-CDR-ELIM to replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2)
by X4.  This produces the following goal.

Subgoal *1.3/3'''
(IMPLIES (AND (CONSP (CONS X3 X4))
              (NOT (EQUAL X1 X3))
              (NOT (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X4)))
                          0))
              (EQUAL (HOW-MANY X1 (TWINS (CONS X3 (RM* X1 X4))))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0))).

This simplifies, using primitive type reasoning, to

Subgoal *1.3/3'4'
(IMPLIES (AND (NOT (EQUAL X1 X3))
              (NOT (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X4)))
                          0))
              (EQUAL (HOW-MANY X1 (TWINS (CONS X3 (RM* X1 X4))))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0))).

We generalize this conjecture, replacing (RM* X1 X4) by R* and restricting
the type of the new variable R* to be that of the term it replaces,
as established by RM*.  This produces

Subgoal *1.3/3'5'
(IMPLIES (AND (TRUE-LISTP R*)
              (NOT (EQUAL X1 X3))
              (NOT (EQUAL (HOW-MANY X1 (TWINS R*)) 0))
              (EQUAL (HOW-MANY X1 (TWINS (CONS X3 R*)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X4)))
                     0))).

Name the formula above *1.3.1.

Subgoal *1.3/2
(IMPLIES (AND (NOT (ENDP X2))
              (EQUAL X1 (CAR X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.3/2'
(IMPLIES (AND (CONSP X2)
              (EQUAL X1 (CAR X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

This simplifies, using the :definition MEMBER-EQUAL and primitive type
reasoning, to

Subgoal *1.3/2''
(IMPLIES (AND (CONSP X2)
              (EQUAL (HOW-MANY (CAR X2)
                               (TWINS (RM* (CAR X2) X2)))
                     0))
         (NOT (EQUAL (HOW-MANY (CAR X2) (CDR X2))
                     0))).

This simplifies, using the :definition RM* and primitive type reasoning,
to

Subgoal *1.3/2'''
(IMPLIES (AND (CONSP X2)
              (EQUAL (HOW-MANY (CAR X2)
                               (TWINS (RM* (CAR X2) (CDR X2))))
                     0))
         (NOT (EQUAL (HOW-MANY (CAR X2) (CDR X2))
                     0))).

The destructor terms (CAR X2) and (CDR X2) can be eliminated by using
CAR-CDR-ELIM to replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2)
by X4.  This produces the following goal.

Subgoal *1.3/2'4'
(IMPLIES (AND (CONSP (CONS X3 X4))
              (EQUAL (HOW-MANY X3 (TWINS (RM* X3 X4)))
                     0))
         (NOT (EQUAL (HOW-MANY X3 X4) 0))).

This simplifies, using primitive type reasoning, to

Subgoal *1.3/2'5'
(IMPLIES (EQUAL (HOW-MANY X3 (TWINS (RM* X3 X4)))
                0)
         (NOT (EQUAL (HOW-MANY X3 X4) 0))).

Name the formula above *1.3.2.

Subgoal *1.3/1
(IMPLIES (AND (ENDP X2)
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1.3/1'
(IMPLIES (AND (NOT (CONSP X2))
              (EQUAL (HOW-MANY X1 (TWINS (RM* X1 X2)))
                     0))
         (NOT (EQUAL (HOW-MANY X1 (CDR (MEMBER-EQUAL X1 X2)))
                     0))).

This simplifies, using the :definitions HOW-MANY, MEMBER-EQUAL and
RM* and the :executable-counterparts of CDR, CONSP, EQUAL and TWINS,
to

Subgoal *1.3/1''
(CONSP X2).

We suspect that this conjecture is not a theorem.  We might as well
be trying to prove

Subgoal *1.3/1'''
NIL.


Summary
Form:  ( DEFTHM TWINS-CORRECT ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION HOW-MANY)
        (:DEFINITION IFF)
        (:DEFINITION MEMBER!)
        (:DEFINITION MEMBER-EQL-EXEC$GUARD-CHECK)
        (:DEFINITION MEMBER-EQUAL)
        (:DEFINITION NOT)
        (:DEFINITION RETURN-LAST)
        (:DEFINITION RM*)
        (:DEFINITION TWINS)
        (:ELIM CAR-CDR-ELIM)
        (:EQUIVALENCE IFF-IS-AN-EQUIVALENCE)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART TWINS)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MEMBER-EQUAL)
        (:INDUCTION RM*)
        (:INDUCTION TWINS)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE HOW-MANY-RM*)
        (:REWRITE MEMBER-HOW-MANY)
        (:TYPE-PRESCRIPTION HOW-MANY)
        (:TYPE-PRESCRIPTION RM*)
        (:TYPE-PRESCRIPTION TWINS))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION HOW-MANY)
             (:DEFINITION MEMBER!)
             (:DEFINITION TWINS)
             (:REWRITE HOW-MANY-RM*))
Warnings:  Subsume

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
<GOAL>

*** Key checkpoints under a top-level induction
    before generating a goal of NIL (see :DOC nil-goal): ***

Subgoal *1/2.5'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X)))))
              (NOT (EQUAL (HOW-MANY (CAR X) (CDR X)) 2)))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2)))

Subgoal *1/2.3'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0
                 (HOW-MANY (CAR X)
                           (CDR (MEMBER-EQUAL (CAR X) (CDR X))))))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2)))

Subgoal *1/1.5'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (NOT (EQUAL (HOW-MANY (CAR X) (CDR X)) 2)))
         (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                2))

ACL2 Error in ( DEFTHM TWINS-CORRECT ...):  See :DOC failure.

******** FAILED ********
ACL2 >>(DEFTHM HOW-MANY-CDR-MEMBER
               (IMPLIES (MEMBER E X)
                        (EQUAL (HOW-MANY E (CDR (MEMBER E X)))
                               (- (HOW-MANY E X) 1))))

By the simple :definitions MEMBER-EQL-EXEC$GUARD-CHECK and RETURN-LAST
and the simple :rewrite rule MEMBER-HOW-MANY we reduce the conjecture
to

Goal'
(IMPLIES (< 0 (HOW-MANY E X))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

Name the formula above *1.

Perhaps we can prove *1 by induction.  Three induction schemes are
suggested by this conjecture.  Subsumption reduces that number to two.
These merge into one derived induction scheme.  

We will induct according to a scheme suggested by (MEMBER-EQUAL E X).
This suggestion was produced using the :induction rules HOW-MANY and
MEMBER-EQUAL.  If we let (:P E X) denote *1 above then the induction
scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (EQUAL E (CAR X)))
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (AND (NOT (ENDP X)) (EQUAL E (CAR X)))
              (:P E X))
     (IMPLIES (ENDP X) (:P E X))).
This induction is justified by the same argument used to admit MEMBER-EQUAL.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1/4
(IMPLIES (AND (NOT (ENDP X))
              (NOT (EQUAL E (CAR X)))
              (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E (CDR X))))
                     (+ -1 (HOW-MANY E (CDR X))))
              (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/4'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E (CDR X))))
                     (+ -1 (HOW-MANY E (CDR X))))
              (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

But simplification reduces this to T, using the :definitions HOW-MANY
and MEMBER-EQUAL and primitive type reasoning.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (EQUAL E (CAR X)))
              (<= (HOW-MANY E (CDR X)) 0)
              (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (<= (HOW-MANY E (CDR X)) 0)
              (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/3''
(IMPLIES (AND (EQUAL (HOW-MANY E (CDR X)) 0)
              (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

But simplification reduces this to T, using the :definition HOW-MANY,
the :executable-counterpart of < and primitive type reasoning.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (EQUAL E (CAR X))
              (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL E (CAR X))
              (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

This simplifies, using the :definition MEMBER-EQUAL and primitive type
reasoning, to

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (< 0 (HOW-MANY (CAR X) X)))
         (EQUAL (HOW-MANY (CAR X) (CDR X))
                (+ -1 (HOW-MANY (CAR X) X)))).

But simplification reduces this to T, using the :definitions FIX, HOW-MANY
and SYNP, the :executable-counterpart of BINARY-+, primitive type reasoning,
the :rewrite rules FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-
prescription rule HOW-MANY.

Subgoal *1/1
(IMPLIES (AND (ENDP X) (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP X))
              (< 0 (HOW-MANY E X)))
         (EQUAL (HOW-MANY E (CDR (MEMBER-EQUAL E X)))
                (+ -1 (HOW-MANY E X)))).

But simplification reduces this to T, using the :definition HOW-MANY
and the :executable-counterpart of <.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM HOW-MANY-CDR-MEMBER ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION FIX)
        (:DEFINITION HOW-MANY)
        (:DEFINITION MEMBER-EQL-EXEC$GUARD-CHECK)
        (:DEFINITION MEMBER-EQUAL)
        (:DEFINITION NOT)
        (:DEFINITION RETURN-LAST)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION HOW-MANY)
        (:INDUCTION MEMBER-EQUAL)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE MEMBER-HOW-MANY)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION HOW-MANY))
 HOW-MANY-CDR-MEMBER
ACL2 >>(DEFTHM TWINS-CORRECT
               (IFF (MEMBER E (TWINS X))
                    (EQUAL (HOW-MANY E X) 2)))

ACL2 Warning [Subsume] in ( DEFTHM TWINS-CORRECT ...):  The previously
added rule MEMBER-HOW-MANY subsumes a newly proposed :REWRITE rule
generated from TWINS-CORRECT, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.


By the simple :definitions MEMBER-EQL-EXEC$GUARD-CHECK and RETURN-LAST,
the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Goal'
(COND ((< 0 (HOW-MANY E (TWINS X)))
       (EQUAL (HOW-MANY E X) 2))
      ((EQUAL (HOW-MANY E X) 2) NIL)
      (T T)).

This simplifies, using trivial observations, to the following two conjectures.

Subgoal 2
(IMPLIES (<= (HOW-MANY E (TWINS X)) 0)
         (NOT (EQUAL (HOW-MANY E X) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal 2'
(IMPLIES (EQUAL (HOW-MANY E (TWINS X)) 0)
         (NOT (EQUAL (HOW-MANY E X) 2))).

Name the formula above *1.

Subgoal 1
(IMPLIES (< 0 (HOW-MANY E (TWINS X)))
         (EQUAL (HOW-MANY E X) 2)).

Normally we would attempt to prove Subgoal 1 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

Perhaps we can prove *1 by induction.  Two induction schemes are suggested
by this conjecture.  By considering those suggested by the largest
number of non-primitive recursive functions, we narrow the field to
one.  

We will induct according to a scheme suggested by (TWINS X).  This
suggestion was produced using the :induction rule TWINS.  If we let
(:P E X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (MEMBER! (CAR X) (CDR X)))
                   (:P E (RM* (CAR X) (CDR X))))
              (:P E X))
     (IMPLIES (AND (CONSP X)
                   (MEMBER! (CAR X) (CDR X))
                   (:P E (RM* (CAR X) (CDR X))))
              (:P E X))).
This induction is justified by the same argument used to admit TWINS.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (NOT (CONSP X))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

But simplification reduces this to T, using the :definitions HOW-MANY
and TWINS and the :executable-counterparts of <, CONSP and EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER! (CAR X) (CDR X)))
              (IFF (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                   (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2)))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the :equivalence rule IFF-IS-AN-EQUIVALENCE and the simple :rewrite
rule MEMBER-HOW-MANY we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEMBER! (CAR X) (CDR X)))
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
(if-intro) and TWINS (if-intro), the :executable-counterparts of <
and EQUAL, linear arithmetic, primitive type reasoning, the :rewrite
rules HOW-MANY-CDR-MEMBER, HOW-MANY-RM* (if-intro) and MEMBER-HOW-MANY
and the :type-prescription rule HOW-MANY, to the following ten conjectures.

Subgoal *1/2.10
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (CDR X)) 2))
              (EQUAL E (CAR X)))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule HOW-MANY.

Subgoal *1/2.9
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (HOW-MANY E (CDR X)))
              (<= (+ -1 (HOW-MANY E (CDR X))) 0)
              (< 0
                 (HOW-MANY E
                           (CONS E (TWINS (RM* (CAR X) (CDR X)))))))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.8
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (+ -1 (HOW-MANY E (CDR X)))))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E (CDR X)) 0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.6
(IMPLIES (AND (CONSP X)
              (<= (HOW-MANY (CAR X) (CDR X)) 0)
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E
                            (CONS E (TWINS (RM* (CAR X) (CDR X)))))
                  0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule HOW-MANY.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (< 0 (+ -1 (HOW-MANY (CAR X) (CDR X))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (CDR X)) 2))
              (EQUAL E (CAR X)))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule HOW-MANY.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (< 0 (+ -1 (HOW-MANY (CAR X) (CDR X))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (HOW-MANY E (CDR X)))
              (<= (+ -1 (HOW-MANY E (CDR X))) 0)
              (< 0
                 (HOW-MANY E
                           (CONS E (TWINS (RM* (CAR X) (CDR X)))))))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (< 0 (+ -1 (HOW-MANY (CAR X) (CDR X))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (+ -1 (HOW-MANY E (CDR X)))))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (< 0 (+ -1 (HOW-MANY (CAR X) (CDR X))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E (CDR X)) 0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (< 0 (+ -1 (HOW-MANY (CAR X) (CDR X))))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E
                            (CONS E (TWINS (RM* (CAR X) (CDR X)))))
                  0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule HOW-MANY.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEMBER! (CAR X) (CDR X))
              (IFF (MEMBER-EQUAL E (TWINS (RM* (CAR X) (CDR X))))
                   (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                          2)))
         (IFF (MEMBER-EQUAL E (TWINS X))
              (EQUAL (HOW-MANY E X) 2))).

By the simple :definition MEMBER!, the :equivalence rule 
IFF-IS-AN-EQUIVALENCE and the simple :rewrite rule MEMBER-HOW-MANY
we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY (CAR X)
                            (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                  0)
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1''
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CDR (MEMBER-EQUAL (CAR X) (CDR X))))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (COND ((< 0
                        (HOW-MANY E (TWINS (RM* (CAR X) (CDR X)))))
                     (EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2))
                    ((EQUAL (HOW-MANY E (RM* (CAR X) (CDR X)))
                            2)
                     NIL)
                    (T T)))
         (COND ((< 0 (HOW-MANY E (TWINS X)))
                (EQUAL (HOW-MANY E X) 2))
               ((EQUAL (HOW-MANY E X) 2) NIL)
               (T T))).

This simplifies, using the :definitions HOW-MANY (if-intro), MEMBER!
(if-intro) and TWINS (if-intro), the :executable-counterparts of <,
BINARY-+ and EQUAL, linear arithmetic, primitive type reasoning, the
:rewrite rules CAR-CONS, CDR-CONS, HOW-MANY-CDR-MEMBER, HOW-MANY-RM*
(if-intro) and MEMBER-HOW-MANY and the :type-prescription rules HOW-MANY
and TWINS, to the following five conjectures.

Subgoal *1/1.5
(IMPLIES (AND (EQUAL (+ -1 (HOW-MANY (CAR X) (CDR X)))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (NOT (EQUAL (HOW-MANY E (CDR X)) 2))
              (EQUAL E (CAR X)))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule HOW-MANY.

Subgoal *1/1.4
(IMPLIES (AND (EQUAL (+ -1 (HOW-MANY (CAR X) (CDR X)))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (HOW-MANY E (CDR X)))
              (<= (+ -1 (HOW-MANY E (CDR X))) 0)
              (< 0
                 (HOW-MANY E
                           (CONS E (TWINS (RM* (CAR X) (CDR X)))))))
         (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2)).

But simplification reduces this to T, using the :executable-counterpart
of <, linear arithmetic, primitive type reasoning and the :type-prescription
rule HOW-MANY.

Subgoal *1/1.3
(IMPLIES (AND (EQUAL (+ -1 (HOW-MANY (CAR X) (CDR X)))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (< 0 (+ -1 (HOW-MANY E (CDR X)))))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using the :executable-counterparts
of < and NOT.

Subgoal *1/1.2
(IMPLIES (AND (EQUAL (+ -1 (HOW-MANY (CAR X) (CDR X)))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E (CDR X)) 0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.1
(IMPLIES (AND (EQUAL (+ -1 (HOW-MANY (CAR X) (CDR X)))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X)))
              (<= (HOW-MANY E (TWINS (RM* (CAR X) (CDR X))))
                  0)
              (EQUAL E (CAR X))
              (<= (HOW-MANY E
                            (CONS E (TWINS (RM* (CAR X) (CDR X)))))
                  0))
         (NOT (EQUAL (+ 1 (HOW-MANY E (CDR X))) 2))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule HOW-MANY, to

Subgoal *1/1.1'
(IMPLIES (AND (EQUAL (HOW-MANY (CAR X)
                               (CONS (CAR X)
                                     (TWINS (RM* (CAR X) (CDR X)))))
                     0)
              (EQUAL (HOW-MANY (CAR X)
                               (TWINS (RM* (CAR X) (CDR X))))
                     0)
              (EQUAL (+ -1 (HOW-MANY (CAR X) (CDR X)))
                     0)
              (CONSP X)
              (< 0 (HOW-MANY (CAR X) (CDR X))))
         (NOT (EQUAL (+ 1 (HOW-MANY (CAR X) (CDR X)))
                     2))).

But simplification reduces this to T, using the :definition HOW-MANY,
the :executable-counterparts of BINARY-+ and EQUAL, primitive type
reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rule TWINS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM TWINS-CORRECT ...)
Rules: ((:DEFINITION HOW-MANY)
        (:DEFINITION IFF)
        (:DEFINITION MEMBER!)
        (:DEFINITION NOT)
        (:DEFINITION TWINS)
        (:EQUIVALENCE IFF-IS-AN-EQUIVALENCE)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TWINS)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE HOW-MANY-CDR-MEMBER)
        (:REWRITE HOW-MANY-RM*)
        (:REWRITE MEMBER-HOW-MANY)
        (:TYPE-PRESCRIPTION HOW-MANY)
        (:TYPE-PRESCRIPTION TWINS))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION HOW-MANY)
             (:DEFINITION MEMBER!)
             (:DEFINITION TWINS)
             (:REWRITE HOW-MANY-RM*))
Warnings:  Subsume
 TWINS-CORRECT
ACL2 >>'(THE END)
(THE END)
ACL2 >>Bye.
