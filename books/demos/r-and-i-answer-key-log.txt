(UNSET-WATERFALL-PARALLELISM)
(ASSIGN SCRIPT-MODE T)
 T
(SET-LD-PROMPT T STATE)
 T
ACL2 !>>(SET-INHIBITED-SUMMARY-TYPES '(TIME STEPS))
 (TIME STEPS)
ACL2 !>>(SET-INHIBIT-OUTPUT-LST '(PROOF-TREE))
 (PROOF-TREE)
ACL2 !>>(IN-PACKAGE "ACL2")
 "ACL2"
ACL2 !>>:----- 
"

; This file was generated by ACL2 from the input file
; r-and-i-answer-key-input.lsp.  The output generated up to
; this point should be ignored by anyone who reads it.

; When the problem requires that you show a term or answer a
; question informally, the answer is written as a comment.

; We answer some ``fill in the blank'' questions by showing
; a theorem.  For example, if the question were to ask you
; to show the constant that is equal to (expt 2 31), we
; might show the theorem (equal (expt 2 31) 2147483648).

; We answer definition problems by just showing the
; appropriate defun.  Sometimes we have to provide the right
; measure.  For example,

; (defun f (x)
;  (declare (xargs :measure (ms x)))
;  <body>)

; means

;   The definition (defun f (x) <body>) is admissible under
;   the ACL2 definitional principle if you use the measure
;   (ms x) as the sense of the size of the argument.

; When the problem requires you to do a proof in the logic,
; we generally answer by showing an ACL2 command of the
; form

; (theorem <Problem-i>
;          <formula>
;          :hints ((\"Goal\" :induct <term>
;                          :enable (<name1>
;                                   ...
;                                   <namek>)))
;          :rule-classes <classes>)

; (Notice that the double-quote character (\") is escaped
; with a backslash (\\), which is similarly escaped, in
; the output file.)

; You can read this as follows.

;   <Problem-i> is the challenge to prove the theorem
;   <formula>.

;   Proof: Induct as suggested by <term>, i.e., to unwind
;   the recursive function in the term <term>.  Then,
;   simplify each case.  The simplification may freely use
;   propositional calculus, axioms, definitions, and lemmas
;   about arithmetic.  However, the proof will require you
;   to use certain lemmas proved earlier in this file,
;   namely those whose names, <name1>, ..., <namek>, are
;   listed.  Q.E.D.

;   If no :induct <term> is given, induction is not necessary
;   to the proof; simplification alone sufficies.

;   If no names are listed, then propositional calculus,
;   axioms, definitions, and arithmetic suffice.

;   If no hints at all are given, it is as though no :induct
;   <term> is given and no lemmas are named, i.e., the proof
;   is by straightforward simplification.

;   You can ignore the :rule-classes entry <classes>; it
;   just tells the mechanical theorem prover how to use this
;   theorem in the future.

;   If you want to see the actual proof output produced by
;   ACL2 when carrying out this high-level description of
;   the proof, inspect the file r-and-i-answer-key-log.txt.

;   In the script below, the first time we use an :induct
;   hint we include as a comment the output you'll find in
;   r-and-i-answer-key-log.txt so you can see how the output
;   elaborates the proof sketch provided by the input.
;   Similarly, we provide output the first time we use an
;   :in-theory hint to list the names of relevant lemmas.

; There is no need for you to understand how we define the
; theorem command to make this happen.  So skip the
; following defmacro and go to the solution of Problem 1.

; WARNING: If you start using ACL2 we do not recommend that
; you use the theorem macro.  Instead, use defthm directly.
; Theorem has the same interface as defthm but (a) no
; induction is done automatically -- you have to give the
; induction hint explicitly and no proof has more than one
; induction, and (b) after the new theorem is proved and
; installed as a rule, the new rule is disabled.  The latter
; feature then forces us to enable each rule proved with
; theorem whenever we want to use it.  Together features (a)
; and (b) ensure that a theorem command pretty much has all
; the information you need to reconstruct the proof
; yourself.  It is far better to get used to the idea that
; ACL2 often chooses the right induction(s) and uses rules
; freely after you've proved them.  So use defthm instead of
; reproducing this macro in your scripts.
"
ACL2 !>>(DEFMACRO THEOREM (NAME FORM &KEY
                                (RULE-CLASSES ':REWRITE
                                              RULE-CLASSES-SUPPLIEDP)
                                HINTS)
         (LET
          ((OLD-HINTS HINTS)
           (HINTS
            (COND ((NULL HINTS)
                   '(("Goal" :DO-NOT-INDUCT T
                             :DO-NOT '(GENERALIZE))))
                  ((AND (TRUE-LISTP HINTS)
                        (EQUAL (LENGTH HINTS) 1)
                        (EQUAL (CAR (CAR HINTS)) "Goal"))
                   (CONS (CONS '"Goal"
                               (CONS ':DO-NOT-INDUCT
                                     (CONS 'T
                                           (CONS ':DO-NOT
                                                 (CONS ''(GENERALIZE)
                                                       (CDR (CAR HINTS)))))))
                         'NIL))
                  (T NIL))))
          (COND
           ((NULL HINTS)
            (CONS
             'ER
             (CONS
              'SOFT
              (CONS
               ''THEOREM
               (CONS
                '"The :hints value ~x0 is not allowed ~
            by this macro."
                (CONS (CONS 'QUOTE (CONS OLD-HINTS 'NIL))
                      'NIL))))))
           ((AND RULE-CLASSES-SUPPLIEDP
                 (EQUAL RULE-CLASSES NIL))
            (CONS
               'DEFTHM
               (CONS NAME
                     (CONS FORM
                           (CONS ':RULE-CLASSES
                                 (CONS 'NIL
                                       (CONS ':HINTS (CONS HINTS 'NIL))))))))
           (T
            (CONS
             'PROGN
             (CONS
              (CONS
               'DEFTHM
               (CONS
                NAME
                (CONS
                 FORM
                 (APPEND
                   (IF RULE-CLASSES-SUPPLIEDP (CONS ':RULE-CLASSES
                                                    (CONS RULE-CLASSES 'NIL))
                     NIL)
                   (CONS ':HINTS (CONS HINTS 'NIL))))))
              (CONS (CONS 'IN-THEORY
                          (CONS (CONS 'DISABLE (CONS NAME 'NIL))
                                'NIL))
                    (CONS (CONS 'VALUE-TRIPLE
                                (CONS (CONS 'QUOTE (CONS NAME 'NIL))
                                      'NIL))
                          'NIL))))))))

Summary
Form:  ( DEFMACRO THEOREM ...)
Rules: NIL
 THEOREM
ACL2 !>>(SET-GAG-MODE NIL)
<state>
ACL2 !>>(SET-STATE-OK T)
 T
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 1.
; 1. Monday                      symbol
; 2. greek letter pi             ill-formed (not ASCII)
; 3. HelloWorld!                 symbol 
; 4. --1                         symbol (!)
; 5. -1                          integer
; 6. *PI*                        symbol
; 7. 31415x10**-4                symbol
; 8. (A . B . C)                 ill-formed (illegal dot)
; 9. Hello World!                ill-formed (two symbols)
; 10. if                         symbol
; 11. invokevirtual              symbol
; 12. ((1) . (2))                pair
; 13. <=                         symbol
; 14. ((A . 1) (B . 2) (C . 3))  pair
; 15. Hello_World!               symbol
; 16. +                          symbol
; 17. lo-part                    symbol
; 18. 31415926535897932384626433832795028841971693993751058209749445923
;                                integer 
; 19. (1 . (2 . 3))              pair
; 20. (1 . 2 3)                  ill-formed (illegal dot)
; 21. \"Hello World!\"             string
; 22. ((1) (2) . 3)              pair
; 23. ()                         symbol (nil)
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 2.

; Rather than just show the answer, I'll define a function to do it
; and then show the result.

; I freely use full ACL2 here since this function isn't part of the
; answer!

; The theorem below equates our computation of the equivalence
; classes with an object that associates each value with the labels
; of all expressions that represent it.  Here is that list.

;            constant          labels
;         '(((1 2 3)           (1 11))
;           ((NIL NIL NIL)     (2))
;           (((NIL NIL))       (3))
;           ((1 (2 . 3) 4)     (4 6))
;           ((NIL NIL)         (5 10 12))
;           ((HELLOWORLD !)    (7))
;           ((1 (2 3) 4)       (8))
;           (((A . T) (B) (C)) (9 16))
;           ((A B C)           (13 14))
;           ((HELLO WORLD !)   (15))))
"
ACL2 !>>(DEFUN ADD-LABEL-TO-BUCKET (LABEL CONST BUCKETS)
          (IF (ENDP BUCKETS)
              (LIST (LIST CONST (LIST LABEL)))
            (IF (EQUAL CONST (CAR (CAR BUCKETS)))
                (CONS (LIST CONST
                            (APPEND (CADR (CAR BUCKETS))
                                    (LIST LABEL)))
                      (CDR BUCKETS))
              (CONS (CAR BUCKETS)
                    (ADD-LABEL-TO-BUCKET LABEL CONST (CDR BUCKETS))))))

The admission of ADD-LABEL-TO-BUCKET is trivial, using the relation
O< (which is known to be well-founded on the domain recognized by O-P)
and the measure (ACL2-COUNT BUCKETS).  We observe that the type of
ADD-LABEL-TO-BUCKET is described by the theorem 
(CONSP (ADD-LABEL-TO-BUCKET LABEL CONST BUCKETS)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN ADD-LABEL-TO-BUCKET ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 ADD-LABEL-TO-BUCKET
ACL2 !>>(DEFUN MAKE-EQUIV-CLASSES (ALIST BUCKETS)
          (IF (ENDP ALIST)
              BUCKETS
            (MAKE-EQUIV-CLASSES (CDR ALIST)
                                (ADD-LABEL-TO-BUCKET (CAAR ALIST)
                                                     (CADR (CAR ALIST))
                                                     BUCKETS))))

The admission of MAKE-EQUIV-CLASSES is trivial, using the relation
O< (which is known to be well-founded on the domain recognized by O-P)
and the measure (ACL2-COUNT ALIST).  We observe that the type of 
MAKE-EQUIV-CLASSES is described by the theorem 
(OR (CONSP (MAKE-EQUIV-CLASSES ALIST BUCKETS))
    (EQUAL (MAKE-EQUIV-CLASSES ALIST BUCKETS)
           BUCKETS)).
We used the :type-prescription rule ADD-LABEL-TO-BUCKET.

Summary
Form:  ( DEFUN MAKE-EQUIV-CLASSES ...)
Rules: ((:TYPE-PRESCRIPTION ADD-LABEL-TO-BUCKET))
 MAKE-EQUIV-CLASSES
ACL2 !>>(THEOREM PROBLEM-2
                 (EQUAL (MAKE-EQUIV-CLASSES '((1 (1 2 3))
                                              (2 (NIL NIL NIL))
                                              (3 ((NIL NIL)))
                                              (4 (1 (2 . 3) 4))
                                              (5 (NIL NIL))
                                              (6 (1 (2 . 3) 4))
                                              (7 (HELLOWORLD !))
                                              (8 (1 (2 3) 4))
                                              (9 ((A . T) (B) (C)))
                                              (10 (NIL NIL))
                                              (11 (1 2 3))
                                              (12 (NIL NIL))
                                              (13 (A B C))
                                              (14 (A B C))
                                              (15 (HELLO WORLD !))
                                              (16 ((A . T) (B) (C))))
                                            NIL)
                        '(((1 2 3) (1 11))
                          ((NIL NIL NIL) (2))
                          (((NIL NIL)) (3))
                          ((1 (2 . 3) 4) (4 6))
                          ((NIL NIL) (5 10 12))
                          ((HELLOWORLD !) (7))
                          ((1 (2 3) 4) (8))
                          (((A . T) (B) (C)) (9 16))
                          ((A B C) (13 14))
                          ((HELLO WORLD !) (15))))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by the :executable-counterparts
of EQUAL and MAKE-EQUIV-CLASSES.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-2 ...)
Rules: ((:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART MAKE-EQUIV-CLASSES))
 PROBLEM-2
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 3.

; 1. (car (cdr x))                yes
; 2. (cons (car x y) z)           no - car takes 1 arg
; 3. (cons 1 2)                   no - constants must be quoted
; 4. (cons '1 '2)                 yes
; 5. (cons one two)               yes - one and two are variable symbols
; 6. (cons 'one 'two)             yes - 'one and 'two are constants
; 7. (equal '1 (car (cons '2 '3)))yes
; 8. (if t 1 2)                   no - constants must be quoted
; 9. (if 't '1 '2)                yes
; 10. (car (cons (cdr hi-part) (car lo-part)))    yes
; 11. car(cons x y)               no - wrong syntax
; 12. car(cons(x,y))              no - wrong syntax
; 13. (cons 1 (2 3 4))            no - constants must be quoted
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 4.
"
ACL2 !>>(THEOREM PROBLEM-4
                 (AND (EQUAL '((1 . 2) 3 . 4)
                             (CONS (CONS '1 '2) (CONS '3 '4)))
                      (EQUAL '(1 2 3)
                             (CONS '1 (CONS '2 (CONS '3 'NIL))))
                      (EQUAL '((1 . T) (2) (3 . T))
                             (CONS (CONS '1 'T)
                                   (CONS (CONS '2 'NIL)
                                         (CONS (CONS '3 'T) 'NIL))))
                      (EQUAL '((A . 1) (B . 2))
                             (CONS (CONS 'A '1)
                                   (CONS (CONS 'B '2) 'NIL))))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by case analysis.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-4 ...)
Rules: NIL
 PROBLEM-4
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 5.
"
ACL2 !>>(THEOREM PROBLEM-5
                 (AND (EQUAL (CONS (CONS '1 '2)
                                   (CONS (CONS '3 '4) 'NIL))
                             '((1 . 2) (3 . 4)))
                      (EQUAL (CONS '1 (CONS '2 '3))
                             '(1 2 . 3))
                      (EQUAL (CONS 'NIL (CONS (CONS 'NIL 'NIL) 'NIL))
                             '(NIL (NIL)))
                      (EQUAL (IF 'NIL '1 '2) '2)
                      (EQUAL (IF '1 '2 '3) '2)
                      (EQUAL (EQUAL 'NIL (CONS 'NIL 'NIL))
                             'NIL)
                      (EQUAL (EQUAL 'HELLO 'HELLO) 'T)
                      (EQUAL (EQUAL (CONS '1 '2) (CONS '1 'TWO))
                             'NIL))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by case analysis.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-5 ...)
Rules: NIL
 PROBLEM-5
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 6.

; Answer: (car (cons (car a) (cons (cdr x) (cons '\"Hello\" z))))
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 7.

; 1. (cons '1 (cons '2 (cons '3 'nil)))
; 2. (equal '\"Hello\" hello)
; 3. (and (or a1 (or a2 a3))
;         (and (or b1 (or b2 b3))
;              (or c1 (or c2 c3))))
; 4. (equal x (cons 'or (cons 'a1 (cons 'a2 (cons 'a3 'nil)))))
; 5. (cons cons
;          (cons 'cons
;                (cons 'cons
;                      (cons (cons 'quote (cons 'cons 'nil))
;                            'nil))))
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 8.
"
ACL2 !>>(DEFUN APP (X Y)
          (IF (CONSP X)
              (CONS (CAR X) (APP (CDR X) Y))
            Y))

The admission of APP is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of APP is described by the
theorem (OR (CONSP (APP X Y)) (EQUAL (APP X Y) Y)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN APP ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 APP
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 9.
"
ACL2 !>>(DEFUN REV (X)
          (IF (CONSP X)
              (APP (REV (CDR X)) (CONS (CAR X) NIL))
            NIL))

The admission of REV is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of REV is described by the
theorem (OR (CONSP (REV X)) (EQUAL (REV X) NIL)).  We used primitive
type reasoning and the :type-prescription rule APP.

Summary
Form:  ( DEFUN REV ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION APP))
 REV
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 10.
"
ACL2 !>>(DEFUN MAPNIL (X)
          (IF (CONSP X)
              (CONS NIL (MAPNIL (CDR X)))
            NIL))

The admission of MAPNIL is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of MAPNIL is described by
the theorem (TRUE-LISTP (MAPNIL X)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN MAPNIL ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 MAPNIL
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 11.
"
ACL2 !>>(DEFUN SWAP-TREE (X)
          (IF (CONSP X)
              (CONS (SWAP-TREE (CDR X))
                    (SWAP-TREE (CAR X)))
            X))

The admission of SWAP-TREE is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We could deduce no constraints on the type
of SWAP-TREE.  However, in normalizing the definition we used primitive
type reasoning.

Summary
Form:  ( DEFUN SWAP-TREE ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 SWAP-TREE
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 12.
"
ACL2 !>>(DEFUN MEM (E X)
          (IF (CONSP X)
              (IF (EQUAL E (CAR X)) T (MEM E (CDR X)))
            NIL))

The admission of MEM is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of MEM is described by the
theorem (OR (EQUAL (MEM E X) T) (EQUAL (MEM E X) NIL)).  

Summary
Form:  ( DEFUN MEM ...)
Rules: NIL
 MEM
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 13.
"
ACL2 !>>(DEFUN SUB (X Y)
          (IF (CONSP X)
              (IF (MEM (CAR X) Y) (SUB (CDR X) Y) NIL)
            T))

The admission of SUB is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of SUB is described by the
theorem (OR (EQUAL (SUB X Y) T) (EQUAL (SUB X Y) NIL)).  

Summary
Form:  ( DEFUN SUB ...)
Rules: NIL
 SUB
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 14.
"
ACL2 !>>(DEFUN INT (X Y)
          (IF (CONSP X)
              (IF (MEM (CAR X) Y)
                  (CONS (CAR X) (INT (CDR X) Y))
                (INT (CDR X) Y))
            NIL))

The admission of INT is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of INT is described by the
theorem (TRUE-LISTP (INT X Y)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN INT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 INT
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 15.
"
ACL2 !>>(DEFUN TIP (E X)
          (IF (CONSP X)
              (OR (TIP E (CAR X)) (TIP E (CDR X)))
            (EQUAL E X)))

The admission of TIP is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of TIP is described by the
theorem (OR (EQUAL (TIP E X) T) (EQUAL (TIP E X) NIL)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN TIP ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 TIP
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 16.
"
ACL2 !>>(DEFUN FLATTEN (X)
          (IF (CONSP X)
              (APP (FLATTEN (CAR X))
                   (FLATTEN (CDR X)))
            (CONS X NIL)))

The admission of FLATTEN is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of FLATTEN is described by
the theorem (CONSP (FLATTEN X)).  We used primitive type reasoning
and the :type-prescription rule APP.

Summary
Form:  ( DEFUN FLATTEN ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION APP))
 FLATTEN
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 17.
"
ACL2 !>>(DEFUN EVENLEN (X)
          (IF (CONSP X)
              (IF (CONSP (CDR X))
                  (EVENLEN (CDR (CDR X)))
                NIL)
            T))

For the admission of EVENLEN we will use the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  The non-trivial part of the measure conjecture is

Goal
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (ACL2-COUNT (CDDR X))
             (ACL2-COUNT X))).

By case analysis we reduce the conjecture to

Goal'
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (ACL2-COUNT (CDDR X))
             (ACL2-COUNT X))).

This simplifies, using the :definitions O-FINP and O< and the :type-
prescription rule ACL2-COUNT, to

Goal''
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (< (ACL2-COUNT (CDDR X))
            (ACL2-COUNT X))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule ACL2-COUNT-CAR-CDR-LINEAR and the
:type-prescription rule ACL2-COUNT.

Q.E.D.

That completes the proof of the measure theorem for EVENLEN.  Thus,
we admit this function under the principle of definition.  We observe
that the type of EVENLEN is described by the theorem 
(OR (EQUAL (EVENLEN X) T) (EQUAL (EVENLEN X) NIL)).  

Summary
Form:  ( DEFUN EVENLEN ...)
Rules: ((:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O<)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR ACL2-COUNT-CAR-CDR-LINEAR)
        (:TYPE-PRESCRIPTION ACL2-COUNT))
 EVENLEN
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 18.

; Theorem. (and p q) /= nil  <-> p /= nil & q /= nil.

; Proof. We consider three cases.  We use lhs and rhs to refer to the
; left and right sides of the equivalence operator.  Because of the
; way we break the cases, it is straightforward to determine the value
; of the rhs and we write it in parentheses at the top of each case.
; We show the lhs has the same truthvalue.

; Case 1.  p /= nil & q /= nil  (rhs is true)
; (and p q) = q /= nil.  Thus lhs is true.

; Case 2.  p /= nil & q  = nil  (rhs is false)
; (and p q) = q = nil.  Thus lhs is false.

; Case 3.  p  = nil             (rhs is false)
; (and p q) = nil.  Thus lhs is false.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 19.

; Theorem. (or p q) /= nil <-> p /= nil v q /= nil.

; Proof. We consider three cases and use the same format as the proof
; in Problem 18.

; Case 1. p /= nil  (rhs is true)
; (or p q) = p /= nil.  Thus lhs is true.

; Case 2. p  = nil and q /= nil  (rhs is true)
; (or p q) = q /= nil.  Thus lhs is true.

; Case 3. p  = nil & q  = nil  (rhs is false)
; (or p q) = nil.  Thus lhs is false.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 20.

; Theorem. (implies p q) /= nil <-> (p /= nil -> q /= nil).

; Proof.  Same format as 18.

; Case 1. p /= nil and q /= nil (rhs is true)
; (implies p q) = t.  Thus lhs is true.

; Case 2. p /= nil and q  = nil (rhs is false)
; (implies p q) = nil.  Thus lhs is false.

; Case 3. p  = nil              (rhs is true)
; (implies p q) = t.  Thus lhs is true.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 21.

; Theorem. (iff p q) /=  <-> (p /= nil <-> q /= nil)

; Proof. We consider four cases.

; Case 1.  p /= nil and q /= nil (rhs is true)
; (iff p q)
;  = (and (implies p q) (implies q p))
;  = (and t t)
;  = t.
; Thus lhs is true.

; Case 2.  p /= nil and q  = nil (rhs is false)
; (iff p q)
;  = (and (implies p q) (implies q p)) 
;  = (and nil t)
;  = nil.
; Thus lhs is false.

; Case 3.  p  = nil and q /= nil (rhs is false)
; (iff p q)
;  = (and (implies p q) (implies q p)) 
;  = (and t nil)
;  = nil.
; Thus lhs is false.

; Case 4.  p  = nil and q  = nil (rhs is true)
; (iff p q)
;  = (and (implies p q) (implies q p)) 
;  = (and t t)
;  = t.
; Thus lhs is true.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 22.

; Theorem.  (equal x y) /= nil  <->  (x = y)

; Proof.

; Case 1.  x=y (rhs is true)
; (equal x y) = t, by Axiom 5.  Thus lhs is true.

; Case 2.  x /= y (rhs is false)
; (equal x y) /= t, by Axiom 5.  Thus, by Axiom 4,
; (equal x y) = nil.  Thus, lhs is false.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 23.

; Theorem.  (implies (and p (implies q r)) s) <->
;           ((p & -q) -> s) & ((p & q & r) -> s)

; Proof.  The proof will also establish the intermediate formula
; requested.  

; Since the lhs above is a term treated as a formula, the lhs is

; (implies (and p (implies q r)) s) /= nil

; <->

; (and p (implies q r)) /= nil -> (s /= nil)

; <->

; ((p /= nil) & (implies q r) /= nil) -> (s /= nil)

; <->

; (p /= nil) & (q /= nil -> r /= nil) -> (s /= nil)

; <->

; (p & (q -> r)) -> s

; We won't use this last formula, since it uses terms as formulas.
; Instead, we'll go back one step:

; (p /= nil) & (q /= nil -> r /= nil) -> (s /= nil)

; <->

; (q  = nil) -> ((p /= nil) & (q /= nil -> r /= nil) -> (s /= nil))
; &
; (q /= nil) -> ((p /= nil) & (q /= nil -> r /= nil) -> (s /= nil))

; The previous step is just the tautology a <-> ((-b -> a) & (b -> a)).
; Continuing, using (a -> (b -> c)) <-> ((a & b) -> c)

; <->

; (q  = nil) & (p /= nil) & (q /= nil -> r /= nil) -> (s /= nil)
; &
; (q /= nil) * (p /= nil) & (q /= nil -> r /= nil) -> (s /= nil)

; <->

; (p /= nil) & (q  = nil) & t -> (s /= nil)
; &
; (p /= nil) & (q /= nil) & (r /= nil) -> (s /= nil)

; <->

; (p & -q) -> s
; &
; (p & q & r) -> s

; Q.E.D.

; This proof was tedious only because we tried to show some of the
; propositional calculus steps.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 24.

; Theorem.  (equal (car (if a b c)) (if a (car b) (car c)))

; Proof.  We will reduce the lhs, (car (if a b c)), to the rhs, (if a
; (car b) (car c)), under two cases, thus establishing lhs=rhs and
; thus (equal lhs rhs).

; Case 1.  a /= nil.

; lhs = (car (if a b c)) = (car b)
; rhs = (if a (car b) (car c)) = (car b).

; Case 2.  a  = nil.

; lhs = (car (if a b c)) = (car c)
; rhs = (if a (car b) (car c)) = (car c).

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 25.

; Theorem.  (equal (if (if a b c) x y)
;                  (if a (if b x y) (if c x y)))

; Proof.  Cases on a.  We take even bigger steps than in Problem 24.

; Case 1. a /= nil.
; lhs = (if b x y) = rhs.

; Case 2. a  = nil.
; lhs = (if c x y) = rhs.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 26.

; Theorem.  (equal (treecopy (cons a b))
;                  (cons (treecopy a) (treecopy b)))

; Proof.  
; (treecopy (cons a b))
; =                                          {by def treecopy}
; (if (consp (cons a b))
;     (cons (treecopy (car (cons a b)))
;           (treecopy (cdr (cons a b))))
;     (cons a b))
; =                                          {by Axiom 7}
; (if t
;     (cons (treecopy (car (cons a b)))
;           (treecopy (cdr (cons a b))))
;     (cons a b))
; =                                          {by Axiom 1 and 2}
; (cons (treecopy (car (cons a b)))
;       (treecopy (cdr (cons a b))))
; =                                          {by Axiom 9 and 10}
; (cons (treecopy a)
;       (treecopy b))
; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 27.

; Proof that 'June = 'July (under the scenario described).

; While f is defined as initially shown, prove the theorem
; Lemma 1:  (f x) = 1.
; After the redefinition, prove the theorem
; Lemma 2:  (f x) = 2.
; By transitivity of equality and Lemmas 1 and 2, 1 = 2.  By
; propositional calculus, we know that if p is a theorem, then 
; -p -> q.  Hence,

; (1 /= 2) -> 'June = 'July.

; By Axiom 1, we know (1 /= 2).  Thus

; 'June = 'July

; Q.E.D.

; Of course, the crux of this proof is establishing any contradiction.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 28.

; Proof that 1=2, given (defun f (x) (cons x y)).

; Lemma 1: (cdr (f x)) = y.  Proof: by def f and Axiom 10.  Q.E.D.

; Thus, 
; (cdr (f 0)) = 1             {instantiation of Lemma 1}
; (cdr (f 0)) = 2             {instantiation of Lemma 1}
; 1=2                         {trans of equality}
; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 29.

; Proof that t=nil, given (defun f (x) (not (f x))).

; First observe that (f x) = (if (f x) nil t).  Thus,
; since (f x) = nil or (f x) /= nil, we know that (f x)
; is either t or nil.  Consider the two cases.

; Case 1.  (f x) = t
; (f x) = (not (f x)) = (not t) = nil.

; Case 2.  (f x) = nil
; (f x) = (not (f x)) = (not nil) = t.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 30.

; Restriction 1 prevents the redefinition of a function, as 
; tried in Problem 27.  Restriction 3 prevents the use of
; global variables, as tried in Problem 28.  Restriction 4
; prevents the silly recursion, as tried in Problem 29.
; In particular, x is not a car/cdr nest and so the definition
; of f in Problem 29 is not acceptable.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 31.

; Yes, because (consp x) governs a recursive call on a
; car/cdr nest around x, namely the nest (cdr (cdr x)).
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 32.

; No.  The only governing test is (consp x) but the only car/cdr nest
; in recursion is around y.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 33.

; No.  The governing test, (consp x), is for the first formal but the
; first actual in the recursive call is not a car/cdr nest around the
; first formal.  This is how the answer to Problem 32 should read!
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 34.

; Yes, because (consp x) governs the recursive call (f (cdr (cdr x))),
; and (cdr (cdr x)) is a car/cdr nest around x.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 35.

; No, because (consp x) does not govern the recursive call.  There is
; no (consp x) anywhere in the definition.  (not (endp x)) governs the
; recursive call and that is not syntactically identical to (consp x).
; However, it is logically equivalent and we will eventually improve
; the definitional principle so that definitions like this are
; allowed.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 36.

; Yes.  (Consp x) governs a recursion on a car/cdr nest around x in
; the same argument position.  It doesn't matter what happens in other
; argument positions.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 37.

; Yes, for the same reasons given in Problem 36.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 38.

; No.  If the first defun is allowed, then we have an axiom about g
; and then we cannot ``redefine'' g with the second defun.  The
; symmetric argument blocks defining them in the other order.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 39.

; No.  All we can do is expand the definition of (f x) and
; consider cases.  We can construct a ``proof'' like this:

; Case 1:  (not (consp x))
; (f x) = t {by def f} 

; Case 2:  (consp x) & (not (consp (cdr x)))
; (f x) = (f (cdr x)) = t {by def f}

; Case 3:  (consp x) & (consp (cdr x)) & (not (consp (cdr (cdr x))))
; (f x) = (f (cdr x)) = (f (cdr (cdr x))) = t {by def f}

; ...

; But we cannot reach the terminal case of the recursion unless we
; know how long x is.  And infinite proofs are not allowed!
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 40.
"
ACL2 !>>(THEOREM PROBLEM-40
                 (EQUAL (APP (APP A B) C)
                        (APP A (APP B C)))
                 :HINTS (("Goal" :INDUCT (APP A B))))


ACL2 !>>>(DEFTHM PROBLEM-40
           (EQUAL (APP (APP A B) C)
                  (APP A (APP B C)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP A B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B C) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B C))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B C))
              (:P A B C))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (APP (APP A B) C)
                (APP A (APP B C)))).

But simplification reduces this to T, using the :definition APP and
primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (APP (APP (CDR A) B) C)
                     (APP (CDR A) (APP B C))))
         (EQUAL (APP (APP A B) C)
                (APP A (APP B C)))).

But simplification reduces this to T, using the :definition APP, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-40 ...)
Rules: ((:DEFINITION APP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
PROBLEM-40


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-40))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-40)
PROBLEM-40

Summary
Form:  ( PROGN (DEFTHM PROBLEM-40 ...) ...)
Rules: NIL
 PROBLEM-40
ACL2 !>>:----- 
"
; Here is the proof output you'll find for this event in
; r-and-i-answer-key-log.txt.  Notice that the output prints the
; induction scheme suggested by the hint.

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).  This
suggestion was produced using the :induction rule APP.  If we let (:P A B C)
denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B C))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B C))
              (:P A B C))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (APP (APP A B) C)
                (APP A (APP B C)))).

But simplification reduces this to T, using the :definition APP and
primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (APP (APP (CDR A) B) C)
                     (APP (CDR A) (APP B C))))
         (EQUAL (APP (APP A B) C)
                (APP A (APP B C)))).

But simplification reduces this to T, using the :definition APP, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-40 ...)
Rules: ((:DEFINITION APP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 41.
"
ACL2 !>>(THEOREM PROBLEM-41-COUNTEREXAMPLE
                 (NOT (EQUAL (APP '(1 2 3 . 4) NIL)
                             '(1 2 3 . 4)))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by the :executable-counterparts
of APP and EQUAL.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-41-COUNTEREXAMPLE ...)
Rules: ((:EXECUTABLE-COUNTERPART APP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT))
 PROBLEM-41-COUNTEREXAMPLE
ACL2 !>>(DEFUN PROPER (X)
          (IF (CONSP X)
              (PROPER (CDR X))
            (EQUAL X NIL)))

The admission of PROPER is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of PROPER is described by
the theorem (OR (EQUAL (PROPER X) T) (EQUAL (PROPER X) NIL)).  We used
primitive type reasoning.

Summary
Form:  ( DEFUN PROPER ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 PROPER
ACL2 !>>(THEOREM PROBLEM-41
                 (IMPLIES (PROPER X)
                          (EQUAL (APP X NIL) X))
                 :HINTS (("Goal" :INDUCT (APP X NIL))))


ACL2 !>>>(DEFTHM PROBLEM-41
           (IMPLIES (PROPER X)
                    (EQUAL (APP X NIL) X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP X NIL))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP X NIL).

This suggestion was produced using the :induction rule APP.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (IMPLIES (PROPER X)
                  (EQUAL (APP X NIL) X))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP X)) (PROPER X))
         (EQUAL (APP X NIL) X)).

But simplification reduces this to T, using the :definition PROPER,
the :executable-counterparts of APP, CONSP and EQUAL and primitive
type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (IMPLIES (PROPER (CDR X))
                       (EQUAL (APP (CDR X) NIL) (CDR X))))
         (IMPLIES (PROPER X)
                  (EQUAL (APP X NIL) X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (IMPLIES (PROPER (CDR X))
                       (EQUAL (APP (CDR X) NIL) (CDR X)))
              (PROPER X))
         (EQUAL (APP X NIL) X)).

But simplification reduces this to T, using the :definitions APP and
PROPER, primitive type reasoning and the :rewrite rule CONS-CAR-CDR.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-41 ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION NOT)
        (:DEFINITION PROPER)
        (:EXECUTABLE-COUNTERPART APP)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CONS-CAR-CDR))
PROBLEM-41


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-41))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-41)
PROBLEM-41

Summary
Form:  ( PROGN (DEFTHM PROBLEM-41 ...) ...)
Rules: NIL
 PROBLEM-41
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 42.
"
ACL2 !>>(THEOREM PROBLEM-42
                 (EQUAL (MAPNIL (APP A B))
                        (APP (MAPNIL A) (MAPNIL B)))
                 :HINTS (("Goal" :INDUCT (APP A B))))


ACL2 !>>>(DEFTHM PROBLEM-42
           (EQUAL (MAPNIL (APP A B))
                  (APP (MAPNIL A) (MAPNIL B)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP A B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B))
              (:P A B))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (MAPNIL (APP A B))
                (APP (MAPNIL A) (MAPNIL B)))).

But simplification reduces this to T, using the :definitions APP and
MAPNIL, the :executable-counterpart of CONSP and primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (MAPNIL (APP (CDR A) B))
                     (APP (MAPNIL (CDR A)) (MAPNIL B))))
         (EQUAL (MAPNIL (APP A B))
                (APP (MAPNIL A) (MAPNIL B)))).

But simplification reduces this to T, using the :definitions APP and
MAPNIL, primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule MAPNIL.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-42 ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION MAPNIL)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION MAPNIL))
PROBLEM-42


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-42))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-42)
PROBLEM-42

Summary
Form:  ( PROGN (DEFTHM PROBLEM-42 ...) ...)
Rules: NIL
 PROBLEM-42
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 43.
"
ACL2 !>>(THEOREM PROBLEM-43
                 (EQUAL (REV (MAPNIL X))
                        (MAPNIL (REV X)))
                 :HINTS (("Goal" :INDUCT (REV X)
                                 :IN-THEORY (ENABLE PROBLEM-42))))


ACL2 !>>>(DEFTHM PROBLEM-43
           (EQUAL (REV (MAPNIL X))
                  (MAPNIL (REV X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (REV X)
                           :IN-THEORY (ENABLE PROBLEM-42))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (REV X).

This suggestion was produced using the :induction rule REV.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit REV.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (REV (MAPNIL X))
                (MAPNIL (REV X)))).

But simplification reduces this to T, using the :definitions MAPNIL
and REV and the :executable-counterparts of EQUAL, MAPNIL and REV.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (REV (MAPNIL (CDR X)))
                     (MAPNIL (REV (CDR X)))))
         (EQUAL (REV (MAPNIL X))
                (MAPNIL (REV X)))).

But simplification reduces this to T, using the :definitions MAPNIL
and REV, the :executable-counterparts of CONS and MAPNIL, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-42
and the :type-prescription rule MAPNIL.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-43 ...)
Rules: ((:DEFINITION MAPNIL)
        (:DEFINITION REV)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART MAPNIL)
        (:EXECUTABLE-COUNTERPART REV)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REV)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-42)
        (:TYPE-PRESCRIPTION MAPNIL))
PROBLEM-43


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-43))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-43)
PROBLEM-43

Summary
Form:  ( PROGN (DEFTHM PROBLEM-43 ...) ...)
Rules: NIL
 PROBLEM-43
ACL2 !>>:----- 
"
; Here is the output generated.  You can find similar output
; for every theorem in r-and-i-answer-key-log.txt.  Note that
; the output makes it clear which subgoal requires Problem-42.
; In addition, the output lists all the rules used.  All of
; the rules below, except Problem-42, are part of the basic
; propositional calculus, axioms, definitions, and
; arithmetic we allow ourselves to use freely in Recursion
; and Induction.

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (REV X).  This suggestion
was produced using the :induction rule REV.  If we let (:P X) denote
*1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit REV.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (REV (MAPNIL X))
                (MAPNIL (REV X)))).

But simplification reduces this to T, using the :definitions MAPNIL
and REV and the :executable-counterparts of EQUAL, MAPNIL and REV.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (REV (MAPNIL (CDR X)))
                     (MAPNIL (REV (CDR X)))))
         (EQUAL (REV (MAPNIL X))
                (MAPNIL (REV X)))).

But simplification reduces this to T, using the :definitions MAPNIL
and REV, the :executable-counterparts of CONS and MAPNIL, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-42
and the :type-prescription rule MAPNIL.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-43 ...)
Rules: ((:DEFINITION MAPNIL)
        (:DEFINITION REV)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART MAPNIL)
        (:EXECUTABLE-COUNTERPART REV)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REV)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-42)
        (:TYPE-PRESCRIPTION MAPNIL))
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 44.
"
ACL2 !>>(THEOREM PROBLEM-44-COUNTEREXAMPLE
                 (NOT (EQUAL (REV (REV '(1 2 3 . 4)))
                             '(1 2 3 . 4)))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by the :executable-counterparts
of EQUAL and REV.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-44-COUNTEREXAMPLE ...)
Rules: ((:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART REV))
 PROBLEM-44-COUNTEREXAMPLE
ACL2 !>>(THEOREM PROBLEM-44C
                 (EQUAL (PROPER (APP A B)) (PROPER B))
                 :HINTS (("Goal" :INDUCT (APP A B))))


ACL2 !>>>(DEFTHM PROBLEM-44C
           (EQUAL (PROPER (APP A B)) (PROPER B))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP A B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B))
              (:P A B))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (PROPER (APP A B)) (PROPER B))).

But simplification reduces this to T, using the :definition APP and
primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (PROPER (APP (CDR A) B))
                     (PROPER B)))
         (EQUAL (PROPER (APP A B)) (PROPER B))).

But simplification reduces this to T, using the :definitions APP and
PROPER, primitive type reasoning and the :rewrite rule CDR-CONS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-44C ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION PROPER)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CDR-CONS))
PROBLEM-44C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-44C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-44C)
PROBLEM-44C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-44C ...) ...)
Rules: NIL
 PROBLEM-44C
ACL2 !>>(THEOREM PROBLEM-44B (PROPER (REV X))
                 :HINTS (("Goal" :INDUCT (REV X)
                                 :IN-THEORY (ENABLE PROBLEM-44C))))


ACL2 !>>>(DEFTHM PROBLEM-44B
           (PROPER (REV X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (REV X)
                           :IN-THEORY (ENABLE PROBLEM-44C))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (REV X).

This suggestion was produced using the :induction rule REV.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit REV.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (PROPER (REV X))).

But simplification reduces this to T, using the :definition REV and
the :executable-counterpart of PROPER.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (PROPER (REV (CDR X))))
         (PROPER (REV X))).

But simplification reduces this to T, using the :definitions PROPER
and REV, the :executable-counterpart of PROPER, primitive type reasoning
and the :rewrite rules CDR-CONS and PROBLEM-44C.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-44B depends upon the :type-prescription rule
PROPER.

Summary
Form:  ( DEFTHM PROBLEM-44B ...)
Rules: ((:DEFINITION PROPER)
        (:DEFINITION REV)
        (:EXECUTABLE-COUNTERPART PROPER)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REV)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-44C)
        (:TYPE-PRESCRIPTION PROPER))
PROBLEM-44B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-44B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-44B)
PROBLEM-44B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-44B ...) ...)
Rules: NIL
 PROBLEM-44B
ACL2 !>>(THEOREM
            PROBLEM-44A
            (EQUAL (REV (APP A B))
                   (APP (REV B) (REV A)))
            :HINTS
            (("Goal" :INDUCT (APP A B)
                     :IN-THEORY (ENABLE PROBLEM-40 PROBLEM-41 PROBLEM-44B))))


ACL2 !>>>(DEFTHM PROBLEM-44A
           (EQUAL (REV (APP A B))
                  (APP (REV B) (REV A)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (APP A B)
                    :IN-THEORY (ENABLE PROBLEM-40 PROBLEM-41 PROBLEM-44B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B))
              (:P A B))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (REV (APP A B))
                (APP (REV B) (REV A)))).

But simplification reduces this to T, using the :definitions APP and
REV, primitive type reasoning and the :rewrite rules PROBLEM-41 and
PROBLEM-44B.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (REV (APP (CDR A) B))
                     (APP (REV B) (REV (CDR A)))))
         (EQUAL (REV (APP A B))
                (APP (REV B) (REV A)))).

This simplifies, using the :definitions APP and REV, primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (EQUAL (REV (APP (CDR A) B))
                     (APP (REV B) (REV (CDR A)))))
         (EQUAL (APP (REV (APP (CDR A) B))
                     (LIST (CAR A)))
                (APP (REV B)
                     (APP (REV (CDR A)) (LIST (CAR A)))))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal *1/1''
(IMPLIES (AND (CONSP (CONS A1 A2))
              (EQUAL (REV (APP A2 B))
                     (APP (REV B) (REV A2))))
         (EQUAL (APP (REV (APP A2 B)) (LIST A1))
                (APP (REV B)
                     (APP (REV A2) (LIST A1))))).

This simplifies, using primitive type reasoning, to

Subgoal *1/1'''
(IMPLIES (EQUAL (REV (APP A2 B))
                (APP (REV B) (REV A2)))
         (EQUAL (APP (REV (APP A2 B)) (LIST A1))
                (APP (REV B)
                     (APP (REV A2) (LIST A1))))).

We now use the hypothesis by substituting (APP (REV B) (REV A2)) for
(REV (APP A2 B)) and throwing away the hypothesis.  This produces

Subgoal *1/1'4'
(EQUAL (APP (APP (REV B) (REV A2)) (LIST A1))
       (APP (REV B) (APP (REV A2) (LIST A1)))).

But we reduce the conjecture to T, by the simple :rewrite rule PROBLEM-40.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-44A ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION REV)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-40)
        (:REWRITE PROBLEM-41)
        (:REWRITE PROBLEM-44B))
PROBLEM-44A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-44A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-44A)
PROBLEM-44A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-44A ...) ...)
Rules: NIL
 PROBLEM-44A
ACL2 !>>(THEOREM PROBLEM-44
                 (IMPLIES (PROPER X)
                          (EQUAL (REV (REV X)) X))
                 :HINTS (("Goal" :INDUCT (REV X)
                                 :IN-THEORY (ENABLE PROBLEM-44A))))


ACL2 !>>>(DEFTHM PROBLEM-44
           (IMPLIES (PROPER X)
                    (EQUAL (REV (REV X)) X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (REV X)
                           :IN-THEORY (ENABLE PROBLEM-44A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (REV X).

This suggestion was produced using the :induction rule REV.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit REV.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (IMPLIES (PROPER X)
                  (EQUAL (REV (REV X)) X))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP X)) (PROPER X))
         (EQUAL (REV (REV X)) X)).

But simplification reduces this to T, using the :definition PROPER,
the :executable-counterparts of CONSP, EQUAL and REV and primitive
type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (IMPLIES (PROPER (CDR X))
                       (EQUAL (REV (REV (CDR X))) (CDR X))))
         (IMPLIES (PROPER X)
                  (EQUAL (REV (REV X)) X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (IMPLIES (PROPER (CDR X))
                       (EQUAL (REV (REV (CDR X))) (CDR X)))
              (PROPER X))
         (EQUAL (REV (REV X)) X)).

But simplification reduces this to T, using the :definitions APP, PROPER
and REV, the :executable-counterparts of CONSP and REV, primitive type
reasoning and the :rewrite rules CAR-CONS, CDR-CONS, CONS-CAR-CDR and
PROBLEM-44A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-44 ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION NOT)
        (:DEFINITION PROPER)
        (:DEFINITION REV)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART REV)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REV)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE CONS-CAR-CDR)
        (:REWRITE PROBLEM-44A))
PROBLEM-44


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-44))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-44)
PROBLEM-44

Summary
Form:  ( PROGN (DEFTHM PROBLEM-44 ...) ...)
Rules: NIL
 PROBLEM-44
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 45.
"
ACL2 !>>(THEOREM PROBLEM-45
                 (EQUAL (SWAP-TREE (SWAP-TREE X)) X)
                 :HINTS (("Goal" :INDUCT (SWAP-TREE X))))


ACL2 !>>>(DEFTHM PROBLEM-45
           (EQUAL (SWAP-TREE (SWAP-TREE X)) X)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (SWAP-TREE X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SWAP-TREE X).

This suggestion was produced using the :induction rule SWAP-TREE. 
If we let (:P X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X)
                   (:P (CDR X))
                   (:P (CAR X)))
              (:P X))).
This induction is justified by the same argument used to admit SWAP-TREE.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (SWAP-TREE (SWAP-TREE X)) X)).

But simplification reduces this to T, using the :definition SWAP-TREE
and primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (SWAP-TREE (SWAP-TREE (CDR X)))
                     (CDR X))
              (EQUAL (SWAP-TREE (SWAP-TREE (CAR X)))
                     (CAR X)))
         (EQUAL (SWAP-TREE (SWAP-TREE X)) X)).

But simplification reduces this to T, using the :definition SWAP-TREE,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS
and CONS-CAR-CDR.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-45 ...)
Rules: ((:DEFINITION SWAP-TREE)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SWAP-TREE)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE CONS-CAR-CDR))
PROBLEM-45


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-45))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-45)
PROBLEM-45

Summary
Form:  ( PROGN (DEFTHM PROBLEM-45 ...) ...)
Rules: NIL
 PROBLEM-45
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 46.
"
ACL2 !>>(THEOREM PROBLEM-46
                 (EQUAL (MEM E (APP A B))
                        (OR (MEM E A) (MEM E B)))
                 :HINTS (("Goal" :INDUCT (MEM E A))))


ACL2 !>>>(DEFTHM PROBLEM-46
           (EQUAL (MEM E (APP A B))
                  (OR (MEM E A) (MEM E B)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MEM E A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MEM E A).

This suggestion was produced using the :induction rule MEM.  If we
let (:P A B E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B E))
     (IMPLIES (AND (CONSP A)
                   (NOT (EQUAL E (CAR A)))
                   (:P (CDR A) B E))
              (:P A B E))
     (IMPLIES (AND (CONSP A) (EQUAL E (CAR A)))
              (:P A B E))).
This induction is justified by the same argument used to admit MEM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (EQUAL (MEM E (APP A B))
                (OR (MEM E A) (MEM E B)))).

But simplification reduces this to T, using the :definitions APP and
MEM and primitive type reasoning.

Subgoal *1/2
(IMPLIES (AND (CONSP A)
              (NOT (EQUAL E (CAR A)))
              (EQUAL (MEM E (APP (CDR A) B))
                     (OR (MEM E (CDR A)) (MEM E B))))
         (EQUAL (MEM E (APP A B))
                (OR (MEM E A) (MEM E B)))).

But simplification reduces this to T, using the :definitions APP and
MEM, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule MEM.

Subgoal *1/1
(IMPLIES (AND (CONSP A) (EQUAL E (CAR A)))
         (EQUAL (MEM E (APP A B))
                (OR (MEM E A) (MEM E B)))).

This simplifies, using the :definition MEM, primitive type reasoning
and the :type-prescription rule MEM, to

Subgoal *1/1'
(IMPLIES (CONSP A)
         (MEM (CAR A) (APP A B))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal *1/1''
(IMPLIES (CONSP (CONS A1 A2))
         (MEM A1 (APP (CONS A1 A2) B))).

But simplification reduces this to T, using the :definitions APP and
MEM, primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-46 ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION MEM)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MEM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-46


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-46))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-46)
PROBLEM-46

Summary
Form:  ( PROGN (DEFTHM PROBLEM-46 ...) ...)
Rules: NIL
 PROBLEM-46
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 47.
"
ACL2 !>>(THEOREM PROBLEM-47A
                 (IMPLIES (NOT (MEM E B))
                          (NOT (MEM E (INT A B))))
                 :HINTS (("Goal" :INDUCT (INT A B))))


ACL2 !>>>(DEFTHM PROBLEM-47A
           (IMPLIES (NOT (MEM E B))
                    (NOT (MEM E (INT A B))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (INT A B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (INT A B).

This suggestion was produced using the :induction rule INT.  If we
let (:P A B E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B E))
     (IMPLIES (AND (CONSP A)
                   (NOT (MEM (CAR A) B))
                   (:P (CDR A) B E))
              (:P A B E))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) B)
                   (:P (CDR A) B E))
              (:P A B E))).
This induction is justified by the same argument used to admit INT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (IMPLIES (NOT (MEM E B))
                  (NOT (MEM E (INT A B))))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP A)) (NOT (MEM E B)))
         (NOT (MEM E (INT A B)))).

But simplification reduces this to T, using the :definitions INT and
MEM and the :executable-counterpart of CONSP.

Subgoal *1/2
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) B))
              (IMPLIES (NOT (MEM E B))
                       (NOT (MEM E (INT (CDR A) B)))))
         (IMPLIES (NOT (MEM E B))
                  (NOT (MEM E (INT A B))))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) B))
              (IMPLIES (NOT (MEM E B))
                       (NOT (MEM E (INT (CDR A) B))))
              (NOT (MEM E B)))
         (NOT (MEM E (INT A B)))).

But simplification reduces this to T, using the :definitions INT and
NOT and the :executable-counterpart of NOT.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (NOT (MEM E B))
                       (NOT (MEM E (INT (CDR A) B)))))
         (IMPLIES (NOT (MEM E B))
                  (NOT (MEM E (INT A B))))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (NOT (MEM E B))
                       (NOT (MEM E (INT (CDR A) B))))
              (NOT (MEM E B)))
         (NOT (MEM E (INT A B)))).

This simplifies, using the :definitions INT, MEM and NOT, the :executable-
counterpart of NOT, primitive type reasoning, the :rewrite rules CAR-CONS
and CDR-CONS and the :type-prescription rules INT and MEM, to

Subgoal *1/1''
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (NOT (MEM E (INT (CDR A) B)))
              (NOT (MEM E B)))
         (NOT (EQUAL E (CAR A)))).

But simplification reduces this to T, using trivial observations.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-47A ...)
Rules: ((:DEFINITION INT)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION INT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION INT)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-47A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-47A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-47A)
PROBLEM-47A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-47A ...) ...)
Rules: NIL
 PROBLEM-47A
ACL2 !>>(THEOREM PROBLEM-47
                 (EQUAL (MEM E (INT A B))
                        (AND (MEM E A) (MEM E B)))
                 :HINTS (("Goal" :INDUCT (MEM E A)
                                 :IN-THEORY (ENABLE PROBLEM-47A))))


ACL2 !>>>(DEFTHM PROBLEM-47
           (EQUAL (MEM E (INT A B))
                  (AND (MEM E A) (MEM E B)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MEM E A)
                           :IN-THEORY (ENABLE PROBLEM-47A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MEM E A).

This suggestion was produced using the :induction rule MEM.  If we
let (:P A B E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B E))
     (IMPLIES (AND (CONSP A)
                   (NOT (EQUAL E (CAR A)))
                   (:P (CDR A) B E))
              (:P A B E))
     (IMPLIES (AND (CONSP A) (EQUAL E (CAR A)))
              (:P A B E))).
This induction is justified by the same argument used to admit MEM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (EQUAL (MEM E (INT A B))
                (AND (MEM E A) (MEM E B)))).

But simplification reduces this to T, using the :definitions INT and
MEM and the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP A)
              (NOT (EQUAL E (CAR A)))
              (EQUAL (MEM E (INT (CDR A) B))
                     (AND (MEM E (CDR A)) (MEM E B))))
         (EQUAL (MEM E (INT A B))
                (AND (MEM E A) (MEM E B)))).

This simplifies, using the :definitions INT (if-intro) and MEM, the
:executable-counterpart of NOT, primitive type reasoning and the :type-
prescription rule MEM, to the following two conjectures.

Subgoal *1/2.2
(IMPLIES (AND (CONSP A)
              (NOT (EQUAL E (CAR A)))
              (MEM E (CDR A))
              (EQUAL (MEM E (INT (CDR A) B))
                     (MEM E B))
              (MEM (CAR A) B))
         (EQUAL (MEM E (CONS (CAR A) (INT (CDR A) B)))
                (MEM E B))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rule INT.

Subgoal *1/2.1
(IMPLIES (AND (CONSP A)
              (NOT (EQUAL E (CAR A)))
              (NOT (MEM E (CDR A)))
              (EQUAL (MEM E (INT (CDR A) B)) NIL)
              (MEM (CAR A) B))
         (NOT (MEM E (CONS (CAR A) (INT (CDR A) B))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.1'
(IMPLIES (AND (CONSP A)
              (NOT (EQUAL E (CAR A)))
              (NOT (MEM E (CDR A)))
              (NOT (MEM E (INT (CDR A) B)))
              (MEM (CAR A) B))
         (NOT (MEM E (CONS (CAR A) (INT (CDR A) B))))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rule INT.

Subgoal *1/1
(IMPLIES (AND (CONSP A) (EQUAL E (CAR A)))
         (EQUAL (MEM E (INT A B))
                (AND (MEM E A) (MEM E B)))).

This simplifies, using the :definition MEM and primitive type reasoning,
to

Subgoal *1/1'
(IMPLIES (CONSP A)
         (EQUAL (MEM (CAR A) (INT A B))
                (MEM (CAR A) B))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal *1/1''
(IMPLIES (CONSP (CONS A1 A2))
         (EQUAL (MEM A1 (INT (CONS A1 A2) B))
                (MEM A1 B))).

This simplifies, using the :definition INT (if-intro), primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the following
two conjectures.

Subgoal *1/1.2
(IMPLIES (MEM A1 B)
         (EQUAL (MEM A1 (CONS A1 (INT A2 B)))
                (MEM A1 B))).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rule CAR-CONS and the :type-prescription rules INT and MEM.

Subgoal *1/1.1
(IMPLIES (NOT (MEM A1 B))
         (EQUAL (MEM A1 (INT A2 B)) (MEM A1 B))).

But simplification reduces this to T, using the :executable-counterpart
of EQUAL and the :rewrite rule PROBLEM-47A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-47 ...)
Rules: ((:DEFINITION INT)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MEM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-47A)
        (:TYPE-PRESCRIPTION INT)
        (:TYPE-PRESCRIPTION MEM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION INT))
PROBLEM-47


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-47))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-47)
PROBLEM-47

Summary
Form:  ( PROGN (DEFTHM PROBLEM-47 ...) ...)
Rules: NIL
 PROBLEM-47
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 48.
"
ACL2 !>>(THEOREM PROBLEM-48A
                 (IMPLIES (SUB X (CDR Y)) (SUB X Y))
                 :HINTS (("Goal" :INDUCT (SUB X Y))))


ACL2 !>>>(DEFTHM PROBLEM-48A
           (IMPLIES (SUB X (CDR Y)) (SUB X Y))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (SUB X Y))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SUB X Y).

This suggestion was produced using the :induction rule SUB.  If we
let (:P X Y) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X Y))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
              (:P X Y))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) Y)
                   (:P (CDR X) Y))
              (:P X Y))).
This induction is justified by the same argument used to admit SUB.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (SUB X (CDR Y)) (SUB X Y))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (SUB X (CDR Y)))
         (SUB X Y)).

But simplification reduces this to T, using the :definition SUB.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
         (IMPLIES (SUB X (CDR Y)) (SUB X Y))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Y))
              (SUB X (CDR Y)))
         (SUB X Y)).

But simplification reduces this to T, using the :definitions MEM and
SUB, the :executable-counterpart of CONSP and the :rewrite rule DEFAULT-CDR.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (SUB (CDR X) (CDR Y))
                       (SUB (CDR X) Y)))
         (IMPLIES (SUB X (CDR Y)) (SUB X Y))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (SUB (CDR X) (CDR Y))
                       (SUB (CDR X) Y))
              (SUB X (CDR Y)))
         (SUB X Y)).

But simplification reduces this to T, using the :definitions MEM and
SUB, primitive type reasoning and the :type-prescription rules MEM
and SUB.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-48A depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-48A ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION SUB)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SUB)
        (:REWRITE DEFAULT-CDR)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
PROBLEM-48A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-48A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-48A)
PROBLEM-48A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-48A ...) ...)
Rules: NIL
 PROBLEM-48A
ACL2 !>>(THEOREM PROBLEM-48 (SUB X X)
                 :HINTS (("Goal" :INDUCT (SUB X X)
                                 :IN-THEORY (ENABLE PROBLEM-48A))))


ACL2 !>>>(DEFTHM PROBLEM-48
           (SUB X X)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (SUB X X)
                           :IN-THEORY (ENABLE PROBLEM-48A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SUB X X).

This suggestion was produced using the :induction rule SUB.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) X)))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) X)
                   (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit SUB.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X)) (SUB X X)).

But simplification reduces this to T, using the :definition SUB, the
:executable-counterpart of CDR and the :rewrite rules DEFAULT-CDR and
PROBLEM-48A.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) X)))
         (SUB X X)).

But simplification reduces this to T, using the :definition MEM and
primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) X)
              (SUB (CDR X) (CDR X)))
         (SUB X X)).

But simplification reduces this to T, using the :definitions MEM and
SUB, primitive type reasoning, the :rewrite rule PROBLEM-48A and the
:type-prescription rule SUB.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-48 depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-48 ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION SUB)
        (:EXECUTABLE-COUNTERPART CDR)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SUB)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE PROBLEM-48A)
        (:TYPE-PRESCRIPTION SUB))
PROBLEM-48


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-48))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-48)
PROBLEM-48

Summary
Form:  ( PROGN (DEFTHM PROBLEM-48 ...) ...)
Rules: NIL
 PROBLEM-48
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 49.
"
ACL2 !>>(THEOREM PROBLEM-49A
                 (IMPLIES (AND (MEM E A) (SUB A B))
                          (MEM E B))
                 :HINTS (("Goal" :INDUCT (SUB A B))))


ACL2 !>>>(DEFTHM PROBLEM-49A
           (IMPLIES (AND (MEM E A) (SUB A B))
                    (MEM E B))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (SUB A B))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-49A ...):  A :REWRITE rule
generated from PROBLEM-49A contains the free variable A.  This variable
will be chosen by searching for an instance of (MEM E A) in the context
of the term being rewritten.  This is generally a severe restriction
on the applicability of a :REWRITE rule.  See :DOC free-variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SUB A B).

This suggestion was produced using the :induction rule SUB.  If we
let (:P A B E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B E))
     (IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
              (:P A B E))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) B)
                   (:P (CDR A) B E))
              (:P A B E))).
This induction is justified by the same argument used to admit SUB.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (IMPLIES (AND (MEM E A) (SUB A B))
                  (MEM E B))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP A))
              (MEM E A)
              (SUB A B))
         (MEM E B)).

But simplification reduces this to T, using the :definition MEM.

Subgoal *1/2
(IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
         (IMPLIES (AND (MEM E A) (SUB A B))
                  (MEM E B))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) B))
              (MEM E A)
              (SUB A B))
         (MEM E B)).

But simplification reduces this to T, using the :definition SUB.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (AND (MEM E (CDR A)) (SUB (CDR A) B))
                       (MEM E B)))
         (IMPLIES (AND (MEM E A) (SUB A B))
                  (MEM E B))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (AND (MEM E (CDR A)) (SUB (CDR A) B))
                       (MEM E B))
              (MEM E A)
              (SUB A B))
         (MEM E B)).

But simplification reduces this to T, using the :definitions MEM and
SUB, primitive type reasoning and the :type-prescription rule MEM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-49A depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-49A ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION SUB)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SUB)
        (:TYPE-PRESCRIPTION MEM))
Warnings:  Free
PROBLEM-49A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-49A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-49A)
PROBLEM-49A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-49A ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-49A
ACL2 !>>(THEOREM
             PROBLEM-49
             (IMPLIES (AND (SUB A B) (SUB B C))
                      (SUB A C))
             :HINTS (("Goal" :INDUCT (SUB A C)
                             :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-49A))))


ACL2 !>>>(DEFTHM PROBLEM-49
           (IMPLIES (AND (SUB A B) (SUB B C))
                    (SUB A C))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (SUB A C)
                           :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-49A))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-49 ...):  A :REWRITE rule generated
from PROBLEM-49 contains the free variable B.  This variable will be
chosen by searching for an instance of (SUB A B) in the context of
the term being rewritten.  This is generally a severe restriction on
the applicability of a :REWRITE rule.  See :DOC free-variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SUB A C).

This suggestion was produced using the :induction rule SUB.  If we
let (:P A B C) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B C))
     (IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) C)))
              (:P A B C))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) C)
                   (:P (CDR A) B C))
              (:P A B C))).
This induction is justified by the same argument used to admit SUB.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (IMPLIES (AND (SUB A B) (SUB B C))
                  (SUB A C))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP A))
              (SUB A B)
              (SUB B C))
         (SUB A C)).

But simplification reduces this to T, using the :definition SUB and
the :rewrite rule PROBLEM-48A.

Subgoal *1/2
(IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) C)))
         (IMPLIES (AND (SUB A B) (SUB B C))
                  (SUB A C))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) C))
              (SUB A B)
              (SUB B C))
         (SUB A C)).

This simplifies (dropping false conclusion; see :DOC clause), using
the :definition SUB, to

Subgoal *1/2''
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) C))
              (SUB A B))
         (NOT (SUB B C))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal *1/2'''
(IMPLIES (AND (CONSP (CONS A1 A2))
              (NOT (MEM A1 C))
              (SUB (CONS A1 A2) B))
         (NOT (SUB B C))).

This simplifies, using the :definition SUB, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/2'4'
(IMPLIES (AND (NOT (MEM A1 C))
              (MEM A1 B)
              (SUB A2 B))
         (NOT (SUB B C))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-49A
and the :type-prescription rules MEM and SUB.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) C)
              (IMPLIES (AND (SUB (CDR A) B) (SUB B C))
                       (SUB (CDR A) C)))
         (IMPLIES (AND (SUB A B) (SUB B C))
                  (SUB A C))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) C)
              (IMPLIES (AND (SUB (CDR A) B) (SUB B C))
                       (SUB (CDR A) C))
              (SUB A B)
              (SUB B C))
         (SUB A C)).

But simplification reduces this to T, using the :definition SUB, the
:rewrite rule PROBLEM-49A and the :type-prescription rules MEM and
SUB.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-49 depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-49 ...)
Rules: ((:DEFINITION NOT)
        (:DEFINITION SUB)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SUB)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-48A)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
Warnings:  Free
PROBLEM-49


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-49))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-49)
PROBLEM-49

Summary
Form:  ( PROGN (DEFTHM PROBLEM-49 ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-49
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 50.
"
ACL2 !>>(THEOREM
           PROBLEM-50A
           (EQUAL (SUB (APP A B) C)
                  (AND (SUB A C) (SUB B C)))
           :HINTS
           (("Goal" :INDUCT (SUB A C)
                    :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-48 PROBLEM-49A))))


ACL2 !>>>(DEFTHM PROBLEM-50A
           (EQUAL (SUB (APP A B) C)
                  (AND (SUB A C) (SUB B C)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (SUB A C)
                    :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-48 PROBLEM-49A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SUB A C).

This suggestion was produced using the :induction rule SUB.  If we
let (:P A B C) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B C))
     (IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) C)))
              (:P A B C))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) C)
                   (:P (CDR A) B C))
              (:P A B C))).
This induction is justified by the same argument used to admit SUB.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (EQUAL (SUB (APP A B) C)
                (AND (SUB A C) (SUB B C)))).

But simplification reduces this to T, using the :definitions APP and
SUB, primitive type reasoning and the :rewrite rule PROBLEM-48A.

Subgoal *1/2
(IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) C)))
         (EQUAL (SUB (APP A B) C)
                (AND (SUB A C) (SUB B C)))).

This simplifies, using the :definition SUB and primitive type reasoning,
to

Subgoal *1/2'
(IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) C)))
         (NOT (SUB (APP A B) C))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal *1/2''
(IMPLIES (AND (CONSP (CONS A1 A2))
              (NOT (MEM A1 C)))
         (NOT (SUB (APP (CONS A1 A2) B) C))).

But simplification reduces this to T, using the :definitions APP and
SUB, primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) C)
              (EQUAL (SUB (APP (CDR A) B) C)
                     (AND (SUB (CDR A) C) (SUB B C))))
         (EQUAL (SUB (APP A B) C)
                (AND (SUB A C) (SUB B C)))).

But simplification reduces this to T, using the :definitions APP and
SUB, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-48 and PROBLEM-49A and
the :type-prescription rules MEM and SUB.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-50A ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION SUB)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SUB)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-48A)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
PROBLEM-50A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-50A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-50A)
PROBLEM-50A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-50A ...) ...)
Rules: NIL
 PROBLEM-50A
ACL2 !>>(THEOREM PROBLEM-50 (SUB (APP A A) A)
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-50A)))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by the :executable-counterpart of
IF and the simple :rewrite rules PROBLEM-48 and PROBLEM-50A.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-50 ...)
Rules: ((:EXECUTABLE-COUNTERPART IF)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-50A))
 PROBLEM-50
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 51.
"
ACL2 !>>(DEFUN MAPNIL1 (X A)
          (IF (CONSP X)
              (MAPNIL1 (CDR X) (CONS NIL A))
            A))

The admission of MAPNIL1 is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of MAPNIL1 is described by
the theorem (OR (CONSP (MAPNIL1 X A)) (EQUAL (MAPNIL1 X A) A)).  We
used primitive type reasoning.

Summary
Form:  ( DEFUN MAPNIL1 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 MAPNIL1
ACL2 !>>(DEFUN NILS (X)
          (IF (CONSP X)
              (AND (EQUAL (CAR X) NIL) (NILS (CDR X)))
            (EQUAL X NIL)))

The admission of NILS is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of NILS is described by the
theorem (OR (EQUAL (NILS X) T) (EQUAL (NILS X) NIL)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN NILS ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 NILS
ACL2 !>>(THEOREM PROBLEM-51A
                 (EQUAL (MAPNIL1 A (CONS NIL B))
                        (CONS NIL (MAPNIL1 A B)))
                 :HINTS (("Goal" :INDUCT (MAPNIL1 A B))))


ACL2 !>>>(DEFTHM PROBLEM-51A
           (EQUAL (MAPNIL1 A (CONS NIL B))
                  (CONS NIL (MAPNIL1 A B)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MAPNIL1 A B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MAPNIL1 A B).

This suggestion was produced using the :induction rule MAPNIL1.  If
we let (:P A B) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A)
                   (:P (CDR A) (CONS NIL B)))
              (:P A B))).
This induction is justified by the same argument used to admit MAPNIL1.
Note, however, that the unmeasured variable B is being instantiated.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (MAPNIL1 A (CONS NIL B))
                (CONS NIL (MAPNIL1 A B)))).

But simplification reduces this to T, using the :definition MAPNIL1
and primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (MAPNIL1 (CDR A) (LIST* NIL NIL B))
                     (CONS NIL (MAPNIL1 (CDR A) (CONS NIL B)))))
         (EQUAL (MAPNIL1 A (CONS NIL B))
                (CONS NIL (MAPNIL1 A B)))).

But simplification reduces this to T, using the :definition MAPNIL1
and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-51A ...)
Rules: ((:DEFINITION MAPNIL1)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MAPNIL1))
PROBLEM-51A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-51A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-51A)
PROBLEM-51A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-51A ...) ...)
Rules: NIL
 PROBLEM-51A
ACL2 !>>(THEOREM PROBLEM-51B
                 (IMPLIES (NILS X)
                          (EQUAL (MAPNIL1 X NIL) X))
                 :HINTS (("Goal" :INDUCT (NILS X)
                                 :IN-THEORY (ENABLE PROBLEM-51A))))


ACL2 !>>>(DEFTHM PROBLEM-51B
           (IMPLIES (NILS X)
                    (EQUAL (MAPNIL1 X NIL) X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (NILS X)
                           :IN-THEORY (ENABLE PROBLEM-51A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (NILS X).

This suggestion was produced using the :induction rule NILS.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (CAR X)) (:P X))
     (IMPLIES (AND (CONSP X)
                   (NOT (CAR X))
                   (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit NILS.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (NILS X)
                  (EQUAL (MAPNIL1 X NIL) X))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (NILS X))
         (EQUAL (MAPNIL1 X NIL) X)).

But simplification reduces this to T, using the :definition NILS, the
:executable-counterparts of CONSP, EQUAL and MAPNIL1 and primitive
type reasoning.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (CAR X))
         (IMPLIES (NILS X)
                  (EQUAL (MAPNIL1 X NIL) X))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X) (CAR X) (NILS X))
         (EQUAL (MAPNIL1 X NIL) X)).

But simplification reduces this to T, using the :definition NILS and
primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (IMPLIES (NILS (CDR X))
                       (EQUAL (MAPNIL1 (CDR X) NIL) (CDR X))))
         (IMPLIES (NILS X)
                  (EQUAL (MAPNIL1 X NIL) X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (IMPLIES (NILS (CDR X))
                       (EQUAL (MAPNIL1 (CDR X) NIL) (CDR X)))
              (NILS X))
         (EQUAL (MAPNIL1 X NIL) X)).

This simplifies, using the :definition NILS and the :executable-counterpart
of EQUAL, to

Subgoal *1/1''
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (EQUAL (MAPNIL1 (CDR X) NIL) (CDR X))
              (NILS (CDR X)))
         (EQUAL (MAPNIL1 X NIL) X)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1'''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT X1)
              (EQUAL (MAPNIL1 X2 NIL) X2)
              (NILS X2))
         (EQUAL (MAPNIL1 (CONS X1 X2) NIL)
                (CONS X1 X2))).

But simplification reduces this to T, using the :definition MAPNIL1,
the :executable-counterpart of CONS, primitive type reasoning and the
:rewrite rules CDR-CONS and PROBLEM-51A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-51B ...)
Rules: ((:DEFINITION MAPNIL1)
        (:DEFINITION NILS)
        (:DEFINITION NOT)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART MAPNIL1)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION NILS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-51A))
PROBLEM-51B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-51B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-51B)
PROBLEM-51B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-51B ...) ...)
Rules: NIL
 PROBLEM-51B
ACL2 !>>(THEOREM
             PROBLEM-51
             (IMPLIES (AND (NILS A) (NILS B))
                      (EQUAL (MAPNIL1 A B) (MAPNIL1 B A)))
             :HINTS (("Goal" :INDUCT (MAPNIL1 A B)
                             :IN-THEORY (ENABLE PROBLEM-51A PROBLEM-51B))))


ACL2 !>>>(DEFTHM PROBLEM-51
           (IMPLIES (AND (NILS A) (NILS B))
                    (EQUAL (MAPNIL1 A B) (MAPNIL1 B A)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MAPNIL1 A B)
                           :IN-THEORY (ENABLE PROBLEM-51A PROBLEM-51B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MAPNIL1 A B).

This suggestion was produced using the :induction rule MAPNIL1.  If
we let (:P A B) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A)
                   (:P (CDR A) (CONS NIL B)))
              (:P A B))).
This induction is justified by the same argument used to admit MAPNIL1.
Note, however, that the unmeasured variable B is being instantiated.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (IMPLIES (AND (NILS A) (NILS B))
                  (EQUAL (MAPNIL1 A B) (MAPNIL1 B A)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP A)) (NILS A) (NILS B))
         (EQUAL (MAPNIL1 A B) (MAPNIL1 B A))).

But simplification reduces this to T, using the :definitions MAPNIL1
and NILS, the :executable-counterpart of CONSP, primitive type reasoning,
the :rewrite rule PROBLEM-51B and the :type-prescription rule NILS.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (IMPLIES (AND (NILS (CDR A)) (NILS (CONS NIL B)))
                       (EQUAL (MAPNIL1 (CDR A) (CONS NIL B))
                              (MAPNIL1 (CONS NIL B) (CDR A)))))
         (IMPLIES (AND (NILS A) (NILS B))
                  (EQUAL (MAPNIL1 A B) (MAPNIL1 B A)))).

By the simple :rewrite rule PROBLEM-51A we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (IMPLIES (AND (NILS (CDR A)) (NILS (CONS NIL B)))
                       (EQUAL (CONS NIL (MAPNIL1 (CDR A) B))
                              (MAPNIL1 (CONS NIL B) (CDR A))))
              (NILS A)
              (NILS B))
         (EQUAL (MAPNIL1 A B) (MAPNIL1 B A))).

This simplifies, using the :definitions MAPNIL1 and NILS, the :executable-
counterpart of EQUAL, primitive type reasoning, the :rewrite rules
CAR-CONS, CDR-CONS, CONS-EQUAL and PROBLEM-51A and the :type-prescription
rule NILS, to

Subgoal *1/1''
(IMPLIES (AND (CONSP A)
              (EQUAL (MAPNIL1 (CDR A) B)
                     (MAPNIL1 B (CDR A)))
              (NOT (CAR A))
              (NILS (CDR A))
              (NILS B))
         (EQUAL (MAPNIL1 (CDR A) (CONS NIL B))
                (MAPNIL1 B A))).

By the simple :rewrite rule PROBLEM-51A we reduce the conjecture to

Subgoal *1/1'''
(IMPLIES (AND (CONSP A)
              (EQUAL (MAPNIL1 (CDR A) B)
                     (MAPNIL1 B (CDR A)))
              (NOT (CAR A))
              (NILS (CDR A))
              (NILS B))
         (EQUAL (CONS NIL (MAPNIL1 (CDR A) B))
                (MAPNIL1 B A))).

This simplifies, using trivial observations, to

Subgoal *1/1'4'
(IMPLIES (AND (CONSP A)
              (EQUAL (MAPNIL1 (CDR A) B)
                     (MAPNIL1 B (CDR A)))
              (NOT (CAR A))
              (NILS (CDR A))
              (NILS B))
         (EQUAL (CONS NIL (MAPNIL1 B (CDR A)))
                (MAPNIL1 B A))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal *1/1'5'
(IMPLIES (AND (CONSP (CONS A1 A2))
              (EQUAL (MAPNIL1 A2 B) (MAPNIL1 B A2))
              (NOT A1)
              (NILS A2)
              (NILS B))
         (EQUAL (CONS NIL (MAPNIL1 B A2))
                (MAPNIL1 B (CONS A1 A2)))).

But simplification reduces this to T, using primitive type reasoning
and the :rewrite rule PROBLEM-51A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-51 ...)
Rules: ((:DEFINITION MAPNIL1)
        (:DEFINITION NILS)
        (:DEFINITION NOT)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MAPNIL1)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE CONS-EQUAL)
        (:REWRITE PROBLEM-51A)
        (:REWRITE PROBLEM-51B)
        (:TYPE-PRESCRIPTION NILS))
PROBLEM-51


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-51))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-51)
PROBLEM-51

Summary
Form:  ( PROGN (DEFTHM PROBLEM-51 ...) ...)
Rules: NIL
 PROBLEM-51
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 52.
"
ACL2 !>>(DEFUN RM (X Y)
          (IF (CONSP Y)
              (IF (EQUAL X (CAR Y))
                  (CDR Y)
                (CONS (CAR Y) (RM X (CDR Y))))
            Y))

The admission of RM is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT Y).  We could deduce no constraints on the type of RM.

Summary
Form:  ( DEFUN RM ...)
Rules: NIL
 RM
ACL2 !>>(DEFUN PERM (X Y)
          (IF (CONSP X)
              (AND (MEM (CAR X) Y)
                   (PERM (CDR X) (RM (CAR X) Y)))
            (NOT (CONSP Y))))

The admission of PERM is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of PERM is described by the
theorem (OR (EQUAL (PERM X Y) T) (EQUAL (PERM X Y) NIL)).  

Summary
Form:  ( DEFUN PERM ...)
Rules: NIL
 PERM
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 53.
"
ACL2 !>>(THEOREM PROBLEM-53 (PERM X X)
                 :HINTS (("Goal" :INDUCT (PERM X X))))


ACL2 !>>>(DEFTHM PROBLEM-53
           (PERM X X)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PERM X X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM X X).

This suggestion was produced using the :induction rule PERM.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) X)))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) X)
                   (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit PERM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X)) (PERM X X)).

But simplification reduces this to T, using the :definition PERM.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) X)))
         (PERM X X)).

But simplification reduces this to T, using the :definition MEM and
primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) X)
              (PERM (CDR X) (CDR X)))
         (PERM X X)).

But simplification reduces this to T, using the :definitions MEM, PERM
and RM, primitive type reasoning and the :type-prescription rule PERM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-53 depends upon the :type-prescription rule
PERM.

Summary
Form:  ( DEFTHM PROBLEM-53 ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION PERM)
        (:DEFINITION RM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PERM)
        (:TYPE-PRESCRIPTION PERM))
PROBLEM-53


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-53))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-53)
PROBLEM-53

Summary
Form:  ( PROGN (DEFTHM PROBLEM-53 ...) ...)
Rules: NIL
 PROBLEM-53
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 54.
"
ACL2 !>>(THEOREM PROBLEM-54A
                 (IMPLIES (MEM A X)
                          (EQUAL (PERM X (CONS A Y))
                                 (PERM (RM A X) Y)))
                 :HINTS (("Goal" :INDUCT (PERM X Y))))


ACL2 !>>>(DEFTHM PROBLEM-54A
           (IMPLIES (MEM A X)
                    (EQUAL (PERM X (CONS A Y))
                           (PERM (RM A X) Y)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PERM X Y))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM X Y).

This suggestion was produced using the :induction rule PERM.  If we
let (:P A X Y) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P A X Y))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
              (:P A X Y))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) Y)
                   (:P A (CDR X) (RM (CAR X) Y)))
              (:P A X Y))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable Y is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (MEM A X)
                  (EQUAL (PERM X (CONS A Y))
                         (PERM (RM A X) Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (MEM A X))
         (EQUAL (PERM X (CONS A Y))
                (PERM (RM A X) Y))).

But simplification reduces this to T, using the :definition MEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
         (IMPLIES (MEM A X)
                  (EQUAL (PERM X (CONS A Y))
                         (PERM (RM A X) Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Y))
              (MEM A X))
         (EQUAL (PERM X (CONS A Y))
                (PERM (RM A X) Y))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/2''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (MEM X1 Y))
              (MEM A (CONS X1 X2)))
         (EQUAL (PERM (CONS X1 X2) (CONS A Y))
                (PERM (RM A (CONS X1 X2)) Y))).

This simplifies, using the :definitions MEM, PERM and RM, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/2'''
(IMPLIES (AND (NOT (MEM X1 Y))
              (MEM A X2)
              (NOT (EQUAL X1 A)))
         (EQUAL NIL (PERM (CONS X1 (RM A X2)) Y))).

But simplification reduces this to T, using the :definition PERM, the
:executable-counterpart of EQUAL, primitive type reasoning and the
:rewrite rule CAR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (MEM A (CDR X))
                       (EQUAL (PERM (CDR X) (CONS A (RM (CAR X) Y)))
                              (PERM (RM A (CDR X)) (RM (CAR X) Y)))))
         (IMPLIES (MEM A X)
                  (EQUAL (PERM X (CONS A Y))
                         (PERM (RM A X) Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (MEM A (CDR X))
                       (EQUAL (PERM (CDR X) (CONS A (RM (CAR X) Y)))
                              (PERM (RM A (CDR X)) (RM (CAR X) Y))))
              (MEM A X))
         (EQUAL (PERM X (CONS A Y))
                (PERM (RM A X) Y))).

This simplifies, using the :definitions MEM (if-intro), PERM and RM
(if-intro), primitive type reasoning and the :rewrite rules CAR-CONS
and CDR-CONS, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (EQUAL (PERM (CDR X) (CONS A (RM (CAR X) Y)))
                     (PERM (RM A (CDR X)) (RM (CAR X) Y)))
              (MEM A (CDR X))
              (EQUAL A (CAR X)))
         (EQUAL (PERM X (CONS A Y))
                (PERM (CDR X) Y))).

But simplification reduces this to T, using the :definitions MEM, PERM
and RM, primitive type reasoning and the :rewrite rules CAR-CONS and
CDR-CONS.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (EQUAL (PERM (CDR X) (CONS A (RM (CAR X) Y)))
                     (PERM (RM A (CDR X)) (RM (CAR X) Y)))
              (MEM A (CDR X))
              (NOT (EQUAL A (CAR X))))
         (EQUAL (PERM X (CONS A Y))
                (PERM (CONS (CAR X) (RM A (CDR X)))
                      Y))).

But simplification reduces this to T, using the :definitions MEM, PERM
and RM, primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule MEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-54A ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PERM)
        (:DEFINITION RM)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PERM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION MEM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION MEM) (:DEFINITION RM))
PROBLEM-54A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-54A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-54A)
PROBLEM-54A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-54A ...) ...)
Rules: NIL
 PROBLEM-54A
ACL2 !>>(THEOREM PROBLEM-54
                 (IMPLIES (PERM X Y) (PERM Y X))
                 :HINTS (("Goal" :INDUCT (PERM X Y)
                                 :IN-THEORY (ENABLE PROBLEM-54A))))


ACL2 !>>>(DEFTHM PROBLEM-54
           (IMPLIES (PERM X Y) (PERM Y X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PERM X Y)
                           :IN-THEORY (ENABLE PROBLEM-54A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM X Y).

This suggestion was produced using the :induction rule PERM.  If we
let (:P X Y) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X Y))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
              (:P X Y))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) Y)
                   (:P (CDR X) (RM (CAR X) Y)))
              (:P X Y))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable Y is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (PERM X Y) (PERM Y X))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (PERM X Y))
         (PERM Y X)).

But simplification reduces this to T, using the :definition PERM.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
         (IMPLIES (PERM X Y) (PERM Y X))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Y))
              (PERM X Y))
         (PERM Y X)).

But simplification reduces this to T, using the :definition PERM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (PERM (CDR X) (RM (CAR X) Y))
                       (PERM (RM (CAR X) Y) (CDR X))))
         (IMPLIES (PERM X Y) (PERM Y X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (PERM (CDR X) (RM (CAR X) Y))
                       (PERM (RM (CAR X) Y) (CDR X)))
              (PERM X Y))
         (PERM Y X)).

This simplifies, using the :definition PERM and the :type-prescription
rule MEM, to

Subgoal *1/1''
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (PERM (RM (CAR X) Y) (CDR X))
              (PERM (CDR X) (RM (CAR X) Y)))
         (PERM Y X)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1'''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (MEM X1 Y)
              (PERM (RM X1 Y) X2)
              (PERM X2 (RM X1 Y)))
         (PERM Y (CONS X1 X2))).

But simplification reduces this to T, using primitive type reasoning,
the :rewrite rule PROBLEM-54A and the :type-prescription rules MEM
and PERM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-54 depends upon the :type-prescription rule
PERM.

Summary
Form:  ( DEFTHM PROBLEM-54 ...)
Rules: ((:DEFINITION NOT)
        (:DEFINITION PERM)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PERM)
        (:REWRITE PROBLEM-54A)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION PERM))
PROBLEM-54


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-54))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-54)
PROBLEM-54

Summary
Form:  ( PROGN (DEFTHM PROBLEM-54 ...) ...)
Rules: NIL
 PROBLEM-54
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 55.
"
ACL2 !>>(THEOREM PROBLEM-55A
                 (IMPLIES (MEM A (RM B X)) (MEM A X))
                 :HINTS (("Goal" :INDUCT (MEM A X))))


ACL2 !>>>(DEFTHM PROBLEM-55A
           (IMPLIES (MEM A (RM B X)) (MEM A X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MEM A X))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-55A ...):  A :REWRITE rule
generated from PROBLEM-55A contains the free variable B.  This variable
will be chosen by searching for an instance of (MEM A (RM B X)) in
the context of the term being rewritten.  This is generally a severe
restriction on the applicability of a :REWRITE rule.  See :DOC free-
variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MEM A X).

This suggestion was produced using the :induction rule MEM.  If we
let (:P A B X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P A B X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL A (CAR X)))
                   (:P A B (CDR X)))
              (:P A B X))
     (IMPLIES (AND (CONSP X) (EQUAL A (CAR X)))
              (:P A B X))).
This induction is justified by the same argument used to admit MEM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (MEM A (RM B X)) (MEM A X))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (MEM A (RM B X)))
         (MEM A X)).

But simplification reduces this to T, using the :definitions MEM and
RM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL A (CAR X)))
              (IMPLIES (MEM A (RM B (CDR X)))
                       (MEM A (CDR X))))
         (IMPLIES (MEM A (RM B X)) (MEM A X))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL A (CAR X)))
              (IMPLIES (MEM A (RM B (CDR X)))
                       (MEM A (CDR X)))
              (MEM A (RM B X)))
         (MEM A X)).

This simplifies, using the :definitions MEM and RM, primitive type
reasoning and the :type-prescription rule MEM, to

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL A (CAR X)))
              (NOT (MEM A (RM B (CDR X))))
              (NOT (EQUAL B (CAR X)))
              (MEM A (CONS (CAR X) (RM B (CDR X)))))
         (MEM A (CDR X))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (EQUAL A (CAR X)))
         (IMPLIES (MEM A (RM B X)) (MEM A X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL A (CAR X))
              (MEM A (RM B X)))
         (MEM A X)).

But simplification reduces this to T, using the :definition MEM and
primitive type reasoning.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-55A depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-55A ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MEM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION MEM))
Warnings:  Free
PROBLEM-55A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-55A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-55A)
PROBLEM-55A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-55A ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-55A
ACL2 !>>(THEOREM PROBLEM-55B
                 (IMPLIES (AND (PERM X Y) (MEM A X))
                          (MEM A Y))
                 :HINTS (("Goal" :INDUCT (PERM X Y)
                                 :IN-THEORY (ENABLE PROBLEM-55A))))


ACL2 !>>>(DEFTHM PROBLEM-55B
           (IMPLIES (AND (PERM X Y) (MEM A X))
                    (MEM A Y))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PERM X Y)
                           :IN-THEORY (ENABLE PROBLEM-55A))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-55B ...):  A :REWRITE rule
generated from PROBLEM-55B contains the free variable X.  This variable
will be chosen by searching for an instance of (PERM X Y) in the context
of the term being rewritten.  This is generally a severe restriction
on the applicability of a :REWRITE rule.  See :DOC free-variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM X Y).

This suggestion was produced using the :induction rule PERM.  If we
let (:P A X Y) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P A X Y))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
              (:P A X Y))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) Y)
                   (:P A (CDR X) (RM (CAR X) Y)))
              (:P A X Y))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable Y is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (AND (PERM X Y) (MEM A X))
                  (MEM A Y))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X))
              (PERM X Y)
              (MEM A X))
         (MEM A Y)).

But simplification reduces this to T, using the :definitions MEM and
PERM.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
         (IMPLIES (AND (PERM X Y) (MEM A X))
                  (MEM A Y))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Y))
              (PERM X Y)
              (MEM A X))
         (MEM A Y)).

But simplification reduces this to T, using the :definition PERM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (AND (PERM (CDR X) (RM (CAR X) Y))
                            (MEM A (CDR X)))
                       (MEM A (RM (CAR X) Y))))
         (IMPLIES (AND (PERM X Y) (MEM A X))
                  (MEM A Y))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (AND (PERM (CDR X) (RM (CAR X) Y))
                            (MEM A (CDR X)))
                       (MEM A (RM (CAR X) Y)))
              (PERM X Y)
              (MEM A X))
         (MEM A Y)).

This simplifies, using the :definitions MEM and PERM, primitive type
reasoning, the :rewrite rule PROBLEM-55A and the :type-prescription
rule MEM, to

Subgoal *1/1''
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (NOT (MEM A (CDR X)))
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL A (CAR X)))
         (MEM A Y)).

But simplification reduces this to T, using trivial observations.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-55B depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-55B ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PERM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PERM)
        (:REWRITE PROBLEM-55A)
        (:TYPE-PRESCRIPTION MEM))
Warnings:  Free
PROBLEM-55B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-55B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-55B)
PROBLEM-55B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-55B ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-55B
ACL2 !>>(THEOREM PROBLEM-55C
                 (EQUAL (RM A (RM B X)) (RM B (RM A X)))
                 :HINTS (("Goal" :INDUCT (RM A X))))


ACL2 !>>>(DEFTHM PROBLEM-55C
           (EQUAL (RM A (RM B X)) (RM B (RM A X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RM A X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RM A X).

This suggestion was produced using the :induction rule RM.  If we let
(:P A B X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P A B X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL A (CAR X)))
                   (:P A B (CDR X)))
              (:P A B X))
     (IMPLIES (AND (CONSP X) (EQUAL A (CAR X)))
              (:P A B X))).
This induction is justified by the same argument used to admit RM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (EQUAL (RM A (RM B X))
                (RM B (RM A X)))).

But simplification reduces this to T, using the :definition RM and
primitive type reasoning.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL A (CAR X)))
              (EQUAL (RM A (RM B (CDR X)))
                     (RM B (RM A (CDR X)))))
         (EQUAL (RM A (RM B X))
                (RM B (RM A X)))).

This simplifies, using the :definition RM, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL A (CAR X)))
              (EQUAL (RM A (RM B (CDR X)))
                     (RM B (RM A (CDR X))))
              (NOT (EQUAL B (CAR X))))
         (EQUAL (RM A (CONS (CAR X) (RM B (CDR X))))
                (CONS (CAR X) (RM A (RM B (CDR X)))))).

But simplification reduces this to T, using the :definition RM, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (EQUAL A (CAR X)))
         (EQUAL (RM A (RM B X))
                (RM B (RM A X)))).

This simplifies, using the :definition RM and primitive type reasoning,
to

Subgoal *1/1'
(IMPLIES (CONSP X)
         (EQUAL (RM (CAR X) (RM B X))
                (RM B (CDR X)))).

This simplifies, using the :definition RM (if-intro), to the following
two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X) (EQUAL B (CAR X)))
         (EQUAL (RM (CAR X) (CDR X))
                (RM B (CDR X)))).

But simplification reduces this to T, using primitive type reasoning.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X) (NOT (EQUAL B (CAR X))))
         (EQUAL (RM (CAR X)
                    (CONS (CAR X) (RM B (CDR X))))
                (RM B (CDR X)))).

But simplification reduces this to T, using the :definition RM, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-55C ...)
Rules: ((:DEFINITION RM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION RM))
PROBLEM-55C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-55C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-55C)
PROBLEM-55C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-55C ...) ...)
Rules: NIL
 PROBLEM-55C
ACL2 !>>(THEOREM
             PROBLEM-55D
             (IMPLIES (AND (NOT (EQUAL E D)) (MEM E X))
                      (MEM E (RM D X)))
             :HINTS (("Goal" :INDUCT (RM D X)
                             :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A))))


ACL2 !>>>(DEFTHM PROBLEM-55D
           (IMPLIES (AND (NOT (EQUAL E D)) (MEM E X))
                    (MEM E (RM D X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RM D X)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RM D X).

This suggestion was produced using the :induction rule RM.  If we let
(:P D E X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P D E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL D (CAR X)))
                   (:P D E (CDR X)))
              (:P D E X))
     (IMPLIES (AND (CONSP X) (EQUAL D (CAR X)))
              (:P D E X))).
This induction is justified by the same argument used to admit RM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (AND (NOT (EQUAL E D)) (MEM E X))
                  (MEM E (RM D X)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X))
              (NOT (EQUAL E D))
              (MEM E X))
         (MEM E (RM D X))).

But simplification reduces this to T, using the :definition MEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL D (CAR X)))
              (IMPLIES (AND (NOT (EQUAL E D)) (MEM E (CDR X)))
                       (MEM E (RM D (CDR X)))))
         (IMPLIES (AND (NOT (EQUAL E D)) (MEM E X))
                  (MEM E (RM D X)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL D (CAR X)))
              (IMPLIES (AND (NOT (EQUAL E D)) (MEM E (CDR X)))
                       (MEM E (RM D (CDR X))))
              (NOT (EQUAL E D))
              (MEM E X))
         (MEM E (RM D X))).

But simplification reduces this to T, using the :definitions MEM and
RM, the :executable-counterpart of NOT, primitive type reasoning, the
:rewrite rules CAR-CONS, CDR-CONS, PROBLEM-48 and PROBLEM-49A and the
:type-prescription rule MEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (EQUAL D (CAR X)))
         (IMPLIES (AND (NOT (EQUAL E D)) (MEM E X))
                  (MEM E (RM D X)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL D (CAR X))
              (NOT (EQUAL E D))
              (MEM E X))
         (MEM E (RM D X))).

This simplifies, using the :definition RM and primitive type reasoning,
to

Subgoal *1/1''
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (MEM E X))
         (MEM E (CDR X))).

But simplification reduces this to T, using the :definition MEM and
primitive type reasoning.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-55D depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-55D ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-55D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-55D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-55D)
PROBLEM-55D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-55D ...) ...)
Rules: NIL
 PROBLEM-55D
ACL2 !>>(THEOREM
           PROBLEM-55E
           (IMPLIES (PERM X Y)
                    (PERM (RM A X) (RM A Y)))
           :HINTS
           (("Goal" :INDUCT (PERM X Y)
                    :IN-THEORY (ENABLE PROBLEM-54A
                                       PROBLEM-54 PROBLEM-55C PROBLEM-55D))))


ACL2 !>>>(DEFTHM PROBLEM-55E
           (IMPLIES (PERM X Y)
                    (PERM (RM A X) (RM A Y)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (PERM X Y)
                    :IN-THEORY (ENABLE PROBLEM-54A
                                       PROBLEM-54 PROBLEM-55C PROBLEM-55D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM X Y).

This suggestion was produced using the :induction rule PERM.  If we
let (:P A X Y) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P A X Y))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
              (:P A X Y))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) Y)
                   (:P A (CDR X) (RM (CAR X) Y)))
              (:P A X Y))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable Y is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (PERM X Y)
                  (PERM (RM A X) (RM A Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (PERM X Y))
         (PERM (RM A X) (RM A Y))).

But simplification reduces this to T, using the :definitions PERM and
RM and the :rewrite rule PROBLEM-54.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
         (IMPLIES (PERM X Y)
                  (PERM (RM A X) (RM A Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Y))
              (PERM X Y))
         (PERM (RM A X) (RM A Y))).

But simplification reduces this to T, using the :definition PERM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (PERM (CDR X) (RM (CAR X) Y))
                       (PERM (RM A (CDR X))
                             (RM A (RM (CAR X) Y)))))
         (IMPLIES (PERM X Y)
                  (PERM (RM A X) (RM A Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (PERM (CDR X) (RM (CAR X) Y))
                       (PERM (RM A (CDR X))
                             (RM A (RM (CAR X) Y))))
              (PERM X Y))
         (PERM (RM A X) (RM A Y))).

This simplifies, using the :definitions PERM and RM (if-intro) and
the :type-prescription rule MEM, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (PERM (RM A (CDR X))
                    (RM A (RM (CAR X) Y)))
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL A (CAR X)))
         (PERM (CDR X) (RM A Y))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (PERM (RM A (CDR X))
                    (RM A (RM (CAR X) Y)))
              (PERM (CDR X) (RM (CAR X) Y))
              (NOT (EQUAL A (CAR X))))
         (PERM (CONS (CAR X) (RM A (CDR X)))
               (RM A Y))).

But simplification reduces this to T, using primitive type reasoning,
the :rewrite rules PROBLEM-54, PROBLEM-54A, PROBLEM-55C and PROBLEM-55D
and the :type-prescription rules MEM and PERM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-55E depends upon the :type-prescription rule
PERM.

Summary
Form:  ( DEFTHM PROBLEM-55E ...)
Rules: ((:DEFINITION NOT)
        (:DEFINITION PERM)
        (:DEFINITION RM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PERM)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-54A)
        (:REWRITE PROBLEM-55C)
        (:REWRITE PROBLEM-55D)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION PERM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION RM))
PROBLEM-55E


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-55E))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-55E)
PROBLEM-55E

Summary
Form:  ( PROGN (DEFTHM PROBLEM-55E ...) ...)
Rules: NIL
 PROBLEM-55E
ACL2 !>>(THEOREM
           PROBLEM-55
           (IMPLIES (AND (PERM X Y) (PERM Y Z))
                    (PERM X Z))
           :HINTS
           (("Goal" :INDUCT (LIST (PERM X Y) (PERM X Z))
                    :IN-THEORY (ENABLE PROBLEM-54 PROBLEM-55B PROBLEM-55E))))


ACL2 !>>>(DEFTHM PROBLEM-55
           (IMPLIES (AND (PERM X Y) (PERM Y Z))
                    (PERM X Z))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (LIST (PERM X Y) (PERM X Z))
                    :IN-THEORY (ENABLE PROBLEM-54 PROBLEM-55B PROBLEM-55E))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-55 ...):  A :REWRITE rule generated
from PROBLEM-55 contains the free variable Y.  This variable will be
chosen by searching for an instance of (PERM X Y) in the context of
the term being rewritten.  This is generally a severe restriction on
the applicability of a :REWRITE rule.  See :DOC free-variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  Two induction schemes are suggested
by the induction hint.  These merge into one derived induction scheme.

We will induct according to a scheme suggested by (PERM X Z), but modified
to accommodate (PERM X Y).

These suggestions were produced using the :induction rule PERM.  If
we let (:P X Y Z) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P X Y Z))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Z)))
              (:P X Y Z))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) Z)
                   (:P (CDR X)
                       (RM (CAR X) Y)
                       (RM (CAR X) Z)))
              (:P X Y Z))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variables Y and Z are being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (AND (PERM X Y) (PERM Y Z))
                  (PERM X Z))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X))
              (PERM X Y)
              (PERM Y Z))
         (PERM X Z)).

But simplification reduces this to T, using the :definition PERM and
the :rewrite rule PROBLEM-54.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Z)))
         (IMPLIES (AND (PERM X Y) (PERM Y Z))
                  (PERM X Z))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Z))
              (PERM X Y)
              (PERM Y Z))
         (PERM X Z)).

This simplifies, using the :definition PERM, the :rewrite rule PROBLEM-55B
and the :type-prescription rules MEM and PERM, to

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Z))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (PERM Y Z))
         (PERM (CDR X) (RM (CAR X) Z))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-55B
and the :type-prescription rules MEM and PERM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Z)
              (IMPLIES (AND (PERM (CDR X) (RM (CAR X) Y))
                            (PERM (RM (CAR X) Y) (RM (CAR X) Z)))
                       (PERM (CDR X) (RM (CAR X) Z))))
         (IMPLIES (AND (PERM X Y) (PERM Y Z))
                  (PERM X Z))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Z)
              (IMPLIES (AND (PERM (CDR X) (RM (CAR X) Y))
                            (PERM (RM (CAR X) Y) (RM (CAR X) Z)))
                       (PERM (CDR X) (RM (CAR X) Z)))
              (PERM X Y)
              (PERM Y Z))
         (PERM X Z)).

But simplification reduces this to T, using the :definition PERM, the
:rewrite rules PROBLEM-55B and PROBLEM-55E and the :type-prescription
rules MEM and PERM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-55 depends upon the :type-prescription rule
PERM.

Summary
Form:  ( DEFTHM PROBLEM-55 ...)
Rules: ((:DEFINITION NOT)
        (:DEFINITION PERM)
        (:INDUCTION PERM)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-55B)
        (:REWRITE PROBLEM-55E)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION PERM))
Warnings:  Free
PROBLEM-55


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-55))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-55)
PROBLEM-55

Summary
Form:  ( PROGN (DEFTHM PROBLEM-55 ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-55
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 56.

; Before Problem 56, the document introduces a total order.  As
; explained in the document, <<= is intended as a more suggestive name
; than the ACL2 built-in relation lexorder.
"
ACL2 !>>(DEFUN <<= (X Y) (LEXORDER X Y))

Since <<= is non-recursive, its admission is trivial.  We observe that
the type of <<= is described by the theorem 
(OR (EQUAL (<<= X Y) T) (EQUAL (<<= X Y) NIL)).  We used the :type-
prescription rule LEXORDER.

Summary
Form:  ( DEFUN <<= ...)
Rules: ((:TYPE-PRESCRIPTION LEXORDER))
 <<=
ACL2 !>>:----- 
"
; ACL2 has already proved that lexorder is a non-strict total order.
; So this lemma about <<= is trival and unnecessary.
"
ACL2 !>>(THEOREM <<=-NON-STRICT-TOTAL-ORDER
                 (AND (<<= X X)
                      (IMPLIES (AND (<<= X Y) (<<= Y X))
                               (EQUAL X Y))
                      (IMPLIES (AND (<<= X Y) (<<= Y Z))
                               (<<= X Z))
                      (OR (<<= X Y) (<<= Y X)))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definition <<= and the simple :rewrite rule LEXORDER-REFLEXIVE
we reduce the conjecture to the following three conjectures.

Subgoal 3
(IMPLIES (AND (LEXORDER X Y) (LEXORDER Y X))
         (EQUAL X Y)).

But we reduce the conjecture to T, by primitive type reasoning, the
:forward-chaining rule LEXORDER-ANTI-SYMMETRIC and the :type-prescription
rule LEXORDER.

Subgoal 2
(IMPLIES (AND (LEXORDER X Y) (LEXORDER Y Z))
         (LEXORDER X Z)).

But simplification reduces this to T, using the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal 1
(OR (LEXORDER X Y) (LEXORDER Y X)).

But we reduce the conjecture to T, by primitive type reasoning, the
:forward-chaining rule LEXORDER-TOTAL and the :type-prescription rule
LEXORDER.

Q.E.D.

Summary
Form:  ( DEFTHM <<=-NON-STRICT-TOTAL-ORDER ...)
Rules: ((:DEFINITION <<=)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-ANTI-SYMMETRIC)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION LEXORDER))
 <<=-NON-STRICT-TOTAL-ORDER
ACL2 !>>:----- "
; Here is the solution to Problem 56.
"
ACL2 !>>(DEFUN ORDERED (X)
          (IF (CONSP X)
              (IF (CONSP (CDR X))
                  (AND (<<= (CAR X) (CADR X))
                       (ORDERED (CDR X)))
                T)
            T))

The admission of ORDERED is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of ORDERED is described by
the theorem (OR (EQUAL (ORDERED X) T) (EQUAL (ORDERED X) NIL)).  

Summary
Form:  ( DEFUN ORDERED ...)
Rules: NIL
 ORDERED
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 57.
"
ACL2 !>>(DEFUN INSERT (E X)
          (IF (CONSP X)
              (IF (<<= E (CAR X))
                  (CONS E X)
                (CONS (CAR X) (INSERT E (CDR X))))
            (CONS E NIL)))

The admission of INSERT is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of INSERT is described by
the theorem (CONSP (INSERT E X)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN INSERT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 INSERT
ACL2 !>>(DEFUN ISORT (X)
          (IF (CONSP X)
              (INSERT (CAR X) (ISORT (CDR X)))
            NIL))

The admission of ISORT is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of ISORT is described by
the theorem (OR (CONSP (ISORT X)) (EQUAL (ISORT X) NIL)).  We used
the :type-prescription rule INSERT.

Summary
Form:  ( DEFUN ISORT ...)
Rules: ((:TYPE-PRESCRIPTION INSERT))
 ISORT
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 58.
"
ACL2 !>>(THEOREM PROBLEM-58A
                 (IMPLIES (ORDERED X)
                          (ORDERED (INSERT E X)))
                 :HINTS (("Goal" :INDUCT (INSERT E X))))


ACL2 !>>>(DEFTHM PROBLEM-58A
           (IMPLIES (ORDERED X)
                    (ORDERED (INSERT E X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (INSERT E X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (INSERT E X).

This suggestion was produced using the :induction rule INSERT.  If
we let (:P E X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (<<= E (CAR X)))
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (AND (CONSP X) (<<= E (CAR X)))
              (:P E X))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (ORDERED X)
                  (ORDERED (INSERT E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (ORDERED X))
         (ORDERED (INSERT E X))).

But simplification reduces this to T, using the :definitions INSERT
and ORDERED, the :executable-counterpart of CONSP, primitive type reasoning
and the :rewrite rule CDR-CONS.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (<<= E (CAR X)))
              (IMPLIES (ORDERED (CDR X))
                       (ORDERED (INSERT E (CDR X)))))
         (IMPLIES (ORDERED X)
                  (ORDERED (INSERT E X)))).

By the simple :definition <<= we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (IMPLIES (ORDERED (CDR X))
                       (ORDERED (INSERT E (CDR X))))
              (ORDERED X))
         (ORDERED (INSERT E X))).

This simplifies, using the :definitions <<=, INSERT and ORDERED (if-
intro), primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rules INSERT, LEXORDER and ORDERED, to the
following four conjectures.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (NOT (ORDERED (CDR X)))
              (NOT (CONSP (CDR X))))
         (LEXORDER (CAR X)
                   (CAR (INSERT E (CDR X))))).

But simplification reduces this to T, using the :definition ORDERED.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (NOT (ORDERED (CDR X)))
              (NOT (CONSP (CDR X))))
         (ORDERED (INSERT E (CDR X)))).

But simplification reduces this to T, using the :definition ORDERED.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (ORDERED (INSERT E (CDR X)))
              (NOT (CONSP (CDR X))))
         (LEXORDER (CAR X)
                   (CAR (INSERT E (CDR X))))).

But simplification reduces this to T, using the :definitions INSERT
and ORDERED, the :executable-counterpart of CONSP, primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rules CAR-CONS,
CDR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-
prescription rule LEXORDER.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (ORDERED (INSERT E (CDR X)))
              (LEXORDER (CAR X) (CADR X))
              (ORDERED (CDR X)))
         (LEXORDER (CAR X)
                   (CAR (INSERT E (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2.  (2) Use CAR-CDR-ELIM, again, to replace X2
by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  These steps produce
the following two goals.

Subgoal *1/2.1.2
(IMPLIES (AND (NOT (CONSP X2))
              (CONSP (CONS X1 X2))
              (NOT (LEXORDER E X1))
              (ORDERED (INSERT E X2))
              (LEXORDER X1 (CAR X2))
              (ORDERED X2))
         (LEXORDER X1 (CAR (INSERT E X2)))).

But simplification reduces this to T, using the :definitions INSERT
and ORDERED, the :executable-counterpart of CONSP, primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and
the :type-prescription rule LEXORDER.

Subgoal *1/2.1.1
(IMPLIES (AND (CONSP (CONS X3 X4))
              (CONSP (LIST* X1 X3 X4))
              (NOT (LEXORDER E X1))
              (ORDERED (INSERT E (CONS X3 X4)))
              (LEXORDER X1 X3)
              (ORDERED (CONS X3 X4)))
         (LEXORDER X1 (CAR (INSERT E (CONS X3 X4))))).

But simplification reduces this to T, using the :definitions <<=, INSERT
and ORDERED, primitive type reasoning, the :forward-chaining rule 
LEXORDER-TOTAL, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (<<= E (CAR X)))
         (IMPLIES (ORDERED X)
                  (ORDERED (INSERT E X)))).

By the simple :definition <<= we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (LEXORDER E (CAR X))
              (ORDERED X))
         (ORDERED (INSERT E X))).

But simplification reduces this to T, using the :definitions <<=, INSERT
and ORDERED, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-
prescription rules LEXORDER and ORDERED.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-58A depends upon the :type-prescription rule
ORDERED.

Summary
Form:  ( DEFTHM PROBLEM-58A ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION INSERT)
        (:DEFINITION NOT)
        (:DEFINITION ORDERED)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:INDUCTION INSERT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION INSERT)
        (:TYPE-PRESCRIPTION LEXORDER)
        (:TYPE-PRESCRIPTION ORDERED))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ORDERED))
PROBLEM-58A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-58A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-58A)
PROBLEM-58A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-58A ...) ...)
Rules: NIL
 PROBLEM-58A
ACL2 !>>(THEOREM PROBLEM-58 (ORDERED (ISORT X))
                 :HINTS (("Goal" :INDUCT (ISORT X)
                                 :IN-THEORY (ENABLE PROBLEM-58A))))


ACL2 !>>>(DEFTHM PROBLEM-58
           (ORDERED (ISORT X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ISORT X)
                           :IN-THEORY (ENABLE PROBLEM-58A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ISORT X).

This suggestion was produced using the :induction rule ISORT.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit ISORT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (ORDERED (ISORT X))).

But simplification reduces this to T, using the :definition ISORT and
the :executable-counterpart of ORDERED.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (ORDERED (ISORT (CDR X))))
         (ORDERED (ISORT X))).

But simplification reduces this to T, using the :definition ISORT,
the :rewrite rule PROBLEM-58A and the :type-prescription rule ORDERED.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-58 depends upon the :type-prescription rule
ORDERED.

Summary
Form:  ( DEFTHM PROBLEM-58 ...)
Rules: ((:DEFINITION ISORT)
        (:EXECUTABLE-COUNTERPART ORDERED)
        (:INDUCTION ISORT)
        (:REWRITE PROBLEM-58A)
        (:TYPE-PRESCRIPTION ORDERED))
PROBLEM-58


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-58))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-58)
PROBLEM-58

Summary
Form:  ( PROGN (DEFTHM PROBLEM-58 ...) ...)
Rules: NIL
 PROBLEM-58
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 59.

; I will show two proofs of Problem 59.
"
ACL2 !>>(THEOREM
           PROBLEM-59A
           (IMPLIES (PERM A B)
                    (PERM (INSERT E A) (CONS E B)))
           :HINTS
           (("Goal" :INDUCT (PERM A B)
                    :IN-THEORY (ENABLE PROBLEM-48
                                       PROBLEM-49A PROBLEM-54A PROBLEM-54))))


ACL2 !>>>(DEFTHM PROBLEM-59A
           (IMPLIES (PERM A B)
                    (PERM (INSERT E A) (CONS E B)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (PERM A B)
                    :IN-THEORY (ENABLE PROBLEM-48
                                       PROBLEM-49A PROBLEM-54A PROBLEM-54))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM A B).

This suggestion was produced using the :induction rule PERM.  If we
let (:P A B E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B E))
     (IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
              (:P A B E))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) B)
                   (:P (CDR A) (RM (CAR A) B) E))
              (:P A B E))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable B is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (IMPLIES (PERM A B)
                  (PERM (INSERT E A) (CONS E B)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP A)) (PERM A B))
         (PERM (INSERT E A) (CONS E B))).

But simplification reduces this to T, using the :definitions INSERT,
MEM, PERM and RM, the :executable-counterpart of CONSP, primitive type
reasoning and the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-54 and
PROBLEM-54A.

Subgoal *1/2
(IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
         (IMPLIES (PERM A B)
                  (PERM (INSERT E A) (CONS E B)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) B))
              (PERM A B))
         (PERM (INSERT E A) (CONS E B))).

But simplification reduces this to T, using the :definition PERM.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (PERM (CDR A) (RM (CAR A) B))
                       (PERM (INSERT E (CDR A))
                             (CONS E (RM (CAR A) B)))))
         (IMPLIES (PERM A B)
                  (PERM (INSERT E A) (CONS E B)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (PERM (CDR A) (RM (CAR A) B))
                       (PERM (INSERT E (CDR A))
                             (CONS E (RM (CAR A) B))))
              (PERM A B))
         (PERM (INSERT E A) (CONS E B))).

This simplifies, using the :definitions <<=, INSERT (if-intro) and
PERM, the :rewrite rules PROBLEM-48 and PROBLEM-49A and the :type-
prescription rule MEM, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (PERM (INSERT E (CDR A))
                    (CONS E (RM (CAR A) B)))
              (PERM (CDR A) (RM (CAR A) B))
              (LEXORDER E (CAR A)))
         (PERM (CONS E A) (CONS E B))).

But simplification reduces this to T, using the :definitions MEM, PERM
and RM, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
PROBLEM-48, PROBLEM-49A, PROBLEM-54 and PROBLEM-54A and the :type-
prescription rules MEM and PERM.

Subgoal *1/1.1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (PERM (INSERT E (CDR A))
                    (CONS E (RM (CAR A) B)))
              (PERM (CDR A) (RM (CAR A) B))
              (NOT (LEXORDER E (CAR A))))
         (PERM (CONS (CAR A) (INSERT E (CDR A)))
               (CONS E B))).

This simplifies, using the :definitions MEM, PERM and RM, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-48 and
PROBLEM-49A and the :type-prescription rule MEM, to

Subgoal *1/1.1'
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (PERM (INSERT E (CDR A))
                    (CONS E (RM (CAR A) B)))
              (PERM (CDR A) (RM (CAR A) B))
              (NOT (LEXORDER E (CAR A)))
              (EQUAL (CAR A) E))
         (PERM (INSERT E (CDR A)) B)).

But simplification reduces this to T, using primitive type reasoning
and the :forward-chaining rule LEXORDER-TOTAL.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-59A depends upon the :type-prescription rule
PERM.

Summary
Form:  ( DEFTHM PROBLEM-59A ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION INSERT)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PERM)
        (:DEFINITION RM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:INDUCTION PERM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-54A)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION PERM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION INSERT))
PROBLEM-59A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-59A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-59A)
PROBLEM-59A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-59A ...) ...)
Rules: NIL
 PROBLEM-59A
ACL2 !>>(THEOREM
             PROBLEM-59 (PERM (ISORT X) X)
             :HINTS (("Goal" :INDUCT (ISORT X)
                             :IN-THEORY (ENABLE PROBLEM-54 PROBLEM-59A))))


ACL2 !>>>(DEFTHM PROBLEM-59
           (PERM (ISORT X) X)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ISORT X)
                           :IN-THEORY (ENABLE PROBLEM-54 PROBLEM-59A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ISORT X).

This suggestion was produced using the :induction rule ISORT.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit ISORT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (PERM (ISORT X) X)).

But simplification reduces this to T, using the :definitions ISORT
and PERM, the :executable-counterpart of CONSP and the :rewrite rule
PROBLEM-54.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (PERM (ISORT (CDR X)) (CDR X)))
         (PERM (ISORT X) X)).

This simplifies, using the :definition ISORT, to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (PERM (ISORT (CDR X)) (CDR X)))
         (PERM (INSERT (CAR X) (ISORT (CDR X)))
               X)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (PERM (ISORT X2) X2))
         (PERM (INSERT X1 (ISORT X2))
               (CONS X1 X2))).

But simplification reduces this to T, using primitive type reasoning,
the :rewrite rule PROBLEM-59A and the :type-prescription rule PERM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-59 depends upon the :type-prescription rule
PERM.

Summary
Form:  ( DEFTHM PROBLEM-59 ...)
Rules: ((:DEFINITION ISORT)
        (:DEFINITION PERM)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ISORT)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-59A)
        (:TYPE-PRESCRIPTION PERM))
PROBLEM-59


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-59))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-59)
PROBLEM-59

Summary
Form:  ( PROGN (DEFTHM PROBLEM-59 ...) ...)
Rules: NIL
 PROBLEM-59
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 60.
"
ACL2 !>>(THEOREM PROBLEM-60A
                 (EQUAL (INSERT E (INSERT D X))
                        (INSERT D (INSERT E X)))
                 :HINTS (("Goal" :INDUCT (INSERT E X))))


ACL2 !>>>(DEFTHM PROBLEM-60A
           (EQUAL (INSERT E (INSERT D X))
                  (INSERT D (INSERT E X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (INSERT E X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (INSERT E X).

This suggestion was produced using the :induction rule INSERT.  If
we let (:P D E X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P D E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (<<= E (CAR X)))
                   (:P D E (CDR X)))
              (:P D E X))
     (IMPLIES (AND (CONSP X) (<<= E (CAR X)))
              (:P D E X))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (EQUAL (INSERT E (INSERT D X))
                (INSERT D (INSERT E X)))).

This simplifies, using the :definitions <<= and INSERT (if-intro),
the :executable-counterpart of CONSP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS, to the following two conjectures.

Subgoal *1/3.2
(IMPLIES (AND (NOT (CONSP X))
              (LEXORDER E D)
              (LEXORDER D E))
         (EQUAL (LIST E D) (LIST D E))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-ANTI-SYMMETRIC and the :type-prescription
rule LEXORDER.

Subgoal *1/3.1
(IMPLIES (AND (NOT (CONSP X))
              (NOT (LEXORDER E D))
              (NOT (LEXORDER D E)))
         (EQUAL (LIST D E) (LIST E D))).

But simplification reduces this to T, using primitive type reasoning
and the :forward-chaining rule LEXORDER-TOTAL.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (<<= E (CAR X)))
              (EQUAL (INSERT E (INSERT D (CDR X)))
                     (INSERT D (INSERT E (CDR X)))))
         (EQUAL (INSERT E (INSERT D X))
                (INSERT D (INSERT E X)))).

By the simple :definition <<= we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (INSERT E (INSERT D (CDR X)))
                     (INSERT D (INSERT E (CDR X)))))
         (EQUAL (INSERT E (INSERT D X))
                (INSERT D (INSERT E X)))).

This simplifies, using the :definitions <<= and INSERT (if-intro),
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS,
to the following two conjectures.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (INSERT E (INSERT D (CDR X)))
                     (INSERT D (INSERT E (CDR X))))
              (LEXORDER D (CAR X)))
         (EQUAL (INSERT E (CONS D X))
                (LIST* D (CAR X) (INSERT E (CDR X))))).

This simplifies, using the :definitions <<= and INSERT, primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/2.2'
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (INSERT E (INSERT D (CDR X)))
                     (INSERT D (INSERT E (CDR X))))
              (LEXORDER D (CAR X))
              (LEXORDER E D))
         (EQUAL (LIST* E D X)
                (LIST* D (CAR X) (INSERT E (CDR X))))).

But simplification reduces this to T, using the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (INSERT E (INSERT D (CDR X)))
                     (INSERT D (INSERT E (CDR X))))
              (NOT (LEXORDER D (CAR X))))
         (EQUAL (INSERT E (CONS (CAR X) (INSERT D (CDR X))))
                (CONS (CAR X)
                      (INSERT D (INSERT E (CDR X)))))).

But simplification reduces this to T, using the :definitions <<= and
INSERT, primitive type reasoning and the :rewrite rules CAR-CONS and
CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (<<= E (CAR X)))
         (EQUAL (INSERT E (INSERT D X))
                (INSERT D (INSERT E X)))).

By the simple :definition <<= we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X) (LEXORDER E (CAR X)))
         (EQUAL (INSERT E (INSERT D X))
                (INSERT D (INSERT E X)))).

This simplifies, using the :definitions <<= and INSERT (if-intro),
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, 
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (LEXORDER E (CAR X))
              (LEXORDER D E))
         (EQUAL (INSERT E (INSERT D X))
                (LIST* D E X))).

This simplifies, using the :definitions <<= and INSERT, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER, to

Subgoal *1/1.2'
(IMPLIES (AND (CONSP X)
              (LEXORDER E (CAR X))
              (LEXORDER D E)
              (LEXORDER E D))
         (EQUAL (LIST* E D X) (LIST* D E X))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rule LEXORDER-ANTI-SYMMETRIC and the :type-prescription
rule LEXORDER.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (LEXORDER E (CAR X))
              (NOT (LEXORDER D E)))
         (EQUAL (INSERT E (INSERT D X))
                (CONS E (INSERT D X)))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.1'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (LEXORDER E X1)
              (NOT (LEXORDER D E)))
         (EQUAL (INSERT E (INSERT D (CONS X1 X2)))
                (CONS E (INSERT D (CONS X1 X2))))).

This simplifies, using the :definitions <<= and INSERT (if-intro),
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS,
to the following two conjectures.

Subgoal *1/1.1.2
(IMPLIES (AND (LEXORDER E X1)
              (NOT (LEXORDER D E))
              (LEXORDER D X1))
         (EQUAL (INSERT E (LIST* D X1 X2))
                (LIST* E D X1 X2))).

But simplification reduces this to T, using the :definitions <<= and
INSERT, primitive type reasoning, the :forward-chaining rule LEXORDER-TOTAL,
the :rewrite rules CAR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE
and the :type-prescription rule LEXORDER.

Subgoal *1/1.1.1
(IMPLIES (AND (LEXORDER E X1)
              (NOT (LEXORDER D E))
              (NOT (LEXORDER D X1)))
         (EQUAL (INSERT E (CONS X1 (INSERT D X2)))
                (LIST* E X1 (INSERT D X2)))).

But simplification reduces this to T, using the :definitions <<= and
INSERT, primitive type reasoning, the :rewrite rules CAR-CONS, 
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-60A ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION INSERT)
        (:DEFINITION NOT)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-ANTI-SYMMETRIC)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:INDUCTION INSERT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION LEXORDER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION INSERT))
PROBLEM-60A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-60A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-60A)
PROBLEM-60A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-60A ...) ...)
Rules: NIL
 PROBLEM-60A
ACL2 !>>(THEOREM PROBLEM-60B
                 (EQUAL (ISORT (APP X (LIST E)))
                        (INSERT E (ISORT X)))
                 :HINTS (("Goal" :INDUCT (ISORT X)
                                 :IN-THEORY (ENABLE PROBLEM-60A))))


ACL2 !>>>(DEFTHM PROBLEM-60B
           (EQUAL (ISORT (APP X (LIST E)))
                  (INSERT E (ISORT X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ISORT X)
                           :IN-THEORY (ENABLE PROBLEM-60A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ISORT X).

This suggestion was produced using the :induction rule ISORT.  If we
let (:P E X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X) (:P E (CDR X)))
              (:P E X))).
This induction is justified by the same argument used to admit ISORT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (ISORT (APP X (LIST E)))
                (INSERT E (ISORT X)))).

But simplification reduces this to T, using the :definitions APP, INSERT
and ISORT, the :executable-counterparts of CONSP and ISORT, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (ISORT (APP (CDR X) (LIST E)))
                     (INSERT E (ISORT (CDR X)))))
         (EQUAL (ISORT (APP X (LIST E)))
                (INSERT E (ISORT X)))).

But simplification reduces this to T, using the :definitions APP and
ISORT, primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS
and PROBLEM-60A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-60B ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION INSERT)
        (:DEFINITION ISORT)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART ISORT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ISORT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-60A))
PROBLEM-60B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-60B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-60B)
PROBLEM-60B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-60B ...) ...)
Rules: NIL
 PROBLEM-60B
ACL2 !>>(THEOREM PROBLEM-60C
                 (EQUAL (ISORT (REV X)) (ISORT X))
                 :HINTS (("Goal" :INDUCT (ISORT X)
                                 :IN-THEORY (ENABLE PROBLEM-60B))))


ACL2 !>>>(DEFTHM PROBLEM-60C
           (EQUAL (ISORT (REV X)) (ISORT X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ISORT X)
                           :IN-THEORY (ENABLE PROBLEM-60B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ISORT X).

This suggestion was produced using the :induction rule ISORT.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit ISORT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (ISORT (REV X)) (ISORT X))).

But simplification reduces this to T, using the :definitions ISORT
and REV and the :executable-counterparts of EQUAL and ISORT.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (ISORT (REV (CDR X)))
                     (ISORT (CDR X))))
         (EQUAL (ISORT (REV X)) (ISORT X))).

But simplification reduces this to T, using the :definitions ISORT
and REV, primitive type reasoning and the :rewrite rule PROBLEM-60B.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-60C ...)
Rules: ((:DEFINITION ISORT)
        (:DEFINITION REV)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART ISORT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ISORT)
        (:REWRITE PROBLEM-60B))
PROBLEM-60C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-60C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-60C)
PROBLEM-60C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-60C ...) ...)
Rules: NIL
 PROBLEM-60C
ACL2 !>>(THEOREM PROBLEM-60D
                 (EQUAL (ISORT (INSERT E X))
                        (INSERT E (ISORT X)))
                 :HINTS (("Goal" :INDUCT (INSERT E X)
                                 :IN-THEORY (ENABLE PROBLEM-60A))))


ACL2 !>>>(DEFTHM PROBLEM-60D
           (EQUAL (ISORT (INSERT E X))
                  (INSERT E (ISORT X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (INSERT E X)
                           :IN-THEORY (ENABLE PROBLEM-60A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (INSERT E X).

This suggestion was produced using the :induction rule INSERT.  If
we let (:P E X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (<<= E (CAR X)))
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (AND (CONSP X) (<<= E (CAR X)))
              (:P E X))).
This induction is justified by the same argument used to admit INSERT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (EQUAL (ISORT (INSERT E X))
                (INSERT E (ISORT X)))).

But simplification reduces this to T, using the :definitions INSERT
and ISORT, the :executable-counterparts of CONSP and ISORT, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (<<= E (CAR X)))
              (EQUAL (ISORT (INSERT E (CDR X)))
                     (INSERT E (ISORT (CDR X)))))
         (EQUAL (ISORT (INSERT E X))
                (INSERT E (ISORT X)))).

By the simple :definition <<= we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (ISORT (INSERT E (CDR X)))
                     (INSERT E (ISORT (CDR X)))))
         (EQUAL (ISORT (INSERT E X))
                (INSERT E (ISORT X)))).

But simplification reduces this to T, using the :definitions <<=, INSERT
and ISORT, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS and PROBLEM-60A.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (<<= E (CAR X)))
         (EQUAL (ISORT (INSERT E X))
                (INSERT E (ISORT X)))).

By the simple :definition <<= we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X) (LEXORDER E (CAR X)))
         (EQUAL (ISORT (INSERT E X))
                (INSERT E (ISORT X)))).

But simplification reduces this to T, using the :definitions <<=, INSERT
and ISORT, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-60D ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION INSERT)
        (:DEFINITION ISORT)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART ISORT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION INSERT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:REWRITE PROBLEM-60A)
        (:TYPE-PRESCRIPTION LEXORDER))
PROBLEM-60D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-60D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-60D)
PROBLEM-60D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-60D ...) ...)
Rules: NIL
 PROBLEM-60D
ACL2 !>>(THEOREM PROBLEM-60E
                 (EQUAL (ISORT (ISORT X)) (ISORT X))
                 :HINTS (("Goal" :INDUCT (ISORT X)
                                 :IN-THEORY (ENABLE PROBLEM-60D))))


ACL2 !>>>(DEFTHM PROBLEM-60E
           (EQUAL (ISORT (ISORT X)) (ISORT X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ISORT X)
                           :IN-THEORY (ENABLE PROBLEM-60D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ISORT X).

This suggestion was produced using the :induction rule ISORT.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit ISORT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (ISORT (ISORT X)) (ISORT X))).

But simplification reduces this to T, using the :definition ISORT and
the :executable-counterparts of EQUAL and ISORT.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (ISORT (ISORT (CDR X)))
                     (ISORT (CDR X))))
         (EQUAL (ISORT (ISORT X)) (ISORT X))).

But simplification reduces this to T, using the :definition ISORT,
primitive type reasoning and the :rewrite rule PROBLEM-60D.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-60E ...)
Rules: ((:DEFINITION ISORT)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART ISORT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ISORT)
        (:REWRITE PROBLEM-60D))
PROBLEM-60E


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-60E))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-60E)
PROBLEM-60E

Summary
Form:  ( PROGN (DEFTHM PROBLEM-60E ...) ...)
Rules: NIL
 PROBLEM-60E
ACL2 !>>(THEOREM
             PROBLEM-60
             (EQUAL (ISORT (REV (ISORT L)))
                    (ISORT L))
             :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-60C PROBLEM-60E))))


ACL2 !>>>(DEFTHM PROBLEM-60
           (EQUAL (ISORT (REV (ISORT L)))
                  (ISORT L))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-60C PROBLEM-60E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by the simple :rewrite rules PROBLEM-60C
and PROBLEM-60E.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-60 ...)
Rules: ((:REWRITE PROBLEM-60C)
        (:REWRITE PROBLEM-60E))
PROBLEM-60


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-60))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-60)
PROBLEM-60

Summary
Form:  ( PROGN (DEFTHM PROBLEM-60 ...) ...)
Rules: NIL
 PROBLEM-60
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 61.
"
ACL2 !>>(DEFUN REV1 (X A)
          (IF (CONSP X)
              (REV1 (CDR X) (CONS (CAR X) A))
            A))

The admission of REV1 is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of REV1 is described by the
theorem (OR (CONSP (REV1 X A)) (EQUAL (REV1 X A) A)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN REV1 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 REV1
ACL2 !>>(THEOREM PROBLEM-61A
                 (EQUAL (REV1 X A) (APP (REV X) A))
                 :HINTS (("Goal" :INDUCT (REV1 X A)
                                 :IN-THEORY (ENABLE PROBLEM-40))))


ACL2 !>>>(DEFTHM PROBLEM-61A
           (EQUAL (REV1 X A) (APP (REV X) A))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (REV1 X A)
                           :IN-THEORY (ENABLE PROBLEM-40))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (REV1 X A).

This suggestion was produced using the :induction rule REV1.  If we
let (:P A X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P A X))
     (IMPLIES (AND (CONSP X)
                   (:P (CONS (CAR X) A) (CDR X)))
              (:P A X))).
This induction is justified by the same argument used to admit REV1.
Note, however, that the unmeasured variable A is being instantiated.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (REV1 X A) (APP (REV X) A))).

But simplification reduces this to T, using the :definitions APP, REV
and REV1, the :executable-counterpart of CONSP and primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (REV1 (CDR X) (CONS (CAR X) A))
                     (APP (REV (CDR X)) (CONS (CAR X) A))))
         (EQUAL (REV1 X A) (APP (REV X) A))).

But simplification reduces this to T, using the :definitions APP, REV
and REV1, the :executable-counterpart of CONSP, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-40.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-61A ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION REV)
        (:DEFINITION REV1)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REV1)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-40))
PROBLEM-61A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-61A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-61A)
PROBLEM-61A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-61A ...) ...)
Rules: NIL
 PROBLEM-61A
ACL2 !>>(THEOREM
           PROBLEM-61 (EQUAL (REV1 X NIL) (REV X))
           :HINTS
           (("Goal" :IN-THEORY (ENABLE PROBLEM-41 PROBLEM-44B PROBLEM-61A))))


ACL2 !>>>(DEFTHM PROBLEM-61
           (EQUAL (REV1 X NIL) (REV X))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :IN-THEORY (ENABLE PROBLEM-41 PROBLEM-44B PROBLEM-61A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :rewrite rule PROBLEM-61A we reduce the conjecture to

Goal'
(EQUAL (APP (REV X) NIL) (REV X)).

But simplification reduces this to T, using primitive type reasoning
and the :rewrite rules PROBLEM-41 and PROBLEM-44B.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-61 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE PROBLEM-41)
        (:REWRITE PROBLEM-44B)
        (:REWRITE PROBLEM-61A))
PROBLEM-61


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-61))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-61)
PROBLEM-61

Summary
Form:  ( PROGN (DEFTHM PROBLEM-61 ...) ...)
Rules: NIL
 PROBLEM-61
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 62.

; This proof relies on the neat fact that we proved above
; (mapnil1 a (cons nil b)) = (cons nil (mapnil1 a b)).
"
ACL2 !>>(THEOREM PROBLEM-62-DIRECT
                 (EQUAL (MAPNIL1 A NIL) (MAPNIL A))
                 :HINTS (("Goal" :INDUCT (MAPNIL A)
                                 :IN-THEORY (ENABLE PROBLEM-51A))))


ACL2 !>>>(DEFTHM PROBLEM-62-DIRECT
           (EQUAL (MAPNIL1 A NIL) (MAPNIL A))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MAPNIL A)
                           :IN-THEORY (ENABLE PROBLEM-51A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MAPNIL A).

This suggestion was produced using the :induction rule MAPNIL.  If
we let (:P A) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A))
     (IMPLIES (AND (CONSP A) (:P (CDR A)))
              (:P A))).
This induction is justified by the same argument used to admit MAPNIL.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (MAPNIL1 A NIL) (MAPNIL A))).

But simplification reduces this to T, using the :definitions MAPNIL
and MAPNIL1 and the :executable-counterpart of EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (MAPNIL1 (CDR A) NIL)
                     (MAPNIL (CDR A))))
         (EQUAL (MAPNIL1 A NIL) (MAPNIL A))).

This simplifies, using the :definition MAPNIL, to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (EQUAL (MAPNIL1 (CDR A) NIL)
                     (MAPNIL (CDR A))))
         (EQUAL (MAPNIL1 A NIL)
                (CONS NIL (MAPNIL (CDR A))))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal *1/1''
(IMPLIES (AND (CONSP (CONS A1 A2))
              (EQUAL (MAPNIL1 A2 NIL) (MAPNIL A2)))
         (EQUAL (MAPNIL1 (CONS A1 A2) NIL)
                (CONS NIL (MAPNIL A2)))).

But simplification reduces this to T, using the :definition MAPNIL1,
the :executable-counterpart of CONS, primitive type reasoning and the
:rewrite rules CDR-CONS and PROBLEM-51A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-62-DIRECT ...)
Rules: ((:DEFINITION MAPNIL)
        (:DEFINITION MAPNIL1)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MAPNIL)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-51A))
PROBLEM-62-DIRECT


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-62-DIRECT))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-62-DIRECT)
PROBLEM-62-DIRECT

Summary
Form:  ( PROGN (DEFTHM PROBLEM-62-DIRECT ...) ...)
Rules: NIL
 PROBLEM-62-DIRECT
ACL2 !>>:----- 
"
; Generally, a better way to prove theorems like this is to
; generalize the accumulator.  Here is that proof.
  
; Note that the following lemma is the analogue of the neat fact
; mentioned above.
"
ACL2 !>>(THEOREM PROBLEM-62A
                 (IMPLIES (NILS A)
                          (EQUAL (APP A (CONS NIL B))
                                 (CONS NIL (APP A B))))
                 :HINTS (("Goal" :INDUCT (APP A B))))


ACL2 !>>>(DEFTHM PROBLEM-62A
           (IMPLIES (NILS A)
                    (EQUAL (APP A (CONS NIL B))
                           (CONS NIL (APP A B))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP A B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B))
              (:P A B))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (IMPLIES (NILS A)
                  (EQUAL (APP A (CONS NIL B))
                         (CONS NIL (APP A B))))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP A)) (NILS A))
         (EQUAL (APP A (CONS NIL B))
                (CONS NIL (APP A B)))).

But simplification reduces this to T, using the :definitions APP and
NILS, the :executable-counterpart of CONSP and primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (IMPLIES (NILS (CDR A))
                       (EQUAL (APP (CDR A) (CONS NIL B))
                              (CONS NIL (APP (CDR A) B)))))
         (IMPLIES (NILS A)
                  (EQUAL (APP A (CONS NIL B))
                         (CONS NIL (APP A B))))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (IMPLIES (NILS (CDR A))
                       (EQUAL (APP (CDR A) (CONS NIL B))
                              (CONS NIL (APP (CDR A) B))))
              (NILS A))
         (EQUAL (APP A (CONS NIL B))
                (CONS NIL (APP A B)))).

But simplification reduces this to T, using the :definitions APP and
NILS and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-62A ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION NILS)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP))
PROBLEM-62A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-62A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-62A)
PROBLEM-62A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-62A ...) ...)
Rules: NIL
 PROBLEM-62A
ACL2 !>>(THEOREM PROBLEM-62B (NILS (MAPNIL A))
                 :HINTS (("Goal" :INDUCT (MAPNIL A))))


ACL2 !>>>(DEFTHM PROBLEM-62B
           (NILS (MAPNIL A))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MAPNIL A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MAPNIL A).

This suggestion was produced using the :induction rule MAPNIL.  If
we let (:P A) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A))
     (IMPLIES (AND (CONSP A) (:P (CDR A)))
              (:P A))).
This induction is justified by the same argument used to admit MAPNIL.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (NILS (MAPNIL A))).

But simplification reduces this to T, using the :definition MAPNIL
and the :executable-counterpart of NILS.

Subgoal *1/1
(IMPLIES (AND (CONSP A) (NILS (MAPNIL (CDR A))))
         (NILS (MAPNIL A))).

But simplification reduces this to T, using the :definitions MAPNIL
and NILS, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rules MAPNIL and NILS.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-62B depends upon the :type-prescription rule
NILS.

Summary
Form:  ( DEFTHM PROBLEM-62B ...)
Rules: ((:DEFINITION MAPNIL)
        (:DEFINITION NILS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NILS)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MAPNIL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION MAPNIL)
        (:TYPE-PRESCRIPTION NILS))
PROBLEM-62B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-62B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-62B)
PROBLEM-62B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-62B ...) ...)
Rules: NIL
 PROBLEM-62B
ACL2 !>>(THEOREM
             PROBLEM-62C
             (EQUAL (MAPNIL1 A B) (APP (MAPNIL A) B))
             :HINTS (("Goal" :INDUCT (MAPNIL1 A B)
                             :IN-THEORY (ENABLE PROBLEM-62A PROBLEM-62B))))


ACL2 !>>>(DEFTHM PROBLEM-62C
           (EQUAL (MAPNIL1 A B) (APP (MAPNIL A) B))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MAPNIL1 A B)
                           :IN-THEORY (ENABLE PROBLEM-62A PROBLEM-62B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MAPNIL1 A B).

This suggestion was produced using the :induction rule MAPNIL1.  If
we let (:P A B) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A)
                   (:P (CDR A) (CONS NIL B)))
              (:P A B))).
This induction is justified by the same argument used to admit MAPNIL1.
Note, however, that the unmeasured variable B is being instantiated.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (MAPNIL1 A B)
                (APP (MAPNIL A) B))).

But simplification reduces this to T, using the :definitions APP, MAPNIL
and MAPNIL1, the :executable-counterpart of CONSP and primitive type
reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (MAPNIL1 (CDR A) (CONS NIL B))
                     (APP (MAPNIL (CDR A)) (CONS NIL B))))
         (EQUAL (MAPNIL1 A B)
                (APP (MAPNIL A) B))).

But simplification reduces this to T, using the :definitions APP, MAPNIL
and MAPNIL1, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, PROBLEM-62A and PROBLEM-62B and the :type-prescription rule
MAPNIL.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-62C ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION MAPNIL)
        (:DEFINITION MAPNIL1)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MAPNIL1)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-62A)
        (:REWRITE PROBLEM-62B)
        (:TYPE-PRESCRIPTION MAPNIL))
PROBLEM-62C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-62C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-62C)
PROBLEM-62C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-62C ...) ...)
Rules: NIL
 PROBLEM-62C
ACL2 !>>(THEOREM PROBLEM-62D (PROPER (MAPNIL A))
                 :HINTS (("Goal" :INDUCT (MAPNIL A))))


ACL2 !>>>(DEFTHM PROBLEM-62D
           (PROPER (MAPNIL A))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MAPNIL A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MAPNIL A).

This suggestion was produced using the :induction rule MAPNIL.  If
we let (:P A) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A))
     (IMPLIES (AND (CONSP A) (:P (CDR A)))
              (:P A))).
This induction is justified by the same argument used to admit MAPNIL.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (PROPER (MAPNIL A))).

But simplification reduces this to T, using the :definition MAPNIL
and the :executable-counterpart of PROPER.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (PROPER (MAPNIL (CDR A))))
         (PROPER (MAPNIL A))).

But simplification reduces this to T, using the :definitions MAPNIL
and PROPER, primitive type reasoning, the :rewrite rule CDR-CONS and
the :type-prescription rules MAPNIL and PROPER.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-62D depends upon the :type-prescription rule
PROPER.

Summary
Form:  ( DEFTHM PROBLEM-62D ...)
Rules: ((:DEFINITION MAPNIL)
        (:DEFINITION PROPER)
        (:EXECUTABLE-COUNTERPART PROPER)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MAPNIL)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION MAPNIL)
        (:TYPE-PRESCRIPTION PROPER))
PROBLEM-62D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-62D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-62D)
PROBLEM-62D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-62D ...) ...)
Rules: NIL
 PROBLEM-62D
ACL2 !>>(THEOREM
           PROBLEM-62
           (EQUAL (MAPNIL1 A NIL) (MAPNIL A))
           :HINTS
           (("Goal" :IN-THEORY (ENABLE PROBLEM-41 PROBLEM-62C PROBLEM-62D))))


ACL2 !>>>(DEFTHM PROBLEM-62
           (EQUAL (MAPNIL1 A NIL) (MAPNIL A))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :IN-THEORY (ENABLE PROBLEM-41 PROBLEM-62C PROBLEM-62D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :rewrite rule PROBLEM-62C we reduce the conjecture to

Goal'
(EQUAL (APP (MAPNIL A) NIL) (MAPNIL A)).

But simplification reduces this to T, using primitive type reasoning
and the :rewrite rules PROBLEM-41 and PROBLEM-62D.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-62 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE PROBLEM-41)
        (:REWRITE PROBLEM-62C)
        (:REWRITE PROBLEM-62D))
PROBLEM-62


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-62))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-62)
PROBLEM-62

Summary
Form:  ( PROGN (DEFTHM PROBLEM-62 ...) ...)
Rules: NIL
 PROBLEM-62
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 63.

; Theorem. x /= (cons x y)

; This fact is built into ACL2 so its proof is not enlightening.  But
; here a primitive proof and it is enlightening because it requires
; induction.

; Proof.  Induction on x.  

; Base Case:  
; (implies (not (consp x))
;          (not (equal x (cons x y))))
; Trivial, since the contrapositive is true by Axiom 7 and equality.

; Induction Step:
; (implies (and (consp x)
;               (not (equal (car x) (cons (car x) (cdr x)))))
;          (not (equal x (cons x y))))

; Note the unusual choice of induction hypothesis.  We replaced x
; by (car x) and y by (cdr x).
         
; So, given (consp x) and Axiom 11, the induction hypothesis becomes

;                (not (equal (car x) x))

; Now suppose the conclusion is false.  That is, suppose
; x = (cons x y).  Then take the car of both sides and we get
; (car x) = x.  Which is contradicted by the induction hypothesis.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 64.
"
ACL2 !>>(DEFUN MCFLATTEN (X A)
          (IF (CONSP X)
              (MCFLATTEN (CAR X)
                         (MCFLATTEN (CDR X) A))
            (CONS X A)))

The admission of MCFLATTEN is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We observe that the type of MCFLATTEN is described
by the theorem (CONSP (MCFLATTEN X A)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN MCFLATTEN ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 MCFLATTEN
ACL2 !>>(THEOREM PROBLEM-64A
                 (EQUAL (MCFLATTEN X A)
                        (APP (FLATTEN X) A))
                 :HINTS (("Goal" :INDUCT (MCFLATTEN X A)
                                 :IN-THEORY (ENABLE PROBLEM-40))))


ACL2 !>>>(DEFTHM PROBLEM-64A
           (EQUAL (MCFLATTEN X A)
                  (APP (FLATTEN X) A))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MCFLATTEN X A)
                           :IN-THEORY (ENABLE PROBLEM-40))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MCFLATTEN X A).

This suggestion was produced using the :induction rule MCFLATTEN. 
If we let (:P A X) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (NOT (CONSP X)) (:P A X))
     (IMPLIES (AND (CONSP X)
                   (:P (MCFLATTEN (CDR X) A) (CAR X))
                   (:P A (CDR X)))
              (:P A X))).
This induction is justified by the same argument used to admit MCFLATTEN.
Note, however, that the unmeasured variable A is being instantiated.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (MCFLATTEN X A)
                (APP (FLATTEN X) A))).

But simplification reduces this to T, using the :definitions APP, FLATTEN
and MCFLATTEN, the :executable-counterpart of CONSP, primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (MCFLATTEN (CAR X)
                                (MCFLATTEN (CDR X) A))
                     (APP (FLATTEN (CAR X))
                          (MCFLATTEN (CDR X) A)))
              (EQUAL (MCFLATTEN (CDR X) A)
                     (APP (FLATTEN (CDR X)) A)))
         (EQUAL (MCFLATTEN X A)
                (APP (FLATTEN X) A))).

But simplification reduces this to T, using the :definitions FLATTEN
and MCFLATTEN, primitive type reasoning and the :rewrite rule PROBLEM-40.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-64A ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION FLATTEN)
        (:DEFINITION MCFLATTEN)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MCFLATTEN)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-40))
PROBLEM-64A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-64A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-64A)
PROBLEM-64A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-64A ...) ...)
Rules: NIL
 PROBLEM-64A
ACL2 !>>(THEOREM PROBLEM-64B (PROPER (FLATTEN X))
                 :HINTS (("Goal" :INDUCT (FLATTEN X)
                                 :IN-THEORY (ENABLE PROBLEM-44C))))


ACL2 !>>>(DEFTHM PROBLEM-64B
           (PROPER (FLATTEN X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FLATTEN X)
                           :IN-THEORY (ENABLE PROBLEM-44C))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FLATTEN X).

This suggestion was produced using the :induction rule FLATTEN.  If
we let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X)
                   (:P (CAR X))
                   (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit FLATTEN.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (PROPER (FLATTEN X))).

But simplification reduces this to T, using the :definitions FLATTEN
and PROPER, the :executable-counterpart of PROPER, primitive type reasoning
and the :rewrite rule CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (PROPER (FLATTEN (CAR X)))
              (PROPER (FLATTEN (CDR X))))
         (PROPER (FLATTEN X))).

But simplification reduces this to T, using the :definition FLATTEN,
the :rewrite rule PROBLEM-44C and the :type-prescription rule PROPER.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-64B depends upon the :type-prescription rule
PROPER.

Summary
Form:  ( DEFTHM PROBLEM-64B ...)
Rules: ((:DEFINITION FLATTEN)
        (:DEFINITION PROPER)
        (:EXECUTABLE-COUNTERPART PROPER)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FLATTEN)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-44C)
        (:TYPE-PRESCRIPTION PROPER))
PROBLEM-64B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-64B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-64B)
PROBLEM-64B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-64B ...) ...)
Rules: NIL
 PROBLEM-64B
ACL2 !>>(THEOREM
           PROBLEM-64
           (EQUAL (MCFLATTEN X NIL) (FLATTEN X))
           :HINTS
           (("Goal" :IN-THEORY (ENABLE PROBLEM-41 PROBLEM-64A PROBLEM-64B))))


ACL2 !>>>(DEFTHM PROBLEM-64
           (EQUAL (MCFLATTEN X NIL) (FLATTEN X))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :IN-THEORY (ENABLE PROBLEM-41 PROBLEM-64A PROBLEM-64B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :rewrite rule PROBLEM-64A we reduce the conjecture to

Goal'
(EQUAL (APP (FLATTEN X) NIL)
       (FLATTEN X)).

But simplification reduces this to T, using primitive type reasoning
and the :rewrite rules PROBLEM-41 and PROBLEM-64B.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-64 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE PROBLEM-41)
        (:REWRITE PROBLEM-64A)
        (:REWRITE PROBLEM-64B))
PROBLEM-64


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-64))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-64)
PROBLEM-64

Summary
Form:  ( PROGN (DEFTHM PROBLEM-64 ...) ...)
Rules: NIL
 PROBLEM-64
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 65.
"
ACL2 !>>(DEFUN NAT (X)
          (IF (CONSP X)
              (AND (EQUAL (CAR X) NIL) (NAT (CDR X)))
            (EQUAL X NIL)))

The admission of NAT is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of NAT is described by the
theorem (OR (EQUAL (NAT X) T) (EQUAL (NAT X) NIL)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN NAT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 NAT
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 66.
"
ACL2 !>>(DEFUN FIX-NAT (X)
          (IF (CONSP X)
              (CONS NIL (FIX-NAT (CDR X)))
            NIL))

The admission of FIX-NAT is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of FIX-NAT is described by
the theorem (TRUE-LISTP (FIX-NAT X)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN FIX-NAT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 FIX-NAT
ACL2 !>>:----- "
; It is useful to know
"
ACL2 !>>(THEOREM PROBLEM-66A (NAT (FIX-NAT X))
                 :HINTS (("Goal" :INDUCT (FIX-NAT X))))


ACL2 !>>>(DEFTHM PROBLEM-66A
           (NAT (FIX-NAT X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FIX-NAT X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FIX-NAT X).

This suggestion was produced using the :induction rule FIX-NAT.  If
we let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit FIX-NAT.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (NAT (FIX-NAT X))).

But simplification reduces this to T, using the :definition FIX-NAT
and the :executable-counterpart of NAT.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (NAT (FIX-NAT (CDR X))))
         (NAT (FIX-NAT X))).

But simplification reduces this to T, using the :definitions FIX-NAT
and NAT, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rules FIX-NAT and NAT.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-66A depends upon the :type-prescription rule
NAT.

Summary
Form:  ( DEFTHM PROBLEM-66A ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION NAT)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NAT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FIX-NAT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FIX-NAT)
        (:TYPE-PRESCRIPTION NAT))
PROBLEM-66A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-66A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-66A)
PROBLEM-66A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-66A ...) ...)
Rules: NIL
 PROBLEM-66A
ACL2 !>>(THEOREM PROBLEM-66B
                 (IMPLIES (NAT X) (EQUAL (FIX-NAT X) X))
                 :HINTS (("Goal" :INDUCT (NAT X))))


ACL2 !>>>(DEFTHM PROBLEM-66B
           (IMPLIES (NAT X) (EQUAL (FIX-NAT X) X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (NAT X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (NAT X).

This suggestion was produced using the :induction rule NAT.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (CAR X)) (:P X))
     (IMPLIES (AND (CONSP X)
                   (NOT (CAR X))
                   (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit NAT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (NAT X)
                  (EQUAL (FIX-NAT X) X))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (NAT X))
         (EQUAL (FIX-NAT X) X)).

But simplification reduces this to T, using the :definition NAT, the
:executable-counterparts of CONSP, EQUAL and FIX-NAT and primitive
type reasoning.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (CAR X))
         (IMPLIES (NAT X)
                  (EQUAL (FIX-NAT X) X))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X) (CAR X) (NAT X))
         (EQUAL (FIX-NAT X) X)).

But simplification reduces this to T, using the :definition NAT and
primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (IMPLIES (NAT (CDR X))
                       (EQUAL (FIX-NAT (CDR X)) (CDR X))))
         (IMPLIES (NAT X)
                  (EQUAL (FIX-NAT X) X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (IMPLIES (NAT (CDR X))
                       (EQUAL (FIX-NAT (CDR X)) (CDR X)))
              (NAT X))
         (EQUAL (FIX-NAT X) X)).

But simplification reduces this to T, using the :definitions FIX-NAT
and NAT, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule FIX-NAT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-66B ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION NAT)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART FIX-NAT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION NAT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FIX-NAT))
PROBLEM-66B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-66B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-66B)
PROBLEM-66B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-66B ...) ...)
Rules: NIL
 PROBLEM-66B
ACL2 !>>(DEFUN PLUS (X Y)
          (IF (CONSP X)
              (CONS NIL (PLUS (CDR X) Y))
            (FIX-NAT Y)))

The admission of PLUS is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of PLUS is described by the
theorem (TRUE-LISTP (PLUS X Y)).  We used primitive type reasoning
and the :type-prescription rule FIX-NAT.

Summary
Form:  ( DEFUN PLUS ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION FIX-NAT))
 PLUS
ACL2 !>>(THEOREM PROBLEM-66C (NAT (PLUS X Y))
                 :HINTS (("Goal" :INDUCT (PLUS X Y)
                                 :IN-THEORY (ENABLE PROBLEM-66A))))


ACL2 !>>>(DEFTHM PROBLEM-66C
           (NAT (PLUS X Y))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PLUS X Y)
                           :IN-THEORY (ENABLE PROBLEM-66A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS X Y).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P X Y) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X Y))
     (IMPLIES (AND (CONSP X) (:P (CDR X) Y))
              (:P X Y))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (NAT (PLUS X Y))).

But simplification reduces this to T, using the :definition PLUS and
the :rewrite rule PROBLEM-66A.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (NAT (PLUS (CDR X) Y)))
         (NAT (PLUS X Y))).

But simplification reduces this to T, using the :definitions NAT and
PLUS, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rules NAT and PLUS.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-66C depends upon the :type-prescription rule
NAT.

Summary
Form:  ( DEFTHM PROBLEM-66C ...)
Rules: ((:DEFINITION NAT)
        (:DEFINITION PLUS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-66A)
        (:TYPE-PRESCRIPTION NAT)
        (:TYPE-PRESCRIPTION PLUS))
PROBLEM-66C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-66C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-66C)
PROBLEM-66C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-66C ...) ...)
Rules: NIL
 PROBLEM-66C
ACL2 !>>(THEOREM PROBLEM-66D
                 (EQUAL (PLUS (FIX-NAT I) J) (PLUS I J))
                 :HINTS (("Goal" :INDUCT (PLUS I J))))


ACL2 !>>>(DEFTHM PROBLEM-66D
           (EQUAL (PLUS (FIX-NAT I) J) (PLUS I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PLUS I J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS I J).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J))
              (:P I J))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (PLUS (FIX-NAT I) J)
                (PLUS I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and PLUS, the :executable-counterpart of CONSP and primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (PLUS (FIX-NAT (CDR I)) J)
                     (PLUS (CDR I) J)))
         (EQUAL (PLUS (FIX-NAT I) J)
                (PLUS I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and PLUS, primitive type reasoning, the :rewrite rule CDR-CONS and
the :type-prescription rule FIX-NAT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-66D ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION PLUS)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FIX-NAT))
PROBLEM-66D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-66D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-66D)
PROBLEM-66D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-66D ...) ...)
Rules: NIL
 PROBLEM-66D
ACL2 !>>(THEOREM
             PROBLEM-66E
             (EQUAL (PLUS I (FIX-NAT J)) (PLUS I J))
             :HINTS (("Goal" :INDUCT (PLUS I J)
                             :IN-THEORY (ENABLE PROBLEM-66A PROBLEM-66B))))


ACL2 !>>>(DEFTHM PROBLEM-66E
           (EQUAL (PLUS I (FIX-NAT J)) (PLUS I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PLUS I J)
                           :IN-THEORY (ENABLE PROBLEM-66A PROBLEM-66B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS I J).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J))
              (:P I J))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (PLUS I (FIX-NAT J))
                (PLUS I J))).

But simplification reduces this to T, using the :definition PLUS, primitive
type reasoning and the :rewrite rules PROBLEM-66A and PROBLEM-66B.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (PLUS (CDR I) (FIX-NAT J))
                     (PLUS (CDR I) J)))
         (EQUAL (PLUS I (FIX-NAT J))
                (PLUS I J))).

But simplification reduces this to T, using the :definition PLUS and
primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-66E ...)
Rules: ((:DEFINITION PLUS)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS)
        (:REWRITE PROBLEM-66A)
        (:REWRITE PROBLEM-66B))
PROBLEM-66E


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-66E))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-66E)
PROBLEM-66E

Summary
Form:  ( PROGN (DEFTHM PROBLEM-66E ...) ...)
Rules: NIL
 PROBLEM-66E
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 67.
"
ACL2 !>>(DEFUN TIMES (X Y)
          (IF (CONSP X)
              (PLUS Y (TIMES (CDR X) Y))
            NIL))

The admission of TIMES is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of TIMES is described by
the theorem (TRUE-LISTP (TIMES X Y)).  We used the :type-prescription
rule PLUS.

Summary
Form:  ( DEFUN TIMES ...)
Rules: ((:TYPE-PRESCRIPTION PLUS))
 TIMES
ACL2 !>>(THEOREM PROBLEM-67A (NAT (TIMES X Y))
                 :HINTS (("Goal" :INDUCT (TIMES X Y)
                                 :IN-THEORY (ENABLE PROBLEM-66C))))


ACL2 !>>>(DEFTHM PROBLEM-67A
           (NAT (TIMES X Y))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TIMES X Y)
                           :IN-THEORY (ENABLE PROBLEM-66C))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES X Y).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P X Y) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X Y))
     (IMPLIES (AND (CONSP X) (:P (CDR X) Y))
              (:P X Y))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (NAT (TIMES X Y))).

But simplification reduces this to T, using the :definition TIMES and
the :executable-counterpart of NAT.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (NAT (TIMES (CDR X) Y)))
         (NAT (TIMES X Y))).

But simplification reduces this to T, using the :definition TIMES and
the :rewrite rule PROBLEM-66C.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-67A depends upon the :type-prescription rule
NAT.

Summary
Form:  ( DEFTHM PROBLEM-67A ...)
Rules: ((:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART NAT)
        (:INDUCTION TIMES)
        (:REWRITE PROBLEM-66C)
        (:TYPE-PRESCRIPTION NAT))
PROBLEM-67A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-67A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-67A)
PROBLEM-67A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-67A ...) ...)
Rules: NIL
 PROBLEM-67A
ACL2 !>>(THEOREM PROBLEM-67B
                 (EQUAL (TIMES (FIX-NAT I) J)
                        (TIMES I J))
                 :HINTS (("Goal" :INDUCT (TIMES I J))))


ACL2 !>>>(DEFTHM PROBLEM-67B
           (EQUAL (TIMES (FIX-NAT I) J)
                  (TIMES I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TIMES I J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I J).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J))
              (:P I J))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (TIMES (FIX-NAT I) J)
                (TIMES I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and TIMES and the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (FIX-NAT (CDR I)) J)
                     (TIMES (CDR I) J)))
         (EQUAL (TIMES (FIX-NAT I) J)
                (TIMES I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and TIMES, primitive type reasoning, the :rewrite rule CDR-CONS and
the :type-prescription rule FIX-NAT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-67B ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FIX-NAT))
PROBLEM-67B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-67B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-67B)
PROBLEM-67B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-67B ...) ...)
Rules: NIL
 PROBLEM-67B
ACL2 !>>(THEOREM PROBLEM-67C
                 (EQUAL (TIMES I (FIX-NAT J))
                        (TIMES I J))
                 :HINTS (("Goal" :INDUCT (TIMES I J)
                                 :IN-THEORY (ENABLE PROBLEM-66D))))


ACL2 !>>>(DEFTHM PROBLEM-67C
           (EQUAL (TIMES I (FIX-NAT J))
                  (TIMES I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TIMES I J)
                           :IN-THEORY (ENABLE PROBLEM-66D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I J).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J))
              (:P I J))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (TIMES I (FIX-NAT J))
                (TIMES I J))).

But simplification reduces this to T, using the :definition TIMES and
the :executable-counterpart of EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (CDR I) (FIX-NAT J))
                     (TIMES (CDR I) J)))
         (EQUAL (TIMES I (FIX-NAT J))
                (TIMES I J))).

But simplification reduces this to T, using the :definition TIMES,
primitive type reasoning and the :rewrite rule PROBLEM-66D.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-67C ...)
Rules: ((:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE PROBLEM-66D))
PROBLEM-67C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-67C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-67C)
PROBLEM-67C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-67C ...) ...)
Rules: NIL
 PROBLEM-67C
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 68.
"
ACL2 !>>(DEFUN POWER (X Y)
          (IF (CONSP Y)
              (TIMES X (POWER X (CDR Y)))
            '(NIL)))

The admission of POWER is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT Y).  We observe that the type of POWER is described by
the theorem (TRUE-LISTP (POWER X Y)).  We used the :type-prescription
rule TIMES.

Summary
Form:  ( DEFUN POWER ...)
Rules: ((:TYPE-PRESCRIPTION TIMES))
 POWER
ACL2 !>>(THEOREM PROBLEM-68A (NAT (POWER X Y))
                 :HINTS (("Goal" :INDUCT (POWER X Y)
                                 :IN-THEORY (ENABLE PROBLEM-67A))))


ACL2 !>>>(DEFTHM PROBLEM-68A
           (NAT (POWER X Y))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (POWER X Y)
                           :IN-THEORY (ENABLE PROBLEM-67A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (POWER X Y).

This suggestion was produced using the :induction rule POWER.  If we
let (:P X Y) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP Y)) (:P X Y))
     (IMPLIES (AND (CONSP Y) (:P X (CDR Y)))
              (:P X Y))).
This induction is justified by the same argument used to admit POWER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP Y))
         (NAT (POWER X Y))).

But simplification reduces this to T, using the :definition POWER and
the :executable-counterpart of NAT.

Subgoal *1/1
(IMPLIES (AND (CONSP Y) (NAT (POWER X (CDR Y))))
         (NAT (POWER X Y))).

But simplification reduces this to T, using the :definition POWER and
the :rewrite rule PROBLEM-67A.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-68A depends upon the :type-prescription rule
NAT.

Summary
Form:  ( DEFTHM PROBLEM-68A ...)
Rules: ((:DEFINITION POWER)
        (:EXECUTABLE-COUNTERPART NAT)
        (:INDUCTION POWER)
        (:REWRITE PROBLEM-67A)
        (:TYPE-PRESCRIPTION NAT))
PROBLEM-68A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-68A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-68A)
PROBLEM-68A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-68A ...) ...)
Rules: NIL
 PROBLEM-68A
ACL2 !>>(THEOREM PROBLEM-68B
                 (EQUAL (POWER (FIX-NAT I) J)
                        (POWER I J))
                 :HINTS (("Goal" :INDUCT (POWER I J)
                                 :IN-THEORY (ENABLE PROBLEM-67B))))


ACL2 !>>>(DEFTHM PROBLEM-68B
           (EQUAL (POWER (FIX-NAT I) J)
                  (POWER I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (POWER I J)
                           :IN-THEORY (ENABLE PROBLEM-67B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (POWER I J).

This suggestion was produced using the :induction rule POWER.  If we
let (:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP J)) (:P I J))
     (IMPLIES (AND (CONSP J) (:P I (CDR J)))
              (:P I J))).
This induction is justified by the same argument used to admit POWER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP J))
         (EQUAL (POWER (FIX-NAT I) J)
                (POWER I J))).

But simplification reduces this to T, using the :definition POWER and
the :executable-counterpart of EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP J)
              (EQUAL (POWER (FIX-NAT I) (CDR J))
                     (POWER I (CDR J))))
         (EQUAL (POWER (FIX-NAT I) J)
                (POWER I J))).

But simplification reduces this to T, using the :definition POWER,
primitive type reasoning and the :rewrite rule PROBLEM-67B.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-68B ...)
Rules: ((:DEFINITION POWER)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION POWER)
        (:REWRITE PROBLEM-67B))
PROBLEM-68B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-68B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-68B)
PROBLEM-68B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-68B ...) ...)
Rules: NIL
 PROBLEM-68B
ACL2 !>>(THEOREM PROBLEM-68C
                 (EQUAL (POWER I (FIX-NAT J))
                        (POWER I J))
                 :HINTS (("Goal" :INDUCT (POWER I J))))


ACL2 !>>>(DEFTHM PROBLEM-68C
           (EQUAL (POWER I (FIX-NAT J))
                  (POWER I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (POWER I J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (POWER I J).

This suggestion was produced using the :induction rule POWER.  If we
let (:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP J)) (:P I J))
     (IMPLIES (AND (CONSP J) (:P I (CDR J)))
              (:P I J))).
This induction is justified by the same argument used to admit POWER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP J))
         (EQUAL (POWER I (FIX-NAT J))
                (POWER I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and POWER and the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP J)
              (EQUAL (POWER I (FIX-NAT (CDR J)))
                     (POWER I (CDR J))))
         (EQUAL (POWER I (FIX-NAT J))
                (POWER I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and POWER, primitive type reasoning, the :rewrite rule CDR-CONS and
the :type-prescription rule FIX-NAT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-68C ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION POWER)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION POWER)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FIX-NAT))
PROBLEM-68C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-68C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-68C)
PROBLEM-68C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-68C ...) ...)
Rules: NIL
 PROBLEM-68C
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 69.
"
ACL2 !>>(DEFUN LESSEQP (X Y)
          (IF (CONSP X)
              (IF (CONSP Y)
                  (LESSEQP (CDR X) (CDR Y))
                NIL)
            T))

The admission of LESSEQP is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of LESSEQP is described by
the theorem (OR (EQUAL (LESSEQP X Y) T) (EQUAL (LESSEQP X Y) NIL)).

Summary
Form:  ( DEFUN LESSEQP ...)
Rules: NIL
 LESSEQP
ACL2 !>>(THEOREM PROBLEM-69A
                 (EQUAL (LESSEQP (FIX-NAT I) J)
                        (LESSEQP I J))
                 :HINTS (("Goal" :INDUCT (LIST (FIX-NAT I) (LESSEQP I J)))))


ACL2 !>>>(DEFTHM PROBLEM-69A
           (EQUAL (LESSEQP (FIX-NAT I) J)
                  (LESSEQP I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LIST (FIX-NAT I) (LESSEQP I J)))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  Two induction schemes are suggested
by the induction hint.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (LESSEQP I J).

This suggestion was produced using the :induction rules FIX-NAT and
LESSEQP.  If we let (:P I J) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (NOT (CONSP J)))
              (:P I J))
     (IMPLIES (AND (CONSP I)
                   (CONSP J)
                   (:P (CDR I) (CDR J)))
              (:P I J))).
This induction is justified by the same argument used to admit LESSEQP.
Note, however, that the unmeasured variable J is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP I))
         (EQUAL (LESSEQP (FIX-NAT I) J)
                (LESSEQP I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and LESSEQP and the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP I) (NOT (CONSP J)))
         (EQUAL (LESSEQP (FIX-NAT I) J)
                (LESSEQP I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and LESSEQP, the :executable-counterpart of EQUAL, primitive type reasoning
and the :type-prescription rule FIX-NAT.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (CONSP J)
              (EQUAL (LESSEQP (FIX-NAT (CDR I)) (CDR J))
                     (LESSEQP (CDR I) (CDR J))))
         (EQUAL (LESSEQP (FIX-NAT I) J)
                (LESSEQP I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and LESSEQP, primitive type reasoning, the :rewrite rule CDR-CONS and
the :type-prescription rule FIX-NAT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-69A ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION LESSEQP)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FIX-NAT)
        (:INDUCTION LESSEQP)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FIX-NAT))
PROBLEM-69A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-69A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-69A)
PROBLEM-69A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-69A ...) ...)
Rules: NIL
 PROBLEM-69A
ACL2 !>>:----- 
"
; Note: I included (fix-nat i) in the :induct hint above because it
; forces the theorem prover to expand (fix-nat i) in the conclusion of
; the induction step.
"
ACL2 !>>(THEOREM PROBLEM-69B
                 (EQUAL (LESSEQP I (FIX-NAT J))
                        (LESSEQP I J))
                 :HINTS (("Goal" :INDUCT (LESSEQP I J))))


ACL2 !>>>(DEFTHM PROBLEM-69B
           (EQUAL (LESSEQP I (FIX-NAT J))
                  (LESSEQP I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LESSEQP I J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LESSEQP I J).

This suggestion was produced using the :induction rule LESSEQP.  If
we let (:P I J) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (NOT (CONSP J)))
              (:P I J))
     (IMPLIES (AND (CONSP I)
                   (CONSP J)
                   (:P (CDR I) (CDR J)))
              (:P I J))).
This induction is justified by the same argument used to admit LESSEQP.
Note, however, that the unmeasured variable J is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP I))
         (EQUAL (LESSEQP I (FIX-NAT J))
                (LESSEQP I J))).

But simplification reduces this to T, using the :definition LESSEQP
and the :executable-counterpart of EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP I) (NOT (CONSP J)))
         (EQUAL (LESSEQP I (FIX-NAT J))
                (LESSEQP I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and LESSEQP and the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (CONSP J)
              (EQUAL (LESSEQP (CDR I) (FIX-NAT (CDR J)))
                     (LESSEQP (CDR I) (CDR J))))
         (EQUAL (LESSEQP I (FIX-NAT J))
                (LESSEQP I J))).

But simplification reduces this to T, using the :definitions FIX-NAT
and LESSEQP, primitive type reasoning, the :rewrite rule CDR-CONS and
the :type-prescription rule FIX-NAT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-69B ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION LESSEQP)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LESSEQP)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FIX-NAT))
PROBLEM-69B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-69B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-69B)
PROBLEM-69B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-69B ...) ...)
Rules: NIL
 PROBLEM-69B
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 70.
"
ACL2 !>>(DEFUN EVENNAT (X)
          (IF (CONSP X)
              (IF (CONSP (CDR X))
                  (EVENNAT (CDR (CDR X)))
                NIL)
            T))

For the admission of EVENNAT we will use the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  The non-trivial part of the measure conjecture is

Goal
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (ACL2-COUNT (CDDR X))
             (ACL2-COUNT X))).

By case analysis we reduce the conjecture to

Goal'
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (ACL2-COUNT (CDDR X))
             (ACL2-COUNT X))).

This simplifies, using the :definitions O-FINP and O< and the :type-
prescription rule ACL2-COUNT, to

Goal''
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (< (ACL2-COUNT (CDDR X))
            (ACL2-COUNT X))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule ACL2-COUNT-CAR-CDR-LINEAR and the
:type-prescription rule ACL2-COUNT.

Q.E.D.

That completes the proof of the measure theorem for EVENNAT.  Thus,
we admit this function under the principle of definition.  We observe
that the type of EVENNAT is described by the theorem 
(OR (EQUAL (EVENNAT X) T) (EQUAL (EVENNAT X) NIL)).  

Summary
Form:  ( DEFUN EVENNAT ...)
Rules: ((:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O<)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR ACL2-COUNT-CAR-CDR-LINEAR)
        (:TYPE-PRESCRIPTION ACL2-COUNT))
 EVENNAT
ACL2 !>>(THEOREM PROBLEM-70A
                 (EQUAL (EVENNAT (FIX-NAT I))
                        (EVENNAT I))
                 :HINTS (("Goal" :INDUCT (EVENNAT I))))


ACL2 !>>>(DEFTHM PROBLEM-70A
           (EQUAL (EVENNAT (FIX-NAT I))
                  (EVENNAT I))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (EVENNAT I))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (EVENNAT I).

This suggestion was produced using the :induction rule EVENNAT.  If
we let (:P I) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I))
     (IMPLIES (AND (CONSP I) (NOT (CONSP (CDR I))))
              (:P I))
     (IMPLIES (AND (CONSP I)
                   (CONSP (CDR I))
                   (:P (CDDR I)))
              (:P I))).
This induction is justified by the same argument used to admit EVENNAT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP I))
         (EQUAL (EVENNAT (FIX-NAT I))
                (EVENNAT I))).

But simplification reduces this to T, using the :definitions EVENNAT
and FIX-NAT and the :executable-counterparts of EQUAL and EVENNAT.

Subgoal *1/2
(IMPLIES (AND (CONSP I) (NOT (CONSP (CDR I))))
         (EQUAL (EVENNAT (FIX-NAT I))
                (EVENNAT I))).

But simplification reduces this to T, using the :definitions EVENNAT
and FIX-NAT and the :executable-counterparts of CONS, EQUAL and EVENNAT.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (CONSP (CDR I))
              (EQUAL (EVENNAT (FIX-NAT (CDDR I)))
                     (EVENNAT (CDDR I))))
         (EQUAL (EVENNAT (FIX-NAT I))
                (EVENNAT I))).

But simplification reduces this to T, using the :definitions EVENNAT
and FIX-NAT, primitive type reasoning, the :rewrite rule CDR-CONS and
the :type-prescription rule FIX-NAT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-70A ...)
Rules: ((:DEFINITION EVENNAT)
        (:DEFINITION FIX-NAT)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART EVENNAT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION EVENNAT)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FIX-NAT))
PROBLEM-70A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-70A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-70A)
PROBLEM-70A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-70A ...) ...)
Rules: NIL
 PROBLEM-70A
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 71.

; We start with a general 0-identity for plus.
"
ACL2 !>>(THEOREM PROBLEM-71A
                 (IMPLIES (NOT (CONSP Z))
                          (EQUAL (PLUS I Z) (FIX-NAT I)))
                 :HINTS (("Goal" :INDUCT (PLUS I Z))))


ACL2 !>>>(DEFTHM PROBLEM-71A
           (IMPLIES (NOT (CONSP Z))
                    (EQUAL (PLUS I Z) (FIX-NAT I)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PLUS I Z))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS I Z).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P I Z) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I Z))
     (IMPLIES (AND (CONSP I) (:P (CDR I) Z))
              (:P I Z))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (IMPLIES (NOT (CONSP Z))
                  (EQUAL (PLUS I Z) (FIX-NAT I)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP I)) (NOT (CONSP Z)))
         (EQUAL (PLUS I Z) (FIX-NAT I))).

But simplification reduces this to T, using the :definitions FIX-NAT
and PLUS and the :executable-counterpart of EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (IMPLIES (NOT (CONSP Z))
                       (EQUAL (PLUS (CDR I) Z)
                              (FIX-NAT (CDR I)))))
         (IMPLIES (NOT (CONSP Z))
                  (EQUAL (PLUS I Z) (FIX-NAT I)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP I)
              (IMPLIES (NOT (CONSP Z))
                       (EQUAL (PLUS (CDR I) Z)
                              (FIX-NAT (CDR I))))
              (NOT (CONSP Z)))
         (EQUAL (PLUS I Z) (FIX-NAT I))).

But simplification reduces this to T, using the :definitions FIX-NAT
and PLUS, the :executable-counterpart of NOT and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-71A ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION NOT)
        (:DEFINITION PLUS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS))
PROBLEM-71A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-71A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-71A)
PROBLEM-71A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-71A ...) ...)
Rules: NIL
 PROBLEM-71A
ACL2 !>>(THEOREM
             PROBLEM-71
             (IMPLIES (NAT I) (EQUAL (PLUS I NIL) I))
             :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-66B PROBLEM-71A))))


ACL2 !>>>(DEFTHM PROBLEM-71
           (IMPLIES (NAT I) (EQUAL (PLUS I NIL) I))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-66B PROBLEM-71A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But simplification reduces this to T, using primitive type reasoning,
the :rewrite rules PROBLEM-66B and PROBLEM-71A and the :type-prescription
rule NAT.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-71 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE PROBLEM-66B)
        (:REWRITE PROBLEM-71A)
        (:TYPE-PRESCRIPTION NAT))
PROBLEM-71


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-71))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-71)
PROBLEM-71

Summary
Form:  ( PROGN (DEFTHM PROBLEM-71 ...) ...)
Rules: NIL
 PROBLEM-71
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 72.
"
ACL2 !>>(THEOREM
          PROBLEM-72
          (EQUAL (PLUS (PLUS I J) K)
                 (PLUS I (PLUS J K)))
          :HINTS
          (("Goal" :INDUCT (PLUS I J)
                   :IN-THEORY (ENABLE PROBLEM-66B PROBLEM-66C PROBLEM-66D))))


ACL2 !>>>(DEFTHM PROBLEM-72
          (EQUAL (PLUS (PLUS I J) K)
                 (PLUS I (PLUS J K)))
          :HINTS
          (("Goal" :DO-NOT-INDUCT T
                   :DO-NOT '(GENERALIZE)
                   :INDUCT (PLUS I J)
                   :IN-THEORY (ENABLE PROBLEM-66B PROBLEM-66C PROBLEM-66D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS I J).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P I J K) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J K))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J K))
              (:P I J K))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (PLUS (PLUS I J) K)
                (PLUS I (PLUS J K)))).

But simplification reduces this to T, using the :definition PLUS, primitive
type reasoning and the :rewrite rules PROBLEM-66B, PROBLEM-66C and
PROBLEM-66D.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (PLUS (PLUS (CDR I) J) K)
                     (PLUS (CDR I) (PLUS J K))))
         (EQUAL (PLUS (PLUS I J) K)
                (PLUS I (PLUS J K)))).

But simplification reduces this to T, using the :definition PLUS, primitive
type reasoning, the :rewrite rule CDR-CONS and the :type-prescription
rule PLUS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-72 ...)
Rules: ((:DEFINITION PLUS)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-66B)
        (:REWRITE PROBLEM-66C)
        (:REWRITE PROBLEM-66D)
        (:TYPE-PRESCRIPTION PLUS))
PROBLEM-72


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-72))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-72)
PROBLEM-72

Summary
Form:  ( PROGN (DEFTHM PROBLEM-72 ...) ...)
Rules: NIL
 PROBLEM-72
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 73.
"
ACL2 !>>(THEOREM PROBLEM-73A
                 (EQUAL (PLUS I (CONS X J))
                        (CONS NIL (PLUS I J)))
                 :HINTS (("Goal" :INDUCT (PLUS I J))))


ACL2 !>>>(DEFTHM PROBLEM-73A
           (EQUAL (PLUS I (CONS X J))
                  (CONS NIL (PLUS I J)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PLUS I J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS I J).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P I J X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J X))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J X))
              (:P I J X))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (PLUS I (CONS X J))
                (CONS NIL (PLUS I J)))).

But simplification reduces this to T, using the :definitions FIX-NAT
and PLUS, primitive type reasoning and the :rewrite rule CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (PLUS (CDR I) (CONS X J))
                     (CONS NIL (PLUS (CDR I) J))))
         (EQUAL (PLUS I (CONS X J))
                (CONS NIL (PLUS I J)))).

But simplification reduces this to T, using the :definition PLUS and
primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-73A ...)
Rules: ((:DEFINITION FIX-NAT)
        (:DEFINITION PLUS)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS)
        (:REWRITE CDR-CONS))
PROBLEM-73A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-73A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-73A)
PROBLEM-73A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-73A ...) ...)
Rules: NIL
 PROBLEM-73A
ACL2 !>>(THEOREM
             PROBLEM-73 (EQUAL (PLUS I J) (PLUS J I))
             :HINTS (("Goal" :INDUCT (PLUS I J)
                             :IN-THEORY (ENABLE PROBLEM-71A PROBLEM-73A))))


ACL2 !>>>(DEFTHM PROBLEM-73
           (EQUAL (PLUS I J) (PLUS J I))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PLUS I J)
                           :IN-THEORY (ENABLE PROBLEM-71A PROBLEM-73A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS I J).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J))
              (:P I J))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (PLUS I J) (PLUS J I))).

But simplification reduces this to T, using the :definition PLUS, primitive
type reasoning and the :rewrite rule PROBLEM-71A.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (PLUS (CDR I) J)
                     (PLUS J (CDR I))))
         (EQUAL (PLUS I J) (PLUS J I))).

This simplifies, using the :definition PLUS, to

Subgoal *1/1'
(IMPLIES (AND (CONSP I)
              (EQUAL (PLUS (CDR I) J)
                     (PLUS J (CDR I))))
         (EQUAL (CONS NIL (PLUS J (CDR I)))
                (PLUS J I))).

The destructor terms (CAR I) and (CDR I) can be eliminated by using
CAR-CDR-ELIM to replace I by (CONS I1 I2), (CAR I) by I1 and (CDR I)
by I2.  This produces the following goal.

Subgoal *1/1''
(IMPLIES (AND (CONSP (CONS I1 I2))
              (EQUAL (PLUS I2 J) (PLUS J I2)))
         (EQUAL (CONS NIL (PLUS J I2))
                (PLUS J (CONS I1 I2)))).

But we reduce the conjecture to T, by the simple :rewrite rule PROBLEM-73A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-73 ...)
Rules: ((:DEFINITION PLUS)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS)
        (:REWRITE PROBLEM-71A)
        (:REWRITE PROBLEM-73A))
PROBLEM-73


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-73))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-73)
PROBLEM-73

Summary
Form:  ( PROGN (DEFTHM PROBLEM-73 ...) ...)
Rules: NIL
 PROBLEM-73
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 74.

; Note that the following lemma is another sense of commutativity
; for plus.
"
ACL2 !>>(THEOREM
          PROBLEM-74A
          (EQUAL (PLUS I (PLUS J K))
                 (PLUS J (PLUS I K)))
          :HINTS
          (("Goal" :INDUCT (PLUS J K)
                   :IN-THEORY (ENABLE PROBLEM-66B
                                      PROBLEM-66C PROBLEM-66E PROBLEM-73A))))


ACL2 !>>>(DEFTHM PROBLEM-74A
          (EQUAL (PLUS I (PLUS J K))
                 (PLUS J (PLUS I K)))
          :HINTS
          (("Goal" :DO-NOT-INDUCT T
                   :DO-NOT '(GENERALIZE)
                   :INDUCT (PLUS J K)
                   :IN-THEORY (ENABLE PROBLEM-66B
                                      PROBLEM-66C PROBLEM-66E PROBLEM-73A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS J K).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P I J K) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP J)) (:P I J K))
     (IMPLIES (AND (CONSP J) (:P I (CDR J) K))
              (:P I J K))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP J))
         (EQUAL (PLUS I (PLUS J K))
                (PLUS J (PLUS I K)))).

But simplification reduces this to T, using the :definition PLUS, primitive
type reasoning and the :rewrite rules PROBLEM-66B, PROBLEM-66C and
PROBLEM-66E.

Subgoal *1/1
(IMPLIES (AND (CONSP J)
              (EQUAL (PLUS I (PLUS (CDR J) K))
                     (PLUS (CDR J) (PLUS I K))))
         (EQUAL (PLUS I (PLUS J K))
                (PLUS J (PLUS I K)))).

But simplification reduces this to T, using the :definition PLUS, primitive
type reasoning and the :rewrite rule PROBLEM-73A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-74A ...)
Rules: ((:DEFINITION PLUS)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS)
        (:REWRITE PROBLEM-66B)
        (:REWRITE PROBLEM-66C)
        (:REWRITE PROBLEM-66E)
        (:REWRITE PROBLEM-73A))
PROBLEM-74A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-74A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-74A)
PROBLEM-74A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-74A ...) ...)
Rules: NIL
 PROBLEM-74A
ACL2 !>>(THEOREM
           PROBLEM-74B
           (EQUAL (TIMES (PLUS I J) K)
                  (PLUS (TIMES I K) (TIMES J K)))
           :HINTS
           (("Goal" :INDUCT (TIMES I K)
                    :IN-THEORY (ENABLE PROBLEM-66B PROBLEM-67A
                                       PROBLEM-67B PROBLEM-73 PROBLEM-74A))))


ACL2 !>>>(DEFTHM PROBLEM-74B
           (EQUAL (TIMES (PLUS I J) K)
                  (PLUS (TIMES I K) (TIMES J K)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (TIMES I K)
                    :IN-THEORY (ENABLE PROBLEM-66B PROBLEM-67A
                                       PROBLEM-67B PROBLEM-73 PROBLEM-74A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I K).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I J K) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J K))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J K))
              (:P I J K))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (TIMES (PLUS I J) K)
                (PLUS (TIMES I K) (TIMES J K)))).

But simplification reduces this to T, using the :definitions PLUS and
TIMES, the :executable-counterpart of CONSP, primitive type reasoning
and the :rewrite rules PROBLEM-66B, PROBLEM-67A and PROBLEM-67B.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (PLUS (CDR I) J) K)
                     (PLUS (TIMES (CDR I) K) (TIMES J K))))
         (EQUAL (TIMES (PLUS I J) K)
                (PLUS (TIMES I K) (TIMES J K)))).

But simplification reduces this to T, using the :definitions PLUS and
TIMES, primitive type reasoning, the :rewrite rules CDR-CONS, PROBLEM-73
and PROBLEM-74A and the :type-prescription rule PLUS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-74B ...)
Rules: ((:DEFINITION PLUS)
        (:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-66B)
        (:REWRITE PROBLEM-67A)
        (:REWRITE PROBLEM-67B)
        (:REWRITE PROBLEM-73)
        (:REWRITE PROBLEM-74A)
        (:TYPE-PRESCRIPTION PLUS))
PROBLEM-74B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-74B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-74B)
PROBLEM-74B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-74B ...) ...)
Rules: NIL
 PROBLEM-74B
ACL2 !>>(THEOREM PROBLEM-74
                 (EQUAL (TIMES (TIMES I J) K)
                        (TIMES I (TIMES J K)))
                 :HINTS (("Goal" :INDUCT (TIMES I J)
                                 :IN-THEORY (ENABLE PROBLEM-74B))))


ACL2 !>>>(DEFTHM PROBLEM-74
           (EQUAL (TIMES (TIMES I J) K)
                  (TIMES I (TIMES J K)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TIMES I J)
                           :IN-THEORY (ENABLE PROBLEM-74B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I J).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I J K) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J K))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J K))
              (:P I J K))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (TIMES (TIMES I J) K)
                (TIMES I (TIMES J K)))).

But simplification reduces this to T, using the :definition TIMES and
the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (TIMES (CDR I) J) K)
                     (TIMES (CDR I) (TIMES J K))))
         (EQUAL (TIMES (TIMES I J) K)
                (TIMES I (TIMES J K)))).

But simplification reduces this to T, using the :definition TIMES,
primitive type reasoning and the :rewrite rule PROBLEM-74B.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-74 ...)
Rules: ((:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE PROBLEM-74B))
PROBLEM-74


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-74))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-74)
PROBLEM-74

Summary
Form:  ( PROGN (DEFTHM PROBLEM-74 ...) ...)
Rules: NIL
 PROBLEM-74
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 75.
"
ACL2 !>>(THEOREM
             PROBLEM-75A
             (IMPLIES (NOT (CONSP Z))
                      (EQUAL (TIMES I Z) NIL))
             :HINTS (("Goal" :INDUCT (TIMES I Z)
                             :IN-THEORY (ENABLE PROBLEM-71A PROBLEM-73))))


ACL2 !>>>(DEFTHM PROBLEM-75A
           (IMPLIES (NOT (CONSP Z))
                    (EQUAL (TIMES I Z) NIL))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TIMES I Z)
                           :IN-THEORY (ENABLE PROBLEM-71A PROBLEM-73))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I Z).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I Z) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I Z))
     (IMPLIES (AND (CONSP I) (:P (CDR I) Z))
              (:P I Z))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (IMPLIES (NOT (CONSP Z))
                  (EQUAL (TIMES I Z) NIL))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP I)) (NOT (CONSP Z)))
         (EQUAL (TIMES I Z) NIL)).

But simplification reduces this to T, using the :definition TIMES and
the :executable-counterpart of EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (IMPLIES (NOT (CONSP Z))
                       (EQUAL (TIMES (CDR I) Z) NIL)))
         (IMPLIES (NOT (CONSP Z))
                  (EQUAL (TIMES I Z) NIL))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP I)
              (IMPLIES (NOT (CONSP Z))
                       (EQUAL (TIMES (CDR I) Z) NIL))
              (NOT (CONSP Z)))
         (EQUAL (TIMES I Z) NIL)).

But simplification reduces this to T, using the :definition TIMES,
the :executable-counterparts of EQUAL, FIX-NAT and NOT, primitive type
reasoning and the :rewrite rules PROBLEM-71A and PROBLEM-73.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-75A ...)
Rules: ((:DEFINITION NOT)
        (:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART FIX-NAT)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE PROBLEM-71A)
        (:REWRITE PROBLEM-73))
PROBLEM-75A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-75A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-75A)
PROBLEM-75A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-75A ...) ...)
Rules: NIL
 PROBLEM-75A
ACL2 !>>(THEOREM
           PROBLEM-75B
           (EQUAL (TIMES I (CONS X J))
                  (PLUS I (TIMES I J)))
           :HINTS
           (("Goal" :INDUCT (TIMES I J)
                    :IN-THEORY (ENABLE PROBLEM-71A PROBLEM-73 PROBLEM-74A))))


ACL2 !>>>(DEFTHM PROBLEM-75B
           (EQUAL (TIMES I (CONS X J))
                  (PLUS I (TIMES I J)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (TIMES I J)
                    :IN-THEORY (ENABLE PROBLEM-71A PROBLEM-73 PROBLEM-74A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I J).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I J X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J X))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J X))
              (:P I J X))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (TIMES I (CONS X J))
                (PLUS I (TIMES I J)))).

But simplification reduces this to T, using the :definition TIMES,
the :executable-counterparts of EQUAL and FIX-NAT and the :rewrite
rules PROBLEM-71A and PROBLEM-73.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (CDR I) (CONS X J))
                     (PLUS (CDR I) (TIMES (CDR I) J))))
         (EQUAL (TIMES I (CONS X J))
                (PLUS I (TIMES I J)))).

This simplifies, using the :definitions PLUS and TIMES, primitive type
reasoning and the :rewrite rule CDR-CONS, to

Subgoal *1/1'
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (CDR I) (CONS X J))
                     (PLUS (CDR I) (TIMES (CDR I) J))))
         (EQUAL (CONS NIL (PLUS J (TIMES (CDR I) (CONS X J))))
                (PLUS I (PLUS J (TIMES (CDR I) J))))).

But simplification reduces this to T, using the :definition PLUS, primitive
type reasoning and the :rewrite rule PROBLEM-74A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-75B ...)
Rules: ((:DEFINITION PLUS)
        (:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART FIX-NAT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-71A)
        (:REWRITE PROBLEM-73)
        (:REWRITE PROBLEM-74A))
PROBLEM-75B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-75B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-75B)
PROBLEM-75B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-75B ...) ...)
Rules: NIL
 PROBLEM-75B
ACL2 !>>(THEOREM
             PROBLEM-75
             (EQUAL (TIMES I J) (TIMES J I))
             :HINTS (("Goal" :INDUCT (TIMES I J)
                             :IN-THEORY (ENABLE PROBLEM-75A PROBLEM-75B))))


ACL2 !>>>(DEFTHM PROBLEM-75
           (EQUAL (TIMES I J) (TIMES J I))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TIMES I J)
                           :IN-THEORY (ENABLE PROBLEM-75A PROBLEM-75B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I J).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J))
              (:P I J))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (TIMES I J) (TIMES J I))).

But simplification reduces this to T, using the :definition TIMES,
the :executable-counterpart of EQUAL and the :rewrite rule PROBLEM-75A.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (CDR I) J)
                     (TIMES J (CDR I))))
         (EQUAL (TIMES I J) (TIMES J I))).

This simplifies, using the :definition TIMES, to

Subgoal *1/1'
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (CDR I) J)
                     (TIMES J (CDR I))))
         (EQUAL (PLUS J (TIMES J (CDR I)))
                (TIMES J I))).

The destructor terms (CAR I) and (CDR I) can be eliminated by using
CAR-CDR-ELIM to replace I by (CONS I1 I2), (CAR I) by I1 and (CDR I)
by I2.  This produces the following goal.

Subgoal *1/1''
(IMPLIES (AND (CONSP (CONS I1 I2))
              (EQUAL (TIMES I2 J) (TIMES J I2)))
         (EQUAL (PLUS J (TIMES J I2))
                (TIMES J (CONS I1 I2)))).

But we reduce the conjecture to T, by the simple :rewrite rule PROBLEM-75B.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-75 ...)
Rules: ((:DEFINITION TIMES)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:INDUCTION TIMES)
        (:REWRITE PROBLEM-75A)
        (:REWRITE PROBLEM-75B))
PROBLEM-75


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-75))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-75)
PROBLEM-75

Summary
Form:  ( PROGN (DEFTHM PROBLEM-75 ...) ...)
Rules: NIL
 PROBLEM-75
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 76.
"
ACL2 !>>(THEOREM
            PROBLEM-76A
            (EQUAL (TIMES I (PLUS J K))
                   (PLUS (TIMES I J) (TIMES I K)))
            :HINTS
            (("Goal" :INDUCT (TIMES I K)
                     :IN-THEORY (ENABLE PROBLEM-72 PROBLEM-73 PROBLEM-74A))))


ACL2 !>>>(DEFTHM PROBLEM-76A
           (EQUAL (TIMES I (PLUS J K))
                  (PLUS (TIMES I J) (TIMES I K)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (TIMES I K)
                    :IN-THEORY (ENABLE PROBLEM-72 PROBLEM-73 PROBLEM-74A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I K).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I J K) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J K))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J K))
              (:P I J K))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (TIMES I (PLUS J K))
                (PLUS (TIMES I J) (TIMES I K)))).

But simplification reduces this to T, using the :definition TIMES and
the :executable-counterparts of EQUAL and PLUS.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (TIMES (CDR I) (PLUS J K))
                     (PLUS (TIMES (CDR I) J)
                           (TIMES (CDR I) K))))
         (EQUAL (TIMES I (PLUS J K))
                (PLUS (TIMES I J) (TIMES I K)))).

But simplification reduces this to T, using the :definition TIMES,
primitive type reasoning and the :rewrite rules PROBLEM-72, PROBLEM-73
and PROBLEM-74A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-76A ...)
Rules: ((:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART PLUS)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE PROBLEM-72)
        (:REWRITE PROBLEM-73)
        (:REWRITE PROBLEM-74A))
PROBLEM-76A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-76A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-76A)
PROBLEM-76A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-76A ...) ...)
Rules: NIL
 PROBLEM-76A
ACL2 !>>(THEOREM
             PROBLEM-76B
             (EQUAL (TIMES I (TIMES J K))
                    (TIMES J (TIMES I K)))
             :HINTS (("Goal" :INDUCT (TIMES J K)
                             :IN-THEORY (ENABLE PROBLEM-75 PROBLEM-76A))))


ACL2 !>>>(DEFTHM PROBLEM-76B
           (EQUAL (TIMES I (TIMES J K))
                  (TIMES J (TIMES I K)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TIMES J K)
                           :IN-THEORY (ENABLE PROBLEM-75 PROBLEM-76A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES J K).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P I J K) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP J)) (:P I J K))
     (IMPLIES (AND (CONSP J) (:P I (CDR J) K))
              (:P I J K))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP J))
         (EQUAL (TIMES I (TIMES J K))
                (TIMES J (TIMES I K)))).

But simplification reduces this to T, using the :definition TIMES,
the :executable-counterparts of CONSP and EQUAL and the :rewrite rule
PROBLEM-75.

Subgoal *1/1
(IMPLIES (AND (CONSP J)
              (EQUAL (TIMES I (TIMES (CDR J) K))
                     (TIMES (CDR J) (TIMES I K))))
         (EQUAL (TIMES I (TIMES J K))
                (TIMES J (TIMES I K)))).

But simplification reduces this to T, using the :definition TIMES,
primitive type reasoning and the :rewrite rule PROBLEM-76A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-76B ...)
Rules: ((:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE PROBLEM-75)
        (:REWRITE PROBLEM-76A))
PROBLEM-76B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-76B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-76B)
PROBLEM-76B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-76B ...) ...)
Rules: NIL
 PROBLEM-76B
ACL2 !>>(THEOREM
            PROBLEM-76
            (EQUAL (POWER B (PLUS I J))
                   (TIMES (POWER B I) (POWER B J)))
            :HINTS
            (("Goal" :INDUCT (POWER B I)
                     :IN-THEORY (ENABLE PROBLEM-66B PROBLEM-68A PROBLEM-68C
                                        PROBLEM-73 PROBLEM-75 PROBLEM-76B))))


ACL2 !>>>(DEFTHM PROBLEM-76
           (EQUAL (POWER B (PLUS I J))
                  (TIMES (POWER B I) (POWER B J)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (POWER B I)
                    :IN-THEORY (ENABLE PROBLEM-66B PROBLEM-68A PROBLEM-68C
                                       PROBLEM-73 PROBLEM-75 PROBLEM-76B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (POWER B I).

This suggestion was produced using the :induction rule POWER.  If we
let (:P B I J) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P B I J))
     (IMPLIES (AND (CONSP I) (:P B (CDR I) J))
              (:P B I J))).
This induction is justified by the same argument used to admit POWER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (POWER B (PLUS I J))
                (TIMES (POWER B I) (POWER B J)))).

But simplification reduces this to T, using the :definitions PLUS,
POWER and TIMES, the :executable-counterparts of CDR and CONSP, primitive
type reasoning and the :rewrite rules PROBLEM-66B, PROBLEM-68A, PROBLEM-68C
and PROBLEM-73.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (POWER B (PLUS (CDR I) J))
                     (TIMES (POWER B (CDR I)) (POWER B J))))
         (EQUAL (POWER B (PLUS I J))
                (TIMES (POWER B I) (POWER B J)))).

But simplification reduces this to T, using the :definitions PLUS and
POWER, primitive type reasoning, the :rewrite rules CDR-CONS, PROBLEM-73,
PROBLEM-75 and PROBLEM-76B and the :type-prescription rule PLUS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-76 ...)
Rules: ((:DEFINITION PLUS)
        (:DEFINITION POWER)
        (:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION POWER)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-66B)
        (:REWRITE PROBLEM-68A)
        (:REWRITE PROBLEM-68C)
        (:REWRITE PROBLEM-73)
        (:REWRITE PROBLEM-75)
        (:REWRITE PROBLEM-76B)
        (:TYPE-PRESCRIPTION PLUS))
PROBLEM-76


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-76))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-76)
PROBLEM-76

Summary
Form:  ( PROGN (DEFTHM PROBLEM-76 ...) ...)
Rules: NIL
 PROBLEM-76
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 77.
"
ACL2 !>>(THEOREM
            PROBLEM-77A
            (EQUAL (POWER (TIMES A B) I)
                   (TIMES (POWER A I) (POWER B I)))
            :HINTS
            (("Goal" :INDUCT (POWER B I)
                     :IN-THEORY (ENABLE PROBLEM-74 PROBLEM-75 PROBLEM-76B))))


ACL2 !>>>(DEFTHM PROBLEM-77A
           (EQUAL (POWER (TIMES A B) I)
                  (TIMES (POWER A I) (POWER B I)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (POWER B I)
                    :IN-THEORY (ENABLE PROBLEM-74 PROBLEM-75 PROBLEM-76B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (POWER B I).

This suggestion was produced using the :induction rule POWER.  If we
let (:P A B I) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P A B I))
     (IMPLIES (AND (CONSP I) (:P A B (CDR I)))
              (:P A B I))).
This induction is justified by the same argument used to admit POWER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (POWER (TIMES A B) I)
                (TIMES (POWER A I) (POWER B I)))).

But simplification reduces this to T, using the :definition POWER and
the :executable-counterparts of EQUAL and TIMES.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (POWER (TIMES A B) (CDR I))
                     (TIMES (POWER A (CDR I))
                            (POWER B (CDR I)))))
         (EQUAL (POWER (TIMES A B) I)
                (TIMES (POWER A I) (POWER B I)))).

But simplification reduces this to T, using the :definition POWER,
primitive type reasoning and the :rewrite rules PROBLEM-74, PROBLEM-75
and PROBLEM-76B.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-77A ...)
Rules: ((:DEFINITION POWER)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART TIMES)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION POWER)
        (:REWRITE PROBLEM-74)
        (:REWRITE PROBLEM-75)
        (:REWRITE PROBLEM-76B))
PROBLEM-77A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-77A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-77A)
PROBLEM-77A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-77A ...) ...)
Rules: NIL
 PROBLEM-77A
ACL2 !>>(THEOREM PROBLEM-77B
                 (EQUAL (POWER '(NIL) I) '(NIL))
                 :HINTS (("Goal" :INDUCT (POWER '(NIL) I))))


ACL2 !>>>(DEFTHM PROBLEM-77B
           (EQUAL (POWER '(NIL) I) '(NIL))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (POWER '(NIL) I))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (POWER '(NIL) I).

This suggestion was produced using the :induction rule POWER.  If we
let (:P I) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I))
     (IMPLIES (AND (CONSP I) (:P (CDR I)))
              (:P I))).
This induction is justified by the same argument used to admit POWER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (POWER '(NIL) I) '(NIL))).

But simplification reduces this to T, using the :definition POWER and
the :executable-counterpart of EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (POWER '(NIL) (CDR I)) '(NIL)))
         (EQUAL (POWER '(NIL) I) '(NIL))).

But simplification reduces this to T, using the :definition POWER and
the :executable-counterparts of EQUAL and TIMES.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-77B ...)
Rules: ((:DEFINITION POWER)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART TIMES)
        (:INDUCTION POWER))
PROBLEM-77B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-77B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-77B)
PROBLEM-77B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-77B ...) ...)
Rules: NIL
 PROBLEM-77B
ACL2 !>>(THEOREM
           PROBLEM-77
           (EQUAL (POWER (POWER B I) J)
                  (POWER B (TIMES I J)))
           :HINTS
           (("Goal" :INDUCT (TIMES I J)
                    :IN-THEORY (ENABLE PROBLEM-76 PROBLEM-77A PROBLEM-77B))))


ACL2 !>>>(DEFTHM PROBLEM-77
           (EQUAL (POWER (POWER B I) J)
                  (POWER B (TIMES I J)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (TIMES I J)
                    :IN-THEORY (ENABLE PROBLEM-76 PROBLEM-77A PROBLEM-77B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TIMES I J).

This suggestion was produced using the :induction rule TIMES.  If we
let (:P B I J) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P B I J))
     (IMPLIES (AND (CONSP I) (:P B (CDR I) J))
              (:P B I J))).
This induction is justified by the same argument used to admit TIMES.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (POWER (POWER B I) J)
                (POWER B (TIMES I J)))).

But simplification reduces this to T, using the :definitions POWER
and TIMES, the :executable-counterparts of CONSP and EQUAL and the
:rewrite rule PROBLEM-77B.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (POWER (POWER B (CDR I)) J)
                     (POWER B (TIMES (CDR I) J))))
         (EQUAL (POWER (POWER B I) J)
                (POWER B (TIMES I J)))).

But simplification reduces this to T, using the :definitions POWER
and TIMES, primitive type reasoning and the :rewrite rules PROBLEM-76
and PROBLEM-77A.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-77 ...)
Rules: ((:DEFINITION POWER)
        (:DEFINITION TIMES)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TIMES)
        (:REWRITE PROBLEM-76)
        (:REWRITE PROBLEM-77A)
        (:REWRITE PROBLEM-77B))
PROBLEM-77


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-77))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-77)
PROBLEM-77

Summary
Form:  ( PROGN (DEFTHM PROBLEM-77 ...) ...)
Rules: NIL
 PROBLEM-77
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 78.
"
ACL2 !>>(THEOREM PROBLEM-78 (LESSEQP I I)
                 :HINTS (("Goal" :INDUCT (LESSEQP I I))))


ACL2 !>>>(DEFTHM PROBLEM-78
           (LESSEQP I I)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LESSEQP I I))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LESSEQP I I).

This suggestion was produced using the :induction rule LESSEQP.  If
we let (:P I) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP I)) (:P I))
     (IMPLIES (AND (CONSP I) (CONSP I) (:P (CDR I)))
              (:P I))).
This induction is justified by the same argument used to admit LESSEQP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I)) (LESSEQP I I)).

But simplification reduces this to T, using the :definition LESSEQP.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (CONSP I)
              (LESSEQP (CDR I) (CDR I)))
         (LESSEQP I I)).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP I)
              (LESSEQP (CDR I) (CDR I)))
         (LESSEQP I I)).

But simplification reduces this to T, using the :definition LESSEQP
and the :type-prescription rule LESSEQP.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-78 depends upon the :type-prescription rule
LESSEQP.

Summary
Form:  ( DEFTHM PROBLEM-78 ...)
Rules: ((:DEFINITION LESSEQP)
        (:DEFINITION NOT)
        (:INDUCTION LESSEQP)
        (:TYPE-PRESCRIPTION LESSEQP))
PROBLEM-78


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-78))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-78)
PROBLEM-78

Summary
Form:  ( PROGN (DEFTHM PROBLEM-78 ...) ...)
Rules: NIL
 PROBLEM-78
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 79.
"
ACL2 !>>(THEOREM
             PROBLEM-79
             (IMPLIES (AND (LESSEQP I J) (LESSEQP J K))
                      (LESSEQP I K))
             :HINTS (("Goal" :INDUCT (LIST (LESSEQP I J) (LESSEQP I K)))))


ACL2 !>>>(DEFTHM PROBLEM-79
           (IMPLIES (AND (LESSEQP I J) (LESSEQP J K))
                    (LESSEQP I K))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LIST (LESSEQP I J) (LESSEQP I K)))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-79 ...):  A :REWRITE rule generated
from PROBLEM-79 contains the free variable J.  This variable will be
chosen by searching for an instance of (LESSEQP I J) in the context
of the term being rewritten.  This is generally a severe restriction
on the applicability of a :REWRITE rule.  See :DOC free-variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  Two induction schemes are suggested
by the induction hint.  These merge into one derived induction scheme.

We will induct according to a scheme suggested by (LESSEQP I K), but
modified to accommodate (LESSEQP I J).

These suggestions were produced using the :induction rule LESSEQP.
If we let (:P I J K) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (NOT (CONSP I)) (:P I J K))
     (IMPLIES (AND (CONSP I) (NOT (CONSP K)))
              (:P I J K))
     (IMPLIES (AND (CONSP I)
                   (CONSP K)
                   (:P (CDR I) (CDR J) (CDR K)))
              (:P I J K))).
This induction is justified by the same argument used to admit LESSEQP.
Note, however, that the unmeasured variables J and K are being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP I))
         (IMPLIES (AND (LESSEQP I J) (LESSEQP J K))
                  (LESSEQP I K))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP I))
              (LESSEQP I J)
              (LESSEQP J K))
         (LESSEQP I K)).

But simplification reduces this to T, using the :definition LESSEQP.

Subgoal *1/2
(IMPLIES (AND (CONSP I) (NOT (CONSP K)))
         (IMPLIES (AND (LESSEQP I J) (LESSEQP J K))
                  (LESSEQP I K))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP I)
              (NOT (CONSP K))
              (LESSEQP I J)
              (LESSEQP J K))
         (LESSEQP I K)).

But simplification reduces this to T, using the :definition LESSEQP.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (CONSP K)
              (IMPLIES (AND (LESSEQP (CDR I) (CDR J))
                            (LESSEQP (CDR J) (CDR K)))
                       (LESSEQP (CDR I) (CDR K))))
         (IMPLIES (AND (LESSEQP I J) (LESSEQP J K))
                  (LESSEQP I K))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP I)
              (CONSP K)
              (IMPLIES (AND (LESSEQP (CDR I) (CDR J))
                            (LESSEQP (CDR J) (CDR K)))
                       (LESSEQP (CDR I) (CDR K)))
              (LESSEQP I J)
              (LESSEQP J K))
         (LESSEQP I K)).

But simplification reduces this to T, using the :definition LESSEQP
and the :type-prescription rule LESSEQP.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-79 depends upon the :type-prescription rule
LESSEQP.

Summary
Form:  ( DEFTHM PROBLEM-79 ...)
Rules: ((:DEFINITION LESSEQP)
        (:DEFINITION NOT)
        (:INDUCTION LESSEQP)
        (:TYPE-PRESCRIPTION LESSEQP))
Warnings:  Free
PROBLEM-79


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-79))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-79)
PROBLEM-79

Summary
Form:  ( PROGN (DEFTHM PROBLEM-79 ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-79
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 80.
"
ACL2 !>>(THEOREM
             PROBLEM-80
             (EQUAL (LESSEQP (PLUS I J) (PLUS I K))
                    (LESSEQP J K))
             :HINTS (("Goal" :INDUCT (PLUS I K)
                             :IN-THEORY (ENABLE PROBLEM-69A PROBLEM-69B))))


ACL2 !>>>(DEFTHM PROBLEM-80
           (EQUAL (LESSEQP (PLUS I J) (PLUS I K))
                  (LESSEQP J K))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PLUS I K)
                           :IN-THEORY (ENABLE PROBLEM-69A PROBLEM-69B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PLUS I K).

This suggestion was produced using the :induction rule PLUS.  If we
let (:P I J K) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J K))
     (IMPLIES (AND (CONSP I) (:P (CDR I) J K))
              (:P I J K))).
This induction is justified by the same argument used to admit PLUS.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP I))
         (EQUAL (LESSEQP (PLUS I J) (PLUS I K))
                (LESSEQP J K))).

But simplification reduces this to T, using the :definition PLUS, primitive
type reasoning and the :rewrite rules PROBLEM-69A and PROBLEM-69B.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (EQUAL (LESSEQP (PLUS (CDR I) J)
                              (PLUS (CDR I) K))
                     (LESSEQP J K)))
         (EQUAL (LESSEQP (PLUS I J) (PLUS I K))
                (LESSEQP J K))).

But simplification reduces this to T, using the :definitions LESSEQP
and PLUS, primitive type reasoning, the :rewrite rule CDR-CONS and
the :type-prescription rule PLUS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-80 ...)
Rules: ((:DEFINITION LESSEQP)
        (:DEFINITION PLUS)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PLUS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-69A)
        (:REWRITE PROBLEM-69B)
        (:TYPE-PRESCRIPTION PLUS))
PROBLEM-80


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-80))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-80)
PROBLEM-80

Summary
Form:  ( PROGN (DEFTHM PROBLEM-80 ...) ...)
Rules: NIL
 PROBLEM-80
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 81.
"
ACL2 !>>(THEOREM
           PROBLEM-81
           (IMPLIES (AND (EVENNAT I) (EVENNAT J))
                    (EVENNAT (PLUS I J)))
           :HINTS
           (("Goal" :INDUCT (EVENNAT I)
                    :IN-THEORY (ENABLE PROBLEM-70A PROBLEM-73 PROBLEM-73A))))


ACL2 !>>>(DEFTHM PROBLEM-81
           (IMPLIES (AND (EVENNAT I) (EVENNAT J))
                    (EVENNAT (PLUS I J)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (EVENNAT I)
                    :IN-THEORY (ENABLE PROBLEM-70A PROBLEM-73 PROBLEM-73A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (EVENNAT I).

This suggestion was produced using the :induction rule EVENNAT.  If
we let (:P I J) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP I)) (:P I J))
     (IMPLIES (AND (CONSP I) (NOT (CONSP (CDR I))))
              (:P I J))
     (IMPLIES (AND (CONSP I)
                   (CONSP (CDR I))
                   (:P (CDDR I) J))
              (:P I J))).
This induction is justified by the same argument used to admit EVENNAT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP I))
         (IMPLIES (AND (EVENNAT I) (EVENNAT J))
                  (EVENNAT (PLUS I J)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP I))
              (EVENNAT I)
              (EVENNAT J))
         (EVENNAT (PLUS I J))).

But simplification reduces this to T, using the :definitions EVENNAT
and PLUS, the :rewrite rule PROBLEM-70A and the :type-prescription
rule EVENNAT.

Subgoal *1/2
(IMPLIES (AND (CONSP I) (NOT (CONSP (CDR I))))
         (IMPLIES (AND (EVENNAT I) (EVENNAT J))
                  (EVENNAT (PLUS I J)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP I)
              (NOT (CONSP (CDR I)))
              (EVENNAT I)
              (EVENNAT J))
         (EVENNAT (PLUS I J))).

But simplification reduces this to T, using the :definition EVENNAT.

Subgoal *1/1
(IMPLIES (AND (CONSP I)
              (CONSP (CDR I))
              (IMPLIES (AND (EVENNAT (CDDR I)) (EVENNAT J))
                       (EVENNAT (PLUS (CDDR I) J))))
         (IMPLIES (AND (EVENNAT I) (EVENNAT J))
                  (EVENNAT (PLUS I J)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP I)
              (CONSP (CDR I))
              (IMPLIES (AND (EVENNAT (CDDR I)) (EVENNAT J))
                       (EVENNAT (PLUS (CDDR I) J)))
              (EVENNAT I)
              (EVENNAT J))
         (EVENNAT (PLUS I J))).

This simplifies, using the :definitions EVENNAT and PLUS, the :rewrite
rule PROBLEM-73 and the :type-prescription rule EVENNAT, to

Subgoal *1/1''
(IMPLIES (AND (CONSP I)
              (CONSP (CDR I))
              (EVENNAT (PLUS J (CDDR I)))
              (EVENNAT (CDDR I))
              (EVENNAT J))
         (EVENNAT (CONS NIL (PLUS J (CDR I))))).

The destructor terms (CAR I) and (CDR I) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace I by (CONS I1 I2), (CAR I)
by I1 and (CDR I) by I2.  (2) Use CAR-CDR-ELIM, again, to replace I2
by (CONS I3 I4), (CAR I2) by I3 and (CDR I2) by I4.  These steps produce
the following goal.

Subgoal *1/1'''
(IMPLIES (AND (CONSP (CONS I3 I4))
              (CONSP (LIST* I1 I3 I4))
              (EVENNAT (PLUS J I4))
              (EVENNAT I4)
              (EVENNAT J))
         (EVENNAT (CONS NIL (PLUS J (CONS I3 I4))))).

By the simple :rewrite rule PROBLEM-73A we reduce the conjecture to

Subgoal *1/1'4'
(IMPLIES (AND (CONSP (CONS I3 I4))
              (CONSP (LIST* I1 I3 I4))
              (EVENNAT (PLUS J I4))
              (EVENNAT I4)
              (EVENNAT J))
         (EVENNAT (LIST* NIL NIL (PLUS J I4)))).

But simplification reduces this to T, using the :definition EVENNAT,
primitive type reasoning, the :rewrite rules CDR-CONS and PROBLEM-73
and the :type-prescription rules EVENNAT and PLUS.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-81 depends upon the :type-prescription rule
EVENNAT.

Summary
Form:  ( DEFTHM PROBLEM-81 ...)
Rules: ((:DEFINITION EVENNAT)
        (:DEFINITION NOT)
        (:DEFINITION PLUS)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION EVENNAT)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-70A)
        (:REWRITE PROBLEM-73)
        (:REWRITE PROBLEM-73A)
        (:TYPE-PRESCRIPTION EVENNAT)
        (:TYPE-PRESCRIPTION PLUS))
PROBLEM-81


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-81))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-81)
PROBLEM-81

Summary
Form:  ( PROGN (DEFTHM PROBLEM-81 ...) ...)
Rules: NIL
 PROBLEM-81
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 82.
"
ACL2 !>>(DEFUN CC (X)
          (IF (CONSP X)
              (+ 1 (+ (CC (CAR X)) (CC (CDR X))))
            0))

The admission of CC is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of CC is described by the
theorem (AND (INTEGERP (CC X)) (<= 0 (CC X))).  We used primitive type
reasoning.

Summary
Form:  ( DEFUN CC ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 CC
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 83.

; Theorem. (natp (cc x))

; Proof.  Induction on x.
; Base Case:  (not (consp x))
; (cc x) = 0.
; (natp 0) = t.

; Induction Step:
;  (implies (and (consp x)
;                (natp (cc (car x)))
;                (natp (cc (cdr x))))
;           (natp (cc x)))

; The conclusion becomes
; (natp (+ 1 (+ (cc (car x)) (cc (cdr x)))))
; and that follows by standard arithmetic from the induction
; hypotheses.

; Q.E.D.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 84.

; (and (implies (consp x)
;               (< (cc (car x)) (cc x)))
;      (implies (consp x)
;               (< (cc (cdr x)) (cc x))))
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 85.
"
ACL2 !>>(THEOREM PROBLEM-85
                 (AND (IMPLIES (CONSP X)
                               (< (CC (CAR X)) (CC X)))
                      (IMPLIES (CONSP X)
                               (< (CC (CDR X)) (CC X))))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-85
           (AND (IMPLIES (CONSP X)
                         (< (CC (CAR X)) (CC X)))
                (IMPLIES (CONSP X)
                         (< (CC (CDR X)) (CC X))))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE))))

[Note:  A hint was supplied for the goal above.  Thanks!]

By case analysis we reduce the conjecture to the following two conjectures.

Subgoal 2
(IMPLIES (CONSP X)
         (< (CC (CAR X)) (CC X))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal 2'
(IMPLIES (CONSP (CONS X1 X2))
         (< (CC X1) (CC (CONS X1 X2)))).

This simplifies, using the :definition CC, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal 2''
(< (CC X1) (+ 1 (CC X1) (CC X2))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (CONSP X)
         (< (CC (CDR X)) (CC X))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal 1'
(IMPLIES (CONSP (CONS X1 X2))
         (< (CC X2) (CC (CONS X1 X2)))).

This simplifies, using the :definition CC, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal 1''
(< (CC X2) (+ 1 (CC X1) (CC X2))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule CC.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-85 ...)
Rules: ((:DEFINITION CC)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION CC))
PROBLEM-85


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-85))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-85)
PROBLEM-85

Summary
Form:  ( PROGN (DEFTHM PROBLEM-85 ...) ...)
Rules: NIL
 PROBLEM-85
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 86.

; Del was defined when we introduced perm.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 87.
"
ACL2 !>>(THEOREM PROBLEM-87A
                 (IMPLIES (MEM E X)
                          (< (CC (RM E X)) (CC X)))
                 :HINTS (("Goal" :INDUCT (CC X)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-87A
           (IMPLIES (MEM E X)
                    (< (CC (RM E X)) (CC X)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (CC X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (CC X).

This suggestion was produced using the :induction rule CC.  If we let
(:P E X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (:P E (CAR X))
                   (:P E (CDR X)))
              (:P E X))).
This induction is justified by the same argument used to admit CC.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (IMPLIES (MEM E X)
                  (< (CC (RM E X)) (CC X)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP X)) (MEM E X))
         (< (CC (RM E X)) (CC X))).

But simplification reduces this to T, using the :definition MEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (IMPLIES (MEM E (CAR X))
                       (< (CC (RM E (CAR X))) (CC (CAR X))))
              (IMPLIES (MEM E (CDR X))
                       (< (CC (RM E (CDR X))) (CC (CDR X)))))
         (IMPLIES (MEM E X)
                  (< (CC (RM E X)) (CC X)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (IMPLIES (MEM E (CAR X))
                       (< (CC (RM E (CAR X))) (CC (CAR X))))
              (IMPLIES (MEM E (CDR X))
                       (< (CC (RM E (CDR X))) (CC (CDR X))))
              (MEM E X))
         (< (CC (RM E X)) (CC X))).

This simplifies, using the :definitions CC, MEM (if-intro) and RM (if-
intro) and primitive type reasoning, to the following eight conjectures.

Subgoal *1/1.8
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (NOT (MEM E (CDR X)))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.7
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.6
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (< (CC (CONS (CAR X) (RM E (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

This simplifies, using the :definition CC, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/1.5'
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (< (+ 1 (CC (CAR X)) (CC (RM E (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule CC.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (NOT (MEM E (CDR X)))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (< (CC (CONS (CAR X) (RM E (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

This simplifies, using the :definition CC, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/1.1'
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (< (+ 1 (CC (CAR X)) (CC (RM E (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule CC.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-87A ...)
Rules: ((:DEFINITION CC)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION CC)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION MEM) (:DEFINITION RM))
PROBLEM-87A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-87A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-87A)
PROBLEM-87A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-87A ...) ...)
Rules: NIL
 PROBLEM-87A
ACL2 !>>(DEFUN F23 (E X)
          (DECLARE (XARGS :MEASURE (CC X)))
          (IF (MEM E X) (F23 E (RM E X)) 23))

For the admission of F23 we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (MEM E X)
              (O< (CC (RM E X)) (CC X)))).

By case analysis we reduce the conjecture to the following two conjectures.

Subgoal 2
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions O-FINP and O-P and
the :type-prescription rule CC.

Subgoal 1
(IMPLIES (MEM E X)
         (O< (CC (RM E X)) (CC X))).

This simplifies, using the :definitions O-FINP and O< and the :type-
prescription rule CC, to

Subgoal 1'
(IMPLIES (MEM E X)
         (< (CC (RM E X)) (CC X))).

Name the formula above *1.

Perhaps we can prove *1 by induction.  Three induction schemes are
suggested by this conjecture.  Subsumption reduces that number to two.
These merge into one derived induction scheme.  

We will induct according to a scheme suggested by (CC X), but modified
to accommodate (RM E X).

These suggestions were produced using the :induction rules CC, MEM
and RM.  If we let (:P E X) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (:P E (CAR X))
                   (:P E (CDR X)))
              (:P E X))).
This induction is justified by the same argument used to admit CC.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.

Subgoal *1/5
(IMPLIES (AND (NOT (CONSP X)) (MEM E X))
         (< (CC (RM E X)) (CC X))).

But simplification reduces this to T, using the :definition MEM.

Subgoal *1/4
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E X))
         (< (CC (RM E X)) (CC X))).

This simplifies, using the :definitions CC, MEM (if-intro) and RM (if-
intro) and primitive type reasoning, to the following three conjectures.

Subgoal *1/4.3
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/4.2
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/4.1
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (< (CC (CONS (CAR X) (RM E (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

This simplifies, using the :definition CC, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/4.1'
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (< (+ 1 (CC (CAR X)) (CC (RM E (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E X))
         (< (CC (RM E X)) (CC X))).

This simplifies, using the :definitions CC, MEM (if-intro) and RM (if-
intro) and primitive type reasoning, to the following three conjectures.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (< (CC (CONS (CAR X) (RM E (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

This simplifies, using the :definition CC, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/3.1'
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (< (CC (RM E (CDR X))) (CC (CDR X)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (< (+ 1 (CC (CAR X)) (CC (RM E (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (NOT (MEM E (CDR X)))
              (MEM E X))
         (< (CC (RM E X)) (CC X))).

This simplifies, using the :definitions CC, MEM and RM and primitive
type reasoning, to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (< (CC (RM E (CAR X))) (CC (CAR X)))
              (NOT (MEM E (CDR X)))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (NOT (MEM E (CDR X)))
              (MEM E X))
         (< (CC (RM E X)) (CC X))).

This simplifies, using the :definitions CC, MEM and RM and primitive
type reasoning, to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (NOT (MEM E (CAR X)))
              (NOT (MEM E (CDR X)))
              (EQUAL E (CAR X)))
         (< (CC (CDR X))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

That completes the proof of the measure theorem for F23.  Thus, we
admit this function under the principle of definition.  We observe
that the type of F23 is described by the theorem 
(AND (INTEGERP (F23 E X)) (< 1 (F23 E X))).  

Summary
Form:  ( DEFUN F23 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION CC)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O-P)
        (:DEFINITION O<)
        (:DEFINITION RM)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION CC)
        (:INDUCTION MEM)
        (:INDUCTION RM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION MEM) (:DEFINITION RM))
 F23
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 88.

; No.  We need to inductively assume that (f23 e (rm e x))
; is 23 to prove that (f e x) is 23.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 89.

; Ack terminates because the second argument always either gets
; smaller or stays fixed.  But when the second argument stays fixed,
; the first argument gets smaller.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 90.

; Rather than just show the answers, I write a function that computes
; the answers.  Again, I feel free to use any feature of ACL2, since
; this question did not require you to write these functions.

; By loading the file (certified book) below, we can write
; ordinals in a nice algebraic notation.  Thus, I can create my
; examples by writing expressions like:

;  (o+ (o* (o^ (omega) 3) 5)
;      (o* (o^ (omega) 1) 25)
;      7)

; instead of ((3 . 5) (1 . 25) . 7).
"
ACL2 !>>(INCLUDE-BOOK "ordinals/ordinals"
                      :DIR :SYSTEM)

Summary
Form:  ( INCLUDE-BOOK "ordinals/ordinals" ...)
Rules: NIL
 (:SYSTEM . "ordinals/ordinals.lisp")
ACL2 !>>:----- 
"
; So here is the function that checks a pair of ordinals and announces
; whether a<b, a=b, or a>b.
"
ACL2 !>>(DEFUN CHECK-ROW (ROW)
          (LET ((A (CAR ROW)) (B (CADR ROW)))
            (IF (AND (O-P A) (O-P B))
                (IF (O< A B)
                    'A<B
                  (IF (EQUAL A B) 'A=B 'B<A))
              'NOT-O-P!)))

Since CHECK-ROW is non-recursive, its admission is trivial.  We observe
that the type of CHECK-ROW is described by the theorem 
(AND (SYMBOLP (CHECK-ROW ROW))
     (NOT (EQUAL (CHECK-ROW ROW) T))
     (NOT (EQUAL (CHECK-ROW ROW) NIL))).

Summary
Form:  ( DEFUN CHECK-ROW ...)
Rules: NIL
 CHECK-ROW
ACL2 !>>:----- 
"
; And now I check all the rows in a table.
; Here are the rows of that table with suitable column headers.

;                 a                      b                           answer
;           (1    23                     100                         A<B)
;           (2    1000000                ((1 . 1) . 0)               A<B)
;           (3    ((2 . 1) . 0)          ((1 . 2) . 0)               B<A)
;           (4    ((3 . 5) (1 . 25) . 7) ((3 . 5) (2 . 1) . 3)       A<B)
;           (5    ((((2 . 1) . 0) . 5) . 3)
;                                        ((((1 . 1) . 0) . 5) (1 . 25) . 7)
                                                                     B<A)))

"
ACL2 !>>(DEFUN CHECK-ALL-ROWS (TAB I)
          (IF (ENDP TAB)
              NIL
            (CONS (LIST I (CAR (CAR TAB))
                        (CADR (CAR TAB))
                        (CHECK-ROW (CAR TAB)))
                  (CHECK-ALL-ROWS (CDR TAB) (+ 1 I)))))

The admission of CHECK-ALL-ROWS is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT TAB).  We observe that the type of CHECK-ALL-ROWS
is described by the theorem (TRUE-LISTP (CHECK-ALL-ROWS TAB I)).  We
used primitive type reasoning.

Summary
Form:  ( DEFUN CHECK-ALL-ROWS ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 CHECK-ALL-ROWS
ACL2 !>>(THEOREM
         PROBLEM-90
         (EQUAL
           (CHECK-ALL-ROWS (LIST (LIST 23 100)
                                 (LIST 1000000 (OMEGA))
                                 (LIST (O^ (OMEGA) 2) (O* (OMEGA) 2))
                                 (LIST (O+ (O* (O^ (OMEGA) 3) 5)
                                           (O* (O^ (OMEGA) 1) 25)
                                           7)
                                       (O+ (O* (O^ (OMEGA) 3) 5)
                                           (O* (O^ (OMEGA) 2) 1)
                                           3))
                                 (LIST (O+ (O* (O^ (OMEGA) (O^ (OMEGA) 2)) 5)
                                           3)
                                       (O+ (O* (O^ (OMEGA) (OMEGA)) 5)
                                           (O* (O^ (OMEGA) 1) 25)
                                           7)))
                           1)
           '((1 23 100 A<B)
             (2 1000000 ((1 . 1) . 0) A<B)
             (3 ((2 . 1) . 0) ((1 . 2) . 0) B<A)
             (4 ((3 . 5) (1 . 25) . 7)
                ((3 . 5) (2 . 1) . 3)
                A<B)
             (5 ((((2 . 1) . 0) . 5) . 3)
                ((((1 . 1) . 0) . 5) (1 . 25) . 7)
                B<A)))
         :HINTS (("Goal" :IN-THEORY (ENABLE (OMEGA) (O^) (O*) (O+))))
         :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by the :executable-counterparts
of CHECK-ALL-ROWS, CONS, EQUAL, OB*, OB+, OB^ and OMEGA.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-90 ...)
Rules: ((:EXECUTABLE-COUNTERPART CHECK-ALL-ROWS)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART OB*)
        (:EXECUTABLE-COUNTERPART OB+)
        (:EXECUTABLE-COUNTERPART OB^)
        (:EXECUTABLE-COUNTERPART OMEGA))
 PROBLEM-90
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 91.

; Note: If you don't load the ordinals book, you can skip enabling of
; all the functions below!  They're normally enabled.  The book disables
; them so that you can use the algebraic notation and lemmas will fire
; to simplify.  Since I used raw conses to construct my ordinals, I'm
; having to fight the book here.  But by using raw conses, you can
; construct a simple proof without the ordinals book.
"
ACL2 !>>(DEFUN M2 (I J)
          (CONS (CONS 1 (+ 1 I)) J))

Since M2 is non-recursive, its admission is trivial.  We observe that
the type of M2 is described by the theorem (CONSP (M2 I J)).  We used
primitive type reasoning.

Summary
Form:  ( DEFUN M2 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 M2
ACL2 !>>(IN-THEORY (ENABLE O< O+ O* OMEGA (OMEGA)
                           O-FIRST-COEFF
                           O-FIRST-EXPT O-RST O-FINP O-P))

Summary
Form:  ( IN-THEORY (ENABLE ...))
Rules: NIL
 :CURRENT-THEORY-UPDATED
ACL2 !>>(THEOREM PROBLEM-91
                 (IMPLIES (AND (NATP I1)
                               (NATP J1)
                               (NATP I2)
                               (NATP J2))
                          (AND (O-P (M2 I1 J1))
                               (IFF (O< (M2 I1 J1) (M2 I2 J2))
                                    (IF (EQUAL I1 I2)
                                        (< J1 J2)
                                      (< I1 I2)))))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definition M2 we reduce the conjecture to

Goal'
(IMPLIES (AND (NATP I1)
              (NATP J1)
              (NATP I2)
              (NATP J2))
         (AND (O-P (CONS (CONS 1 (+ 1 I1)) J1))
              (COND ((O< (CONS (CONS 1 (+ 1 I1)) J1)
                         (CONS (CONS 1 (+ 1 I2)) J2))
                     (IF (EQUAL I1 I2) (< J1 J2) (< I1 I2)))
                    ((IF (EQUAL I1 I2) (< J1 J2) (< I1 I2))
                     NIL)
                    (T T)))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER, O-FINP-CR and POSP-COMPOUND-RECOGNIZER,
the :definitions FIX, O-FIRST-COEFF, O-FIRST-EXPT, O-P, O-RST and O<,
the :executable-counterparts of EQUAL, O-P and O<, primitive type reasoning,
the :meta rules CANCEL_PLUS-EQUAL-CORRECT and CANCEL_PLUS-LESSP-CORRECT
and the :rewrite rules CAR-CONS, CDR-CONS, O-FIRST-EXPT-DEF-O-FINP
and O-P-DEF-O-FINP-1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-91 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:DEFINITION FIX)
        (:DEFINITION IFF)
        (:DEFINITION M2)
        (:DEFINITION O-FIRST-COEFF)
        (:DEFINITION O-FIRST-EXPT)
        (:DEFINITION O-P)
        (:DEFINITION O-RST)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART O-P)
        (:EXECUTABLE-COUNTERPART O<)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-EQUAL-CORRECT)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE O-FIRST-EXPT-DEF-O-FINP)
        (:REWRITE O-P-DEF-O-FINP-1))
 PROBLEM-91
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 92.

; The longest decreasing chain from 10 has eleven ordinals in it:

; 0 o< 1 o< 2 o< 3 o< 4 o< 5 o< 6 o< 7 o< 8 o< 9 o< 10

; There is no longest decreasing chain from ((1 . 1) . 0).  But any
; step down from that will be a finite natural, e.g., n.  And from n
; down to 0 there can be at most n+1 steps.  So any decreasing chain
; from ((1 . 1) . 0) will have at most n+2 ordinals in it, but n can
; be an arbitrary natural.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 93.

; The following infinite chain is decreasing.

; x0 ((2 . 1) . 0)
; x1 ((1 . 1) (2 . 1) . 0)
; x2 ((1 . 1) (1 . 1) (2 . 1) . 0) 
; x3 ((1 . 1) (1 . 1) (1 . 1) (2 . 1) . 0) 
;    ...

; That is, ... x3 o< x2 o< x1 o< x0.  But all these objects (except
; x0) fail to be ordinals because the powers of omega do not decrease.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 94.

; For a proof of the well-foundedness of our ordinals, see the ACL2
; online documentation topic proof-of-well-foundedness:

; http://www.cs.utexas.edu/users/moore/acl2/manuals/latest/index.html?topic=ACL2____PROOF-OF-WELL-FOUNDEDNESS

; Alternatively, go to the ACL2 home page

; http://www.cs.utexas.edu/users/moore/acl2

; and click on
; > The User's Manual
;  > Index of all documented topics
;   > P
;    > PROOF-OF-WELL-FOUNDEDNESS
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 95.

; The measure is cc.  The measure conjecture is
"
ACL2 !>>(THEOREM PROBLEM-95
                 (AND (O-P (CC X))
                      (IMPLIES (NOT (ATOM X))
                               (O< (CC (FIRST X)) (CC X)))
                      (IMPLIES (NOT (ATOM X))
                               (O< (CC (REST X)) (CC X))))
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-85)))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definition ATOM we reduce the conjecture to the following
three conjectures.

Subgoal 3
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 2
(IMPLIES (CONSP X)
         (O< (CC (CAR X)) (CC X))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, linear arithmetic, the :linear rule PROBLEM-85, the
:rewrite rule O-FINP-< and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (CONSP X)
         (O< (CC (CDR X)) (CC X))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, linear arithmetic, the :linear rule PROBLEM-85, the
:rewrite rule O-FINP-< and the :type-prescription rule CC.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-95 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION ATOM)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:LINEAR PROBLEM-85)
        (:REWRITE O-FINP-<)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:TYPE-PRESCRIPTION CC))
 PROBLEM-95
ACL2 !>>:----- 
"
; To admit this definition of tree-copy with the measure cc we would
; write the following and it would generate and prove the conjecture
; above.  

; (defun tree-copy (x)
;   (declare (xargs :measure (cc x)))
;   (if (atom x)
;       x
;     (cons (tree-copy (first x))
;           (tree-copy (rest x)))))

; However we cannot, since tree-copy has already been defined.  For
; the other problems of this sort, we actually define the required
; function and you can look at the ACL2 output to see the measure
; conjectures and their proofs.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 96.
"
ACL2 !>>(DEFUN ACK (X Y)
          (DECLARE (XARGS :MEASURE (M2 (NFIX Y) (NFIX X))))
          (IF (ZP X)
              1
            (IF (ZP Y)
                (IF (EQUAL X 1) 2 (+ X 2))
              (ACK (ACK (- X 1) Y) (- Y 1)))))

For the admission of ACK we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(M2 (NFIX Y) (NFIX X)).  The non-trivial part of the measure conjecture
is

Goal
(AND (O-P (M2 (NFIX Y) (NFIX X)))
     (IMPLIES (AND (NOT (ZP X)) (NOT (ZP Y)))
              (O< (M2 (NFIX Y) (NFIX (+ -1 X)))
                  (M2 (NFIX Y) (NFIX X))))
     (IMPLIES (AND (NOT (ZP X)) (NOT (ZP Y)))
              (O< (M2 (NFIX (+ -1 Y))
                      (NFIX (ACK (+ -1 X) Y)))
                  (M2 (NFIX Y) (NFIX X))))).

By the simple :definition M2 we reduce the conjecture to the following
three conjectures.

Subgoal 3
(O-P (CONS (CONS 1 (+ 1 (NFIX Y)))
           (NFIX X))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER, O-FINP-CR and POSP-COMPOUND-RECOGNIZER,
the :definitions NFIX, O-FIRST-COEFF, O-FIRST-EXPT, O-P and O-RST,
the :executable-counterparts of EQUAL, O-P and O<, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS, O-FIRST-EXPT-DEF-O-FINP
and O-P-DEF-O-FINP-1.

Subgoal 2
(IMPLIES (AND (NOT (ZP X)) (NOT (ZP Y)))
         (O< (CONS (CONS 1 (+ 1 (NFIX Y)))
                   (NFIX (+ -1 X)))
             (CONS (CONS 1 (+ 1 (NFIX Y)))
                   (NFIX X)))).

But simplification reduces this to T, using the :compound-recognizer
rules O-FINP-CR and ZP-COMPOUND-RECOGNIZER, the :definitions NFIX,
O-FIRST-COEFF, O-FIRST-EXPT, O-RST and O<, the :executable-counterpart
of EQUAL, linear arithmetic, primitive type reasoning and the :rewrite
rules <-+-NEGATIVE-0-1, CAR-CONS, CDR-CONS and O-FINP-<.

Subgoal 1
(IMPLIES (AND (NOT (ZP X)) (NOT (ZP Y)))
         (O< (CONS (CONS 1 (+ 1 (NFIX (+ -1 Y))))
                   (NFIX (ACK (+ -1 X) Y)))
             (CONS (CONS 1 (+ 1 (NFIX Y)))
                   (NFIX X)))).

But simplification reduces this to T, using the :compound-recognizer
rules O-FINP-CR and ZP-COMPOUND-RECOGNIZER, the :definitions FIX, NFIX,
O-FIRST-COEFF and O-FIRST-EXPT, the :executable-counterpart of EQUAL,
linear arithmetic, primitive type reasoning and the :rewrite rules
<-+-NEGATIVE-0-1, CAR-CONS, CDR-CONS, MINUS-CANCELLATION-ON-LEFT and
O-FIRST-COEFF-<.

Q.E.D.

That completes the proof of the measure theorem for ACK.  Thus, we
admit this function under the principle of definition.  We observe
that the type of ACK is described by the theorem 
(AND (INTEGERP (ACK X Y)) (< 0 (ACK X Y))).  We used the :compound-
recognizer rule ZP-COMPOUND-RECOGNIZER and primitive type reasoning.

Summary
Form:  ( DEFUN ACK ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION FIX)
        (:DEFINITION M2)
        (:DEFINITION NFIX)
        (:DEFINITION O-FIRST-COEFF)
        (:DEFINITION O-FIRST-EXPT)
        (:DEFINITION O-P)
        (:DEFINITION O-RST)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART O-P)
        (:EXECUTABLE-COUNTERPART O<)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE <-+-NEGATIVE-0-1)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE MINUS-CANCELLATION-ON-LEFT)
        (:REWRITE O-FINP-<)
        (:REWRITE O-FIRST-COEFF-<)
        (:REWRITE O-FIRST-EXPT-DEF-O-FINP)
        (:REWRITE O-P-DEF-O-FINP-1))
 ACK
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 97.

; The proof of the existence of non-primitive recursive functions
; has not been carried out in ACL2 but was carried out in the
; closely related Nqthm.  See

; http://www.cs.utexas.edu/users/boyer/ftp/nqthm/nqthm-1992/examples/basic/pr.events
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 98.
"
ACL2 !>>(DEFUN F1 (I J)
          (DECLARE (XARGS :MEASURE
                          (IF (AND (NATP I) (NATP J) (< I J))
                              (- J I)
                            0)))
          (IF (AND (NATP I) (NATP J) (< I J))
              (F1 (+ 1 I) J)
            1))

For the admission of F1 we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(IF (AND (NATP I) (NATP J) (< I J)) (+ J (- I)) 0).  The non-trivial
part of the measure conjecture is

Goal
(AND (O-P (IF (AND (NATP I) (NATP J) (< I J))
              (+ J (- I))
            0))
     (IMPLIES (AND (NATP I) (NATP J) (< I J))
              (O< (IF (AND (NATP (+ 1 I))
                           (NATP J)
                           (< (+ 1 I) J))
                      (+ J (- (+ 1 I)))
                    0)
                  (IF (AND (NATP I) (NATP J) (< I J))
                      (+ J (- I))
                    0)))).

By the :executable-counterpart of UNARY-- and the simple :rewrite rule
DISTRIBUTIVITY-OF-MINUS-OVER-+ we reduce the conjecture to the following
two conjectures.

Subgoal 2
(O-P (IF (AND (NATP I) (NATP J) (< I J))
         (+ J (- I))
       0)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rules 
COMMUTATIVITY-OF-+ and O-P-DEF-O-FINP-1 and the :type-prescription
rule |x < y  =>  0 < -x+y|.

Subgoal 1
(IMPLIES (AND (NATP I) (NATP J) (< I J))
         (O< (IF (AND (NATP (+ 1 I))
                      (NATP J)
                      (< (+ 1 I) J))
                 (+ J -1 (- I))
               0)
             (IF (AND (NATP I) (NATP J) (< I J))
                 (+ J (- I))
               0))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :definition O< (if-intro),
primitive type reasoning, the :rewrite rules COMMUTATIVITY-2-OF-+ and
COMMUTATIVITY-OF-+ and the :type-prescription rule |x < y  =>  0 < -x+y|,
to the following two conjectures.

Subgoal 1.2
(IMPLIES (AND (NATP I)
              (NATP J)
              (< I J)
              (< (+ 1 I) J))
         (< (+ -1 (- I) J) (+ (- I) J))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 1.1
(IMPLIES (AND (NATP I)
              (NATP J)
              (< I J)
              (<= J (+ 1 I)))
         (< 0 (+ (- I) J))).

But we reduce the conjecture to T, by the simple :rewrite rule 
<-0-+-NEGATIVE-1.

Q.E.D.

That completes the proof of the measure theorem for F1.  Thus, we admit
this function under the principle of definition.  We observe that the
type of F1 is described by the theorem (EQUAL (F1 I J) 1).  

Summary
Form:  ( DEFUN F1 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE <-0-+-NEGATIVE-1)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DISTRIBUTIVITY-OF-MINUS-OVER-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:TYPE-PRESCRIPTION |x < y  =>  0 < -x+y|))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION O<))
 F1
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 99.
"
ACL2 !>>(DEFUN F2 (X)
          (DECLARE (XARGS :MEASURE (IF (EQUAL X NIL) 0 (+ 1 (CC X)))))
          (IF (EQUAL X NIL)
              2
            (AND (F2 (CAR X)) (F2 (CDR X)))))

For the admission of F2 we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(IF (EQUAL X NIL) 0 (+ 1 (CC X))).  The non-trivial part of the measure
conjecture is

Goal
(AND (O-P (IF (EQUAL X NIL) 0 (+ 1 (CC X))))
     (IMPLIES X
              (O< (IF (EQUAL (CAR X) NIL)
                      0
                    (+ 1 (CC (CAR X))))
                  (IF (EQUAL X NIL) 0 (+ 1 (CC X)))))
     (IMPLIES (AND X (F2 (CAR X)))
              (O< (IF (EQUAL (CDR X) NIL)
                      0
                    (+ 1 (CC (CDR X))))
                  (IF (EQUAL X NIL) 0 (+ 1 (CC X)))))).

By case analysis we reduce the conjecture to the following three conjectures.

Subgoal 3
(O-P (IF (EQUAL X NIL) 0 (+ 1 (CC X)))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, primitive type reasoning,
the :rewrite rule O-P-DEF-O-FINP-1 and the :type-prescription rule
CC.

Subgoal 2
(IMPLIES X
         (O< (IF (EQUAL (CAR X) NIL)
                 0
               (+ 1 (CC (CAR X))))
             (IF (EQUAL X NIL) 0 (+ 1 (CC X))))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definition O< (if-intro), primitive type reasoning and the :type-
prescription rule CC, to the following two conjectures.

Subgoal 2.2
(IMPLIES (AND X (CAR X))
         (< (+ 1 (CC (CAR X))) (+ 1 (CC X)))).

This simplifies, using the :meta rule CANCEL_PLUS-LESSP-CORRECT, to

Subgoal 2.2'
(IMPLIES (AND X (CAR X))
         (< (CC (CAR X)) (CC X))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following two goals.

Subgoal 2.2.2
(IMPLIES (AND (NOT (CONSP X)) X (CAR X))
         (< (CC (CAR X)) (CC X))).

But we reduce the conjecture to T, by case analysis.

Subgoal 2.2.1
(IMPLIES (AND (CONSP (CONS X1 X2))
              (CONS X1 X2)
              X1)
         (< (CC X1) (CC (CONS X1 X2)))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS
and CDR-CONS, to

Subgoal 2.2.1'
(IMPLIES (AND (CONS X1 X2) X1)
         (< 0 (+ 1 (CC X2)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.1
(IMPLIES (AND X (NOT (CAR X)))
         (< 0 (+ 1 (CC X)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 1
(IMPLIES (AND X (F2 (CAR X)))
         (O< (IF (EQUAL (CDR X) NIL)
                 0
               (+ 1 (CC (CDR X))))
             (IF (EQUAL X NIL) 0 (+ 1 (CC X))))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro) and O< (if-intro), primitive type reasoning
and the :type-prescription rule CC, to the following three conjectures.

Subgoal 1.3
(IMPLIES (AND X (F2 (CAR X)) (CDR X) (CONSP X))
         (< (+ 1 (CC (CDR X)))
            (+ 1 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 1.2
(IMPLIES (AND X (F2 (CAR X))
              (NOT (CDR X))
              (CONSP X))
         (< 0 (+ 1 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 1.1
(IMPLIES (AND X (F2 (CAR X))
              (CDR X)
              (NOT (CONSP X)))
         (< (+ 1 (CC (CDR X))) 1)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Q.E.D.

That completes the proof of the measure theorem for F2.  Thus, we admit
this function under the principle of definition.  We observe that the
type of F2 is described by the theorem (AND (INTEGERP (F2 X)) (< 1 (F2 X))).

Summary
Form:  ( DEFUN F2 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION CC)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION CC) (:DEFINITION O<))
 F2
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 100.
"
ACL2 !>>(DEFUN F3 (X Y)
          (DECLARE (XARGS :MEASURE (+ (CC X) (CC Y))))
          (IF (AND (ENDP X) (ENDP Y))
              3
            (F3 (CDR X) (CDR Y))))

For the admission of F3 we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(+ (CC X) (CC Y)).  The non-trivial part of the measure conjecture
is

Goal
(AND (O-P (+ (CC X) (CC Y)))
     (IMPLIES (NOT (AND (ENDP X) (ENDP Y)))
              (O< (+ (CC (CDR X)) (CC (CDR Y)))
                  (+ (CC X) (CC Y))))).

By case analysis we reduce the conjecture to the following two conjectures.

Subgoal 2
(O-P (+ (CC X) (CC Y))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, primitive type reasoning,
the :rewrite rule O-P-DEF-O-FINP-1 and the :type-prescription rule
CC.

Subgoal 1
(IMPLIES (NOT (AND (ENDP X) (ENDP Y)))
         (O< (+ (CC (CDR X)) (CC (CDR Y)))
             (+ (CC X) (CC Y)))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions ENDP (if-intro) and O<, primitive type reasoning and the
:type-prescription rule CC, to the following two conjectures.

Subgoal 1.2
(IMPLIES (CONSP X)
         (< (+ (CC (CDR X)) (CC (CDR Y)))
            (+ (CC X) (CC Y)))).

The destructor terms (CAR Y) and (CDR Y) can be eliminated by using
CAR-CDR-ELIM to replace Y by (CONS Y1 Y2), (CAR Y) by Y1 and (CDR Y)
by Y2.  This produces the following two goals.

Subgoal 1.2.2
(IMPLIES (AND (NOT (CONSP Y)) (CONSP X))
         (< (+ (CC (CDR X)) (CC (CDR Y)))
            (+ (CC X) (CC Y)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterpart of CC, the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CDR
and UNICITY-OF-0 and the :type-prescription rule CC, to

Subgoal 1.2.2'
(IMPLIES (AND (NOT (CONSP Y)) (CONSP X))
         (< (CC (CDR X)) (CC X))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal 1.2.2''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (CONSP Y)))
         (< (CC X2) (CC (CONS X1 X2)))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS
and CDR-CONS, to

Subgoal 1.2.2'''
(IMPLIES (NOT (CONSP Y))
         (< 0 (+ 1 (CC X1)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.1
(IMPLIES (AND (CONSP (CONS Y1 Y2)) (CONSP X))
         (< (+ (CC (CDR X)) (CC Y2))
            (+ (CC X) (CC (CONS Y1 Y2))))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and COMMUTATIVITY-OF-+, to

Subgoal 1.2.1'
(IMPLIES (CONSP X)
         (< (CC (CDR X)) (+ 1 (CC X) (CC Y1)))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal 1.2.1''
(IMPLIES (CONSP (CONS X1 X2))
         (< (CC X2)
            (+ 1 (CC (CONS X1 X2)) (CC Y1)))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterpart of BINARY-+, primitive type reasoning, the :meta rule 
CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS, CDR-CONS,
COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 1.2.1'''
(< 0 (+ 2 (CC X1) (CC Y1))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.1
(IMPLIES (CONSP Y)
         (< (+ (CC (CDR X)) (CC (CDR Y)))
            (+ (CC X) (CC Y)))).

The destructor terms (CAR Y) and (CDR Y) can be eliminated by using
CAR-CDR-ELIM to replace Y by (CONS Y1 Y2), (CAR Y) by Y1 and (CDR Y)
by Y2.  This produces the following goal.

Subgoal 1.1'
(IMPLIES (CONSP (CONS Y1 Y2))
         (< (+ (CC (CDR X)) (CC Y2))
            (+ (CC X) (CC (CONS Y1 Y2))))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and COMMUTATIVITY-OF-+, to

Subgoal 1.1''
(< (CC (CDR X)) (+ 1 (CC X) (CC Y1))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following two goals.

Subgoal 1.1.2
(IMPLIES (NOT (CONSP X))
         (< (CC (CDR X)) (+ 1 (CC X) (CC Y1)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterpart of CC, the :rewrite rules DEFAULT-CDR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.1.2'
(IMPLIES (NOT (CONSP X))
         (< 0 (+ 1 (CC Y1)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.1.1
(IMPLIES (CONSP (CONS X1 X2))
         (< (CC X2)
            (+ 1 (CC (CONS X1 X2)) (CC Y1)))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterpart of BINARY-+, primitive type reasoning, the :meta rule 
CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS, CDR-CONS,
COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 1.1.1'
(< 0 (+ 2 (CC X1) (CC Y1))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for F3.  Thus, we admit
this function under the principle of definition.  We observe that the
type of F3 is described by the theorem 
(AND (INTEGERP (F3 X Y)) (< 1 (F3 X Y))).  We used primitive type reasoning.

Summary
Form:  ( DEFUN F3 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION CC)
        (:DEFINITION ENDP)
        (:DEFINITION FIX)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CC)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ENDP))
 F3
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 101.

; I'd like to thank Anand Padmanaban for helping me formulate and
; solve this problem.

; The following mysterious incantation makes ACL2 add a new axiom,
; called problem-101a, that constrains m, p, dn, and up as stated in
; the problem.  For example, dn represents ``down'', and we know
; nothing about (up x).
"
ACL2 !>>(ENCAPSULATE ((P (X) T)
                      (DN (X) T)
                      (UP (X) T)
                      (M (X) T))
          (LOCAL (DEFUN P (X) (NOT (ZP X))))
          (LOCAL (DEFUN DN (X) (- X 1)))
          (LOCAL (DEFUN UP (X) X))
          (LOCAL (DEFUN M (X) (ACL2-COUNT X)))
          (THEOREM PROBLEM-101A
                   (AND (O-P (M X))
                        (IMPLIES (P X) (O< (M (DN X)) (M X))))))

To verify that the five encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(LOCAL (DEFUN P (X) (NOT (ZP X))))

Since P is non-recursive, its admission is trivial.  We observe that
the type of P is described by the theorem 
(OR (EQUAL (P X) T) (EQUAL (P X) NIL)).  

Summary
Form:  ( DEFUN P ...)
Rules: NIL
P


ACL2 !>>>(LOCAL (DEFUN DN (X) (- X 1)))

Since DN is non-recursive, its admission is trivial.  We observe that
the type of DN is described by the theorem (ACL2-NUMBERP (DN X)). 
We used primitive type reasoning.

Summary
Form:  ( DEFUN DN ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
DN


ACL2 !>>>(LOCAL (DEFUN UP (X) X))

Since UP is non-recursive, its admission is trivial.  We observe that
the type of UP is described by the theorem (EQUAL (UP X) X).  

Summary
Form:  ( DEFUN UP ...)
Rules: NIL
UP


ACL2 !>>>(LOCAL (DEFUN M (X) (ACL2-COUNT X)))

Since M is non-recursive, its admission is trivial.  We observe that
the type of M is described by the theorem 
(AND (INTEGERP (M X)) (<= 0 (M X))).  We used the :type-prescription
rule ACL2-COUNT.

Summary
Form:  ( DEFUN M ...)
Rules: ((:TYPE-PRESCRIPTION ACL2-COUNT))
M


ACL2 !>>>(THEOREM PROBLEM-101A
                  (AND (O-P (M X))
                       (IMPLIES (P X) (O< (M (DN X)) (M X)))))


ACL2 !>>>(DEFTHM PROBLEM-101A
           (AND (O-P (M X))
                (IMPLIES (P X) (O< (M (DN X)) (M X))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE))))

ACL2 Warning [Non-rec] in ( DEFTHM PROBLEM-101A ...):  A :REWRITE rule
generated from PROBLEM-101A will be triggered only by terms containing
the function symbol M, which has a non-recursive definition.  Unless
this definition is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Non-rec] in ( DEFTHM PROBLEM-101A ...):  A :REWRITE rule
generated from PROBLEM-101A will be triggered only by terms containing
the function symbols M and DN, which have non-recursive definitions.
Unless these definitions are disabled, this rule is unlikely ever to
be used.


[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions DN, M and P we reduce the conjecture to
the following two conjectures.

Subgoal 2
(O-P (ACL2-COUNT X)).

But we reduce the conjecture to T, by case analysis.

Subgoal 1
(IMPLIES (NOT (ZP X))
         (O< (ACL2-COUNT (+ -1 X))
             (ACL2-COUNT X))).

But we reduce the conjecture to T, by case analysis.

Q.E.D.

The storage of PROBLEM-101A depends upon the :type-prescription rules
O-P and O<.

Summary
Form:  ( DEFTHM PROBLEM-101A ...)
Rules: ((:DEFINITION DN)
        (:DEFINITION M)
        (:DEFINITION P)
        (:TYPE-PRESCRIPTION O-P)
        (:TYPE-PRESCRIPTION O<))
Warnings:  Non-rec
PROBLEM-101A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-101A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-101A)
PROBLEM-101A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-101A ...) ...)
Rules: NIL
Warnings:  Non-rec
PROBLEM-101A

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.

The following constraint is associated with every one of the functions
P, DN, UP and M:

(AND (O-P (M X)) (IMPLIES (P X) (O< (M (DN X)) (M X))))

Summary
Form:  ( ENCAPSULATE ((P ...) ...) ...)
Rules: NIL
Warnings:  Non-rec
 (P DN UP M)
ACL2 !>>(THEOREM
             PROBLEM-101B
             (IMPLIES (P X) (NOT (EQUAL (M X) 0)))
             :HINTS (("Goal" :USE ((:INSTANCE PROBLEM-101A (X X))
                                   (:INSTANCE PROBLEM-101A (X (DN X)))))))


ACL2 !>>>(DEFTHM PROBLEM-101B
           (IMPLIES (P X) (NOT (EQUAL (M X) 0)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :USE ((:INSTANCE PROBLEM-101A (X X))
                                 (:INSTANCE PROBLEM-101A (X (DN X)))))))

[Note:  A hint was supplied for the goal above.  Thanks!]

We augment the goal with the hypotheses provided by the :USE hint.
These hypotheses can be derived from PROBLEM-101A via instantiation.
We are left with the following subgoal.

Goal'
(IMPLIES (AND (AND (O-P (M X))
                   (IMPLIES (P X) (O< (M (DN X)) (M X))))
              (AND (O-P (M (DN X)))
                   (IMPLIES (P (DN X))
                            (O< (M (DN (DN X))) (M (DN X))))))
         (IMPLIES (P X) (NOT (EQUAL (M X) 0)))).

By case analysis we reduce the conjecture to

Goal''
(IMPLIES (AND (O-P (M X))
              (IMPLIES (P X) (O< (M (DN X)) (M X)))
              (O-P (M (DN X)))
              (IMPLIES (P (DN X))
                       (O< (M (DN (DN X))) (M (DN X))))
              (P X))
         (NOT (EQUAL (M X) 0))).

But simplification reduces this to T, using the :executable-counterparts
of NOT and O-P, the :rewrite rule |~(a<0)| and the :type-prescription
rule O-P.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-101B ...)
Rules: ((:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART O-P)
        (:REWRITE |~(a<0)|)
        (:TYPE-PRESCRIPTION O-P))
Hint-events: ((:USE PROBLEM-101A))
PROBLEM-101B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-101B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-101B)
PROBLEM-101B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-101B ...) ...)
Rules: NIL
 PROBLEM-101B
ACL2 !>>(THEOREM
             PROBLEM-101C
             (OR (CONSP (M X))
                 (AND (INTEGERP (M X)) (<= 0 (M X))))
             :RULE-CLASSES :TYPE-PRESCRIPTION
             :HINTS (("Goal" :USE ((:INSTANCE PROBLEM-101A (X X))
                                   (:INSTANCE PROBLEM-101A (X (DN X)))))))


ACL2 !>>>(DEFTHM PROBLEM-101C
           (OR (CONSP (M X))
               (AND (INTEGERP (M X)) (<= 0 (M X))))
           :RULE-CLASSES :TYPE-PRESCRIPTION
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :USE ((:INSTANCE PROBLEM-101A (X X))
                                 (:INSTANCE PROBLEM-101A (X (DN X)))))))

ACL2 Observation in ( DEFTHM PROBLEM-101C ...):  Our heuristics choose
(M X) as the :TYPED-TERM.

[Note:  A hint was supplied for the goal above.  Thanks!]

We augment the goal with the hypotheses provided by the :USE hint.
These hypotheses can be derived from PROBLEM-101A via instantiation.
We are left with the following subgoal.

Goal'
(IMPLIES (AND (AND (O-P (M X))
                   (IMPLIES (P X) (O< (M (DN X)) (M X))))
              (AND (O-P (M (DN X)))
                   (IMPLIES (P (DN X))
                            (O< (M (DN (DN X))) (M (DN X))))))
         (OR (CONSP (M X))
             (AND (INTEGERP (M X)) (<= 0 (M X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-101C ...)
Rules: ((:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM))
Hint-events: ((:USE PROBLEM-101A))
PROBLEM-101C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-101C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-101C)
PROBLEM-101C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-101C ...) ...)
Rules: NIL
 PROBLEM-101C
ACL2 !>>(THEOREM
             PROBLEM-101D
             (IMPLIES (P X)
                      (NOT (EQUAL (M (DN X)) (M X))))
             :HINTS (("Goal" :USE ((:INSTANCE PROBLEM-101A (X X))
                                   (:INSTANCE PROBLEM-101A (X (DN X)))))))


ACL2 !>>>(DEFTHM PROBLEM-101D
           (IMPLIES (P X)
                    (NOT (EQUAL (M (DN X)) (M X))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :USE ((:INSTANCE PROBLEM-101A (X X))
                                 (:INSTANCE PROBLEM-101A (X (DN X)))))))

[Note:  A hint was supplied for the goal above.  Thanks!]

We augment the goal with the hypotheses provided by the :USE hint.
These hypotheses can be derived from PROBLEM-101A via instantiation.
We are left with the following subgoal.

Goal'
(IMPLIES (AND (AND (O-P (M X))
                   (IMPLIES (P X) (O< (M (DN X)) (M X))))
              (AND (O-P (M (DN X)))
                   (IMPLIES (P (DN X))
                            (O< (M (DN (DN X))) (M (DN X))))))
         (IMPLIES (P X)
                  (NOT (EQUAL (M (DN X)) (M X))))).

By case analysis we reduce the conjecture to

Goal''
(IMPLIES (AND (O-P (M X))
              (IMPLIES (P X) (O< (M (DN X)) (M X)))
              (O-P (M (DN X)))
              (IMPLIES (P (DN X))
                       (O< (M (DN (DN X))) (M (DN X))))
              (P X))
         (NOT (EQUAL (M (DN X)) (M X)))).

But simplification reduces this to T, using primitive type reasoning,
the :forward-chaining rules |a <= b  =>  (a < b <=> ~(a = b))| and
|a = b  =>  (a <= b)| and the :type-prescription rules O-P and O<.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-101D ...)
Rules: ((:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING |a <= b  =>  (a < b <=> ~(a = b))|)
        (:FORWARD-CHAINING |a = b  =>  (a <= b)|)
        (:TYPE-PRESCRIPTION O-P)
        (:TYPE-PRESCRIPTION O<))
Hint-events: ((:USE PROBLEM-101A))
PROBLEM-101D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-101D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-101D)
PROBLEM-101D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-101D ...) ...)
Rules: NIL
 PROBLEM-101D
ACL2 !>>(DEFUN F4 (X Y Q)
         (DECLARE
          (XARGS
            :MEASURE
            (IF Q (IF (EQUAL (M X) 0)
                      1
                    (MAKE-ORD (M X) 1 1))
              (IF (EQUAL (M Y) 0)
                  2
                (MAKE-ORD (M Y) 1 2)))
            :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-101A PROBLEM-101B)))))
         (IF (P X)
             (IF Q (F4 Y (DN X) (NOT Q))
               (F4 Y (UP X) (NOT Q)))
           4))

For the admission of F4 we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(COND (Q (IF (EQUAL (M X) 0)
             1
           (MAKE-ORD (M X) 1 1)))
      ((EQUAL (M Y) 0) 2)
      (T (MAKE-ORD (M Y) 1 2))).
  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (COND (Q (IF (EQUAL (M X) 0)
                       1
                     (MAKE-ORD (M X) 1 1)))
                ((EQUAL (M Y) 0) 2)
                (T (MAKE-ORD (M Y) 1 2))))
     (IMPLIES (AND (P X) (NOT Q))
              (O< (COND ((NOT Q)
                         (IF (EQUAL (M Y) 0)
                             1
                           (MAKE-ORD (M Y) 1 1)))
                        ((EQUAL (M (UP X)) 0) 2)
                        (T (MAKE-ORD (M (UP X)) 1 2)))
                  (COND (Q (IF (EQUAL (M X) 0)
                               1
                             (MAKE-ORD (M X) 1 1)))
                        ((EQUAL (M Y) 0) 2)
                        (T (MAKE-ORD (M Y) 1 2)))))
     (IMPLIES (AND (P X) Q)
              (O< (COND ((NOT Q)
                         (IF (EQUAL (M Y) 0)
                             1
                           (MAKE-ORD (M Y) 1 1)))
                        ((EQUAL (M (DN X)) 0) 2)
                        (T (MAKE-ORD (M (DN X)) 1 2)))
                  (COND (Q (IF (EQUAL (M X) 0)
                               1
                             (MAKE-ORD (M X) 1 1)))
                        ((EQUAL (M Y) 0) 2)
                        (T (MAKE-ORD (M Y) 1 2)))))).

[Note:  A hint was supplied for the goal above.  Thanks!]

By case analysis we reduce the conjecture to the following three conjectures.

Subgoal 3
(O-P (COND (Q (IF (EQUAL (M X) 0)
                  1
                (MAKE-ORD (M X) 1 1)))
           ((EQUAL (M Y) 0) 2)
           (T (MAKE-ORD (M Y) 1 2)))).

This simplifies, using trivial observations, to the following four
conjectures.

Subgoal 3.4
(IMPLIES (AND Q (EQUAL (M X) 0))
         (O-P 1)).

But we reduce the conjecture to T, by the :executable-counterpart of
O-P.

Subgoal 3.3
(IMPLIES (AND Q (NOT (EQUAL (M X) 0)))
         (O-P (MAKE-ORD (M X) 1 1))).

But simplification reduces this to T, using the :executable-counterparts
of NOT, O-FIRST-EXPT, O-P and POSP and the :rewrite rules 
|0 < a  =  ~(a = 0)|, MAKE-ORD-O-P and PROBLEM-101A.

Subgoal 3.2
(IMPLIES (AND (NOT Q) (EQUAL (M Y) 0))
         (O-P 2)).

But we reduce the conjecture to T, by the :executable-counterpart of
O-P.

Subgoal 3.1
(IMPLIES (AND (NOT Q) (NOT (EQUAL (M Y) 0)))
         (O-P (MAKE-ORD (M Y) 1 2))).

But simplification reduces this to T, using the :executable-counterparts
of NOT, O-FIRST-EXPT, O-P and POSP and the :rewrite rules 
|0 < a  =  ~(a = 0)|, MAKE-ORD-O-P and PROBLEM-101A.

Subgoal 2
(IMPLIES (AND (P X) (NOT Q))
         (O< (COND ((NOT Q)
                    (IF (EQUAL (M Y) 0)
                        1
                      (MAKE-ORD (M Y) 1 1)))
                   ((EQUAL (M (UP X)) 0) 2)
                   (T (MAKE-ORD (M (UP X)) 1 2)))
             (COND (Q (IF (EQUAL (M X) 0)
                          1
                        (MAKE-ORD (M X) 1 1)))
                   ((EQUAL (M Y) 0) 2)
                   (T (MAKE-ORD (M Y) 1 2))))).

This simplifies, using the :executable-counterpart of NOT, to the following
two conjectures.

Subgoal 2.2
(IMPLIES (AND (P X) (EQUAL (M Y) 0))
         (O< 1 2)).

But we reduce the conjecture to T, by the :executable-counterpart of
O<.

Subgoal 2.1
(IMPLIES (AND (P X) (NOT (EQUAL (M Y) 0)))
         (O< (MAKE-ORD (M Y) 1 1)
             (MAKE-ORD (M Y) 1 2))).

But simplification reduces this to T, using the :executable-counterpart
of O< and the :rewrite rule O-RST-<.

Subgoal 1
(IMPLIES (AND (P X) Q)
         (O< (COND ((NOT Q)
                    (IF (EQUAL (M Y) 0)
                        1
                      (MAKE-ORD (M Y) 1 1)))
                   ((EQUAL (M (DN X)) 0) 2)
                   (T (MAKE-ORD (M (DN X)) 1 2)))
             (COND (Q (IF (EQUAL (M X) 0)
                          1
                        (MAKE-ORD (M X) 1 1)))
                   ((EQUAL (M Y) 0) 2)
                   (T (MAKE-ORD (M Y) 1 2))))).

This simplifies, using the :congruence rule IFF-IMPLIES-EQUAL-NOT,
the :executable-counterpart of NOT and the :rewrite rule PROBLEM-101B,
to the following two conjectures.

Subgoal 1.2
(IMPLIES (AND (P X) (EQUAL (M (DN X)) 0))
         (O< 2 (MAKE-ORD (M X) 1 1))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, primitive type reasoning, the :rewrite rule AC-< and
the :type-prescription rule MAKE-ORD.

Subgoal 1.1
(IMPLIES (AND (P X) (NOT (EQUAL (M (DN X)) 0)))
         (O< (MAKE-ORD (M (DN X)) 1 2)
             (MAKE-ORD (M X) 1 1))).

But simplification reduces this to T, using the :executable-counterparts
of NOT, O-FIRST-EXPT, O-P and POSP and the :rewrite rules 
|0 < a  =  ~(a = 0)|, MAKE-ORD-O-FIRST-EXPT, MAKE-ORD-O-P, O-FIRST-EXPT-<
and PROBLEM-101A.

Q.E.D.

That completes the proof of the measure theorem for F4.  Thus, we admit
this function under the principle of definition.  We observe that the
type of F4 is described by the theorem 
(AND (INTEGERP (F4 X Y Q)) (< 1 (F4 X Y Q))).  

Summary
Form:  ( DEFUN F4 ...)
Rules: ((:COMPOUND-RECOGNIZER O-FINP-CR)
        (:CONGRUENCE IFF-IMPLIES-EQUAL-NOT)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART O-FIRST-EXPT)
        (:EXECUTABLE-COUNTERPART O-P)
        (:EXECUTABLE-COUNTERPART O<)
        (:EXECUTABLE-COUNTERPART POSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE |0 < a  =  ~(a = 0)|)
        (:REWRITE AC-<)
        (:REWRITE MAKE-ORD-O-FIRST-EXPT)
        (:REWRITE MAKE-ORD-O-P)
        (:REWRITE O-FIRST-EXPT-<)
        (:REWRITE O-RST-<)
        (:REWRITE PROBLEM-101A)
        (:REWRITE PROBLEM-101B)
        (:TYPE-PRESCRIPTION MAKE-ORD))
 F4
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 102.
"
ACL2 !>>(THEOREM PROBLEM-102 (EQUAL (F1 I J) 1)
                 :HINTS (("Goal" :INDUCT (F1 I J))))


ACL2 !>>>(DEFTHM PROBLEM-102
           (EQUAL (F1 I J) 1)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (F1 I J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (F1 I J).

This suggestion was produced using the :induction rule F1.  If we let
(:P I J) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (AND (NATP I) (NATP J) (< I J)))
              (:P I J))
     (IMPLIES (AND (AND (NATP I) (NATP J) (< I J))
                   (:P (+ 1 I) J))
              (:P I J))).
This induction is justified by the same argument used to admit F1.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (AND (NATP I) (NATP J) (< I J)))
         (EQUAL (F1 I J) 1)).

But we reduce the conjecture to T, by primitive type reasoning and
the :type-prescription rule F1.

Subgoal *1/1
(IMPLIES (AND (AND (NATP I) (NATP J) (< I J))
              (EQUAL (F1 (+ 1 I) J) 1))
         (EQUAL (F1 I J) 1)).

But we reduce the conjecture to T, by primitive type reasoning and
the :type-prescription rule F1.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-102 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION F1)
        (:TYPE-PRESCRIPTION F1))
PROBLEM-102


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-102))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-102)
PROBLEM-102

Summary
Form:  ( PROGN (DEFTHM PROBLEM-102 ...) ...)
Rules: NIL
 PROBLEM-102
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 103.
"
ACL2 !>>(THEOREM PROBLEM-103 (EQUAL (F2 X) 2)
                 :HINTS (("Goal" :INDUCT (F2 X))))


ACL2 !>>>(DEFTHM PROBLEM-103
           (EQUAL (F2 X) 2)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (F2 X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (F2 X).

This suggestion was produced using the :induction rule F2.  If we let
(:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND X (NOT (F2 (CAR X))) (:P (CAR X)))
              (:P X))
     (IMPLIES (AND X (F2 (CAR X))
                   (:P (CAR X))
                   (:P (CDR X)))
              (:P X))
     (IMPLIES (NOT X) (:P X))).
This induction is justified by the same argument used to admit F2.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND X (NOT (F2 (CAR X)))
              (EQUAL (F2 (CAR X)) 2))
         (EQUAL (F2 X) 2)).

But we reduce the conjecture to T, by the :type-prescription rule F2.

Subgoal *1/2
(IMPLIES (AND X (F2 (CAR X))
              (EQUAL (F2 (CAR X)) 2)
              (EQUAL (F2 (CDR X)) 2))
         (EQUAL (F2 X) 2)).

But simplification reduces this to T, using the :definition F2, the
:executable-counterparts of EQUAL and NOT and primitive type reasoning.

Subgoal *1/1
(IMPLIES (NOT X) (EQUAL (F2 X) 2)).

But simplification reduces this to T, using the :executable-counterparts
of EQUAL and F2.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-103 ...)
Rules: ((:DEFINITION F2)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART F2)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION F2)
        (:TYPE-PRESCRIPTION F2))
PROBLEM-103


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-103))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-103)
PROBLEM-103

Summary
Form:  ( PROGN (DEFTHM PROBLEM-103 ...) ...)
Rules: NIL
 PROBLEM-103
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 104.
"
ACL2 !>>(THEOREM PROBLEM-104 (EQUAL (F3 X Y) 3)
                 :HINTS (("Goal" :INDUCT (F3 X Y))))


ACL2 !>>>(DEFTHM PROBLEM-104
           (EQUAL (F3 X Y) 3)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (F3 X Y))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (F3 X Y).

This suggestion was produced using the :induction rule F3.  If we let
(:P X Y) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (AND (ENDP X) (ENDP Y)))
                   (:P (CDR X) (CDR Y)))
              (:P X Y))
     (IMPLIES (AND (ENDP X) (ENDP Y))
              (:P X Y))).
This induction is justified by the same argument used to admit F3.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (AND (ENDP X) (ENDP Y)))
              (EQUAL (F3 (CDR X) (CDR Y)) 3))
         (EQUAL (F3 X Y) 3)).

This simplifies, using the :definitions ENDP and F3 and the :executable-
counterpart of EQUAL, to

Subgoal *1/2'
(IMPLIES (AND (CONSP Y)
              (EQUAL (F3 (CDR X) (CDR Y)) 3)
              (NOT (CONSP X)))
         (EQUAL (F3 NIL (CDR Y)) 3)).

But simplification reduces this to T, using the :rewrite rule DEFAULT-CDR.

Subgoal *1/1
(IMPLIES (AND (ENDP X) (ENDP Y))
         (EQUAL (F3 X Y) 3)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP X)) (NOT (CONSP Y)))
         (EQUAL (F3 X Y) 3)).

But simplification reduces this to T, using the :definition F3 and
the :executable-counterpart of EQUAL.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-104 ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION F3)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:INDUCTION F3)
        (:REWRITE DEFAULT-CDR))
PROBLEM-104


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-104))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-104)
PROBLEM-104

Summary
Form:  ( PROGN (DEFTHM PROBLEM-104 ...) ...)
Rules: NIL
 PROBLEM-104
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 105.
"
ACL2 !>>(THEOREM PROBLEM-105 (EQUAL (F4 X Y Q) 4)
                 :HINTS (("Goal" :INDUCT (F4 X Y Q))))


ACL2 !>>>(DEFTHM PROBLEM-105
           (EQUAL (F4 X Y Q) 4)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (F4 X Y Q))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (F4 X Y Q).

This suggestion was produced using the :induction rule F4.  If we let
(:P Q X Y) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (P X)) (:P Q X Y))
     (IMPLIES (AND (P X)
                   (NOT Q)
                   (:P (NOT Q) Y (UP X)))
              (:P Q X Y))
     (IMPLIES (AND (P X) Q (:P (NOT Q) Y (DN X)))
              (:P Q X Y))).
This induction is justified by the same argument used to admit F4.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (P X))
         (EQUAL (F4 X Y Q) 4)).

But simplification reduces this to T, using the :definition F4 and
the :executable-counterpart of EQUAL.

Subgoal *1/2
(IMPLIES (AND (P X)
              (NOT Q)
              (EQUAL (F4 Y (UP X) (NOT Q)) 4))
         (EQUAL (F4 X Y Q) 4)).

But simplification reduces this to T, using the :definition F4 and
the :executable-counterparts of EQUAL and NOT.

Subgoal *1/1
(IMPLIES (AND (P X)
              Q (EQUAL (F4 Y (DN X) (NOT Q)) 4))
         (EQUAL (F4 X Y Q) 4)).

But simplification reduces this to T, using the :congruence rule 
IFF-IMPLIES-EQUAL-NOT, the :definition F4 and the :executable-counterparts
of EQUAL and NOT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-105 ...)
Rules: ((:CONGRUENCE IFF-IMPLIES-EQUAL-NOT)
        (:DEFINITION F4)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:INDUCTION F4))
PROBLEM-105


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-105))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-105)
PROBLEM-105

Summary
Form:  ( PROGN (DEFTHM PROBLEM-105 ...) ...)
Rules: NIL
 PROBLEM-105
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 106.
"
ACL2 !>>(DEFUN FLATTEN! (X)
          (DECLARE (XARGS :MEASURE (M2 (CC X) (CC (CAR X)))))
          (IF (ATOM X)
              (CONS X NIL)
            (IF (ATOM (CAR X))
                (CONS (CAR X) (FLATTEN! (CDR X)))
              (FLATTEN! (CONS (CAAR X)
                              (CONS (CDAR X) (CDR X)))))))

For the admission of FLATTEN! we will use the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(M2 (CC X) (CC (CAR X))).  The non-trivial part of the measure conjecture
is

Goal
(AND (O-P (M2 (CC X) (CC (CAR X))))
     (IMPLIES (AND (NOT (ATOM X))
                   (NOT (ATOM (CAR X))))
              (O< (M2 (CC (LIST* (CAR (CAR X))
                                 (CDR (CAR X))
                                 (CDR X)))
                      (CC (CAR (LIST* (CAR (CAR X))
                                      (CDR (CAR X))
                                      (CDR X)))))
                  (M2 (CC X) (CC (CAR X)))))
     (IMPLIES (AND (NOT (ATOM X)) (ATOM (CAR X)))
              (O< (M2 (CC (CDR X)) (CC (CADR X)))
                  (M2 (CC X) (CC (CAR X)))))).

By the simple :definitions ATOM and M2 and the simple :rewrite rule
CAR-CONS we reduce the conjecture to the following three conjectures.

Subgoal 3
(O-P (CONS (CONS 1 (+ 1 (CC X)))
           (CC (CAR X)))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER, O-FINP-CR and POSP-COMPOUND-RECOGNIZER,
the :definitions O-FIRST-COEFF, O-FIRST-EXPT, O-P and O-RST, the :executable-
counterparts of EQUAL, O-P and O<, primitive type reasoning, the :rewrite
rules CAR-CONS, CDR-CONS, O-FIRST-EXPT-DEF-O-FINP and O-P-DEF-O-FINP-1
and the :type-prescription rule CC.

Subgoal 2
(IMPLIES (AND (CONSP X) (CONSP (CAR X)))
         (O< (CONS (CONS 1
                         (+ 1
                            (CC (LIST* (CAR (CAR X))
                                       (CDR (CAR X))
                                       (CDR X)))))
                   (CC (CAR (CAR X))))
             (CONS (CONS 1 (+ 1 (CC X)))
                   (CC (CAR X))))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, the :definitions CC, O-FIRST-COEFF, O-FIRST-EXPT, O-RST,
O< and SYNP, the :executable-counterparts of BINARY-+ and EQUAL, linear
arithmetic, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, FOLD-CONSTS-IN-+
and O-FINP-< and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (AND (CONSP X) (NOT (CONSP (CAR X))))
         (O< (CONS (CONS 1 (+ 1 (CC (CDR X))))
                   (CC (CADR X)))
             (CONS (CONS 1 (+ 1 (CC X)))
                   (CC (CAR X))))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, the :definitions CC, FIX, O-FIRST-COEFF, O-FIRST-EXPT
and SYNP, the :executable-counterparts of BINARY-+ and EQUAL, linear
arithmetic, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, FOLD-CONSTS-IN-+, O-FIRST-COEFF-< and UNICITY-OF-0 and the
:type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for FLATTEN!.  Thus,
we admit this function under the principle of definition.  We observe
that the type of FLATTEN! is described by the theorem 
(AND (CONSP (FLATTEN! X)) (TRUE-LISTP (FLATTEN! X))).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN FLATTEN! ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:DEFINITION ATOM)
        (:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION M2)
        (:DEFINITION NOT)
        (:DEFINITION O-FIRST-COEFF)
        (:DEFINITION O-FIRST-EXPT)
        (:DEFINITION O-P)
        (:DEFINITION O-RST)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART O-P)
        (:EXECUTABLE-COUNTERPART O<)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-FINP-<)
        (:REWRITE O-FIRST-COEFF-<)
        (:REWRITE O-FIRST-EXPT-DEF-O-FINP)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
 FLATTEN!
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 107.
"
ACL2 !>>(THEOREM PROBLEM-107
                 (EQUAL (FLATTEN! X) (FLATTEN X))
                 :HINTS (("Goal" :INDUCT (FLATTEN! X)
                                 :IN-THEORY (ENABLE PROBLEM-40))))


ACL2 !>>>(DEFTHM PROBLEM-107
           (EQUAL (FLATTEN! X) (FLATTEN X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FLATTEN! X)
                           :IN-THEORY (ENABLE PROBLEM-40))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FLATTEN! X).

This suggestion was produced using the :induction rule FLATTEN!.  If
we let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ATOM X))
                   (NOT (ATOM (CAR X)))
                   (:P (LIST* (CAR (CAR X))
                              (CDR (CAR X))
                              (CDR X))))
              (:P X))
     (IMPLIES (AND (NOT (ATOM X))
                   (ATOM (CAR X))
                   (:P (CDR X)))
              (:P X))
     (IMPLIES (ATOM X) (:P X))).
This induction is justified by the same argument used to admit FLATTEN!.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ATOM X))
              (NOT (ATOM (CAR X)))
              (EQUAL (FLATTEN! (LIST* (CAR (CAR X))
                                      (CDR (CAR X))
                                      (CDR X)))
                     (FLATTEN (LIST* (CAR (CAR X))
                                     (CDR (CAR X))
                                     (CDR X)))))
         (EQUAL (FLATTEN! X) (FLATTEN X))).

By the simple :definition ATOM we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (CONSP (CAR X))
              (EQUAL (FLATTEN! (LIST* (CAR (CAR X))
                                      (CDR (CAR X))
                                      (CDR X)))
                     (FLATTEN (LIST* (CAR (CAR X))
                                     (CDR (CAR X))
                                     (CDR X)))))
         (EQUAL (FLATTEN! X) (FLATTEN X))).

But simplification reduces this to T, using the :definitions FLATTEN
and FLATTEN!, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS and PROBLEM-40.

Subgoal *1/2
(IMPLIES (AND (NOT (ATOM X))
              (ATOM (CAR X))
              (EQUAL (FLATTEN! (CDR X))
                     (FLATTEN (CDR X))))
         (EQUAL (FLATTEN! X) (FLATTEN X))).

By the simple :definition ATOM we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (CONSP (CAR X)))
              (EQUAL (FLATTEN! (CDR X))
                     (FLATTEN (CDR X))))
         (EQUAL (FLATTEN! X) (FLATTEN X))).

But simplification reduces this to T, using the :definitions APP, FLATTEN
and FLATTEN!, the :executable-counterpart of CONSP, primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (ATOM X)
         (EQUAL (FLATTEN! X) (FLATTEN X))).

By the simple :definition ATOM we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (EQUAL (FLATTEN! X) (FLATTEN X))).

But simplification reduces this to T, using the :definitions FLATTEN
and FLATTEN! and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-107 ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION ATOM)
        (:DEFINITION FLATTEN)
        (:DEFINITION FLATTEN!)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FLATTEN!)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-40))
PROBLEM-107


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-107))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-107)
PROBLEM-107

Summary
Form:  ( PROGN (DEFTHM PROBLEM-107 ...) ...)
Rules: NIL
 PROBLEM-107
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 108.
"
ACL2 !>>(DEFUN GOPHER (X)
          (DECLARE (XARGS :MEASURE (CC (CAR X))))
          (IF (OR (ATOM X) (ATOM (CAR X)))
              X
            (GOPHER (CONS (CAR (CAR X))
                          (CONS (CDR (CAR X)) (CDR X))))))

For the admission of GOPHER we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(CC (CAR X)).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC (CAR X)))
     (IMPLIES (NOT (OR (ATOM X) (ATOM (CAR X))))
              (O< (CC (CAR (LIST* (CAR (CAR X))
                                  (CDR (CAR X))
                                  (CDR X))))
                  (CC (CAR X))))).

By the simple :rewrite rule CAR-CONS we reduce the conjecture to the
following two conjectures.

Subgoal 2
(O-P (CC (CAR X))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (NOT (OR (ATOM X) (ATOM (CAR X))))
         (O< (CC (CAR (CAR X))) (CC (CAR X)))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions ATOM and O< and the :type-prescription rule CC, to

Subgoal 1'
(IMPLIES (AND (CONSP X) (CONSP (CAR X)))
         (< (CC (CAR (CAR X))) (CC (CAR X)))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2.  (2) Use CAR-CDR-ELIM, again, to replace X1
by (CONS X3 X4), (CAR X1) by X3 and (CDR X1) by X4.  These steps produce
the following goal.

Subgoal 1''
(IMPLIES (AND (CONSP (CONS X3 X4))
              (CONSP (CONS (CONS X3 X4) X2)))
         (< (CC X3) (CC (CONS X3 X4)))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS
and CDR-CONS, to

Subgoal 1'''
(< 0 (+ 1 (CC X4))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for GOPHER.  Thus,
we admit this function under the principle of definition.  We observe
that the type of GOPHER is described by the theorem 
(OR (CONSP (GOPHER X)) (EQUAL (GOPHER X) X)).  We used primitive type
reasoning.

Summary
Form:  ( DEFUN GOPHER ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION ATOM)
        (:DEFINITION CC)
        (:DEFINITION O<)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:TYPE-PRESCRIPTION CC))
 GOPHER
ACL2 !>>(THEOREM PROBLEM-108A (<= (CC (GOPHER X)) (CC X))
                 :HINTS (("Goal" :INDUCT (GOPHER X)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-108A
           (<= (CC (GOPHER X)) (CC X))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (GOPHER X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (GOPHER X).

This suggestion was produced using the :induction rule GOPHER.  If
we let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (OR (ATOM X) (ATOM (CAR X))))
                   (:P (LIST* (CAR (CAR X))
                              (CDR (CAR X))
                              (CDR X))))
              (:P X))
     (IMPLIES (OR (ATOM X) (ATOM (CAR X)))
              (:P X))).
This induction is justified by the same argument used to admit GOPHER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (OR (ATOM X) (ATOM (CAR X))))
              (<= (CC (GOPHER (LIST* (CAR (CAR X))
                                     (CDR (CAR X))
                                     (CDR X))))
                  (CC (LIST* (CAR (CAR X))
                             (CDR (CAR X))
                             (CDR X)))))
         (<= (CC (GOPHER X)) (CC X))).

But simplification reduces this to T, using the :definitions ATOM,
CC, GOPHER and SYNP, the :executable-counterpart of BINARY-+, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, 
COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+.

Subgoal *1/1
(IMPLIES (OR (ATOM X) (ATOM (CAR X)))
         (<= (CC (GOPHER X)) (CC X))).

This simplifies, using the :definitions ATOM, CC and GOPHER and the
:executable-counterpart of <, to

Subgoal *1/1'
(IMPLIES (NOT (CONSP (CAR X)))
         (<= (CC X) (CC X))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-108A ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION CC)
        (:DEFINITION GOPHER)
        (:DEFINITION NOT)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION GOPHER)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE FOLD-CONSTS-IN-+))
PROBLEM-108A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-108A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-108A)
PROBLEM-108A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-108A ...) ...)
Rules: NIL
 PROBLEM-108A
ACL2 !>>(THEOREM PROBLEM-108B
                 (EQUAL (CONSP (GOPHER X)) (CONSP X))
                 :HINTS (("Goal" :INDUCT (GOPHER X))))


ACL2 !>>>(DEFTHM PROBLEM-108B
           (EQUAL (CONSP (GOPHER X)) (CONSP X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (GOPHER X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (GOPHER X).

This suggestion was produced using the :induction rule GOPHER.  If
we let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (OR (ATOM X) (ATOM (CAR X))))
                   (:P (LIST* (CAR (CAR X))
                              (CDR (CAR X))
                              (CDR X))))
              (:P X))
     (IMPLIES (OR (ATOM X) (ATOM (CAR X)))
              (:P X))).
This induction is justified by the same argument used to admit GOPHER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (OR (ATOM X) (ATOM (CAR X))))
              (EQUAL (CONSP (GOPHER (LIST* (CAR (CAR X))
                                           (CDR (CAR X))
                                           (CDR X))))
                     (CONSP (LIST* (CAR (CAR X))
                                   (CDR (CAR X))
                                   (CDR X)))))
         (EQUAL (CONSP (GOPHER X)) (CONSP X))).

But we reduce the conjecture to T, by primitive type reasoning and
the :type-prescription rule GOPHER.

Subgoal *1/1
(IMPLIES (OR (ATOM X) (ATOM (CAR X)))
         (EQUAL (CONSP (GOPHER X)) (CONSP X))).

But simplification reduces this to T, using the :definitions ATOM and
GOPHER, the :executable-counterpart of EQUAL and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-108B ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION GOPHER)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION GOPHER)
        (:TYPE-PRESCRIPTION GOPHER))
PROBLEM-108B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-108B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-108B)
PROBLEM-108B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-108B ...) ...)
Rules: NIL
 PROBLEM-108B
ACL2 !>>(THEOREM PROBLEM-108C
                 (IMPLIES (CONSP X)
                          (< (CC (CDR X)) (CC X)))
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-85)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-108C
           (IMPLIES (CONSP X)
                    (< (CC (CDR X)) (CC X)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-85))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But simplification reduces this to T, using linear arithmetic, the
:linear rule PROBLEM-85 and the :type-prescription rule CC.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-108C ...)
Rules: ((:FAKE-RUNE-FOR-LINEAR NIL)
        (:LINEAR PROBLEM-85)
        (:TYPE-PRESCRIPTION CC))
PROBLEM-108C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-108C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-108C)
PROBLEM-108C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-108C ...) ...)
Rules: NIL
 PROBLEM-108C
ACL2 !>>(THEOREM
             PROBLEM-108D
             (IMPLIES (CONSP X)
                      (< (CC (CDR (GOPHER X))) (CC X)))
             :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-108A
                                                PROBLEM-108B PROBLEM-108C))))


ACL2 !>>>(DEFTHM PROBLEM-108D
           (IMPLIES (CONSP X)
                    (< (CC (CDR (GOPHER X))) (CC X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-108A
                                              PROBLEM-108B PROBLEM-108C))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But simplification reduces this to T, using linear arithmetic, the
:linear rules PROBLEM-108A and PROBLEM-108C and the :type-prescription
rules CC and GOPHER.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-108D ...)
Rules: ((:FAKE-RUNE-FOR-LINEAR NIL)
        (:LINEAR PROBLEM-108A)
        (:LINEAR PROBLEM-108C)
        (:TYPE-PRESCRIPTION CC)
        (:TYPE-PRESCRIPTION GOPHER))
PROBLEM-108D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-108D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-108D)
PROBLEM-108D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-108D ...) ...)
Rules: NIL
 PROBLEM-108D
ACL2 !>>(DEFUN SAMEFRINGE (X Y)
         (DECLARE (XARGS :MEASURE (CC X)
                         :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-108D)))))
         (IF (OR (ATOM X) (ATOM Y))
             (EQUAL X Y)
           (AND (EQUAL (CAR (GOPHER X))
                       (CAR (GOPHER Y)))
                (SAMEFRINGE (CDR (GOPHER X))
                            (CDR (GOPHER Y))))))

For the admission of SAMEFRINGE we will use the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (AND (NOT (OR (ATOM X) (ATOM Y)))
                   (EQUAL (CAR (GOPHER X))
                          (CAR (GOPHER Y))))
              (O< (CC (CDR (GOPHER X))) (CC X)))).

[Note:  A hint was supplied for the goal above.  Thanks!]

By case analysis we reduce the conjecture to the following two conjectures.

Subgoal 2
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (AND (NOT (OR (ATOM X) (ATOM Y)))
              (EQUAL (CAR (GOPHER X))
                     (CAR (GOPHER Y))))
         (O< (CC (CDR (GOPHER X))) (CC X))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, the :definition ATOM, the :rewrite rules O-FINP-< and
PROBLEM-108D and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for SAMEFRINGE.  Thus,
we admit this function under the principle of definition.  We observe
that the type of SAMEFRINGE is described by the theorem 
(OR (EQUAL (SAMEFRINGE X Y) T) (EQUAL (SAMEFRINGE X Y) NIL)).  We used
primitive type reasoning.

Summary
Form:  ( DEFUN SAMEFRINGE ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION ATOM)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE O-FINP-<)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE PROBLEM-108D)
        (:TYPE-PRESCRIPTION CC))
 SAMEFRINGE
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 109.
"
ACL2 !>>(THEOREM PROBLEM-109A
                 (EQUAL (CAR (GOPHER X))
                        (IF (CONSP X) (CAR (FLATTEN X)) NIL))
                 :HINTS (("Goal" :INDUCT (GOPHER X)
                                 :IN-THEORY (ENABLE PROBLEM-40))))


ACL2 !>>>(DEFTHM PROBLEM-109A
           (EQUAL (CAR (GOPHER X))
                  (IF (CONSP X) (CAR (FLATTEN X)) NIL))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (GOPHER X)
                           :IN-THEORY (ENABLE PROBLEM-40))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (GOPHER X).

This suggestion was produced using the :induction rule GOPHER.  If
we let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (OR (ATOM X) (ATOM (CAR X))))
                   (:P (LIST* (CAR (CAR X))
                              (CDR (CAR X))
                              (CDR X))))
              (:P X))
     (IMPLIES (OR (ATOM X) (ATOM (CAR X)))
              (:P X))).
This induction is justified by the same argument used to admit GOPHER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (OR (ATOM X) (ATOM (CAR X))))
              (EQUAL (CAR (GOPHER (LIST* (CAR (CAR X))
                                         (CDR (CAR X))
                                         (CDR X))))
                     (AND (CONSP (LIST* (CAR (CAR X))
                                        (CDR (CAR X))
                                        (CDR X)))
                          (CAR (FLATTEN (LIST* (CAR (CAR X))
                                               (CDR (CAR X))
                                               (CDR X)))))))
         (EQUAL (CAR (GOPHER X))
                (AND (CONSP X) (CAR (FLATTEN X))))).

But simplification reduces this to T, using the :definitions ATOM,
FLATTEN and GOPHER, primitive type reasoning and the :rewrite rules
CAR-CONS, CDR-CONS and PROBLEM-40.

Subgoal *1/1
(IMPLIES (OR (ATOM X) (ATOM (CAR X)))
         (EQUAL (CAR (GOPHER X))
                (AND (CONSP X) (CAR (FLATTEN X))))).

This simplifies, using the :definitions ATOM (if-intro) and GOPHER,
the :executable-counterpart of EQUAL and the :rewrite rule DEFAULT-CAR,
to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (NOT (CONSP (CAR X))) (CONSP X))
         (EQUAL (CAR X) (CAR (FLATTEN X)))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/1.2'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (CONSP X1)))
         (EQUAL X1 (CAR (FLATTEN (CONS X1 X2))))).

But simplification reduces this to T, using the :definitions APP and
FLATTEN, the :executable-counterpart of CONSP, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1.1
(IMPLIES (AND (NOT (CONSP (CAR X)))
              (NOT (CONSP X)))
         (EQUAL (CAR X) NIL)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-109A ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION ATOM)
        (:DEFINITION FLATTEN)
        (:DEFINITION GOPHER)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION GOPHER)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE PROBLEM-40))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ATOM))
PROBLEM-109A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-109A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-109A)
PROBLEM-109A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-109A ...) ...)
Rules: NIL
 PROBLEM-109A
ACL2 !>>(THEOREM PROBLEM-109B
                 (EQUAL (FLATTEN (CDR (GOPHER X)))
                        (IF (CONSP X)
                            (CDR (FLATTEN X))
                          (CONS NIL NIL)))
                 :HINTS (("Goal" :INDUCT (GOPHER X)
                                 :IN-THEORY (ENABLE PROBLEM-40))))


ACL2 !>>>(DEFTHM PROBLEM-109B
           (EQUAL (FLATTEN (CDR (GOPHER X)))
                  (IF (CONSP X)
                      (CDR (FLATTEN X))
                    (CONS NIL NIL)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (GOPHER X)
                           :IN-THEORY (ENABLE PROBLEM-40))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (GOPHER X).

This suggestion was produced using the :induction rule GOPHER.  If
we let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (OR (ATOM X) (ATOM (CAR X))))
                   (:P (LIST* (CAR (CAR X))
                              (CDR (CAR X))
                              (CDR X))))
              (:P X))
     (IMPLIES (OR (ATOM X) (ATOM (CAR X)))
              (:P X))).
This induction is justified by the same argument used to admit GOPHER.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (OR (ATOM X) (ATOM (CAR X))))
              (EQUAL (FLATTEN (CDR (GOPHER (LIST* (CAR (CAR X))
                                                  (CDR (CAR X))
                                                  (CDR X)))))
                     (IF (CONSP (LIST* (CAR (CAR X))
                                       (CDR (CAR X))
                                       (CDR X)))
                         (CDR (FLATTEN (LIST* (CAR (CAR X))
                                              (CDR (CAR X))
                                              (CDR X))))
                       '(NIL))))
         (EQUAL (FLATTEN (CDR (GOPHER X)))
                (IF (CONSP X)
                    (CDR (FLATTEN X))
                  '(NIL)))).

But simplification reduces this to T, using the :definitions ATOM,
FLATTEN and GOPHER, primitive type reasoning and the :rewrite rules
CAR-CONS, CDR-CONS and PROBLEM-40.

Subgoal *1/1
(IMPLIES (OR (ATOM X) (ATOM (CAR X)))
         (EQUAL (FLATTEN (CDR (GOPHER X)))
                (IF (CONSP X)
                    (CDR (FLATTEN X))
                  '(NIL)))).

This simplifies, using the :definitions ATOM (if-intro) and GOPHER,
the :executable-counterparts of EQUAL and FLATTEN and the :rewrite
rule DEFAULT-CDR, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (NOT (CONSP (CAR X))) (CONSP X))
         (EQUAL (FLATTEN (CDR X))
                (CDR (FLATTEN X)))).

But simplification reduces this to T, using the :definitions APP and
FLATTEN, the :executable-counterpart of CONSP, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1.1
(IMPLIES (AND (NOT (CONSP (CAR X)))
              (NOT (CONSP X)))
         (EQUAL (FLATTEN (CDR X)) '(NIL))).

But simplification reduces this to T, using the :executable-counterparts
of CONSP, EQUAL and FLATTEN and the :rewrite rules DEFAULT-CAR and
DEFAULT-CDR.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-109B ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION ATOM)
        (:DEFINITION FLATTEN)
        (:DEFINITION GOPHER)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART FLATTEN)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION GOPHER)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE PROBLEM-40))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ATOM))
PROBLEM-109B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-109B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-109B)
PROBLEM-109B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-109B ...) ...)
Rules: NIL
 PROBLEM-109B
ACL2 !>>(THEOREM PROBLEM-109C
                 (EQUAL (EQUAL (CONS E NIL) (APP X Y))
                        (IF (CONSP X)
                            (AND (EQUAL (CAR X) E)
                                 (ATOM (CDR X))
                                 (EQUAL Y NIL))
                          (EQUAL Y (CONS E NIL))))
                 :HINTS (("Goal" :INDUCT (APP X Y))))


ACL2 !>>>(DEFTHM PROBLEM-109C
           (EQUAL (EQUAL (CONS E NIL) (APP X Y))
                  (IF (CONSP X)
                      (AND (EQUAL (CAR X) E)
                           (ATOM (CDR X))
                           (EQUAL Y NIL))
                    (EQUAL Y (CONS E NIL))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP X Y))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP X Y).

This suggestion was produced using the :induction rule APP.  If we
let (:P E X Y) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P E X Y))
     (IMPLIES (AND (CONSP X) (:P E (CDR X) Y))
              (:P E X Y))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (EQUAL (LIST E) (APP X Y))
                (IF (CONSP X)
                    (AND (EQUAL (CAR X) E)
                         (ATOM (CDR X))
                         (EQUAL Y NIL))
                  (EQUAL Y (LIST E))))).

This simplifies, using the :definition APP and primitive type reasoning,
to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP X)) (EQUAL (LIST E) Y))
         (EQUAL (EQUAL Y (LIST E)) T)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (EQUAL (LIST E) (APP (CDR X) Y))
                     (IF (CONSP (CDR X))
                         (AND (EQUAL (CADR X) E)
                              (ATOM (CDDR X))
                              (EQUAL Y NIL))
                       (EQUAL Y (LIST E)))))
         (EQUAL (EQUAL (LIST E) (APP X Y))
                (IF (CONSP X)
                    (AND (EQUAL (CAR X) E)
                         (ATOM (CDR X))
                         (EQUAL Y NIL))
                  (EQUAL Y (LIST E))))).

This simplifies, using the :definitions APP and ATOM (if-intro), the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CDR-CONS and CONS-EQUAL (if-intro) and the :type-prescription
rule APP, to the following four conjectures.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LIST E) (APP (CDR X) Y)))
              (CONSP (CDR X))
              (CONSP (CDDR X))
              (EQUAL E (CAR X)))
         (APP (CDR X) Y)).

This simplifies, using the :definition APP, primitive type reasoning
and the :rewrite rule CONS-EQUAL (if-intro), to the following two conjectures.

Subgoal *1/1.4.2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (CAR X) (CADR X)))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (CONS (CADR X) (APP (CDDR X) Y))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.4.1
(IMPLIES (AND (CONSP X)
              (APP (CDDR X) Y)
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (CONS (CADR X) (APP (CDDR X) Y))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LIST E) (APP (CDR X) Y)))
              (NOT (CONSP (CDR X)))
              (NOT (EQUAL Y (LIST E)))
              (EQUAL E (CAR X))
              (NOT (APP (CDR X) Y)))
         (NOT Y)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LIST E) (APP (CDR X) NIL)))
              (NOT (CONSP (CDR X)))
              (LIST E)
              (EQUAL E (CAR X))
              (APP (CDR X) NIL))
         Y).

But simplification reduces this to T, using the :definition APP and
primitive type reasoning.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LIST E) (APP (CDR X) Y)))
              (CONSP (CDR X))
              (NOT (EQUAL (CADR X) E))
              (EQUAL E (CAR X)))
         (APP (CDR X) Y)).

This simplifies, using primitive type reasoning, to

Subgoal *1/1.1'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (NOT (EQUAL (CADR X) (CAR X))))
         (APP (CDR X) Y)).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2.  (2) Use CAR-CDR-ELIM, again, to replace X2
by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  These steps produce
the following goal.

Subgoal *1/1.1''
(IMPLIES (AND (CONSP (CONS X3 X4))
              (CONSP (LIST* X1 X3 X4))
              (NOT (EQUAL X3 X1)))
         (APP (CONS X3 X4) Y)).

This simplifies, using the :definition APP, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to

Subgoal *1/1.1'''
(IMPLIES (NOT (EQUAL X3 X1))
         (CONS X3 (APP X4 Y))).

But simplification reduces this to T, using primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-109C ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION ATOM)
        (:DEFINITION NOT)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE CONS-EQUAL)
        (:TYPE-PRESCRIPTION APP))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ATOM)
             (:REWRITE CONS-EQUAL))
PROBLEM-109C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-109C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-109C)
PROBLEM-109C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-109C ...) ...)
Rules: NIL
 PROBLEM-109C
ACL2 !>>(THEOREM
             PROBLEM-109D
             (EQUAL (EQUAL (FLATTEN X) (CONS A NIL))
                    (AND (ATOM X) (EQUAL X A)))
             :HINTS (("Goal" :INDUCT (FLATTEN X)
                             :IN-THEORY (ENABLE PROBLEM-40 PROBLEM-109C))))


ACL2 !>>>(DEFTHM PROBLEM-109D
           (EQUAL (EQUAL (FLATTEN X) (CONS A NIL))
                  (AND (ATOM X) (EQUAL X A)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FLATTEN X)
                           :IN-THEORY (ENABLE PROBLEM-40 PROBLEM-109C))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FLATTEN X).

This suggestion was produced using the :induction rule FLATTEN.  If
we let (:P A X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P A X))
     (IMPLIES (AND (CONSP X)
                   (:P A (CAR X))
                   (:P A (CDR X)))
              (:P A X))).
This induction is justified by the same argument used to admit FLATTEN.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (EQUAL (FLATTEN X) (LIST A))
                (AND (ATOM X) (EQUAL X A)))).

But simplification reduces this to T, using the :definition FLATTEN,
the :executable-counterpart of EQUAL, primitive type reasoning and
the :rewrite rule CONS-EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (EQUAL (FLATTEN (CAR X)) (LIST A))
                     (AND (ATOM (CAR X)) (EQUAL (CAR X) A)))
              (EQUAL (EQUAL (FLATTEN (CDR X)) (LIST A))
                     (AND (ATOM (CDR X)) (EQUAL (CDR X) A))))
         (EQUAL (EQUAL (FLATTEN X) (LIST A))
                (AND (ATOM X) (EQUAL X A)))).

But simplification reduces this to T, using the :definitions ATOM and
FLATTEN, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules PROBLEM-109C and PROBLEM-40 and the :type-prescription
rules APP and FLATTEN.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-109D ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION FLATTEN)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FLATTEN)
        (:REWRITE CONS-EQUAL)
        (:REWRITE PROBLEM-109C)
        (:REWRITE PROBLEM-40)
        (:TYPE-PRESCRIPTION APP)
        (:TYPE-PRESCRIPTION FLATTEN))
PROBLEM-109D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-109D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-109D)
PROBLEM-109D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-109D ...) ...)
Rules: NIL
 PROBLEM-109D
ACL2 !>>(THEOREM
             PROBLEM-109
             (EQUAL (SAMEFRINGE X Y)
                    (EQUAL (FLATTEN X) (FLATTEN Y)))
             :HINTS (("Goal" :INDUCT (SAMEFRINGE X Y)
                             :IN-THEORY (ENABLE PROBLEM-109A
                                                PROBLEM-109B PROBLEM-109D))))


ACL2 !>>>(DEFTHM PROBLEM-109
           (EQUAL (SAMEFRINGE X Y)
                  (EQUAL (FLATTEN X) (FLATTEN Y)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (SAMEFRINGE X Y)
                           :IN-THEORY (ENABLE PROBLEM-109A
                                              PROBLEM-109B PROBLEM-109D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SAMEFRINGE X Y).

This suggestion was produced using the :induction rule SAMEFRINGE.
If we let (:P X Y) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (OR (ATOM X) (ATOM Y)))
                   (NOT (EQUAL (CAR (GOPHER X))
                               (CAR (GOPHER Y)))))
              (:P X Y))
     (IMPLIES (AND (NOT (OR (ATOM X) (ATOM Y)))
                   (EQUAL (CAR (GOPHER X))
                          (CAR (GOPHER Y)))
                   (:P (CDR (GOPHER X)) (CDR (GOPHER Y))))
              (:P X Y))
     (IMPLIES (OR (ATOM X) (ATOM Y))
              (:P X Y))).
This induction is justified by the same argument used to admit SAMEFRINGE.
Note, however, that the unmeasured variable Y is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (OR (ATOM X) (ATOM Y)))
              (NOT (EQUAL (CAR (GOPHER X))
                          (CAR (GOPHER Y)))))
         (EQUAL (SAMEFRINGE X Y)
                (EQUAL (FLATTEN X) (FLATTEN Y)))).

But simplification reduces this to T, using the :definitions ATOM and
SAMEFRINGE, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rule PROBLEM-109A and the :type-prescription rule FLATTEN.

Subgoal *1/2
(IMPLIES (AND (NOT (OR (ATOM X) (ATOM Y)))
              (EQUAL (CAR (GOPHER X))
                     (CAR (GOPHER Y)))
              (EQUAL (SAMEFRINGE (CDR (GOPHER X))
                                 (CDR (GOPHER Y)))
                     (EQUAL (FLATTEN (CDR (GOPHER X)))
                            (FLATTEN (CDR (GOPHER Y))))))
         (EQUAL (SAMEFRINGE X Y)
                (EQUAL (FLATTEN X) (FLATTEN Y)))).

But simplification reduces this to T, using the :definitions ATOM and
SAMEFRINGE, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules PROBLEM-109A and PROBLEM-109B and the :type-prescription
rule FLATTEN.

Subgoal *1/1
(IMPLIES (OR (ATOM X) (ATOM Y))
         (EQUAL (SAMEFRINGE X Y)
                (EQUAL (FLATTEN X) (FLATTEN Y)))).

This simplifies, using the :definitions ATOM, FLATTEN and SAMEFRINGE,
primitive type reasoning and the :rewrite rule PROBLEM-109D, to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP X)) (EQUAL X Y))
         (NOT (CONSP Y))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-109 ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION FLATTEN)
        (:DEFINITION NOT)
        (:DEFINITION SAMEFRINGE)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SAMEFRINGE)
        (:REWRITE PROBLEM-109A)
        (:REWRITE PROBLEM-109B)
        (:REWRITE PROBLEM-109D)
        (:TYPE-PRESCRIPTION FLATTEN))
PROBLEM-109


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-109))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-109)
PROBLEM-109

Summary
Form:  ( PROGN (DEFTHM PROBLEM-109 ...) ...)
Rules: NIL
 PROBLEM-109
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 110.

; McCarthy's idea was that (gopher x) returns a pair (ans . state)
; where ans is the left-most atom in the tree x and state is the state
; of the gopher co-routine.  Thus, if gopher is invoked on state it
; returns the next left-most atom, etc.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 111.
"
ACL2 !>>(DEFUN REL (FN X Y)
          (IF (EQUAL FN '<<=)
              (<<= X Y)
            (IF (EQUAL FN '>>=)
                (<<= Y X)
              (IF (EQUAL FN '<<)
                  (AND (<<= X Y) (NOT (EQUAL X Y)))
                (AND (<<= Y X) (NOT (EQUAL X Y)))))))

Since REL is non-recursive, its admission is trivial.  We observe that
the type of REL is described by the theorem 
(OR (EQUAL (REL FN X Y) T) (EQUAL (REL FN X Y) NIL)).  We used the
:type-prescription rule <<=.

Summary
Form:  ( DEFUN REL ...)
Rules: ((:TYPE-PRESCRIPTION <<=))
 REL
ACL2 !>>(DEFUN FILTER (FN X E)
          (COND ((ENDP X) NIL)
                ((REL FN (CAR X) E)
                 (CONS (CAR X) (FILTER FN (CDR X) E)))
                (T (FILTER FN (CDR X) E))))

The admission of FILTER is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of FILTER is described by
the theorem (TRUE-LISTP (FILTER FN X E)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN FILTER ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 FILTER
ACL2 !>>(THEOREM PROBLEM-111A
                 (<= (CC (FILTER FN X E)) (CC X))
                 :HINTS (("Goal" :INDUCT (CC X)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-111A
           (<= (CC (FILTER FN X E)) (CC X))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (CC X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (CC X).

This suggestion was produced using the :induction rule CC.  If we let
(:P E FN X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E FN X))
     (IMPLIES (AND (CONSP X)
                   (:P E FN (CAR X))
                   (:P E FN (CDR X)))
              (:P E FN X))).
This induction is justified by the same argument used to admit CC.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (<= (CC (FILTER FN X E)) (CC X))).

But simplification reduces this to T, using the :definitions CC and
FILTER and the :executable-counterparts of < and CC.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER FN (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER FN (CDR X) E))
                  (CC (CDR X))))
         (<= (CC (FILTER FN X E)) (CC X))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro)
and REL (if-intro), to the following ten conjectures.

Subgoal *1/1.10
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER '<<= (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER '<<= (CDR X) E))
                  (CC (CDR X)))
              (EQUAL FN '<<=)
              (LEXORDER (CAR X) E))
         (<= (CC (CONS (CAR X) (FILTER '<<= (CDR X) E)))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But simplification reduces this to T, using the :definition CC, primitive
type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.9
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER '<<= (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER '<<= (CDR X) E))
                  (CC (CDR X)))
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR X) E)))
         (<= (CC (FILTER '<<= (CDR X) E))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.8
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER FN (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER FN (CDR X) E))
                  (CC (CDR X)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (EQUAL (CAR X) E))
         (<= (CC (FILTER FN (CDR X) E))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.7
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER FN (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER FN (CDR X) E))
                  (CC (CDR X)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR X))))
         (<= (CC (FILTER FN (CDR X) E))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.6
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER FN (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER FN (CDR X) E))
                  (CC (CDR X)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E)))
         (<= (CC (CONS (CAR X) (FILTER FN (CDR X) E)))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But simplification reduces this to T, using the :definition CC, primitive
type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER '>>= (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER '>>= (CDR X) E))
                  (CC (CDR X)))
              (EQUAL FN '>>=)
              (LEXORDER E (CAR X)))
         (<= (CC (CONS (CAR X) (FILTER '>>= (CDR X) E)))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But simplification reduces this to T, using the :definition CC, primitive
type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER '>>= (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER '>>= (CDR X) E))
                  (CC (CDR X)))
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR X))))
         (<= (CC (FILTER '>>= (CDR X) E))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER '<< (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER '<< (CDR X) E))
                  (CC (CDR X)))
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) E)))
         (<= (CC (FILTER '<< (CDR X) E))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER '<< (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER '<< (CDR X) E))
                  (CC (CDR X)))
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E)))
         (<= (CC (CONS (CAR X) (FILTER '<< (CDR X) E)))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But simplification reduces this to T, using the :definition CC, primitive
type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (<= (CC (FILTER '<< (CAR X) E))
                  (CC (CAR X)))
              (<= (CC (FILTER '<< (CDR X) E))
                  (CC (CDR X)))
              (EQUAL FN '<<)
              (EQUAL (CAR X) E))
         (<= (CC (FILTER '<< (CDR X) E))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111A ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION CC)
        (:DEFINITION FILTER)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION CC)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FILTER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FILTER) (:DEFINITION REL))
PROBLEM-111A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111A)
PROBLEM-111A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111A ...) ...)
Rules: NIL
 PROBLEM-111A
ACL2 !>>(DEFUN QSORT (X)
          (DECLARE (XARGS :MEASURE (CC X)))
          (IF (ENDP X)
              NIL
            (IF (ENDP (CDR X))
                X
              (APP (QSORT (FILTER '<< (CDR X) (CAR X)))
                   (CONS (CAR X)
                         (QSORT (FILTER '>>= (CDR X) (CAR X))))))))

For the admission of QSORT we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (AND (NOT (ENDP X))
                   (NOT (ENDP (CDR X))))
              (O< (CC (FILTER '>>= (CDR X) (CAR X)))
                  (CC X)))
     (IMPLIES (AND (NOT (ENDP X))
                   (NOT (ENDP (CDR X))))
              (O< (CC (FILTER '<< (CDR X) (CAR X)))
                  (CC X)))).

By the simple :definition ENDP we reduce the conjecture to the following
three conjectures.

Subgoal 3
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 2
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (CC (FILTER '>>= (CDR X) (CAR X)))
             (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC and O<, primitive type reasoning and the :type-prescription
rule CC, to

Subgoal 2'
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (< (CC (FILTER '>>= (CDR X) (CAR X)))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal 2''
(IMPLIES (AND (CONSP (CONS X1 X2)) (CONSP X2))
         (< (CC (FILTER '>>= X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using primitive type reasoning, to

Subgoal 2'''
(IMPLIES (CONSP X2)
         (< (CC (FILTER '>>= X2 X1))
            (+ 1 (CC X1) (CC X2)))).

Name the formula above *1.

Subgoal 1
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (CC (FILTER '<< (CDR X) (CAR X)))
             (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC and O<, primitive type reasoning and the :type-prescription
rule CC, to

Subgoal 1'
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (< (CC (FILTER '<< (CDR X) (CAR X)))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal 1''
(IMPLIES (AND (CONSP (CONS X1 X2)) (CONSP X2))
         (< (CC (FILTER '<< X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using primitive type reasoning, to

Subgoal 1'''
(IMPLIES (CONSP X2)
         (< (CC (FILTER '<< X2 X1))
            (+ 1 (CC X1) (CC X2)))).

Name the formula above *2.

Perhaps we can prove *2 by induction.  Three induction schemes are
suggested by this conjecture.  These merge into two derived induction
schemes.  However, one of these is flawed and so we are left with one
viable candidate.  

We will induct according to a scheme suggested by (CC X2), but modified
to accommodate (FILTER '<< X2 X1).

These suggestions were produced using the :induction rules CC and FILTER.
If we let (:P X1 X2) denote *2 above then the induction scheme we'll
use is
(AND (IMPLIES (NOT (CONSP X2)) (:P X1 X2))
     (IMPLIES (AND (CONSP X2)
                   (:P X1 (CAR X2))
                   (:P X1 (CDR X2)))
              (:P X1 X2))).
This induction is justified by the same argument used to admit CC.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *2/4
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2)))))
         (< (CC (FILTER '<< X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro),
REL (if-intro) and SYNP, the :executable-counterparts of BINARY-+ and
EQUAL and the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+,
to the following three conjectures.

Subgoal *2/4.3
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (NOT (LEXORDER (CAR X2) X1)))
         (< (CC (FILTER '<< (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/4.2
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (LEXORDER (CAR X2) X1)
              (NOT (EQUAL (CAR X2) X1)))
         (< (CC (CONS (CAR X2)
                      (FILTER '<< (CDR X2) X1)))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS
and CDR-CONS and the :type-prescription rule FILTER, to

Subgoal *2/4.2'
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (LEXORDER (CAR X2) X1)
              (NOT (EQUAL (CAR X2) X1)))
         (< (+ 1 (CC (FILTER '<< (CDR X2) X1)))
            (+ 2 (CC X1) (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/4.1
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (EQUAL (CAR X2) X1))
         (< (CC (FILTER '<< (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/3
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2)))))
         (< (CC (FILTER '<< X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro),
REL (if-intro) and SYNP, the :executable-counterparts of BINARY-+ and
EQUAL and the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+,
to the following three conjectures.

Subgoal *2/3.3
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (NOT (LEXORDER (CAR X2) X1)))
         (< (CC (FILTER '<< (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/3.2
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (LEXORDER (CAR X2) X1)
              (NOT (EQUAL (CAR X2) X1)))
         (< (CC (CONS (CAR X2)
                      (FILTER '<< (CDR X2) X1)))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC and FIX, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS and UNICITY-OF-0 and
the :type-prescription rules CC and FILTER, to

Subgoal *2/3.2'
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (LEXORDER (CAR X2) X1)
              (NOT (EQUAL (CAR X2) X1)))
         (< (+ 1 (CC (FILTER '<< (CDR X2) X1)))
            (+ 2 (CC X1) (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/3.1
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '<< (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (EQUAL (CAR X2) X1))
         (< (CC (FILTER '<< (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/2
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2))))
         (< (CC (FILTER '<< X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro),
REL (if-intro) and SYNP, the :executable-counterparts of BINARY-+ and
EQUAL and the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+,
to the following three conjectures.

Subgoal *2/2.3
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (NOT (LEXORDER (CAR X2) X1)))
         (< (CC (FILTER '<< (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterpart of CC, the :rewrite rules COMMUTATIVITY-OF-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal *2/2.3'
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (NOT (LEXORDER (CAR X2) X1)))
         (< 0 (+ 2 (CC X1) (CC (CAR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/2.2
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (LEXORDER (CAR X2) X1)
              (NOT (EQUAL (CAR X2) X1)))
         (< (CC (CONS (CAR X2)
                      (FILTER '<< (CDR X2) X1)))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterpart of CC, primitive type reasoning, the :meta rule 
CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription rule
CC, to

Subgoal *2/2.2'
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (LEXORDER (CAR X2) X1)
              (NOT (EQUAL (CAR X2) X1)))
         (< 1 (+ 2 (CC X1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/2.1
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (EQUAL (CAR X2) X1))
         (< (CC (FILTER '<< (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterpart of CC, the :rewrite rules COMMUTATIVITY-OF-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal *2/2.1'
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '<< (CAR X2) (CAR X2)))
                 (+ 1 (CC (CAR X2)) (CC (CAR X2))))
              (NOT (CONSP (CDR X2))))
         (< 0 (+ 2 (CC (CAR X2)) (CC (CAR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/1
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2))))
         (< (CC (FILTER '<< X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro),
REL (if-intro) and SYNP, the :executable-counterparts of BINARY-+ and
EQUAL and the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+,
to the following three conjectures.

Subgoal *2/1.3
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (NOT (LEXORDER (CAR X2) X1)))
         (< (CC (FILTER '<< (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterparts of BINARY-+ and CC, the :rewrite rules COMMUTATIVITY-OF-+
and UNICITY-OF-0 and the :type-prescription rule CC, to

Subgoal *2/1.3'
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (NOT (LEXORDER (CAR X2) X1)))
         (< 0 (+ 2 (CC X1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/1.2
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (LEXORDER (CAR X2) X1)
              (NOT (EQUAL (CAR X2) X1)))
         (< (CC (CONS (CAR X2)
                      (FILTER '<< (CDR X2) X1)))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterparts of BINARY-+ and CC, primitive type reasoning, the :rewrite
rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the
:type-prescription rule CC, to

Subgoal *2/1.2'
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (LEXORDER (CAR X2) X1)
              (NOT (EQUAL (CAR X2) X1)))
         (< 1 (+ 2 (CC X1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *2/1.1
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (EQUAL (CAR X2) X1))
         (< (CC (FILTER '<< (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

But simplification reduces this to T, using the :definitions CC and
FILTER and the :executable-counterparts of <, BINARY-+ and CC.

That completes the proof of *2.

We therefore turn our attention to *1, which is

(IMPLIES (CONSP X2)
         (< (CC (FILTER '>>= X2 X1))
            (+ 1 (CC X1) (CC X2)))).

Perhaps we can prove *1 by induction.  Three induction schemes are
suggested by this conjecture.  These merge into two derived induction
schemes.  However, one of these is flawed and so we are left with one
viable candidate.  

We will induct according to a scheme suggested by (CC X2), but modified
to accommodate (FILTER '>>= X2 X1).

These suggestions were produced using the :induction rules CC and FILTER.
If we let (:P X1 X2) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (NOT (CONSP X2)) (:P X1 X2))
     (IMPLIES (AND (CONSP X2)
                   (:P X1 (CAR X2))
                   (:P X1 (CDR X2)))
              (:P X1 X2))).
This induction is justified by the same argument used to admit CC.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1/4
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '>>= (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2)))))
         (< (CC (FILTER '>>= X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro),
REL and SYNP, the :executable-counterparts of BINARY-+ and EQUAL and
the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to the
following two conjectures.

Subgoal *1/4.2
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '>>= (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (LEXORDER X1 (CAR X2)))
         (< (CC (CONS (CAR X2)
                      (FILTER '>>= (CDR X2) X1)))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS
and CDR-CONS and the :type-prescription rule FILTER, to

Subgoal *1/4.2'
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '>>= (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (LEXORDER X1 (CAR X2)))
         (< (+ 1 (CC (FILTER '>>= (CDR X2) X1)))
            (+ 2 (CC X1) (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/4.1
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (< (CC (FILTER '>>= (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (NOT (LEXORDER X1 (CAR X2))))
         (< (CC (FILTER '>>= (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '>>= (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2)))))
         (< (CC (FILTER '>>= X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro),
REL and SYNP, the :executable-counterparts of BINARY-+ and EQUAL and
the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to the
following two conjectures.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '>>= (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (LEXORDER X1 (CAR X2)))
         (< (CC (CONS (CAR X2)
                      (FILTER '>>= (CDR X2) X1)))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC and FIX, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS and UNICITY-OF-0 and
the :type-prescription rules CC and FILTER, to

Subgoal *1/3.2'
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '>>= (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (LEXORDER X1 (CAR X2)))
         (< (+ 1 (CC (FILTER '>>= (CDR X2) X1)))
            (+ 2 (CC X1) (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (< (CC (FILTER '>>= (CDR X2) X1))
                 (+ 1 (CC X1) (CC (CDR X2))))
              (NOT (LEXORDER X1 (CAR X2))))
         (< (CC (FILTER '>>= (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2))))
         (< (CC (FILTER '>>= X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro),
REL and SYNP, the :executable-counterparts of BINARY-+ and EQUAL and
the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to the
following two conjectures.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (LEXORDER X1 (CAR X2)))
         (< (CC (CONS (CAR X2)
                      (FILTER '>>= (CDR X2) X1)))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterpart of CC, primitive type reasoning, the :meta rule 
CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription rule
CC, to

Subgoal *1/2.2'
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (LEXORDER X1 (CAR X2)))
         (< 1 (+ 2 (CC X1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (NOT (LEXORDER X1 (CAR X2))))
         (< (CC (FILTER '>>= (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterpart of CC, the :rewrite rules COMMUTATIVITY-OF-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal *1/2.1'
(IMPLIES (AND (CONSP X2)
              (< (CC (FILTER '>>= (CAR X2) X1))
                 (+ 1 (CC X1) (CC (CAR X2))))
              (NOT (CONSP (CDR X2)))
              (NOT (LEXORDER X1 (CAR X2))))
         (< 0 (+ 2 (CC X1) (CC (CAR X2))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2))))
         (< (CC (FILTER '>>= X2 X1))
            (+ 1 (CC X1) (CC X2)))).

This simplifies, using the :definitions <<=, CC, FILTER (if-intro),
REL and SYNP, the :executable-counterparts of BINARY-+ and EQUAL and
the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to the
following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (LEXORDER X1 (CAR X2)))
         (< (CC (CONS (CAR X2)
                      (FILTER '>>= (CDR X2) X1)))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterparts of BINARY-+ and CC, primitive type reasoning, the :rewrite
rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the
:type-prescription rule CC, to

Subgoal *1/1.2'
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (LEXORDER X1 (CAR X2)))
         (< 1 (+ 2 (CC X1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (NOT (LEXORDER X1 (CAR X2))))
         (< (CC (FILTER '>>= (CDR X2) X1))
            (+ 2 (CC X1)
               (CC (CAR X2))
               (CC (CDR X2))))).

This simplifies, using the :definitions CC, FILTER and FIX, the :executable-
counterparts of BINARY-+ and CC, the :rewrite rules COMMUTATIVITY-OF-+
and UNICITY-OF-0 and the :type-prescription rule CC, to

Subgoal *1/1.1'
(IMPLIES (AND (CONSP X2)
              (NOT (CONSP (CAR X2)))
              (NOT (CONSP (CDR X2)))
              (NOT (LEXORDER X1 (CAR X2))))
         (< 0 (+ 2 (CC X1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

That completes the proof of the measure theorem for QSORT.  Thus, we
admit this function under the principle of definition.  We observe
that the type of QSORT is described by the theorem 
(OR (CONSP (QSORT X)) (EQUAL (QSORT X) NIL)).  We used primitive type
reasoning and the :type-prescription rule APP.

Summary
Form:  ( DEFUN QSORT ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION <<=)
        (:DEFINITION CC)
        (:DEFINITION ENDP)
        (:DEFINITION FILTER)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:DEFINITION REL)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION CC)
        (:INDUCTION FILTER)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION APP)
        (:TYPE-PRESCRIPTION CC)
        (:TYPE-PRESCRIPTION FILTER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FILTER) (:DEFINITION REL))
 QSORT
ACL2 !>>(THEOREM
             PROBLEM-111B
             (AND (BOOLEANP (PERM X Y))
                  (PERM X X)
                  (IMPLIES (PERM X Y) (PERM Y X))
                  (IMPLIES (AND (PERM X Y) (PERM Y Z))
                           (PERM X Z)))
             :HINTS
             (("Goal" :IN-THEORY (ENABLE PROBLEM-53 PROBLEM-54 PROBLEM-55)))
             :RULE-CLASSES (:EQUIVALENCE))


ACL2 !>>>(DEFTHM PROBLEM-111B
           (AND (BOOLEANP (PERM X Y))
                (PERM X X)
                (IMPLIES (PERM X Y) (PERM Y X))
                (IMPLIES (AND (PERM X Y) (PERM Y Z))
                         (PERM X Z)))
           :RULE-CLASSES (:EQUIVALENCE)
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :IN-THEORY (ENABLE PROBLEM-53 PROBLEM-54 PROBLEM-55))))

ACL2 Warning [Equiv] in ( DEFTHM PROBLEM-111B ...):  Any lemma about
(PERM X Y), proved before PERM is marked as an equivalence relation,
is stored so as to rewrite (PERM X Y) to T.  After PERM is known to
be an equivalence relation, such a rule would rewrite the left-hand
side to the right-hand side, preserving PERM.  You have previously
proved three possibly problematic rules about PERM, namely PROBLEM-59,
PROBLEM-59A and PROBLEM-55E.  After PERM is marked as an equivalence
relation you should reconsider each problematic rule.  If the rule
is merely in support of establishing that PERM is an equivalence relation,
it may be appropriate to disable it permanently hereafter.  If the
rule is now intended to rewrite left to right, you must prove the lemma
again after PERM is known to be an equivalence relation.


[Note:  A hint was supplied for the goal above.  Thanks!]

By the :executable-counterpart of TAU-SYSTEM and the simple :rewrite
rule PROBLEM-53 we reduce the conjecture to the following two conjectures.

Subgoal 2
(IMPLIES (PERM X Y) (PERM Y X)).

But simplification reduces this to T, using the :rewrite rule PROBLEM-54
and the :type-prescription rule PERM.

Subgoal 1
(IMPLIES (AND (PERM X Y) (PERM Y Z))
         (PERM X Z)).

But simplification reduces this to T, using the :rewrite rule PROBLEM-55
and the :type-prescription rule PERM.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111B ...)
Rules: ((:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:REWRITE PROBLEM-53)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-55)
        (:TYPE-PRESCRIPTION PERM))
Warnings:  Equiv
PROBLEM-111B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111B)
PROBLEM-111B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111B ...) ...)
Rules: NIL
Warnings:  Equiv
 PROBLEM-111B
ACL2 !>>(THEOREM PROBLEM-111C
                 (IMPLIES (NOT (REL FN D E))
                          (EQUAL (FILTER FN (RM D Y) E)
                                 (FILTER FN Y E)))
                 :HINTS (("Goal" :INDUCT (FILTER FN Y E))))


ACL2 !>>>(DEFTHM PROBLEM-111C
           (IMPLIES (NOT (REL FN D E))
                    (EQUAL (FILTER FN (RM D Y) E)
                           (FILTER FN Y E)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FILTER FN Y E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FILTER FN Y E).

This suggestion was produced using the :induction rule FILTER.  If
we let (:P D E FN Y) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (ENDP Y))
                   (NOT (REL FN (CAR Y) E))
                   (:P D E FN (CDR Y)))
              (:P D E FN Y))
     (IMPLIES (AND (NOT (ENDP Y))
                   (REL FN (CAR Y) E)
                   (:P D E FN (CDR Y)))
              (:P D E FN Y))
     (IMPLIES (ENDP Y) (:P D E FN Y))).
This induction is justified by the same argument used to admit FILTER.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP Y))
              (NOT (REL FN (CAR Y) E))
              (IMPLIES (NOT (REL FN D E))
                       (EQUAL (FILTER FN (RM D (CDR Y)) E)
                              (FILTER FN (CDR Y) E))))
         (IMPLIES (NOT (REL FN D E))
                  (EQUAL (FILTER FN (RM D Y) E)
                         (FILTER FN Y E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP Y)
              (NOT (REL FN (CAR Y) E))
              (IMPLIES (NOT (REL FN D E))
                       (EQUAL (FILTER FN (RM D (CDR Y)) E)
                              (FILTER FN (CDR Y) E)))
              (NOT (REL FN D E)))
         (EQUAL (FILTER FN (RM D Y) E)
                (FILTER FN Y E))).

This simplifies, using the :definitions <<=, FILTER (if-intro), NOT
(if-intro), REL (if-intro) and RM (if-intro), the :executable-counterpart
of EQUAL, primitive type reasoning, the :rewrite rules LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER, to
the following 14 conjectures.

Subgoal *1/3.14
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR Y) E))
              (EQUAL (FILTER '<<= (RM D (CDR Y)) E)
                     (FILTER '<<= (CDR Y) E))
              (NOT (LEXORDER D E))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '<<=
                        (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (FILTER '<<= (CDR Y) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/3.13
(IMPLIES (AND (CONSP Y)
              (EQUAL (CAR Y) E)
              (NOT (LEXORDER D E))
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E))
              (EQUAL FN '<<)
              (NOT (EQUAL D E)))
         (EQUAL (FILTER '<< (CONS E (RM D (CDR Y))) E)
                (FILTER '<< (CDR Y) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.12
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (EQUAL (CAR Y) E)
              (NOT (LEXORDER D E))
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (NOT (LEXORDER E D))
              (NOT (EQUAL D E)))
         (EQUAL (FILTER FN (CONS E (RM D (CDR Y))) E)
                (FILTER FN (CDR Y) E))).

But simplification reduces this to T, using primitive type reasoning
and the :forward-chaining rule LEXORDER-TOTAL.

Subgoal *1/3.11
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (EQUAL (CAR Y) E)
              (NOT (EQUAL FN '<<))
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (NOT (LEXORDER E D))
              (NOT (EQUAL D E)))
         (EQUAL (FILTER FN (CONS E (RM D (CDR Y))) E)
                (FILTER FN (CDR Y) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.10
(IMPLIES (AND (CONSP Y)
              (NOT (LEXORDER E (CAR Y)))
              (EQUAL FN '>>=)
              (EQUAL (FILTER '>>= (RM D (CDR Y)) E)
                     (FILTER '>>= (CDR Y) E))
              (NOT (LEXORDER E D))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '>>=
                        (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (FILTER '>>= (CDR Y) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/3.9
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR Y)))
              (EQUAL D E)
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL D (CAR Y)))
              (LEXORDER D (CAR Y)))
         (EQUAL (FILTER FN (CONS (CAR Y) (RM D (CDR Y)))
                        D)
                (CONS (CAR Y) (FILTER FN (CDR Y) D)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.8
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR Y)))
              (EQUAL D E)
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL D (CAR Y)))
              (NOT (LEXORDER D (CAR Y))))
         (EQUAL (FILTER FN (CONS (CAR Y) (RM D (CDR Y)))
                        D)
                (FILTER FN (CDR Y) D))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, primitive type reasoning and the :rewrite rules CAR-CONS and
CDR-CONS.

Subgoal *1/3.7
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR Y)))
              (NOT (LEXORDER E D))
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER FN (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (FILTER FN (CDR Y) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, primitive type reasoning and the :rewrite rules CAR-CONS and
CDR-CONS.

Subgoal *1/3.6
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<)
              (EQUAL (CAR Y) E)
              (NOT (LEXORDER D E))
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E))
              (NOT (EQUAL D E)))
         (EQUAL (FILTER '<< (CONS E (RM D (CDR Y))) E)
                (FILTER '<< (CDR Y) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.5
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<)
              (EQUAL (CAR Y) E)
              (EQUAL D E)
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E)))
         (EQUAL (FILTER '<< (CDR Y) D)
                (FILTER '<< Y D))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule LEXORDER-REFLEXIVE.

Subgoal *1/3.4
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR Y) E))
              (NOT (LEXORDER D E))
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '<<
                        (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (FILTER '<< (CDR Y) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/3.3
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR Y) E))
              (EQUAL D E)
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E))
              (EQUAL D (CAR Y)))
         (EQUAL (FILTER '<< (CDR Y) D)
                (FILTER '<< Y D))).

But simplification reduces this to T, using primitive type reasoning
and the :forward-chaining rule LEXORDER-TOTAL.

Subgoal *1/3.2
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR Y) E))
              (EQUAL D E)
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '<<
                        (CONS (CAR Y) (RM D (CDR Y)))
                        D)
                (FILTER '<< Y D))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/3.1
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR Y)))
              (EQUAL (FILTER '>>= (RM D (CDR Y)) E)
                     (FILTER '>>= (CDR Y) E))
              (NOT (LEXORDER E D))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '>>=
                        (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (FILTER '>>= (CDR Y) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP Y))
              (REL FN (CAR Y) E)
              (IMPLIES (NOT (REL FN D E))
                       (EQUAL (FILTER FN (RM D (CDR Y)) E)
                              (FILTER FN (CDR Y) E))))
         (IMPLIES (NOT (REL FN D E))
                  (EQUAL (FILTER FN (RM D Y) E)
                         (FILTER FN Y E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP Y)
              (REL FN (CAR Y) E)
              (IMPLIES (NOT (REL FN D E))
                       (EQUAL (FILTER FN (RM D (CDR Y)) E)
                              (FILTER FN (CDR Y) E)))
              (NOT (REL FN D E)))
         (EQUAL (FILTER FN (RM D Y) E)
                (FILTER FN Y E))).

This simplifies, using the :definitions <<=, FILTER (if-intro), NOT
(if-intro), REL (if-intro) and RM (if-intro), the :executable-counterpart
of EQUAL, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER, to the following thirteen conjectures.

Subgoal *1/2.13
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<=)
              (LEXORDER (CAR Y) E)
              (EQUAL (FILTER '<<= (RM D (CDR Y)) E)
                     (FILTER '<<= (CDR Y) E))
              (NOT (LEXORDER D E))
              (EQUAL D (CAR Y)))
         (EQUAL (FILTER '<<= (CDR Y) E)
                (CONS (CAR Y)
                      (FILTER '<<= (CDR Y) E)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.12
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<=)
              (LEXORDER (CAR Y) E)
              (EQUAL (FILTER '<<= (RM D (CDR Y)) E)
                     (FILTER '<<= (CDR Y) E))
              (NOT (LEXORDER D E))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '<<=
                        (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (CONS (CAR Y)
                      (FILTER '<<= (CDR Y) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.11
(IMPLIES (AND (CONSP Y)
              (LEXORDER E (CAR Y))
              (NOT (EQUAL (CAR Y) E))
              (EQUAL FN '>>=)
              (EQUAL (FILTER '>>= (RM D (CDR Y)) E)
                     (FILTER '>>= (CDR Y) E))
              (NOT (LEXORDER E D))
              (EQUAL D (CAR Y)))
         (EQUAL (FILTER '>>= (CDR Y) E)
                (CONS (CAR Y)
                      (FILTER '>>= (CDR Y) E)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.10
(IMPLIES (AND (CONSP Y)
              (LEXORDER E (CAR Y))
              (NOT (EQUAL (CAR Y) E))
              (EQUAL FN '>>=)
              (EQUAL (FILTER '>>= (RM D (CDR Y)) E)
                     (FILTER '>>= (CDR Y) E))
              (NOT (LEXORDER E D))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '>>=
                        (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (CONS (CAR Y)
                      (FILTER '>>= (CDR Y) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.9
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR Y))
              (NOT (EQUAL (CAR Y) E))
              (EQUAL D E)
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (NOT (EQUAL FN '>>=))
              (LEXORDER D (CAR Y)))
         (EQUAL (CONS (CAR Y)
                      (FILTER FN (RM D (CDR Y)) D))
                (CONS (CAR Y) (FILTER FN (CDR Y) D)))).

But simplification reduces this to T, using primitive type reasoning.

Subgoal *1/2.8
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR Y))
              (NOT (EQUAL (CAR Y) E))
              (EQUAL D E)
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (NOT (EQUAL FN '>>=))
              (NOT (LEXORDER D (CAR Y))))
         (EQUAL (FILTER FN (RM D (CDR Y)) D)
                (FILTER FN (CDR Y) D))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.7
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR Y))
              (NOT (EQUAL (CAR Y) E))
              (NOT (LEXORDER E D))
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (EQUAL D (CAR Y)))
         (EQUAL (FILTER FN (CDR Y) E)
                (CONS (CAR Y) (FILTER FN (CDR Y) E)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.6
(IMPLIES (AND (CONSP Y)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR Y))
              (NOT (EQUAL (CAR Y) E))
              (NOT (LEXORDER E D))
              (EQUAL (FILTER FN (RM D (CDR Y)) E)
                     (FILTER FN (CDR Y) E))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER FN (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (CONS (CAR Y) (FILTER FN (CDR Y) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

Subgoal *1/2.5
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '>>=)
              (LEXORDER E (CAR Y))
              (EQUAL (FILTER '>>= (RM D (CDR Y)) E)
                     (FILTER '>>= (CDR Y) E))
              (NOT (LEXORDER E D))
              (EQUAL D (CAR Y)))
         (EQUAL (FILTER '>>= (CDR Y) E)
                (CONS (CAR Y)
                      (FILTER '>>= (CDR Y) E)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.4
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '>>=)
              (LEXORDER E (CAR Y))
              (EQUAL (FILTER '>>= (RM D (CDR Y)) E)
                     (FILTER '>>= (CDR Y) E))
              (NOT (LEXORDER E D))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '>>=
                        (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (CONS (CAR Y)
                      (FILTER '>>= (CDR Y) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.3
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<)
              (LEXORDER (CAR Y) E)
              (NOT (EQUAL (CAR Y) E))
              (NOT (LEXORDER D E))
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E))
              (EQUAL D (CAR Y)))
         (EQUAL (FILTER '<< (CDR Y) E)
                (CONS (CAR Y) (FILTER '<< (CDR Y) E)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2.2
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<)
              (LEXORDER (CAR Y) E)
              (NOT (EQUAL (CAR Y) E))
              (NOT (LEXORDER D E))
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E))
              (NOT (EQUAL D (CAR Y))))
         (EQUAL (FILTER '<<
                        (CONS (CAR Y) (RM D (CDR Y)))
                        E)
                (CONS (CAR Y) (FILTER '<< (CDR Y) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.1
(IMPLIES (AND (CONSP Y)
              (EQUAL FN '<<)
              (LEXORDER (CAR Y) E)
              (NOT (EQUAL (CAR Y) E))
              (EQUAL D E)
              (EQUAL (FILTER '<< (RM D (CDR Y)) E)
                     (FILTER '<< (CDR Y) E)))
         (EQUAL (CONS (CAR Y)
                      (FILTER '<< (RM D (CDR Y)) D))
                (FILTER '<< Y D))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the
:type-prescription rule LEXORDER.

Subgoal *1/1
(IMPLIES (ENDP Y)
         (IMPLIES (NOT (REL FN D E))
                  (EQUAL (FILTER FN (RM D Y) E)
                         (FILTER FN Y E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP Y)) (NOT (REL FN D E)))
         (EQUAL (FILTER FN (RM D Y) E)
                (FILTER FN Y E))).

But simplification reduces this to T, using the :definitions <<=, FILTER,
REL and RM, the :executable-counterpart of EQUAL and primitive type
reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111C ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ENDP)
        (:DEFINITION FILTER)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:DEFINITION RM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:INDUCTION FILTER)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION LEXORDER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FILTER)
             (:DEFINITION NOT)
             (:DEFINITION REL)
             (:DEFINITION RM))
PROBLEM-111C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111C)
PROBLEM-111C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111C ...) ...)
Rules: NIL
 PROBLEM-111C
ACL2 !>>(THEOREM
             PROBLEM-111D
             (EQUAL (MEM D (FILTER FN X E))
                    (AND (MEM D X) (REL FN D E)))
             :HINTS (("Goal" :INDUCT (LEN X)
                             :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A))))


ACL2 !>>>(DEFTHM PROBLEM-111D
           (EQUAL (MEM D (FILTER FN X E))
                  (AND (MEM D X) (REL FN D E)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LEN X)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LEN X).

This suggestion was produced using the :induction rule LEN.  If we
let (:P D E FN X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P D E FN X))
     (IMPLIES (AND (CONSP X) (:P D E FN (CDR X)))
              (:P D E FN X))).
This induction is justified by the same argument used to admit LEN.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (MEM D (FILTER FN X E))
                (AND (MEM D X) (REL FN D E)))).

But simplification reduces this to T, using the :definitions FILTER
and MEM and the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     (AND (MEM D (CDR X)) (REL FN D E))))
         (EQUAL (MEM D (FILTER FN X E))
                (AND (MEM D X) (REL FN D E)))).

This simplifies, using the :definitions <<=, FILTER (if-intro), MEM
(if-intro) and REL (if-intro), the :executable-counterparts of EQUAL
and NOT, primitive type reasoning, the :rewrite rules LEXORDER-REFLEXIVE,
LEXORDER-TRANSITIVE, PROBLEM-48 and PROBLEM-49A and the :type-prescription
rules LEXORDER and MEM, to the following 30 conjectures.

Subgoal *1/1.30
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<<= (CDR X) E))
                     NIL)
              (EQUAL FN '<<=)
              (LEXORDER (CAR X) E)
              (EQUAL D (CAR X)))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '<<= (CDR X) E)))
                (LEXORDER D E))).

By case analysis we reduce the conjecture to

Subgoal *1/1.30'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<<= (CDR X) E)))
              (EQUAL FN '<<=)
              (LEXORDER (CAR X) E)
              (EQUAL D (CAR X)))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '<<= (CDR X) E)))
                (LEXORDER D E))).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CAR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the
:type-prescription rules FILTER and LEXORDER.

Subgoal *1/1.29
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<<= (CDR X) E))
                     NIL)
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR X) E))
              (EQUAL D (CAR X)))
         (EQUAL NIL (LEXORDER D E))).

By case analysis we reduce the conjecture to

Subgoal *1/1.29'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<<= (CDR X) E)))
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR X) E))
              (EQUAL D (CAR X)))
         (EQUAL NIL (LEXORDER D E))).

But simplification reduces this to T, using primitive type reasoning.

Subgoal *1/1.28
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<<= (CDR X) E))
                     NIL)
              (EQUAL FN '<<=)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL D (CAR X))))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '<<= (CDR X) E)))
                NIL)).

By case analysis we reduce the conjecture to

Subgoal *1/1.28'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<<= (CDR X) E)))
              (EQUAL FN '<<=)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL D (CAR X))))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '<<= (CDR X) E)))
                NIL)).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.27
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (MEM D (CONS (CAR X) (FILTER FN (CDR X) E)))
                NIL)).

By case analysis we reduce the conjecture to

Subgoal *1/1.27'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (MEM D (CONS (CAR X) (FILTER FN (CDR X) E)))
                NIL)).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.26
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (NOT (LEXORDER E D)))
         (EQUAL (MEM D (CONS (CAR X) (FILTER FN (CDR X) E)))
                NIL)).

By case analysis we reduce the conjecture to

Subgoal *1/1.26'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (NOT (LEXORDER E D)))
         (EQUAL (MEM D (CONS (CAR X) (FILTER FN (CDR X) E)))
                NIL)).

This simplifies, using the :definition MEM, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule FILTER, to

Subgoal *1/1.26''
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (NOT (LEXORDER E D)))
         (NOT (EQUAL D (CAR X)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.25
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (EQUAL D E))
         (EQUAL (MEM D (CONS (CAR X) (FILTER FN (CDR X) E)))
                NIL)).

By case analysis we reduce the conjecture to

Subgoal *1/1.25'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (EQUAL D E))
         (EQUAL (MEM D (CONS (CAR X) (FILTER FN (CDR X) E)))
                NIL)).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.24
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR X)))
              (EQUAL D (CAR X))
              (LEXORDER E D))
         (EQUAL D E)).

By case analysis we reduce the conjecture to

Subgoal *1/1.24'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR X)))
              (EQUAL D (CAR X))
              (LEXORDER E D))
         (EQUAL D E)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.23
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (EQUAL (CAR X) E)
              (EQUAL D (CAR X))
              (LEXORDER E D))
         (EQUAL D E)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.22
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (EQUAL D (CAR X))
              (LEXORDER E D)
              (NOT (EQUAL D E)))
         (EQUAL (MEM D (CONS (CAR X) (FILTER FN (CDR X) E)))
                T)).

By case analysis we reduce the conjecture to

Subgoal *1/1.22'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (EQUAL D (CAR X))
              (LEXORDER E D)
              (NOT (EQUAL D E)))
         (EQUAL (MEM D (CONS (CAR X) (FILTER FN (CDR X) E)))
                T)).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rule CAR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.21
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '>>= (CDR X) E))
                     NIL)
              (EQUAL FN '>>=)
              (LEXORDER E (CAR X))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '>>= (CDR X) E)))
                NIL)).

By case analysis we reduce the conjecture to

Subgoal *1/1.21'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '>>= (CDR X) E)))
              (EQUAL FN '>>=)
              (LEXORDER E (CAR X))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '>>= (CDR X) E)))
                NIL)).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.20
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '>>= (CDR X) E))
                     NIL)
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL D (CAR X)))
         (EQUAL NIL (LEXORDER E D))).

By case analysis we reduce the conjecture to

Subgoal *1/1.20'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '>>= (CDR X) E)))
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL D (CAR X)))
         (EQUAL NIL (LEXORDER E D))).

But simplification reduces this to T, using primitive type reasoning.

Subgoal *1/1.19
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '>>= (CDR X) E))
                     NIL)
              (EQUAL FN '>>=)
              (LEXORDER E (CAR X))
              (EQUAL D (CAR X)))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '>>= (CDR X) E)))
                (LEXORDER E D))).

By case analysis we reduce the conjecture to

Subgoal *1/1.19'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '>>= (CDR X) E)))
              (EQUAL FN '>>=)
              (LEXORDER E (CAR X))
              (EQUAL D (CAR X)))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '>>= (CDR X) E)))
                (LEXORDER E D))).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CAR-CONS, LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the
:type-prescription rules FILTER and LEXORDER.

Subgoal *1/1.18
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL)
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (NOT (LEXORDER D E)))
         (EQUAL (MEM D (CONS (CAR X) (FILTER '<< (CDR X) E)))
                NIL)).

By case analysis we reduce the conjecture to

Subgoal *1/1.18'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (NOT (LEXORDER D E)))
         (EQUAL (MEM D (CONS (CAR X) (FILTER '<< (CDR X) E)))
                NIL)).

This simplifies, using the :definition MEM, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule FILTER, to

Subgoal *1/1.18''
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (NOT (LEXORDER D E)))
         (NOT (EQUAL D (CAR X)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.17
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL)
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (EQUAL D E))
         (EQUAL (MEM D (CONS (CAR X) (FILTER '<< (CDR X) E)))
                NIL)).

By case analysis we reduce the conjecture to

Subgoal *1/1.17'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (EQUAL D E))
         (EQUAL (MEM D (CONS (CAR X) (FILTER '<< (CDR X) E)))
                NIL)).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.16
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL)
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (MEM D (CONS (CAR X) (FILTER '<< (CDR X) E)))
                NIL)).

By case analysis we reduce the conjecture to

Subgoal *1/1.16'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (MEM D (CONS (CAR X) (FILTER '<< (CDR X) E)))
                NIL)).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rules CAR-CONS and CDR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.15
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) E))
              (EQUAL D (CAR X))
              (LEXORDER D E))
         (EQUAL D E)).

By case analysis we reduce the conjecture to

Subgoal *1/1.15'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) E))
              (EQUAL D (CAR X))
              (LEXORDER D E))
         (EQUAL D E)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.14
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL)
              (EQUAL FN '<<)
              (EQUAL D (CAR X))
              (LEXORDER D E)
              (NOT (EQUAL D E)))
         (EQUAL (MEM D (CONS (CAR X) (FILTER '<< (CDR X) E)))
                T)).

By case analysis we reduce the conjecture to

Subgoal *1/1.14'
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (EQUAL FN '<<)
              (EQUAL D (CAR X))
              (LEXORDER D E)
              (NOT (EQUAL D E)))
         (EQUAL (MEM D (CONS (CAR X) (FILTER '<< (CDR X) E)))
                T)).

But simplification reduces this to T, using the :definition MEM, the
:executable-counterpart of EQUAL, primitive type reasoning, the :rewrite
rule CAR-CONS and the :type-prescription rule FILTER.

Subgoal *1/1.13
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (CDR X)))
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL)
              (EQUAL FN '<<)
              (EQUAL (CAR X) E)
              (EQUAL D (CAR X))
              (LEXORDER D E))
         (EQUAL D E)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.12
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (EQUAL FN '<<=)
              (EQUAL (MEM D (FILTER '<<= (CDR X) E))
                     (LEXORDER D E)))
         (EQUAL (MEM D (FILTER '<<= X E))
                (LEXORDER D E))).

This simplifies, using the :definitions <<=, FILTER and REL and the
:executable-counterpart of EQUAL, to

Subgoal *1/1.12'
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (EQUAL (MEM D (FILTER '<<= (CDR X) E))
                     (LEXORDER D E))
              (LEXORDER (CAR X) E))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '<<= (CDR X) E)))
                (LEXORDER D E))).

This simplifies, using the :definition MEM, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule FILTER, to

Subgoal *1/1.12''
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (EQUAL (MEM D (FILTER '<<= (CDR X) E))
                     (LEXORDER D E))
              (LEXORDER (CAR X) E)
              (EQUAL D (CAR X)))
         (EQUAL T (LEXORDER D E))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule LEXORDER.

Subgoal *1/1.11
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E D)
              (NOT (EQUAL D E))
              (EQUAL (MEM D (FILTER FN (CDR X) E)) T)
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E)))
         (MEM D
              (CONS (CAR X) (FILTER FN (CDR X) E)))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-48 and
PROBLEM-49A and the :type-prescription rules FILTER and MEM.

Subgoal *1/1.10
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (EQUAL FN '>>=)
              (EQUAL (MEM D (FILTER '>>= (CDR X) E))
                     (LEXORDER E D)))
         (EQUAL (MEM D (FILTER '>>= X E))
                (LEXORDER E D))).

This simplifies, using the :definitions <<=, FILTER and REL and the
:executable-counterpart of EQUAL, to

Subgoal *1/1.10'
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (EQUAL (MEM D (FILTER '>>= (CDR X) E))
                     (LEXORDER E D))
              (LEXORDER E (CAR X)))
         (EQUAL (MEM D
                     (CONS (CAR X) (FILTER '>>= (CDR X) E)))
                (LEXORDER E D))).

This simplifies, using the :definition MEM, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule FILTER, to

Subgoal *1/1.10''
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (EQUAL (MEM D (FILTER '>>= (CDR X) E))
                     (LEXORDER E D))
              (LEXORDER E (CAR X))
              (EQUAL D (CAR X)))
         (EQUAL T (LEXORDER E D))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule LEXORDER.

Subgoal *1/1.9
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (EQUAL FN '<<)
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     T))
         (MEM D (FILTER '<< X E))).

This simplifies, using the :definitions <<=, FILTER and REL, the :executable-
counterpart of EQUAL, primitive type reasoning and the :type-prescription
rule MEM, to

Subgoal *1/1.9'
(IMPLIES (AND (CONSP X)
              (MEM D (CDR X))
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D (FILTER '<< (CDR X) E))
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E)))
         (MEM D
              (CONS (CAR X) (FILTER '<< (CDR X) E)))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-48 and
PROBLEM-49A and the :type-prescription rules FILTER and MEM.

Subgoal *1/1.8
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (EQUAL D E)
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL))
         (NOT (MEM D (FILTER '<< X D)))).

By case analysis we reduce the conjecture to

Subgoal *1/1.8'
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (EQUAL D E)
              (NOT (MEM D (FILTER '<< (CDR X) E))))
         (NOT (MEM D (FILTER '<< X D)))).

This simplifies, using the :definitions <<=, FILTER and REL and the
:executable-counterpart of EQUAL, to

Subgoal *1/1.8''
(IMPLIES (AND (CONSP X)
              (NOT (MEM D (FILTER '<< (CDR X) D)))
              (LEXORDER (CAR X) D)
              (NOT (EQUAL (CAR X) D)))
         (NOT (MEM D
                   (CONS (CAR X)
                         (FILTER '<< (CDR X) D))))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rule FILTER.

Subgoal *1/1.7
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (NOT (LEXORDER D E))
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL))
         (NOT (MEM D (FILTER '<< X E)))).

By case analysis we reduce the conjecture to

Subgoal *1/1.7'
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (NOT (LEXORDER D E))
              (NOT (MEM D (FILTER '<< (CDR X) E))))
         (NOT (MEM D (FILTER '<< X E)))).

This simplifies, using the :definitions <<=, FILTER and REL and the
:executable-counterpart of EQUAL, to

Subgoal *1/1.7''
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER D E))
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E)))
         (NOT (MEM D
                   (CONS (CAR X)
                         (FILTER '<< (CDR X) E))))).

This simplifies, using the :definition MEM, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule FILTER, to

Subgoal *1/1.7'''
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER D E))
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E)))
         (NOT (EQUAL D (CAR X)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.6
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E D))
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E)))
         (NOT (MEM D
                   (CONS (CAR X) (FILTER FN (CDR X) E))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.6'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E D))
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E)))
         (NOT (MEM D
                   (CONS (CAR X) (FILTER FN (CDR X) E))))).

This simplifies, using the :definition MEM, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule FILTER, to

Subgoal *1/1.6''
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E D))
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E)))
         (NOT (EQUAL D (CAR X)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (LEXORDER E D)
              (EQUAL D E)
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (EQUAL (CAR X) D))
         (NOT (MEM D (FILTER FN (CDR X) D)))).

By case analysis we reduce the conjecture to

Subgoal *1/1.5'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (LEXORDER E D)
              (EQUAL D E)
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (EQUAL (CAR X) D))
         (NOT (MEM D (FILTER FN (CDR X) D)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (LEXORDER E D)
              (EQUAL D E)
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL)
              (EQUAL FN '<<)
              (LEXORDER (CAR X) D)
              (NOT (EQUAL (CAR X) D)))
         (NOT (MEM D
                   (CONS (CAR X)
                         (FILTER '<< (CDR X) D))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.4'
(IMPLIES (AND (CONSP X)
              (LEXORDER E D)
              (EQUAL D E)
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (EQUAL FN '<<)
              (LEXORDER (CAR X) D)
              (NOT (EQUAL (CAR X) D)))
         (NOT (MEM D
                   (CONS (CAR X)
                         (FILTER '<< (CDR X) D))))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE
and the :type-prescription rule FILTER.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (LEXORDER E D)
              (EQUAL D E)
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (NOT (EQUAL FN '<<))
              (LEXORDER D (CAR X))
              (NOT (EQUAL (CAR X) D)))
         (NOT (MEM D
                   (CONS (CAR X) (FILTER FN (CDR X) D))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.3'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (LEXORDER E D)
              (EQUAL D E)
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL FN '<<))
              (LEXORDER D (CAR X))
              (NOT (EQUAL (CAR X) D)))
         (NOT (MEM D
                   (CONS (CAR X) (FILTER FN (CDR X) D))))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE
and the :type-prescription rule FILTER.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (LEXORDER E D)
              (EQUAL D E)
              (EQUAL (MEM D (FILTER '<< (CDR X) E))
                     NIL)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) D)))
         (NOT (MEM D (FILTER '<< (CDR X) D)))).

By case analysis we reduce the conjecture to

Subgoal *1/1.2'
(IMPLIES (AND (CONSP X)
              (LEXORDER E D)
              (EQUAL D E)
              (NOT (MEM D (FILTER '<< (CDR X) E)))
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) D)))
         (NOT (MEM D (FILTER '<< (CDR X) D)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (LEXORDER E D)
              (EQUAL D E)
              (EQUAL (MEM D (FILTER FN (CDR X) E))
                     NIL)
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER D (CAR X))))
         (NOT (MEM D (FILTER FN (CDR X) D)))).

By case analysis we reduce the conjecture to

Subgoal *1/1.1'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (LEXORDER E D)
              (EQUAL D E)
              (NOT (MEM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER D (CAR X))))
         (NOT (MEM D (FILTER FN (CDR X) D)))).

But simplification reduces this to T, using trivial observations.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111D ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION FILTER)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION FILTER)
        (:TYPE-PRESCRIPTION LEXORDER)
        (:TYPE-PRESCRIPTION MEM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FILTER)
             (:DEFINITION MEM)
             (:DEFINITION REL))
PROBLEM-111D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111D)
PROBLEM-111D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111D ...) ...)
Rules: NIL
 PROBLEM-111D
ACL2 !>>(THEOREM PROBLEM-111E
                 (IMPLIES (NOT (MEM D X))
                          (EQUAL (RM D X) X))
                 :HINTS (("Goal" :INDUCT (RM D X))))


ACL2 !>>>(DEFTHM PROBLEM-111E
           (IMPLIES (NOT (MEM D X))
                    (EQUAL (RM D X) X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RM D X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RM D X).

This suggestion was produced using the :induction rule RM.  If we let
(:P D X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P D X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL D (CAR X)))
                   (:P D (CDR X)))
              (:P D X))
     (IMPLIES (AND (CONSP X) (EQUAL D (CAR X)))
              (:P D X))).
This induction is justified by the same argument used to admit RM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (NOT (MEM D X))
                  (EQUAL (RM D X) X))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (NOT (MEM D X)))
         (EQUAL (RM D X) X)).

But simplification reduces this to T, using the :definitions MEM and
RM and primitive type reasoning.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL D (CAR X)))
              (IMPLIES (NOT (MEM D (CDR X)))
                       (EQUAL (RM D (CDR X)) (CDR X))))
         (IMPLIES (NOT (MEM D X))
                  (EQUAL (RM D X) X))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL D (CAR X)))
              (IMPLIES (NOT (MEM D (CDR X)))
                       (EQUAL (RM D (CDR X)) (CDR X)))
              (NOT (MEM D X)))
         (EQUAL (RM D X) X)).

But simplification reduces this to T, using the :definitions MEM, NOT
and RM, primitive type reasoning, the :rewrite rule CONS-CAR-CDR and
the :type-prescription rule MEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (EQUAL D (CAR X)))
         (IMPLIES (NOT (MEM D X))
                  (EQUAL (RM D X) X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL D (CAR X))
              (NOT (MEM D X)))
         (EQUAL (RM D X) X)).

But simplification reduces this to T, using the :definition MEM and
primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111E ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RM)
        (:REWRITE CONS-CAR-CDR)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-111E


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111E))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111E)
PROBLEM-111E

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111E ...) ...)
Rules: NIL
 PROBLEM-111E
ACL2 !>>(THEOREM
             PROBLEM-111F
             (EQUAL (FILTER FN (RM D X) E)
                    (RM D (FILTER FN X E)))
             :HINTS (("Goal" :INDUCT (FILTER FN X E)
                             :IN-THEORY (ENABLE PROBLEM-111C
                                                PROBLEM-111D PROBLEM-111E))))


ACL2 !>>>(DEFTHM PROBLEM-111F
           (EQUAL (FILTER FN (RM D X) E)
                  (RM D (FILTER FN X E)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FILTER FN X E)
                           :IN-THEORY (ENABLE PROBLEM-111C
                                              PROBLEM-111D PROBLEM-111E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FILTER FN X E).

This suggestion was produced using the :induction rule FILTER.  If
we let (:P D E FN X) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (REL FN (CAR X) E))
                   (:P D E FN (CDR X)))
              (:P D E FN X))
     (IMPLIES (AND (NOT (ENDP X))
                   (REL FN (CAR X) E)
                   (:P D E FN (CDR X)))
              (:P D E FN X))
     (IMPLIES (ENDP X) (:P D E FN X))).
This induction is justified by the same argument used to admit FILTER.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (REL FN (CAR X) E))
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E))))
         (EQUAL (FILTER FN (RM D X) E)
                (RM D (FILTER FN X E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (NOT (REL FN (CAR X) E))
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E))))
         (EQUAL (FILTER FN (RM D X) E)
                (RM D (FILTER FN X E)))).

This simplifies, using the :definitions <<=, FILTER, REL (if-intro)
and RM (if-intro), the :executable-counterpart of EQUAL, primitive
type reasoning and the :rewrite rule LEXORDER-REFLEXIVE, to the following
twelve conjectures.

Subgoal *1/3.12
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR X) E))
              (EQUAL (FILTER '<<= (RM D (CDR X)) E)
                     (RM D (FILTER '<<= (CDR X) E)))
              (EQUAL D (CAR X)))
         (EQUAL (FILTER '<<= (CDR X) E)
                (FILTER '<<= (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules PROBLEM-111C, PROBLEM-111D and PROBLEM-111E and
the :type-prescription rule LEXORDER.

Subgoal *1/3.11
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR X) E))
              (EQUAL (FILTER '<<= (RM D (CDR X)) E)
                     (RM D (FILTER '<<= (CDR X) E)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (FILTER '<<=
                        (CONS (CAR X) (RM D (CDR X)))
                        E)
                (FILTER '<<= (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/3.10
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (EQUAL (CAR X) E)
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E)))
              (EQUAL D E))
         (EQUAL (FILTER FN (CDR X) E)
                (FILTER FN (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<= and
REL, primitive type reasoning and the :rewrite rules LEXORDER-REFLEXIVE,
PROBLEM-111C, PROBLEM-111D and PROBLEM-111E.

Subgoal *1/3.9
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (EQUAL (CAR X) E)
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL D E)))
         (EQUAL (FILTER FN (CONS E (RM D (CDR X))) E)
                (FILTER FN (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.8
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E)))
              (EQUAL D (CAR X)))
         (EQUAL (FILTER FN (CDR X) E)
                (FILTER FN (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<= and
REL, primitive type reasoning, the :rewrite rules PROBLEM-111C, PROBLEM-111D
and PROBLEM-111E and the :type-prescription rule LEXORDER.

Subgoal *1/3.7
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (FILTER FN (CONS (CAR X) (RM D (CDR X)))
                        E)
                (FILTER FN (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, primitive type reasoning and the :rewrite rules CAR-CONS and
CDR-CONS.

Subgoal *1/3.6
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (EQUAL (CAR X) E)
              (EQUAL (FILTER '<< (RM D (CDR X)) E)
                     (RM D (FILTER '<< (CDR X) E)))
              (EQUAL D E))
         (EQUAL (FILTER '<< (CDR X) E)
                (FILTER '<< (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules LEXORDER-REFLEXIVE, PROBLEM-111C, PROBLEM-111D
and PROBLEM-111E.

Subgoal *1/3.5
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (EQUAL (CAR X) E)
              (EQUAL (FILTER '<< (RM D (CDR X)) E)
                     (RM D (FILTER '<< (CDR X) E)))
              (NOT (EQUAL D E)))
         (EQUAL (FILTER '<< (CONS E (RM D (CDR X))) E)
                (FILTER '<< (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.4
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) E))
              (EQUAL (FILTER '<< (RM D (CDR X)) E)
                     (RM D (FILTER '<< (CDR X) E)))
              (EQUAL D (CAR X)))
         (EQUAL (FILTER '<< (CDR X) E)
                (FILTER '<< (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules PROBLEM-111C, PROBLEM-111D and PROBLEM-111E and
the :type-prescription rule LEXORDER.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) E))
              (EQUAL (FILTER '<< (RM D (CDR X)) E)
                     (RM D (FILTER '<< (CDR X) E)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (FILTER '<<
                        (CONS (CAR X) (RM D (CDR X)))
                        E)
                (FILTER '<< (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (FILTER '>>= (RM D (CDR X)) E)
                     (RM D (FILTER '>>= (CDR X) E)))
              (EQUAL D (CAR X)))
         (EQUAL (FILTER '>>= (CDR X) E)
                (FILTER '>>= (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules PROBLEM-111C, PROBLEM-111D and PROBLEM-111E and
the :type-prescription rule LEXORDER.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR X)))
              (EQUAL (FILTER '>>= (RM D (CDR X)) E)
                     (RM D (FILTER '>>= (CDR X) E)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (FILTER '>>=
                        (CONS (CAR X) (RM D (CDR X)))
                        E)
                (FILTER '>>= (RM D (CDR X)) E))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (REL FN (CAR X) E)
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E))))
         (EQUAL (FILTER FN (RM D X) E)
                (RM D (FILTER FN X E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (REL FN (CAR X) E)
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E))))
         (EQUAL (FILTER FN (RM D X) E)
                (RM D (FILTER FN X E)))).

This simplifies, using the :definitions <<=, FILTER, REL (if-intro)
and RM (if-intro), the :executable-counterpart of EQUAL, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rules FILTER and
LEXORDER, to the following four conjectures.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<=)
              (LEXORDER (CAR X) E)
              (EQUAL (FILTER '<<= (RM D (CDR X)) E)
                     (RM D (FILTER '<<= (CDR X) E)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (FILTER '<<=
                        (CONS (CAR X) (RM D (CDR X)))
                        E)
                (CONS (CAR X)
                      (FILTER '<<= (RM D (CDR X)) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (EQUAL (FILTER FN (RM D (CDR X)) E)
                     (RM D (FILTER FN (CDR X) E)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (FILTER FN (CONS (CAR X) (RM D (CDR X)))
                        E)
                (CONS (CAR X)
                      (FILTER FN (RM D (CDR X)) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (EQUAL FN '>>=)
              (LEXORDER E (CAR X))
              (EQUAL (FILTER '>>= (RM D (CDR X)) E)
                     (RM D (FILTER '>>= (CDR X) E)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (FILTER '>>=
                        (CONS (CAR X) (RM D (CDR X)))
                        E)
                (CONS (CAR X)
                      (FILTER '>>= (RM D (CDR X)) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (EQUAL (FILTER '<< (RM D (CDR X)) E)
                     (RM D (FILTER '<< (CDR X) E)))
              (NOT (EQUAL D (CAR X))))
         (EQUAL (FILTER '<<
                        (CONS (CAR X) (RM D (CDR X)))
                        E)
                (CONS (CAR X)
                      (FILTER '<< (RM D (CDR X)) E)))).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/1
(IMPLIES (ENDP X)
         (EQUAL (FILTER FN (RM D X) E)
                (RM D (FILTER FN X E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (EQUAL (FILTER FN (RM D X) E)
                (RM D (FILTER FN X E)))).

But simplification reduces this to T, using the :definitions FILTER
and MEM, the :executable-counterparts of CONSP and EQUAL and the :rewrite
rule PROBLEM-111E.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111F ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ENDP)
        (:DEFINITION FILTER)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:DEFINITION RM)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FILTER)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:REWRITE PROBLEM-111C)
        (:REWRITE PROBLEM-111D)
        (:REWRITE PROBLEM-111E)
        (:TYPE-PRESCRIPTION FILTER)
        (:TYPE-PRESCRIPTION LEXORDER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION REL) (:DEFINITION RM))
PROBLEM-111F


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111F))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111F)
PROBLEM-111F

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111F ...) ...)
Rules: NIL
 PROBLEM-111F
ACL2 !>>(THEOREM
             PROBLEM-111G
             (IMPLIES (PERM X Y)
                      (PERM (FILTER FN X E) (FILTER FN Y E)))
             :HINTS
             (("Goal" :INDUCT (PERM X Y)
                      :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                         PROBLEM-54A PROBLEM-54 PROBLEM-55B
                                         PROBLEM-55 PROBLEM-111B PROBLEM-111D
                                         PROBLEM-111E PROBLEM-111F)))
             :RULE-CLASSES :CONGRUENCE)


ACL2 !>>>(DEFTHM PROBLEM-111G
           (IMPLIES (PERM X Y)
                    (PERM (FILTER FN X E) (FILTER FN Y E)))
           :RULE-CLASSES :CONGRUENCE
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (PERM X Y)
                    :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                       PROBLEM-54A PROBLEM-54 PROBLEM-55B
                                       PROBLEM-55 PROBLEM-111B PROBLEM-111D
                                       PROBLEM-111E PROBLEM-111F))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM X Y).

This suggestion was produced using the :induction rule PERM.  If we
let (:P E FN X Y) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P E FN X Y))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
              (:P E FN X Y))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) Y)
                   (:P E FN (CDR X) (RM (CAR X) Y)))
              (:P E FN X Y))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable Y is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (PERM X Y)
                  (PERM (FILTER FN X E)
                        (FILTER FN Y E)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (PERM X Y))
         (PERM (FILTER FN X E) (FILTER FN Y E))).

But simplification reduces this to T, using the :definitions FILTER
and PERM and the :executable-counterpart of PERM.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
         (IMPLIES (PERM X Y)
                  (PERM (FILTER FN X E)
                        (FILTER FN Y E)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Y))
              (PERM X Y))
         (PERM (FILTER FN X E) (FILTER FN Y E))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning and the :rewrite rule PROBLEM-55B.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (PERM (CDR X) (RM (CAR X) Y))
                       (PERM (FILTER FN (CDR X) E)
                             (FILTER FN (RM (CAR X) Y) E))))
         (IMPLIES (PERM X Y)
                  (PERM (FILTER FN X E)
                        (FILTER FN Y E)))).

By the simple :rewrite rule PROBLEM-111F we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (PERM (CDR X) (RM (CAR X) Y))
                       (PERM (FILTER FN (CDR X) E)
                             (RM (CAR X) (FILTER FN Y E))))
              (PERM X Y))
         (PERM (FILTER FN X E) (FILTER FN Y E))).

This simplifies, using the :definitions <<=, FILTER (if-intro), MEM,
PERM (if-intro) and REL (if-intro), primitive type reasoning and the
:rewrite rule PROBLEM-55B, to the following ten conjectures.

Subgoal *1/1.10
(IMPLIES (AND (CONSP X)
              (PERM (FILTER '<<= (CDR X) E)
                    (RM (CAR X) (FILTER '<<= Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL FN '<<=)
              (LEXORDER (CAR X) E))
         (PERM (CONS (CAR X) (FILTER '<<= (CDR X) E))
               (FILTER '<<= Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :equivalence rule PROBLEM-111B, the :executable-counterpart
of EQUAL, primitive type reasoning, the :rewrite rules LEXORDER-REFLEXIVE,
LEXORDER-TRANSITIVE, PROBLEM-111D, PROBLEM-48, PROBLEM-49A, PROBLEM-54,
PROBLEM-54A and PROBLEM-55 and the :type-prescription rules LEXORDER
and MEM.

Subgoal *1/1.9
(IMPLIES (AND (CONSP X)
              (PERM (FILTER '<<= (CDR X) E)
                    (RM (CAR X) (FILTER '<<= Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR X) E)))
         (PERM (FILTER '<<= (CDR X) E)
               (FILTER '<<= Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, the :rewrite rules PROBLEM-111D,
PROBLEM-111E, PROBLEM-48 and PROBLEM-49A and the :type-prescription
rules LEXORDER and MEM.

Subgoal *1/1.8
(IMPLIES (AND (CONSP X)
              (PERM (FILTER FN (CDR X) E)
                    (RM (CAR X) (FILTER FN Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (EQUAL (CAR X) E))
         (PERM (FILTER FN (CDR X) E)
               (FILTER FN Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, primitive type reasoning, the :rewrite rules LEXORDER-REFLEXIVE,
PROBLEM-111D, PROBLEM-111E, PROBLEM-48 and PROBLEM-49A and the :type-
prescription rule MEM.

Subgoal *1/1.7
(IMPLIES (AND (CONSP X)
              (PERM (FILTER FN (CDR X) E)
                    (RM (CAR X) (FILTER FN Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR X))))
         (PERM (FILTER FN (CDR X) E)
               (FILTER FN Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :rewrite rules PROBLEM-111D, PROBLEM-111E, PROBLEM-48 and
PROBLEM-49A and the :type-prescription rules LEXORDER and MEM.

Subgoal *1/1.6
(IMPLIES (AND (CONSP X)
              (PERM (FILTER FN (CDR X) E)
                    (RM (CAR X) (FILTER FN Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E)))
         (PERM (CONS (CAR X) (FILTER FN (CDR X) E))
               (FILTER FN Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :equivalence rule PROBLEM-111B, primitive type reasoning,
the :rewrite rules LEXORDER-REFLEXIVE, LEXORDER-TRANSITIVE, PROBLEM-111D,
PROBLEM-48, PROBLEM-49A, PROBLEM-54, PROBLEM-54A and PROBLEM-55 and
the :type-prescription rules LEXORDER and MEM.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (PERM (FILTER '>>= (CDR X) E)
                    (RM (CAR X) (FILTER '>>= Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL FN '>>=)
              (LEXORDER E (CAR X)))
         (PERM (CONS (CAR X) (FILTER '>>= (CDR X) E))
               (FILTER '>>= Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :equivalence rule PROBLEM-111B, the :executable-counterpart
of EQUAL, primitive type reasoning, the :rewrite rules LEXORDER-REFLEXIVE,
LEXORDER-TRANSITIVE, PROBLEM-111D, PROBLEM-48, PROBLEM-49A, PROBLEM-54,
PROBLEM-54A and PROBLEM-55 and the :type-prescription rules LEXORDER
and MEM.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (PERM (FILTER '>>= (CDR X) E)
                    (RM (CAR X) (FILTER '>>= Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR X))))
         (PERM (FILTER '>>= (CDR X) E)
               (FILTER '>>= Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, the :rewrite rules PROBLEM-111D,
PROBLEM-111E, PROBLEM-48 and PROBLEM-49A and the :type-prescription
rules LEXORDER and MEM.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (PERM (FILTER '<< (CDR X) E)
                    (RM (CAR X) (FILTER '<< Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) E)))
         (PERM (FILTER '<< (CDR X) E)
               (FILTER '<< Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, the :rewrite rules PROBLEM-111D,
PROBLEM-111E, PROBLEM-48 and PROBLEM-49A and the :type-prescription
rules LEXORDER and MEM.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (PERM (FILTER '<< (CDR X) E)
                    (RM (CAR X) (FILTER '<< Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E)))
         (PERM (CONS (CAR X) (FILTER '<< (CDR X) E))
               (FILTER '<< Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :equivalence rule PROBLEM-111B, the :executable-counterpart
of EQUAL, primitive type reasoning, the :rewrite rules LEXORDER-REFLEXIVE,
LEXORDER-TRANSITIVE, PROBLEM-111D, PROBLEM-48, PROBLEM-49A, PROBLEM-54,
PROBLEM-54A and PROBLEM-55 and the :type-prescription rules LEXORDER
and MEM.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (PERM (FILTER '<< (CDR X) E)
                    (RM (CAR X) (FILTER '<< Y E)))
              (MEM (CAR X) Y)
              (PERM (CDR X) (RM (CAR X) Y))
              (EQUAL FN '<<)
              (EQUAL (CAR X) E))
         (PERM (FILTER '<< (CDR X) E)
               (FILTER '<< Y E))).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules LEXORDER-REFLEXIVE, PROBLEM-111D, PROBLEM-111E,
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111G ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION FILTER)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PERM)
        (:DEFINITION REL)
        (:EQUIVALENCE PROBLEM-111B)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART PERM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PERM)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:REWRITE PROBLEM-111D)
        (:REWRITE PROBLEM-111E)
        (:REWRITE PROBLEM-111F)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-54A)
        (:REWRITE PROBLEM-55)
        (:REWRITE PROBLEM-55B)
        (:TYPE-PRESCRIPTION LEXORDER)
        (:TYPE-PRESCRIPTION MEM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FILTER)
             (:DEFINITION PERM)
             (:DEFINITION REL))
PROBLEM-111G


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111G))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111G)
PROBLEM-111G

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111G ...) ...)
Rules: NIL
 PROBLEM-111G
ACL2 !>>(THEOREM
           PROBLEM-111H
           (PERM (APP A (CONS E B))
                 (CONS E (APP A B)))
           :HINTS
           (("Goal" :INDUCT (APP A B)
                    :IN-THEORY (ENABLE PROBLEM-46 PROBLEM-54A
                                       PROBLEM-54 PROBLEM-55 PROBLEM-111B))))


ACL2 !>>>(DEFTHM PROBLEM-111H
           (PERM (APP A (CONS E B))
                 (CONS E (APP A B)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (APP A B)
                    :IN-THEORY (ENABLE PROBLEM-46 PROBLEM-54A
                                       PROBLEM-54 PROBLEM-55 PROBLEM-111B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B E))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B E))
              (:P A B E))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (PERM (APP A (CONS E B))
               (CONS E (APP A B)))).

But simplification reduces this to T, using the :definition APP, primitive
type reasoning and the :rewrite rule PROBLEM-54.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (PERM (APP (CDR A) (CONS E B))
                    (CONS E (APP (CDR A) B))))
         (PERM (APP A (CONS E B))
               (CONS E (APP A B)))).

But simplification reduces this to T, using the :definitions APP, MEM
and RM, the :equivalence rule PROBLEM-111B, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-46, PROBLEM-54,
PROBLEM-54A and PROBLEM-55.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111H ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION MEM)
        (:DEFINITION RM)
        (:EQUIVALENCE PROBLEM-111B)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-46)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-54A)
        (:REWRITE PROBLEM-55))
PROBLEM-111H


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111H))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111H)
PROBLEM-111H

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111H ...) ...)
Rules: NIL
 PROBLEM-111H
ACL2 !>>(THEOREM
         PROBLEM-111I
         (PERM (APP (FILTER '<< X E) (FILTER '>>= X E))
               X)
         :HINTS
         (("Goal" :INDUCT (FILTER '>>= X E)
                  :IN-THEORY (ENABLE PROBLEM-54A PROBLEM-54
                                     PROBLEM-55 PROBLEM-111B PROBLEM-111H))))


ACL2 !>>>(DEFTHM PROBLEM-111I
           (PERM (APP (FILTER '<< X E) (FILTER '>>= X E))
                 X)
           :HINTS
           (("Goal"
                 :DO-NOT-INDUCT T
                 :DO-NOT '(GENERALIZE)
                 :INDUCT (FILTER '>>= X E)
                 :IN-THEORY (ENABLE PROBLEM-54A PROBLEM-54
                                    PROBLEM-55 PROBLEM-111B PROBLEM-111H))))

ACL2 Warning [Double-rewrite] in ( DEFTHM PROBLEM-111I ...):  In a
:REWRITE rule generated from PROBLEM-111I, equivalence relation PERM
is maintained at one problematic occurrence of variable X in the right-
hand side, but not at any binding occurrence of X.  Consider replacing
that occurrence of X in the right-hand side with (DOUBLE-REWRITE X).
See :doc double-rewrite for more information on this issue.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FILTER '>>= X E).

This suggestion was produced using the :induction rule FILTER.  If
we let (:P E X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (REL '>>= (CAR X) E))
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (AND (NOT (ENDP X))
                   (REL '>>= (CAR X) E)
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (ENDP X) (:P E X))).
This induction is justified by the same argument used to admit FILTER.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (REL '>>= (CAR X) E))
              (PERM (APP (FILTER '<< (CDR X) E)
                         (FILTER '>>= (CDR X) E))
                    (CDR X)))
         (PERM (APP (FILTER '<< X E) (FILTER '>>= X E))
               X)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (NOT (REL '>>= (CAR X) E))
              (PERM (APP (FILTER '<< (CDR X) E)
                         (FILTER '>>= (CDR X) E))
                    (CDR X)))
         (PERM (APP (FILTER '<< X E) (FILTER '>>= X E))
               X)).

This simplifies, using the :definitions <<=, FILTER (if-intro) and
REL (if-intro) and the :executable-counterpart of EQUAL, to the following
three conjectures.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (PERM (APP (FILTER '<< (CDR X) E)
                         (FILTER '>>= (CDR X) E))
                    (CDR X))
              (NOT (LEXORDER (CAR X) E)))
         (PERM (APP (FILTER '<< (CDR X) E)
                    (FILTER '>>= (CDR X) E))
               X)).

But simplification reduces this to T, using primitive type reasoning
and the :forward-chaining rule LEXORDER-TOTAL.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (PERM (APP (FILTER '<< (CDR X) E)
                         (FILTER '>>= (CDR X) E))
                    (CDR X))
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E)))
         (PERM (APP (CONS (CAR X) (FILTER '<< (CDR X) E))
                    (FILTER '>>= (CDR X) E))
               X)).

But simplification reduces this to T, using the :definitions APP, MEM
and RM, the :equivalence rule PROBLEM-111B, primitive type reasoning,
the :forward-chaining rule LEXORDER-TOTAL, the :rewrite rules CAR-CONS,
CDR-CONS, LEXORDER-REFLEXIVE, LEXORDER-TRANSITIVE, PROBLEM-54, PROBLEM-54A
and PROBLEM-55 and the :type-prescription rules FILTER and LEXORDER.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (PERM (APP (FILTER '<< (CDR X) E)
                         (FILTER '>>= (CDR X) E))
                    (CDR X))
              (EQUAL (CAR X) E))
         (PERM (APP (FILTER '<< (CDR X) E)
                    (FILTER '>>= (CDR X) E))
               X)).

But simplification reduces this to T, using primitive type reasoning
and the :forward-chaining rule LEXORDER-TOTAL.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (REL '>>= (CAR X) E)
              (PERM (APP (FILTER '<< (CDR X) E)
                         (FILTER '>>= (CDR X) E))
                    (CDR X)))
         (PERM (APP (FILTER '<< X E) (FILTER '>>= X E))
               X)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (REL '>>= (CAR X) E)
              (PERM (APP (FILTER '<< (CDR X) E)
                         (FILTER '>>= (CDR X) E))
                    (CDR X)))
         (PERM (APP (FILTER '<< X E) (FILTER '>>= X E))
               X)).

This simplifies, using the :definitions <<=, FILTER, MEM, PERM, REL
and RM, the :equivalence rule PROBLEM-111B, the :executable-counterpart
of EQUAL, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
LEXORDER-REFLEXIVE, LEXORDER-TRANSITIVE and PROBLEM-111H and the :type-
prescription rule LEXORDER, to

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (LEXORDER E (CAR X))
              (PERM (APP (FILTER '<< (CDR X) E)
                         (FILTER '>>= (CDR X) E))
                    (CDR X))
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E)))
         (PERM (APP (CONS (CAR X) (FILTER '<< (CDR X) E))
                    (FILTER '>>= (CDR X) E))
               (CDR X))).

But simplification reduces this to T, using the :forward-chaining rule
LEXORDER-ANTI-SYMMETRIC and the :type-prescription rule LEXORDER.

Subgoal *1/1
(IMPLIES (ENDP X)
         (PERM (APP (FILTER '<< X E) (FILTER '>>= X E))
               X)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (PERM (APP (FILTER '<< X E) (FILTER '>>= X E))
               X)).

But simplification reduces this to T, using the :definitions FILTER
and PERM, the :executable-counterparts of APP and CONSP and the :rewrite
rule PROBLEM-54.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111I ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION APP)
        (:DEFINITION ENDP)
        (:DEFINITION FILTER)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PERM)
        (:DEFINITION REL)
        (:DEFINITION RM)
        (:EQUIVALENCE PROBLEM-111B)
        (:EXECUTABLE-COUNTERPART APP)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING LEXORDER-ANTI-SYMMETRIC)
        (:FORWARD-CHAINING LEXORDER-TOTAL)
        (:INDUCTION FILTER)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:REWRITE PROBLEM-111H)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-54A)
        (:REWRITE PROBLEM-55)
        (:TYPE-PRESCRIPTION FILTER)
        (:TYPE-PRESCRIPTION LEXORDER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FILTER) (:DEFINITION REL))
Warnings:  Double-rewrite
PROBLEM-111I


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111I))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111I)
PROBLEM-111I

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111I ...) ...)
Rules: NIL
Warnings:  Double-rewrite
 PROBLEM-111I
ACL2 !>>(THEOREM
          PROBLEM-111J
          (IMPLIES (MEM E X)
                   (PERM (APP (RM E X) Y)
                         (RM E (APP X Y))))
          :HINTS
          (("Goal" :INDUCT (APP X Y)
                   :IN-THEORY (ENABLE PROBLEM-53 PROBLEM-54
                                      PROBLEM-54A PROBLEM-55 PROBLEM-111B))))


ACL2 !>>>(DEFTHM PROBLEM-111J
          (IMPLIES (MEM E X)
                   (PERM (APP (RM E X) Y)
                         (RM E (APP X Y))))
          :HINTS
          (("Goal" :DO-NOT-INDUCT T
                   :DO-NOT '(GENERALIZE)
                   :INDUCT (APP X Y)
                   :IN-THEORY (ENABLE PROBLEM-53 PROBLEM-54
                                      PROBLEM-54A PROBLEM-55 PROBLEM-111B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP X Y).

This suggestion was produced using the :induction rule APP.  If we
let (:P E X Y) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P E X Y))
     (IMPLIES (AND (CONSP X) (:P E (CDR X) Y))
              (:P E X Y))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (IMPLIES (MEM E X)
                  (PERM (APP (RM E X) Y)
                        (RM E (APP X Y))))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP X)) (MEM E X))
         (PERM (APP (RM E X) Y)
               (RM E (APP X Y)))).

But simplification reduces this to T, using the :definition MEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (IMPLIES (MEM E (CDR X))
                       (PERM (APP (RM E (CDR X)) Y)
                             (RM E (APP (CDR X) Y)))))
         (IMPLIES (MEM E X)
                  (PERM (APP (RM E X) Y)
                        (RM E (APP X Y))))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (IMPLIES (MEM E (CDR X))
                       (PERM (APP (RM E (CDR X)) Y)
                             (RM E (APP (CDR X) Y))))
              (MEM E X))
         (PERM (APP (RM E X) Y)
               (RM E (APP X Y)))).

This simplifies, using the :definitions APP, MEM (if-intro) and RM
(if-intro), primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS and PROBLEM-54, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (PERM (APP (RM E (CDR X)) Y)
                    (RM E (APP (CDR X) Y)))
              (MEM E (CDR X))
              (EQUAL E (CAR X)))
         (PERM (APP (CDR X) Y) (APP (CDR X) Y))).

But we reduce the conjecture to T, by the simple :rewrite rule PROBLEM-53.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (PERM (APP (RM E (CDR X)) Y)
                    (RM E (APP (CDR X) Y)))
              (MEM E (CDR X))
              (NOT (EQUAL E (CAR X))))
         (PERM (APP (CONS (CAR X) (RM E (CDR X))) Y)
               (CONS (CAR X) (RM E (APP (CDR X) Y))))).

But simplification reduces this to T, using the :definitions APP, MEM
and RM, the :equivalence rule PROBLEM-111B, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-54, PROBLEM-54A
and PROBLEM-55.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111J ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:EQUIVALENCE PROBLEM-111B)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-53)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-54A)
        (:REWRITE PROBLEM-55))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION MEM) (:DEFINITION RM))
PROBLEM-111J


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111J))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111J)
PROBLEM-111J

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111J ...) ...)
Rules: NIL
 PROBLEM-111J
ACL2 !>>(THEOREM
          PROBLEM-111K
          (IMPLIES (PERM A B)
                   (PERM (APP A C) (APP B C)))
          :HINTS
          (("Goal" :INDUCT (PERM A B)
                   :IN-THEORY (ENABLE PROBLEM-46 PROBLEM-48 PROBLEM-49A
                                      PROBLEM-54A PROBLEM-54 PROBLEM-55B
                                      PROBLEM-55 PROBLEM-111B PROBLEM-111J)))
          :RULE-CLASSES :CONGRUENCE)


ACL2 !>>>(DEFTHM PROBLEM-111K
           (IMPLIES (PERM A B)
                    (PERM (APP A C) (APP B C)))
           :RULE-CLASSES :CONGRUENCE
           :HINTS
           (("Goal"
                 :DO-NOT-INDUCT T
                 :DO-NOT '(GENERALIZE)
                 :INDUCT (PERM A B)
                 :IN-THEORY (ENABLE PROBLEM-46 PROBLEM-48 PROBLEM-49A
                                    PROBLEM-54A PROBLEM-54 PROBLEM-55B
                                    PROBLEM-55 PROBLEM-111B PROBLEM-111J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM A B).

This suggestion was produced using the :induction rule PERM.  If we
let (:P A B C) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B C))
     (IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
              (:P A B C))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) B)
                   (:P (CDR A) (RM (CAR A) B) C))
              (:P A B C))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable B is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (IMPLIES (PERM A B)
                  (PERM (APP A C) (APP B C)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP A)) (PERM A B))
         (PERM (APP A C) (APP B C))).

But simplification reduces this to T, using the :definitions APP and
PERM, primitive type reasoning and the :rewrite rule PROBLEM-54.

Subgoal *1/2
(IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
         (IMPLIES (PERM A B)
                  (PERM (APP A C) (APP B C)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) B))
              (PERM A B))
         (PERM (APP A C) (APP B C))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning and the :rewrite rule PROBLEM-55B.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (PERM (CDR A) (RM (CAR A) B))
                       (PERM (APP (CDR A) C)
                             (APP (RM (CAR A) B) C))))
         (IMPLIES (PERM A B)
                  (PERM (APP A C) (APP B C)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (PERM (CDR A) (RM (CAR A) B))
                       (PERM (APP (CDR A) C)
                             (APP (RM (CAR A) B) C)))
              (PERM A B))
         (PERM (APP A C) (APP B C))).

But simplification reduces this to T, using the :definitions APP, MEM
and PERM, the :equivalence rule PROBLEM-111B, primitive type reasoning,
the :rewrite rules PROBLEM-111J, PROBLEM-46, PROBLEM-48, PROBLEM-49A,
PROBLEM-54, PROBLEM-54A, PROBLEM-55 and PROBLEM-55B and the :type-
prescription rule MEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111K ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PERM)
        (:EQUIVALENCE PROBLEM-111B)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PERM)
        (:REWRITE PROBLEM-111J)
        (:REWRITE PROBLEM-46)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-54A)
        (:REWRITE PROBLEM-55)
        (:REWRITE PROBLEM-55B)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-111K


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111K))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111K)
PROBLEM-111K

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111K ...) ...)
Rules: NIL
 PROBLEM-111K
ACL2 !>>(THEOREM
            PROBLEM-111L
            (IMPLIES (PERM A B)
                     (PERM (APP C A) (APP C B)))
            :HINTS
            (("Goal" :INDUCT (APP C B)
                     :IN-THEORY (ENABLE PROBLEM-54A
                                        PROBLEM-54 PROBLEM-55 PROBLEM-111B)))
            :RULE-CLASSES :CONGRUENCE)


ACL2 !>>>(DEFTHM PROBLEM-111L
           (IMPLIES (PERM A B)
                    (PERM (APP C A) (APP C B)))
           :RULE-CLASSES :CONGRUENCE
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (APP C B)
                    :IN-THEORY (ENABLE PROBLEM-54A
                                       PROBLEM-54 PROBLEM-55 PROBLEM-111B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP C B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B C) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP C)) (:P A B C))
     (IMPLIES (AND (CONSP C) (:P A B (CDR C)))
              (:P A B C))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP C))
         (IMPLIES (PERM A B)
                  (PERM (APP C A) (APP C B)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP C)) (PERM A B))
         (PERM (APP C A) (APP C B))).

But simplification reduces this to T, using the :definition APP, the
:equivalence rule PROBLEM-111B, primitive type reasoning and the :rewrite
rule PROBLEM-55.

Subgoal *1/1
(IMPLIES (AND (CONSP C)
              (IMPLIES (PERM A B)
                       (PERM (APP (CDR C) A) (APP (CDR C) B))))
         (IMPLIES (PERM A B)
                  (PERM (APP C A) (APP C B)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP C)
              (IMPLIES (PERM A B)
                       (PERM (APP (CDR C) A) (APP (CDR C) B)))
              (PERM A B))
         (PERM (APP C A) (APP C B))).

But simplification reduces this to T, using the :definitions APP, MEM
and RM, the :equivalence rule PROBLEM-111B, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-54, PROBLEM-54A
and PROBLEM-55.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111L ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:EQUIVALENCE PROBLEM-111B)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-54)
        (:REWRITE PROBLEM-54A)
        (:REWRITE PROBLEM-55))
PROBLEM-111L


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111L))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111L)
PROBLEM-111L

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111L ...) ...)
Rules: NIL
 PROBLEM-111L
ACL2 !>>(THEOREM
           PROBLEM-111-A (PERM (QSORT X) X)
           :HINTS
           (("Goal" :INDUCT (QSORT X)
                    :IN-THEORY (ENABLE PROBLEM-54
                                       PROBLEM-111B PROBLEM-111H PROBLEM-111I
                                       PROBLEM-111K PROBLEM-111L))))


ACL2 !>>>(DEFTHM PROBLEM-111-A
           (PERM (QSORT X) X)
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (QSORT X)
                    :IN-THEORY (ENABLE PROBLEM-54
                                       PROBLEM-111B PROBLEM-111H PROBLEM-111I
                                       PROBLEM-111K PROBLEM-111L))))

ACL2 Warning [Double-rewrite] in ( DEFTHM PROBLEM-111-A ...):  In a
:REWRITE rule generated from PROBLEM-111-A, equivalence relation PERM
is maintained at one problematic occurrence of variable X in the right-
hand side, but not at any binding occurrence of X.  Consider replacing
that occurrence of X in the right-hand side with (DOUBLE-REWRITE X).
See :doc double-rewrite for more information on this issue.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (QSORT X).

This suggestion was produced using the :induction rule QSORT.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (ENDP (CDR X)))
                   (:P (FILTER '<< (CDR X) (CAR X)))
                   (:P (FILTER '>>= (CDR X) (CAR X))))
              (:P X))
     (IMPLIES (AND (NOT (ENDP X)) (ENDP (CDR X)))
              (:P X))
     (IMPLIES (ENDP X) (:P X))).
This induction is justified by the same argument used to admit QSORT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (ENDP (CDR X)))
              (PERM (QSORT (FILTER '<< (CDR X) (CAR X)))
                    (FILTER '<< (CDR X) (CAR X)))
              (PERM (QSORT (FILTER '>>= (CDR X) (CAR X)))
                    (FILTER '>>= (CDR X) (CAR X))))
         (PERM (QSORT X) X)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (PERM (QSORT (FILTER '<< (CDR X) (CAR X)))
                    (FILTER '<< (CDR X) (CAR X)))
              (PERM (QSORT (FILTER '>>= (CDR X) (CAR X)))
                    (FILTER '>>= (CDR X) (CAR X))))
         (PERM (QSORT X) X)).

But simplification reduces this to T, using the :congruence rules 
PROBLEM-111K and PROBLEM-111L, the :definitions MEM, PERM, QSORT and
RM, the :equivalence rule PROBLEM-111B, primitive type reasoning and
the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-111H, PROBLEM-111I and
PROBLEM-54.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X)) (ENDP (CDR X)))
         (PERM (QSORT X) X)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
         (PERM (QSORT X) X)).

But simplification reduces this to T, using the :definition QSORT,
primitive type reasoning and the :rewrite rule PROBLEM-54.

Subgoal *1/1
(IMPLIES (ENDP X) (PERM (QSORT X) X)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (PERM (QSORT X) X)).

But simplification reduces this to T, using the :definitions PERM and
QSORT, the :executable-counterpart of CONSP and the :rewrite rule PROBLEM-54.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111-A ...)
Rules: ((:CONGRUENCE PROBLEM-111K)
        (:CONGRUENCE PROBLEM-111L)
        (:DEFINITION ENDP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PERM)
        (:DEFINITION QSORT)
        (:DEFINITION RM)
        (:EQUIVALENCE PROBLEM-111B)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION QSORT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-111H)
        (:REWRITE PROBLEM-111I)
        (:REWRITE PROBLEM-54))
Warnings:  Double-rewrite
PROBLEM-111-A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111-A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111-A)
PROBLEM-111-A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111-A ...) ...)
Rules: NIL
Warnings:  Double-rewrite
 PROBLEM-111-A
ACL2 !>>(DEFUN ALL-REL (FN X E)
          (COND ((ENDP X) T)
                ((REL FN (CAR X) E)
                 (ALL-REL FN (CDR X) E))
                (T NIL)))

The admission of ALL-REL is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of ALL-REL is described by
the theorem (OR (EQUAL (ALL-REL FN X E) T) (EQUAL (ALL-REL FN X E) NIL)).

Summary
Form:  ( DEFUN ALL-REL ...)
Rules: NIL
 ALL-REL
ACL2 !>>(THEOREM PROBLEM-111M
                 (EQUAL (CAR (APP A B))
                        (IF (CONSP A) (CAR A) (CAR B))))


ACL2 !>>>(DEFTHM PROBLEM-111M
           (EQUAL (CAR (APP A B))
                  (IF (CONSP A) (CAR A) (CAR B)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE))))

[Note:  A hint was supplied for the goal above.  Thanks!]

This simplifies, using trivial observations, to the following two conjectures.

Subgoal 2
(IMPLIES (CONSP A)
         (EQUAL (CAR (APP A B)) (CAR A))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal 2'
(IMPLIES (CONSP (CONS A1 A2))
         (EQUAL (CAR (APP (CONS A1 A2) B)) A1)).

But simplification reduces this to T, using the :definition APP, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal 1
(IMPLIES (NOT (CONSP A))
         (EQUAL (CAR (APP A B)) (CAR B))).

But simplification reduces this to T, using the :definition APP and
primitive type reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111M ...)
Rules: ((:DEFINITION APP)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
PROBLEM-111M


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111M))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111M)
PROBLEM-111M

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111M ...) ...)
Rules: NIL
 PROBLEM-111M
ACL2 !>>(THEOREM PROBLEM-111N
                 (IMPLIES (AND (LEXORDER E (CAR A)) (ORDERED A))
                          (ALL-REL '>>= A E))
                 :HINTS (("Goal" :INDUCT (ALL-REL '>>= A E))))


ACL2 !>>>(DEFTHM PROBLEM-111N
           (IMPLIES (AND (LEXORDER E (CAR A)) (ORDERED A))
                    (ALL-REL '>>= A E))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ALL-REL '>>= A E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ALL-REL '>>= A E).

This suggestion was produced using the :induction rule ALL-REL.  If
we let (:P A E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP A))
                   (NOT (REL '>>= (CAR A) E)))
              (:P A E))
     (IMPLIES (AND (NOT (ENDP A))
                   (REL '>>= (CAR A) E)
                   (:P (CDR A) E))
              (:P A E))
     (IMPLIES (ENDP A) (:P A E))).
This induction is justified by the same argument used to admit ALL-REL.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP A))
              (NOT (REL '>>= (CAR A) E)))
         (IMPLIES (AND (LEXORDER E (CAR A)) (ORDERED A))
                  (ALL-REL '>>= A E))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP A)
              (NOT (REL '>>= (CAR A) E))
              (LEXORDER E (CAR A))
              (ORDERED A))
         (ALL-REL '>>= A E)).

But simplification reduces this to T, using the :definitions <<= and
REL, the :executable-counterpart of EQUAL, the :rewrite rules 
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP A))
              (REL '>>= (CAR A) E)
              (IMPLIES (AND (LEXORDER E (CADR A))
                            (ORDERED (CDR A)))
                       (ALL-REL '>>= (CDR A) E)))
         (IMPLIES (AND (LEXORDER E (CAR A)) (ORDERED A))
                  (ALL-REL '>>= A E))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (REL '>>= (CAR A) E)
              (IMPLIES (AND (LEXORDER E (CADR A))
                            (ORDERED (CDR A)))
                       (ALL-REL '>>= (CDR A) E))
              (LEXORDER E (CAR A))
              (ORDERED A))
         (ALL-REL '>>= A E)).

This simplifies, using the :definitions <<=, ALL-REL, ORDERED (if-intro)
and REL, the :executable-counterpart of EQUAL, the :rewrite rules 
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rules ALL-REL and LEXORDER, to the following three conjectures.

Subgoal *1/2.3
(IMPLIES (AND (CONSP A)
              (NOT (LEXORDER E (CADR A)))
              (LEXORDER E (CAR A))
              (NOT (CONSP (CDR A))))
         (ALL-REL '>>= (CDR A) E)).

But simplification reduces this to T, using the :definition ALL-REL
and the :rewrite rule DEFAULT-CAR.

Subgoal *1/2.2
(IMPLIES (AND (CONSP A)
              (NOT (LEXORDER E (CADR A)))
              (LEXORDER E (CAR A))
              (LEXORDER (CAR A) (CADR A))
              (ORDERED (CDR A)))
         (ALL-REL '>>= (CDR A) E)).

But simplification reduces this to T, using the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.1
(IMPLIES (AND (CONSP A)
              (NOT (ORDERED (CDR A)))
              (LEXORDER E (CAR A))
              (NOT (CONSP (CDR A))))
         (ALL-REL '>>= (CDR A) E)).

But simplification reduces this to T, using the :definition ORDERED.

Subgoal *1/1
(IMPLIES (ENDP A)
         (IMPLIES (AND (LEXORDER E (CAR A)) (ORDERED A))
                  (ALL-REL '>>= A E))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP A))
              (LEXORDER E (CAR A))
              (ORDERED A))
         (ALL-REL '>>= A E)).

But simplification reduces this to T, using the :definitions ALL-REL
and ORDERED and the :rewrite rule DEFAULT-CAR.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111N depends upon the :type-prescription rule
ALL-REL.

Summary
Form:  ( DEFTHM PROBLEM-111N ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ALL-REL)
        (:DEFINITION ENDP)
        (:DEFINITION NOT)
        (:DEFINITION ORDERED)
        (:DEFINITION REL)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:INDUCTION ALL-REL)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION ALL-REL)
        (:TYPE-PRESCRIPTION LEXORDER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ORDERED))
PROBLEM-111N


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111N))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111N)
PROBLEM-111N

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111N ...) ...)
Rules: NIL
 PROBLEM-111N
ACL2 !>>(THEOREM PROBLEM-111O
                 (IMPLIES (AND (LEXORDER D (CAR A))
                               (CONSP A)
                               (ORDERED (APP A (CONS E B))))
                          (LEXORDER D E))
                 :HINTS (("Goal" :INDUCT (APP A (CONS E B))
                                 :IN-THEORY (ENABLE PROBLEM-111M))))


ACL2 !>>>(DEFTHM PROBLEM-111O
           (IMPLIES (AND (LEXORDER D (CAR A))
                         (CONSP A)
                         (ORDERED (APP A (CONS E B))))
                    (LEXORDER D E))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP A (CONS E B))
                           :IN-THEORY (ENABLE PROBLEM-111M))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-111O ...):  A :REWRITE rule
generated from PROBLEM-111O contains the free variables A and B.  These
variables will be chosen by searching for instances of (LEXORDER D (CAR A))
and (ORDERED (APP A (CONS E B))) in the context of the term being rewritten.
This is generally a severe restriction on the applicability of a :REWRITE
rule.  See :DOC free-variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A (CONS E B)).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B D E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B D E))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B D E))
              (:P A B D E))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.

Subgoal *1/
(IMPLIES (AND (CONSP A)
              (IMPLIES (AND (LEXORDER D (CADR A))
                            (CONSP (CDR A))
                            (ORDERED (APP (CDR A) (CONS E B))))
                       (LEXORDER D E)))
         (IMPLIES (AND (LEXORDER D (CAR A))
                       (CONSP A)
                       (ORDERED (APP A (CONS E B))))
                  (LEXORDER D E))).

By case analysis we reduce the conjecture to

Subgoal *1/'
(IMPLIES (AND (CONSP A)
              (IMPLIES (AND (LEXORDER D (CADR A))
                            (CONSP (CDR A))
                            (ORDERED (APP (CDR A) (CONS E B))))
                       (LEXORDER D E))
              (LEXORDER D (CAR A))
              (ORDERED (APP A (CONS E B))))
         (LEXORDER D E)).

This simplifies, using the :definitions <<=, APP and ORDERED, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-TRANSITIVE
and PROBLEM-111M and the :type-prescription rules APP and LEXORDER,
to

Subgoal *1/''
(IMPLIES (AND (CONSP A)
              (NOT (LEXORDER D (CADR A)))
              (LEXORDER D (CAR A))
              (CONSP (CDR A))
              (LEXORDER (CAR A) (CADR A))
              (ORDERED (APP (CDR A) (CONS E B))))
         (LEXORDER D E)).

But simplification reduces this to T, using the :rewrite rule 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111O depends upon the :type-prescription rule
LEXORDER.

Summary
Form:  ( DEFTHM PROBLEM-111O ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION APP)
        (:DEFINITION NOT)
        (:DEFINITION ORDERED)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:REWRITE PROBLEM-111M)
        (:TYPE-PRESCRIPTION APP)
        (:TYPE-PRESCRIPTION LEXORDER))
Warnings:  Free
PROBLEM-111O


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111O))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111O)
PROBLEM-111O

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111O ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-111O
ACL2 !>>(THEOREM
             PROBLEM-111P
             (IFF (ORDERED (APP A (CONS E B)))
                  (AND (ORDERED A)
                       (ORDERED B)
                       (ALL-REL '<<= A E)
                       (ALL-REL '>>= B E)))
             :HINTS (("Goal" :INDUCT (ALL-REL '<<= A E)
                             :IN-THEORY (ENABLE PROBLEM-111M
                                                PROBLEM-111N PROBLEM-111O))))


ACL2 !>>>(DEFTHM PROBLEM-111P
           (IFF (ORDERED (APP A (CONS E B)))
                (AND (ORDERED A)
                     (ORDERED B)
                     (ALL-REL '<<= A E)
                     (ALL-REL '>>= B E)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ALL-REL '<<= A E)
                           :IN-THEORY (ENABLE PROBLEM-111M
                                              PROBLEM-111N PROBLEM-111O))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ALL-REL '<<= A E).

This suggestion was produced using the :induction rule ALL-REL.  If
we let (:P A B E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP A))
                   (NOT (REL '<<= (CAR A) E)))
              (:P A B E))
     (IMPLIES (AND (NOT (ENDP A))
                   (REL '<<= (CAR A) E)
                   (:P (CDR A) B E))
              (:P A B E))
     (IMPLIES (ENDP A) (:P A B E))).
This induction is justified by the same argument used to admit ALL-REL.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP A))
              (NOT (REL '<<= (CAR A) E)))
         (IFF (ORDERED (APP A (CONS E B)))
              (AND (ORDERED A)
                   (ORDERED B)
                   (ALL-REL '<<= A E)
                   (ALL-REL '>>= B E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP A)
              (NOT (REL '<<= (CAR A) E)))
         (COND ((ORDERED (APP A (CONS E B)))
                (AND (ORDERED A)
                     (ORDERED B)
                     (ALL-REL '<<= A E)
                     (ALL-REL '>>= B E)))
               ((AND (ORDERED A)
                     (ORDERED B)
                     (ALL-REL '<<= A E)
                     (ALL-REL '>>= B E))
                NIL)
               (T T))).

This simplifies, using the :definitions <<=, ALL-REL and REL and the
:executable-counterpart of EQUAL, to

Subgoal *1/3''
(IMPLIES (AND (CONSP A)
              (NOT (LEXORDER (CAR A) E)))
         (NOT (ORDERED (APP A (CONS E B))))).

The destructor terms (CAR A) and (CDR A) can be eliminated by using
CAR-CDR-ELIM to replace A by (CONS A1 A2), (CAR A) by A1 and (CDR A)
by A2.  This produces the following goal.

Subgoal *1/3'''
(IMPLIES (AND (CONSP (CONS A1 A2))
              (NOT (LEXORDER A1 E)))
         (NOT (ORDERED (APP (CONS A1 A2) (CONS E B))))).

This simplifies, using the :definitions <<=, APP and ORDERED, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-111M
and the :type-prescription rule APP, to

Subgoal *1/3'4'
(IMPLIES (AND (NOT (LEXORDER A1 E))
              (CONSP A2)
              (LEXORDER A1 (CAR A2)))
         (NOT (ORDERED (APP A2 (CONS E B))))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-111O
and the :type-prescription rules LEXORDER and ORDERED.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP A))
              (REL '<<= (CAR A) E)
              (IFF (ORDERED (APP (CDR A) (CONS E B)))
                   (AND (ORDERED (CDR A))
                        (ORDERED B)
                        (ALL-REL '<<= (CDR A) E)
                        (ALL-REL '>>= B E))))
         (IFF (ORDERED (APP A (CONS E B)))
              (AND (ORDERED A)
                   (ORDERED B)
                   (ALL-REL '<<= A E)
                   (ALL-REL '>>= B E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (REL '<<= (CAR A) E)
              (COND ((ORDERED (APP (CDR A) (CONS E B)))
                     (AND (ORDERED (CDR A))
                          (ORDERED B)
                          (ALL-REL '<<= (CDR A) E)
                          (ALL-REL '>>= B E)))
                    ((AND (ORDERED (CDR A))
                          (ORDERED B)
                          (ALL-REL '<<= (CDR A) E)
                          (ALL-REL '>>= B E))
                     NIL)
                    (T T)))
         (COND ((ORDERED (APP A (CONS E B)))
                (AND (ORDERED A)
                     (ORDERED B)
                     (ALL-REL '<<= A E)
                     (ALL-REL '>>= B E)))
               ((AND (ORDERED A)
                     (ORDERED B)
                     (ALL-REL '<<= A E)
                     (ALL-REL '>>= B E))
                NIL)
               (T T))).

This simplifies, using the :definitions <<=, ALL-REL, APP, ORDERED
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE, 
LEXORDER-TRANSITIVE and PROBLEM-111M and the :type-prescription rules
ALL-REL, APP, LEXORDER and ORDERED, to

Subgoal *1/2''
(IMPLIES (AND (CONSP A)
              (LEXORDER (CAR A) E)
              (NOT (ORDERED (APP (CDR A) (CONS E B))))
              (NOT (ORDERED (CDR A)))
              (NOT (CONSP (CDR A)))
              (ORDERED B)
              (ALL-REL '<<= (CDR A) E))
         (NOT (ALL-REL '>>= B E))).

But simplification reduces this to T, using the :definitions <<=, APP
and ORDERED, primitive type reasoning, the :rewrite rules CAR-CONS
and CDR-CONS and the :type-prescription rules LEXORDER and ORDERED.

Subgoal *1/1
(IMPLIES (ENDP A)
         (IFF (ORDERED (APP A (CONS E B)))
              (AND (ORDERED A)
                   (ORDERED B)
                   (ALL-REL '<<= A E)
                   (ALL-REL '>>= B E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP A))
         (COND ((ORDERED (APP A (CONS E B)))
                (AND (ORDERED A)
                     (ORDERED B)
                     (ALL-REL '<<= A E)
                     (ALL-REL '>>= B E)))
               ((AND (ORDERED A)
                     (ORDERED B)
                     (ALL-REL '<<= A E)
                     (ALL-REL '>>= B E))
                NIL)
               (T T))).

This simplifies, using the :definitions <<=, ALL-REL, APP and ORDERED
(if-intro), primitive type reasoning and the :rewrite rules CAR-CONS
and CDR-CONS, to the following four conjectures.

Subgoal *1/1.4
(IMPLIES (AND (NOT (CONSP A))
              (CONSP B)
              (NOT (LEXORDER E (CAR B)))
              (ORDERED B))
         (NOT (ALL-REL '>>= B E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL and the :executable-counterpart of EQUAL.

Subgoal *1/1.3
(IMPLIES (AND (NOT (CONSP A)) (NOT (CONSP B)))
         (ALL-REL '>>= B E)).

But simplification reduces this to T, using the :definition ALL-REL.

Subgoal *1/1.2
(IMPLIES (AND (NOT (CONSP A)) (NOT (CONSP B)))
         (ORDERED B)).

But simplification reduces this to T, using the :definition ORDERED.

Subgoal *1/1.1
(IMPLIES (AND (NOT (CONSP A))
              (LEXORDER E (CAR B))
              (ORDERED B))
         (ALL-REL '>>= B E)).

But simplification reduces this to T, using the :rewrite rule PROBLEM-111N
and the :type-prescription rules LEXORDER and ORDERED.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111P depends upon the :type-prescription rules
ALL-REL and ORDERED.

Summary
Form:  ( DEFTHM PROBLEM-111P ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ALL-REL)
        (:DEFINITION APP)
        (:DEFINITION ENDP)
        (:DEFINITION IFF)
        (:DEFINITION NOT)
        (:DEFINITION ORDERED)
        (:DEFINITION REL)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ALL-REL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:REWRITE PROBLEM-111M)
        (:REWRITE PROBLEM-111N)
        (:REWRITE PROBLEM-111O)
        (:TYPE-PRESCRIPTION ALL-REL)
        (:TYPE-PRESCRIPTION APP)
        (:TYPE-PRESCRIPTION LEXORDER)
        (:TYPE-PRESCRIPTION ORDERED))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ORDERED))
PROBLEM-111P


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111P))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111P)
PROBLEM-111P

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111P ...) ...)
Rules: NIL
 PROBLEM-111P
ACL2 !>>(THEOREM PROBLEM-111Q
                 (ALL-REL '<<= (FILTER '<< X E) E)
                 :HINTS (("Goal" :INDUCT (FILTER '<< X E))))


ACL2 !>>>(DEFTHM PROBLEM-111Q
           (ALL-REL '<<= (FILTER '<< X E) E)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FILTER '<< X E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FILTER '<< X E).

This suggestion was produced using the :induction rule FILTER.  If
we let (:P E X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (REL '<< (CAR X) E))
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (AND (NOT (ENDP X))
                   (REL '<< (CAR X) E)
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (ENDP X) (:P E X))).
This induction is justified by the same argument used to admit FILTER.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (REL '<< (CAR X) E))
              (ALL-REL '<<= (FILTER '<< (CDR X) E) E))
         (ALL-REL '<<= (FILTER '<< X E) E)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (NOT (REL '<< (CAR X) E))
              (ALL-REL '<<= (FILTER '<< (CDR X) E) E))
         (ALL-REL '<<= (FILTER '<< X E) E)).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rule LEXORDER-REFLEXIVE and the :type-prescription rule
ALL-REL.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (REL '<< (CAR X) E)
              (ALL-REL '<<= (FILTER '<< (CDR X) E) E))
         (ALL-REL '<<= (FILTER '<< X E) E)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (REL '<< (CAR X) E)
              (ALL-REL '<<= (FILTER '<< (CDR X) E) E))
         (ALL-REL '<<= (FILTER '<< X E) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
FILTER and REL, the :executable-counterpart of EQUAL, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rules ALL-REL, FILTER
and LEXORDER.

Subgoal *1/1
(IMPLIES (ENDP X)
         (ALL-REL '<<= (FILTER '<< X E) E)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (ALL-REL '<<= (FILTER '<< X E) E)).

But simplification reduces this to T, using the :definitions ALL-REL
and FILTER and the :executable-counterpart of CONSP.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111Q depends upon the :type-prescription rule
ALL-REL.

Summary
Form:  ( DEFTHM PROBLEM-111Q ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ALL-REL)
        (:DEFINITION ENDP)
        (:DEFINITION FILTER)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FILTER)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION ALL-REL)
        (:TYPE-PRESCRIPTION FILTER)
        (:TYPE-PRESCRIPTION LEXORDER))
PROBLEM-111Q


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111Q))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111Q)
PROBLEM-111Q

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111Q ...) ...)
Rules: NIL
 PROBLEM-111Q
ACL2 !>>(THEOREM PROBLEM-111R
                 (ALL-REL '>>= (FILTER '>>= X E) E)
                 :HINTS (("Goal" :INDUCT (FILTER '>>= X E))))


ACL2 !>>>(DEFTHM PROBLEM-111R
           (ALL-REL '>>= (FILTER '>>= X E) E)
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FILTER '>>= X E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FILTER '>>= X E).

This suggestion was produced using the :induction rule FILTER.  If
we let (:P E X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (REL '>>= (CAR X) E))
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (AND (NOT (ENDP X))
                   (REL '>>= (CAR X) E)
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (ENDP X) (:P E X))).
This induction is justified by the same argument used to admit FILTER.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (REL '>>= (CAR X) E))
              (ALL-REL '>>=
                       (FILTER '>>= (CDR X) E)
                       E))
         (ALL-REL '>>= (FILTER '>>= X E) E)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (NOT (REL '>>= (CAR X) E))
              (ALL-REL '>>=
                       (FILTER '>>= (CDR X) E)
                       E))
         (ALL-REL '>>= (FILTER '>>= X E) E)).

But simplification reduces this to T, using the :definitions <<=, FILTER
and REL, the :executable-counterpart of EQUAL and the :type-prescription
rule ALL-REL.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (REL '>>= (CAR X) E)
              (ALL-REL '>>=
                       (FILTER '>>= (CDR X) E)
                       E))
         (ALL-REL '>>= (FILTER '>>= X E) E)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (REL '>>= (CAR X) E)
              (ALL-REL '>>=
                       (FILTER '>>= (CDR X) E)
                       E))
         (ALL-REL '>>= (FILTER '>>= X E) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
FILTER and REL, the :executable-counterpart of EQUAL, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE
and LEXORDER-TRANSITIVE and the :type-prescription rules ALL-REL, FILTER
and LEXORDER.

Subgoal *1/1
(IMPLIES (ENDP X)
         (ALL-REL '>>= (FILTER '>>= X E) E)).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (ALL-REL '>>= (FILTER '>>= X E) E)).

But simplification reduces this to T, using the :definitions ALL-REL
and FILTER and the :executable-counterpart of CONSP.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111R depends upon the :type-prescription rule
ALL-REL.

Summary
Form:  ( DEFTHM PROBLEM-111R ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ALL-REL)
        (:DEFINITION ENDP)
        (:DEFINITION FILTER)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FILTER)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION ALL-REL)
        (:TYPE-PRESCRIPTION FILTER)
        (:TYPE-PRESCRIPTION LEXORDER))
PROBLEM-111R


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111R))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111R)
PROBLEM-111R

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111R ...) ...)
Rules: NIL
 PROBLEM-111R
ACL2 !>>(THEOREM PROBLEM-111S
                 (IMPLIES (ALL-REL FN X E)
                          (ALL-REL FN (RM D X) E))
                 :HINTS (("Goal" :INDUCT (RM D X))))


ACL2 !>>>(DEFTHM PROBLEM-111S
           (IMPLIES (ALL-REL FN X E)
                    (ALL-REL FN (RM D X) E))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RM D X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RM D X).

This suggestion was produced using the :induction rule RM.  If we let
(:P D E FN X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P D E FN X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL D (CAR X)))
                   (:P D E FN (CDR X)))
              (:P D E FN X))
     (IMPLIES (AND (CONSP X) (EQUAL D (CAR X)))
              (:P D E FN X))).
This induction is justified by the same argument used to admit RM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (ALL-REL FN X E)
                  (ALL-REL FN (RM D X) E))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (ALL-REL FN X E))
         (ALL-REL FN (RM D X) E)).

But simplification reduces this to T, using the :definitions ALL-REL
and RM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL D (CAR X)))
              (IMPLIES (ALL-REL FN (CDR X) E)
                       (ALL-REL FN (RM D (CDR X)) E)))
         (IMPLIES (ALL-REL FN X E)
                  (ALL-REL FN (RM D X) E))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL D (CAR X)))
              (IMPLIES (ALL-REL FN (CDR X) E)
                       (ALL-REL FN (RM D (CDR X)) E))
              (ALL-REL FN X E))
         (ALL-REL FN (RM D X) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
REL and RM, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rules ALL-REL and LEXORDER.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (EQUAL D (CAR X)))
         (IMPLIES (ALL-REL FN X E)
                  (ALL-REL FN (RM D X) E))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL D (CAR X))
              (ALL-REL FN X E))
         (ALL-REL FN (RM D X) E)).

This simplifies, using the :definition RM and primitive type reasoning,
to

Subgoal *1/1''
(IMPLIES (AND (CONSP X) (ALL-REL FN X E))
         (ALL-REL FN (CDR X) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111S depends upon the :type-prescription rule
ALL-REL.

Summary
Form:  ( DEFTHM PROBLEM-111S ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ALL-REL)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:DEFINITION RM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION ALL-REL)
        (:TYPE-PRESCRIPTION LEXORDER))
PROBLEM-111S


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111S))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111S)
PROBLEM-111S

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111S ...) ...)
Rules: NIL
 PROBLEM-111S
ACL2 !>>(THEOREM PROBLEM-111T
                 (IMPLIES (AND (ALL-REL FN (RM D X) E)
                               (REL FN D E))
                          (ALL-REL FN X E))
                 :HINTS (("Goal" :INDUCT (ALL-REL FN X E))))


ACL2 !>>>(DEFTHM PROBLEM-111T
           (IMPLIES (AND (ALL-REL FN (RM D X) E)
                         (REL FN D E))
                    (ALL-REL FN X E))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ALL-REL FN X E))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-111T ...):  A :REWRITE rule
generated from PROBLEM-111T contains the free variable D.  This variable
will be chosen by searching for an instance of (ALL-REL FN (RM D X) E)
in the context of the term being rewritten.  This is generally a severe
restriction on the applicability of a :REWRITE rule.  See :DOC free-
variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ALL-REL FN X E).

This suggestion was produced using the :induction rule ALL-REL.  If
we let (:P D E FN X) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (REL FN (CAR X) E)))
              (:P D E FN X))
     (IMPLIES (AND (NOT (ENDP X))
                   (REL FN (CAR X) E)
                   (:P D E FN (CDR X)))
              (:P D E FN X))
     (IMPLIES (ENDP X) (:P D E FN X))).
This induction is justified by the same argument used to admit ALL-REL.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (REL FN (CAR X) E)))
         (IMPLIES (AND (ALL-REL FN (RM D X) E)
                       (REL FN D E))
                  (ALL-REL FN X E))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (NOT (REL FN (CAR X) E))
              (ALL-REL FN (RM D X) E)
              (REL FN D E))
         (ALL-REL FN X E)).

This simplifies (dropping false conclusion; see :DOC clause), using
the :definitions <<=, ALL-REL and REL (if-intro), the :executable-
counterpart of EQUAL, primitive type reasoning and the :rewrite rule
LEXORDER-REFLEXIVE, to the following eight conjectures.

Subgoal *1/3.8
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR X) E))
              (ALL-REL '<<= (RM D X) E))
         (NOT (LEXORDER D E))).

This simplifies, using trivial observations, to

Subgoal *1/3.8'
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER (CAR X) E))
              (ALL-REL '<<= (RM D X) E))
         (NOT (LEXORDER D E))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/3.8''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (LEXORDER X1 E))
              (ALL-REL '<<= (RM D (CONS X1 X2)) E))
         (NOT (LEXORDER D E))).

This simplifies, using the :definition RM (if-intro), primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the following
two conjectures.

Subgoal *1/3.8.2
(IMPLIES (AND (NOT (LEXORDER X1 E))
              (EQUAL D X1)
              (ALL-REL '<<= X2 E))
         (NOT (LEXORDER D E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.8.1
(IMPLIES (AND (NOT (LEXORDER X1 E))
              (NOT (EQUAL D X1))
              (ALL-REL '<<= (CONS X1 (RM D X2)) E))
         (NOT (LEXORDER D E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/3.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) E)
              (ALL-REL '<< (RM D X) E)
              (EQUAL FN '<<)
              (LEXORDER D E))
         (EQUAL D E)).

This simplifies, using trivial observations, to

Subgoal *1/3.7'
(IMPLIES (AND (CONSP X)
              (ALL-REL '<< (RM D X) (CAR X))
              (LEXORDER D (CAR X)))
         (EQUAL D (CAR X))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/3.7''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (ALL-REL '<< (RM D (CONS X1 X2)) X1)
              (LEXORDER D X1))
         (EQUAL D X1)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
REL and RM, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.6
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (EQUAL (CAR X) E)
              (ALL-REL FN (RM D X) E)
              (NOT (EQUAL FN '<<))
              (LEXORDER E D))
         (EQUAL D E)).

This simplifies, using trivial observations, to

Subgoal *1/3.6'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (ALL-REL FN (RM D X) (CAR X))
              (NOT (EQUAL FN '<<))
              (LEXORDER (CAR X) D))
         (EQUAL D (CAR X))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/3.6''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (ALL-REL FN (RM D (CONS X1 X2)) X1)
              (NOT (EQUAL FN '<<))
              (LEXORDER X1 D))
         (EQUAL D X1)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
REL and RM, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.5
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (ALL-REL '>>= (RM D X) E)
              (EQUAL FN '>>=))
         (NOT (LEXORDER E D))).

This simplifies, using trivial observations, to

Subgoal *1/3.5'
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (ALL-REL '>>= (RM D X) E))
         (NOT (LEXORDER E D))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/3.5''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (LEXORDER E X1))
              (ALL-REL '>>= (RM D (CONS X1 X2)) E))
         (NOT (LEXORDER E D))).

This simplifies, using the :definition RM (if-intro), primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the following
two conjectures.

Subgoal *1/3.5.2
(IMPLIES (AND (NOT (LEXORDER E X1))
              (EQUAL D X1)
              (ALL-REL '>>= X2 E))
         (NOT (LEXORDER E D))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.5.1
(IMPLIES (AND (NOT (LEXORDER E X1))
              (NOT (EQUAL D X1))
              (ALL-REL '>>= (CONS X1 (RM D X2)) E))
         (NOT (LEXORDER E D))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/3.4
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR X)))
              (ALL-REL FN (RM D X) E)
              (LEXORDER E D))
         (EQUAL D E)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/3.4'
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E X1))
              (ALL-REL FN (RM D (CONS X1 X2)) E)
              (LEXORDER E D))
         (EQUAL D E)).

This simplifies, using the :definition RM (if-intro), primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the following
two conjectures.

Subgoal *1/3.4.2
(IMPLIES (AND (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E X1))
              (EQUAL D X1)
              (ALL-REL FN X2 E)
              (LEXORDER E D))
         (EQUAL D E)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.4.1
(IMPLIES (AND (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E X1))
              (NOT (EQUAL D X1))
              (ALL-REL FN (CONS X1 (RM D X2)) E)
              (LEXORDER E D))
         (EQUAL D E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, primitive type reasoning and the :rewrite rule CAR-CONS.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (EQUAL (CAR X) E)
              (ALL-REL '<< (RM D X) E)
              (LEXORDER D E))
         (EQUAL D E)).

This simplifies, using trivial observations, to

Subgoal *1/3.3'
(IMPLIES (AND (CONSP X)
              (ALL-REL '<< (RM D X) (CAR X))
              (LEXORDER D (CAR X)))
         (EQUAL D (CAR X))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/3.3''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (ALL-REL '<< (RM D (CONS X1 X2)) X1)
              (LEXORDER D X1))
         (EQUAL D X1)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
REL and RM, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR X) E))
              (ALL-REL '<< (RM D X) E)
              (LEXORDER D E))
         (EQUAL D E)).

This simplifies, using trivial observations, to

Subgoal *1/3.2'
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER (CAR X) E))
              (ALL-REL '<< (RM D X) E)
              (LEXORDER D E))
         (EQUAL D E)).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/3.2''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (LEXORDER X1 E))
              (ALL-REL '<< (RM D (CONS X1 X2)) E)
              (LEXORDER D E))
         (EQUAL D E)).

This simplifies, using the :definition RM (if-intro), primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the following
two conjectures.

Subgoal *1/3.2.2
(IMPLIES (AND (NOT (LEXORDER X1 E))
              (EQUAL D X1)
              (ALL-REL '<< X2 E)
              (LEXORDER D E))
         (EQUAL D E)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.2.1
(IMPLIES (AND (NOT (LEXORDER X1 E))
              (NOT (EQUAL D X1))
              (ALL-REL '<< (CONS X1 (RM D X2)) E)
              (LEXORDER D E))
         (EQUAL D E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR X)))
              (ALL-REL '>>= (RM D X) E))
         (NOT (LEXORDER E D))).

This simplifies, using trivial observations, to

Subgoal *1/3.1'
(IMPLIES (AND (CONSP X)
              (NOT (LEXORDER E (CAR X)))
              (ALL-REL '>>= (RM D X) E))
         (NOT (LEXORDER E D))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal *1/3.1''
(IMPLIES (AND (CONSP (CONS X1 X2))
              (NOT (LEXORDER E X1))
              (ALL-REL '>>= (RM D (CONS X1 X2)) E))
         (NOT (LEXORDER E D))).

This simplifies, using the :definition RM (if-intro), primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the following
two conjectures.

Subgoal *1/3.1.2
(IMPLIES (AND (NOT (LEXORDER E X1))
              (EQUAL D X1)
              (ALL-REL '>>= X2 E))
         (NOT (LEXORDER E D))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.1.1
(IMPLIES (AND (NOT (LEXORDER E X1))
              (NOT (EQUAL D X1))
              (ALL-REL '>>= (CONS X1 (RM D X2)) E))
         (NOT (LEXORDER E D))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (REL FN (CAR X) E)
              (IMPLIES (AND (ALL-REL FN (RM D (CDR X)) E)
                            (REL FN D E))
                       (ALL-REL FN (CDR X) E)))
         (IMPLIES (AND (ALL-REL FN (RM D X) E)
                       (REL FN D E))
                  (ALL-REL FN X E))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (REL FN (CAR X) E)
              (IMPLIES (AND (ALL-REL FN (RM D (CDR X)) E)
                            (REL FN D E))
                       (ALL-REL FN (CDR X) E))
              (ALL-REL FN (RM D X) E)
              (REL FN D E))
         (ALL-REL FN X E)).

This simplifies, using the :definitions <<=, ALL-REL (if-intro), REL
(if-intro) and RM (if-intro), the :executable-counterpart of EQUAL,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, 
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rules ALL-REL and LEXORDER, to the following five conjectures.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<=)
              (LEXORDER (CAR X) E)
              (NOT (ALL-REL '<<= (RM D (CDR X)) E))
              (NOT (EQUAL D (CAR X)))
              (ALL-REL '<<=
                       (CONS (CAR X) (RM D (CDR X)))
                       E)
              (LEXORDER D E))
         (ALL-REL '<<= (CDR X) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (NOT (ALL-REL '>>= (RM D (CDR X)) E))
              (NOT (EQUAL D (CAR X)))
              (ALL-REL '>>=
                       (CONS (CAR X) (RM D (CDR X)))
                       E)
              (EQUAL FN '>>=)
              (LEXORDER E D))
         (ALL-REL '>>= (CDR X) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR X))
              (NOT (EQUAL (CAR X) E))
              (NOT (ALL-REL FN (RM D (CDR X)) E))
              (NOT (EQUAL D (CAR X)))
              (ALL-REL FN (CONS (CAR X) (RM D (CDR X)))
                       E)
              (LEXORDER E D)
              (NOT (EQUAL D E)))
         (ALL-REL FN (CDR X) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (EQUAL FN '>>=)
              (LEXORDER E (CAR X))
              (NOT (ALL-REL '>>= (RM D (CDR X)) E))
              (NOT (EQUAL D (CAR X)))
              (ALL-REL '>>=
                       (CONS (CAR X) (RM D (CDR X)))
                       E)
              (LEXORDER E D))
         (ALL-REL '>>= (CDR X) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (EQUAL FN '<<)
              (LEXORDER (CAR X) E)
              (NOT (EQUAL (CAR X) E))
              (NOT (ALL-REL '<< (RM D (CDR X)) E))
              (NOT (EQUAL D (CAR X)))
              (ALL-REL '<<
                       (CONS (CAR X) (RM D (CDR X)))
                       E)
              (LEXORDER D E)
              (NOT (EQUAL D E)))
         (ALL-REL '<< (CDR X) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/1
(IMPLIES (ENDP X)
         (IMPLIES (AND (ALL-REL FN (RM D X) E)
                       (REL FN D E))
                  (ALL-REL FN X E))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP X))
              (ALL-REL FN (RM D X) E)
              (REL FN D E))
         (ALL-REL FN X E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
REL and RM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111T depends upon the :type-prescription rule
ALL-REL.

Summary
Form:  ( DEFTHM PROBLEM-111T ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ALL-REL)
        (:DEFINITION ENDP)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:DEFINITION RM)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ALL-REL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION ALL-REL)
        (:TYPE-PRESCRIPTION LEXORDER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ALL-REL)
             (:DEFINITION REL)
             (:DEFINITION RM))
Warnings:  Free
PROBLEM-111T


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111T))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111T)
PROBLEM-111T

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111T ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-111T
ACL2 !>>(THEOREM PROBLEM-111U
                 (IMPLIES (AND (ALL-REL FN B E) (MEM D B))
                          (REL FN D E))
                 :HINTS (("Goal" :INDUCT (MEM D B))))


ACL2 !>>>(DEFTHM PROBLEM-111U
           (IMPLIES (AND (ALL-REL FN B E) (MEM D B))
                    (REL FN D E))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MEM D B))))

ACL2 Warning [Non-rec] in ( DEFTHM PROBLEM-111U ...):  A :REWRITE rule
generated from PROBLEM-111U will be triggered only by terms containing
the function symbol REL, which has a non-recursive definition.  Unless
this definition is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Free] in ( DEFTHM PROBLEM-111U ...):  A :REWRITE rule
generated from PROBLEM-111U contains the free variable B.  This variable
will be chosen by searching for an instance of (ALL-REL FN B E) in
the context of the term being rewritten.  This is generally a severe
restriction on the applicability of a :REWRITE rule.  See :DOC free-
variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MEM D B).

This suggestion was produced using the :induction rule MEM.  If we
let (:P B D E FN) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP B)) (:P B D E FN))
     (IMPLIES (AND (CONSP B)
                   (NOT (EQUAL D (CAR B)))
                   (:P (CDR B) D E FN))
              (:P B D E FN))
     (IMPLIES (AND (CONSP B) (EQUAL D (CAR B)))
              (:P B D E FN))).
This induction is justified by the same argument used to admit MEM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP B))
         (IMPLIES (AND (ALL-REL FN B E) (MEM D B))
                  (REL FN D E))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP B))
              (ALL-REL FN B E)
              (MEM D B))
         (REL FN D E)).

But simplification reduces this to T, using the :definitions ALL-REL
and MEM.

Subgoal *1/2
(IMPLIES (AND (CONSP B)
              (NOT (EQUAL D (CAR B)))
              (IMPLIES (AND (ALL-REL FN (CDR B) E)
                            (MEM D (CDR B)))
                       (REL FN D E)))
         (IMPLIES (AND (ALL-REL FN B E) (MEM D B))
                  (REL FN D E))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP B)
              (NOT (EQUAL D (CAR B)))
              (IMPLIES (AND (ALL-REL FN (CDR B) E)
                            (MEM D (CDR B)))
                       (REL FN D E))
              (ALL-REL FN B E)
              (MEM D B))
         (REL FN D E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
MEM and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the
:type-prescription rule LEXORDER.

Subgoal *1/1
(IMPLIES (AND (CONSP B) (EQUAL D (CAR B)))
         (IMPLIES (AND (ALL-REL FN B E) (MEM D B))
                  (REL FN D E))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP B)
              (EQUAL D (CAR B))
              (ALL-REL FN B E)
              (MEM D B))
         (REL FN D E)).

This simplifies, using the :definitions <<=, MEM and REL (if-intro)
and primitive type reasoning, to the following six conjectures.

Subgoal *1/1.6
(IMPLIES (AND (CONSP B)
              (ALL-REL '<<= B E)
              (EQUAL FN '<<=))
         (LEXORDER (CAR B) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL and the :executable-counterpart of EQUAL.

Subgoal *1/1.5
(IMPLIES (AND (CONSP B)
              (ALL-REL FN B E)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=)))
         (NOT (EQUAL (CAR B) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, primitive type reasoning and the :rewrite rule LEXORDER-REFLEXIVE.

Subgoal *1/1.4
(IMPLIES (AND (CONSP B)
              (ALL-REL FN B E)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<)))
         (LEXORDER E (CAR B))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL.

Subgoal *1/1.3
(IMPLIES (AND (CONSP B)
              (ALL-REL '<< B E)
              (EQUAL FN '<<))
         (NOT (EQUAL (CAR B) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule LEXORDER-REFLEXIVE.

Subgoal *1/1.2
(IMPLIES (AND (CONSP B)
              (ALL-REL '<< B E)
              (EQUAL FN '<<))
         (LEXORDER (CAR B) E)).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL and the :executable-counterpart of EQUAL.

Subgoal *1/1.1
(IMPLIES (AND (CONSP B)
              (ALL-REL '>>= B E)
              (EQUAL FN '>>=))
         (LEXORDER E (CAR B))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL and the :executable-counterpart of EQUAL.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111U depends upon the :type-prescription rule
REL.

Summary
Form:  ( DEFTHM PROBLEM-111U ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ALL-REL)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MEM)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION LEXORDER)
        (:TYPE-PRESCRIPTION REL))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION REL))
Warnings:  Free and Non-rec
PROBLEM-111U


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111U))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111U)
PROBLEM-111U

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111U ...) ...)
Rules: NIL
Warnings:  Free and Non-rec
 PROBLEM-111U
ACL2 !>>(THEOREM PROBLEM-111V
                 (IMPLIES (AND (REL FN D E) (MEM D B))
                          (EQUAL (ALL-REL FN (RM D B) E)
                                 (ALL-REL FN B E)))
                 :HINTS (("Goal" :INDUCT (ALL-REL FN B E))))


ACL2 !>>>(DEFTHM PROBLEM-111V
           (IMPLIES (AND (REL FN D E) (MEM D B))
                    (EQUAL (ALL-REL FN (RM D B) E)
                           (ALL-REL FN B E)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (ALL-REL FN B E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ALL-REL FN B E).

This suggestion was produced using the :induction rule ALL-REL.  If
we let (:P B D E FN) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (ENDP B))
                   (NOT (REL FN (CAR B) E)))
              (:P B D E FN))
     (IMPLIES (AND (NOT (ENDP B))
                   (REL FN (CAR B) E)
                   (:P (CDR B) D E FN))
              (:P B D E FN))
     (IMPLIES (ENDP B) (:P B D E FN))).
This induction is justified by the same argument used to admit ALL-REL.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP B))
              (NOT (REL FN (CAR B) E)))
         (IMPLIES (AND (REL FN D E) (MEM D B))
                  (EQUAL (ALL-REL FN (RM D B) E)
                         (ALL-REL FN B E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP B)
              (NOT (REL FN (CAR B) E))
              (REL FN D E)
              (MEM D B))
         (EQUAL (ALL-REL FN (RM D B) E)
                (ALL-REL FN B E))).

This simplifies, using the :definitions <<=, ALL-REL and REL (if-intro),
the :executable-counterpart of EQUAL, primitive type reasoning and
the :rewrite rule LEXORDER-REFLEXIVE, to the following eight conjectures.

Subgoal *1/3.8
(IMPLIES (AND (CONSP B)
              (EQUAL FN '<<=)
              (NOT (LEXORDER (CAR B) E))
              (LEXORDER D E)
              (MEM D B))
         (NOT (ALL-REL '<<= (RM D B) E))).

This simplifies, using trivial observations, to

Subgoal *1/3.8'
(IMPLIES (AND (CONSP B)
              (NOT (LEXORDER (CAR B) E))
              (LEXORDER D E)
              (MEM D B))
         (NOT (ALL-REL '<<= (RM D B) E))).

The destructor terms (CAR B) and (CDR B) can be eliminated by using
CAR-CDR-ELIM to replace B by (CONS B1 B2), (CAR B) by B1 and (CDR B)
by B2.  This produces the following goal.

Subgoal *1/3.8''
(IMPLIES (AND (CONSP (CONS B1 B2))
              (NOT (LEXORDER B1 E))
              (LEXORDER D E)
              (MEM D (CONS B1 B2)))
         (NOT (ALL-REL '<<= (RM D (CONS B1 B2)) E))).

This simplifies, using the :definitions MEM (if-intro) and RM (if-intro),
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS,
to the following three conjectures.

Subgoal *1/3.8.3
(IMPLIES (AND (NOT (LEXORDER B1 E))
              (LEXORDER D E)
              (EQUAL D B1))
         (NOT (ALL-REL '<<= B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.8.2
(IMPLIES (AND (NOT (LEXORDER B1 E))
              (LEXORDER D E)
              (MEM D B2)
              (EQUAL D B1))
         (NOT (ALL-REL '<<= B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.8.1
(IMPLIES (AND (NOT (LEXORDER B1 E))
              (LEXORDER D E)
              (MEM D B2)
              (NOT (EQUAL D B1)))
         (NOT (ALL-REL '<<= (CONS B1 (RM D B2)) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/3.7
(IMPLIES (AND (CONSP B)
              (EQUAL (CAR B) E)
              (EQUAL FN '<<)
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D B))
         (NOT (ALL-REL '<< (RM D B) E))).

This simplifies, using trivial observations, to

Subgoal *1/3.7'
(IMPLIES (AND (CONSP B)
              (LEXORDER D (CAR B))
              (NOT (EQUAL D (CAR B)))
              (MEM D B))
         (NOT (ALL-REL '<< (RM D B) (CAR B)))).

The destructor terms (CAR B) and (CDR B) can be eliminated by using
CAR-CDR-ELIM to replace B by (CONS B1 B2), (CAR B) by B1 and (CDR B)
by B2.  This produces the following goal.

Subgoal *1/3.7''
(IMPLIES (AND (CONSP (CONS B1 B2))
              (LEXORDER D B1)
              (NOT (EQUAL D B1))
              (MEM D (CONS B1 B2)))
         (NOT (ALL-REL '<< (RM D (CONS B1 B2)) B1))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
MEM, REL and RM, the :executable-counterpart of EQUAL, primitive type
reasoning and the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.6
(IMPLIES (AND (CONSP B)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (EQUAL (CAR B) E)
              (NOT (EQUAL FN '<<))
              (LEXORDER E D)
              (NOT (EQUAL D E))
              (MEM D B))
         (NOT (ALL-REL FN (RM D B) E))).

This simplifies, using trivial observations, to

Subgoal *1/3.6'
(IMPLIES (AND (CONSP B)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (LEXORDER (CAR B) D)
              (NOT (EQUAL D (CAR B)))
              (MEM D B))
         (NOT (ALL-REL FN (RM D B) (CAR B)))).

The destructor terms (CAR B) and (CDR B) can be eliminated by using
CAR-CDR-ELIM to replace B by (CONS B1 B2), (CAR B) by B1 and (CDR B)
by B2.  This produces the following goal.

Subgoal *1/3.6''
(IMPLIES (AND (CONSP (CONS B1 B2))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '>>=))
              (NOT (EQUAL FN '<<))
              (LEXORDER B1 D)
              (NOT (EQUAL D B1))
              (MEM D (CONS B1 B2)))
         (NOT (ALL-REL FN (RM D (CONS B1 B2)) B1))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
MEM, REL and RM, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.5
(IMPLIES (AND (CONSP B)
              (NOT (LEXORDER E (CAR B)))
              (EQUAL FN '>>=)
              (LEXORDER E D)
              (MEM D B))
         (NOT (ALL-REL '>>= (RM D B) E))).

This simplifies, using trivial observations, to

Subgoal *1/3.5'
(IMPLIES (AND (CONSP B)
              (NOT (LEXORDER E (CAR B)))
              (LEXORDER E D)
              (MEM D B))
         (NOT (ALL-REL '>>= (RM D B) E))).

The destructor terms (CAR B) and (CDR B) can be eliminated by using
CAR-CDR-ELIM to replace B by (CONS B1 B2), (CAR B) by B1 and (CDR B)
by B2.  This produces the following goal.

Subgoal *1/3.5''
(IMPLIES (AND (CONSP (CONS B1 B2))
              (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (MEM D (CONS B1 B2)))
         (NOT (ALL-REL '>>= (RM D (CONS B1 B2)) E))).

This simplifies, using the :definitions MEM (if-intro) and RM (if-intro),
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS,
to the following three conjectures.

Subgoal *1/3.5.3
(IMPLIES (AND (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (EQUAL D B1))
         (NOT (ALL-REL '>>= B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.5.2
(IMPLIES (AND (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (MEM D B2)
              (EQUAL D B1))
         (NOT (ALL-REL '>>= B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.5.1
(IMPLIES (AND (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (MEM D B2)
              (NOT (EQUAL D B1)))
         (NOT (ALL-REL '>>= (CONS B1 (RM D B2)) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/3.4
(IMPLIES (AND (CONSP B)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E (CAR B)))
              (LEXORDER E D)
              (NOT (EQUAL D E))
              (MEM D B))
         (NOT (ALL-REL FN (RM D B) E))).

The destructor terms (CAR B) and (CDR B) can be eliminated by using
CAR-CDR-ELIM to replace B by (CONS B1 B2), (CAR B) by B1 and (CDR B)
by B2.  This produces the following goal.

Subgoal *1/3.4'
(IMPLIES (AND (CONSP (CONS B1 B2))
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (NOT (EQUAL D E))
              (MEM D (CONS B1 B2)))
         (NOT (ALL-REL FN (RM D (CONS B1 B2)) E))).

This simplifies, using the :definitions MEM (if-intro) and RM (if-intro),
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS,
to the following three conjectures.

Subgoal *1/3.4.3
(IMPLIES (AND (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (NOT (EQUAL D E))
              (EQUAL D B1))
         (NOT (ALL-REL FN B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.4.2
(IMPLIES (AND (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (NOT (EQUAL D E))
              (MEM D B2)
              (EQUAL D B1))
         (NOT (ALL-REL FN B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.4.1
(IMPLIES (AND (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (NOT (EQUAL D E))
              (MEM D B2)
              (NOT (EQUAL D B1)))
         (NOT (ALL-REL FN (CONS B1 (RM D B2)) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, primitive type reasoning and the :rewrite rule CAR-CONS.

Subgoal *1/3.3
(IMPLIES (AND (CONSP B)
              (EQUAL FN '<<)
              (EQUAL (CAR B) E)
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D B))
         (NOT (ALL-REL '<< (RM D B) E))).

This simplifies, using trivial observations, to

Subgoal *1/3.3'
(IMPLIES (AND (CONSP B)
              (LEXORDER D (CAR B))
              (NOT (EQUAL D (CAR B)))
              (MEM D B))
         (NOT (ALL-REL '<< (RM D B) (CAR B)))).

The destructor terms (CAR B) and (CDR B) can be eliminated by using
CAR-CDR-ELIM to replace B by (CONS B1 B2), (CAR B) by B1 and (CDR B)
by B2.  This produces the following goal.

Subgoal *1/3.3''
(IMPLIES (AND (CONSP (CONS B1 B2))
              (LEXORDER D B1)
              (NOT (EQUAL D B1))
              (MEM D (CONS B1 B2)))
         (NOT (ALL-REL '<< (RM D (CONS B1 B2)) B1))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL,
MEM, REL and RM, the :executable-counterpart of EQUAL, primitive type
reasoning and the :rewrite rules CAR-CONS, CDR-CONS and LEXORDER-REFLEXIVE.

Subgoal *1/3.2
(IMPLIES (AND (CONSP B)
              (EQUAL FN '<<)
              (NOT (LEXORDER (CAR B) E))
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D B))
         (NOT (ALL-REL '<< (RM D B) E))).

This simplifies, using trivial observations, to

Subgoal *1/3.2'
(IMPLIES (AND (CONSP B)
              (NOT (LEXORDER (CAR B) E))
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D B))
         (NOT (ALL-REL '<< (RM D B) E))).

The destructor terms (CAR B) and (CDR B) can be eliminated by using
CAR-CDR-ELIM to replace B by (CONS B1 B2), (CAR B) by B1 and (CDR B)
by B2.  This produces the following goal.

Subgoal *1/3.2''
(IMPLIES (AND (CONSP (CONS B1 B2))
              (NOT (LEXORDER B1 E))
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D (CONS B1 B2)))
         (NOT (ALL-REL '<< (RM D (CONS B1 B2)) E))).

This simplifies, using the :definitions MEM (if-intro) and RM (if-intro),
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS,
to the following three conjectures.

Subgoal *1/3.2.3
(IMPLIES (AND (NOT (LEXORDER B1 E))
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (EQUAL D B1))
         (NOT (ALL-REL '<< B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.2.2
(IMPLIES (AND (NOT (LEXORDER B1 E))
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D B2)
              (EQUAL D B1))
         (NOT (ALL-REL '<< B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.2.1
(IMPLIES (AND (NOT (LEXORDER B1 E))
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D B2)
              (NOT (EQUAL D B1)))
         (NOT (ALL-REL '<< (CONS B1 (RM D B2)) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/3.1
(IMPLIES (AND (CONSP B)
              (EQUAL FN '>>=)
              (NOT (LEXORDER E (CAR B)))
              (LEXORDER E D)
              (MEM D B))
         (NOT (ALL-REL '>>= (RM D B) E))).

This simplifies, using trivial observations, to

Subgoal *1/3.1'
(IMPLIES (AND (CONSP B)
              (NOT (LEXORDER E (CAR B)))
              (LEXORDER E D)
              (MEM D B))
         (NOT (ALL-REL '>>= (RM D B) E))).

The destructor terms (CAR B) and (CDR B) can be eliminated by using
CAR-CDR-ELIM to replace B by (CONS B1 B2), (CAR B) by B1 and (CDR B)
by B2.  This produces the following goal.

Subgoal *1/3.1''
(IMPLIES (AND (CONSP (CONS B1 B2))
              (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (MEM D (CONS B1 B2)))
         (NOT (ALL-REL '>>= (RM D (CONS B1 B2)) E))).

This simplifies, using the :definitions MEM (if-intro) and RM (if-intro),
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS,
to the following three conjectures.

Subgoal *1/3.1.3
(IMPLIES (AND (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (EQUAL D B1))
         (NOT (ALL-REL '>>= B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.1.2
(IMPLIES (AND (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (MEM D B2)
              (EQUAL D B1))
         (NOT (ALL-REL '>>= B2 E))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.1.1
(IMPLIES (AND (NOT (LEXORDER E B1))
              (LEXORDER E D)
              (MEM D B2)
              (NOT (EQUAL D B1)))
         (NOT (ALL-REL '>>= (CONS B1 (RM D B2)) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP B))
              (REL FN (CAR B) E)
              (IMPLIES (AND (REL FN D E) (MEM D (CDR B)))
                       (EQUAL (ALL-REL FN (RM D (CDR B)) E)
                              (ALL-REL FN (CDR B) E))))
         (IMPLIES (AND (REL FN D E) (MEM D B))
                  (EQUAL (ALL-REL FN (RM D B) E)
                         (ALL-REL FN B E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP B)
              (REL FN (CAR B) E)
              (IMPLIES (AND (REL FN D E) (MEM D (CDR B)))
                       (EQUAL (ALL-REL FN (RM D (CDR B)) E)
                              (ALL-REL FN (CDR B) E)))
              (REL FN D E)
              (MEM D B))
         (EQUAL (ALL-REL FN (RM D B) E)
                (ALL-REL FN B E))).

This simplifies, using the :definitions <<=, ALL-REL, MEM (if-intro),
REL (if-intro) and RM (if-intro), the :executable-counterpart of EQUAL,
primitive type reasoning, the :rewrite rules LEXORDER-REFLEXIVE and
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER, to the
following five conjectures.

Subgoal *1/2.5
(IMPLIES (AND (CONSP B)
              (EQUAL FN '<<=)
              (LEXORDER (CAR B) E)
              (EQUAL (ALL-REL '<<= (RM D (CDR B)) E)
                     (ALL-REL '<<= (CDR B) E))
              (LEXORDER D E)
              (MEM D (CDR B))
              (NOT (EQUAL D (CAR B))))
         (EQUAL (ALL-REL '<<=
                         (CONS (CAR B) (RM D (CDR B)))
                         E)
                (ALL-REL '<<= (CDR B) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.4
(IMPLIES (AND (CONSP B)
              (LEXORDER E (CAR B))
              (NOT (EQUAL (CAR B) E))
              (EQUAL (ALL-REL '>>= (RM D (CDR B)) E)
                     (ALL-REL '>>= (CDR B) E))
              (EQUAL FN '>>=)
              (LEXORDER E D)
              (MEM D (CDR B))
              (NOT (EQUAL D (CAR B))))
         (EQUAL (ALL-REL '>>=
                         (CONS (CAR B) (RM D (CDR B)))
                         E)
                (ALL-REL '>>= (CDR B) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.3
(IMPLIES (AND (CONSP B)
              (NOT (EQUAL FN '<<=))
              (NOT (EQUAL FN '<<))
              (LEXORDER E (CAR B))
              (NOT (EQUAL (CAR B) E))
              (EQUAL (ALL-REL FN (RM D (CDR B)) E)
                     (ALL-REL FN (CDR B) E))
              (LEXORDER E D)
              (NOT (EQUAL D E))
              (MEM D (CDR B))
              (NOT (EQUAL D (CAR B))))
         (EQUAL (ALL-REL FN (CONS (CAR B) (RM D (CDR B)))
                         E)
                (ALL-REL FN (CDR B) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
LEXORDER-REFLEXIVE and LEXORDER-TRANSITIVE and the :type-prescription
rule LEXORDER.

Subgoal *1/2.2
(IMPLIES (AND (CONSP B)
              (EQUAL FN '>>=)
              (LEXORDER E (CAR B))
              (EQUAL (ALL-REL '>>= (RM D (CDR B)) E)
                     (ALL-REL '>>= (CDR B) E))
              (LEXORDER E D)
              (MEM D (CDR B))
              (NOT (EQUAL D (CAR B))))
         (EQUAL (ALL-REL '>>=
                         (CONS (CAR B) (RM D (CDR B)))
                         E)
                (ALL-REL '>>= (CDR B) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/2.1
(IMPLIES (AND (CONSP B)
              (EQUAL FN '<<)
              (LEXORDER (CAR B) E)
              (NOT (EQUAL (CAR B) E))
              (EQUAL (ALL-REL '<< (RM D (CDR B)) E)
                     (ALL-REL '<< (CDR B) E))
              (LEXORDER D E)
              (NOT (EQUAL D E))
              (MEM D (CDR B))
              (NOT (EQUAL D (CAR B))))
         (EQUAL (ALL-REL '<<
                         (CONS (CAR B) (RM D (CDR B)))
                         E)
                (ALL-REL '<< (CDR B) E))).

But simplification reduces this to T, using the :definitions <<=, ALL-REL
and REL, the :executable-counterpart of EQUAL, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, LEXORDER-REFLEXIVE and 
LEXORDER-TRANSITIVE and the :type-prescription rule LEXORDER.

Subgoal *1/1
(IMPLIES (ENDP B)
         (IMPLIES (AND (REL FN D E) (MEM D B))
                  (EQUAL (ALL-REL FN (RM D B) E)
                         (ALL-REL FN B E)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP B))
              (REL FN D E)
              (MEM D B))
         (EQUAL (ALL-REL FN (RM D B) E)
                (ALL-REL FN B E))).

But simplification reduces this to T, using the :definitions <<=, MEM
and REL.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111V ...)
Rules: ((:DEFINITION <<=)
        (:DEFINITION ALL-REL)
        (:DEFINITION ENDP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION REL)
        (:DEFINITION RM)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ALL-REL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE LEXORDER-REFLEXIVE)
        (:REWRITE LEXORDER-TRANSITIVE)
        (:TYPE-PRESCRIPTION LEXORDER))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION MEM)
             (:DEFINITION REL)
             (:DEFINITION RM))
PROBLEM-111V


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111V))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111V)
PROBLEM-111V

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111V ...) ...)
Rules: NIL
 PROBLEM-111V
ACL2 !>>:----- "
; Note that I disable rel below!
"
ACL2 !>>(THEOREM
             PROBLEM-111W
             (IMPLIES (PERM A B)
                      (EQUAL (ALL-REL FN A E)
                             (ALL-REL FN B E)))
             :HINTS
             (("Goal" :INDUCT (PERM A B)
                      :IN-THEORY (E/D (PROBLEM-55B PROBLEM-111U PROBLEM-111V)
                                      (REL))))
             :RULE-CLASSES :CONGRUENCE)


ACL2 !>>>(DEFTHM PROBLEM-111W
           (IMPLIES (PERM A B)
                    (EQUAL (ALL-REL FN A E)
                           (ALL-REL FN B E)))
           :RULE-CLASSES :CONGRUENCE
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (PERM A B)
                    :IN-THEORY (E/D (PROBLEM-55B PROBLEM-111U PROBLEM-111V)
                                    (REL)))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM A B).

This suggestion was produced using the :induction rule PERM.  If we
let (:P A B E FN) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B E FN))
     (IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
              (:P A B E FN))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) B)
                   (:P (CDR A) (RM (CAR A) B) E FN))
              (:P A B E FN))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable B is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (IMPLIES (PERM A B)
                  (EQUAL (ALL-REL FN A E)
                         (ALL-REL FN B E)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP A)) (PERM A B))
         (EQUAL (ALL-REL FN A E)
                (ALL-REL FN B E))).

But simplification reduces this to T, using the :definitions ALL-REL
and PERM and the :executable-counterpart of EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
         (IMPLIES (PERM A B)
                  (EQUAL (ALL-REL FN A E)
                         (ALL-REL FN B E)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) B))
              (PERM A B))
         (EQUAL (ALL-REL FN A E)
                (ALL-REL FN B E))).

But simplification reduces this to T, using the :definition MEM, primitive
type reasoning and the :rewrite rule PROBLEM-55B.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (PERM (CDR A) (RM (CAR A) B))
                       (EQUAL (ALL-REL FN (CDR A) E)
                              (ALL-REL FN (RM (CAR A) B) E))))
         (IMPLIES (PERM A B)
                  (EQUAL (ALL-REL FN A E)
                         (ALL-REL FN B E)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (PERM (CDR A) (RM (CAR A) B))
                       (EQUAL (ALL-REL FN (CDR A) E)
                              (ALL-REL FN (RM (CAR A) B) E)))
              (PERM A B))
         (EQUAL (ALL-REL FN A E)
                (ALL-REL FN B E))).

This simplifies, using the :definitions ALL-REL (if-intro), MEM and
PERM (if-intro), primitive type reasoning and the :rewrite rule PROBLEM-55B,
to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP A)
              (EQUAL (ALL-REL FN (CDR A) E)
                     (ALL-REL FN (RM (CAR A) B) E))
              (MEM (CAR A) B)
              (PERM (CDR A) (RM (CAR A) B))
              (REL FN (CAR A) E))
         (EQUAL (ALL-REL FN (CDR A) E)
                (ALL-REL FN B E))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-111V
and the :type-prescription rules MEM and REL.

Subgoal *1/1.1
(IMPLIES (AND (CONSP A)
              (EQUAL (ALL-REL FN (CDR A) E)
                     (ALL-REL FN (RM (CAR A) B) E))
              (MEM (CAR A) B)
              (PERM (CDR A) (RM (CAR A) B))
              (NOT (REL FN (CAR A) E)))
         (EQUAL NIL (ALL-REL FN B E))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-111U
and the :type-prescription rules ALL-REL and MEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-111W ...)
Rules: ((:DEFINITION ALL-REL)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PERM)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PERM)
        (:REWRITE PROBLEM-111U)
        (:REWRITE PROBLEM-111V)
        (:REWRITE PROBLEM-55B)
        (:TYPE-PRESCRIPTION ALL-REL)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION REL))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ALL-REL)
             (:DEFINITION PERM))
PROBLEM-111W


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111W))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111W)
PROBLEM-111W

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111W ...) ...)
Rules: NIL
 PROBLEM-111W
ACL2 !>>(THEOREM
           PROBLEM-111-B (ORDERED (QSORT X))
           :HINTS
           (("Goal" :INDUCT (QSORT X)
                    :IN-THEORY (ENABLE PROBLEM-111P PROBLEM-111Q PROBLEM-111R
                                       PROBLEM-111W PROBLEM-111-A))))


ACL2 !>>>(DEFTHM PROBLEM-111-B
           (ORDERED (QSORT X))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (QSORT X)
                    :IN-THEORY (ENABLE PROBLEM-111P PROBLEM-111Q PROBLEM-111R
                                       PROBLEM-111W PROBLEM-111-A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (QSORT X).

This suggestion was produced using the :induction rule QSORT.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (ENDP (CDR X)))
                   (:P (FILTER '<< (CDR X) (CAR X)))
                   (:P (FILTER '>>= (CDR X) (CAR X))))
              (:P X))
     (IMPLIES (AND (NOT (ENDP X)) (ENDP (CDR X)))
              (:P X))
     (IMPLIES (ENDP X) (:P X))).
This induction is justified by the same argument used to admit QSORT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (ENDP (CDR X)))
              (ORDERED (QSORT (FILTER '<< (CDR X) (CAR X))))
              (ORDERED (QSORT (FILTER '>>= (CDR X) (CAR X)))))
         (ORDERED (QSORT X))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (ORDERED (QSORT (FILTER '<< (CDR X) (CAR X))))
              (ORDERED (QSORT (FILTER '>>= (CDR X) (CAR X)))))
         (ORDERED (QSORT X))).

This simplifies, using the :definition QSORT, the :rewrite rule PROBLEM-111P
(if-intro) and the :type-prescription rule ORDERED, to the following
two conjectures.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (ORDERED (QSORT (FILTER '<< (CDR X) (CAR X))))
              (ORDERED (QSORT (FILTER '>>= (CDR X) (CAR X)))))
         (ALL-REL '<<=
                  (QSORT (FILTER '<< (CDR X) (CAR X)))
                  (CAR X))).

But we reduce the conjecture to T, by the :congruence rule PROBLEM-111W
and the simple :rewrite rules PROBLEM-111-A and PROBLEM-111Q.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (ORDERED (QSORT (FILTER '<< (CDR X) (CAR X))))
              (ORDERED (QSORT (FILTER '>>= (CDR X) (CAR X)))))
         (ALL-REL '>>=
                  (QSORT (FILTER '>>= (CDR X) (CAR X)))
                  (CAR X))).

But we reduce the conjecture to T, by the :congruence rule PROBLEM-111W
and the simple :rewrite rules PROBLEM-111-A and PROBLEM-111R.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X)) (ENDP (CDR X)))
         (ORDERED (QSORT X))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
         (ORDERED (QSORT X))).

But simplification reduces this to T, using the :definitions ORDERED
and QSORT.

Subgoal *1/1
(IMPLIES (ENDP X) (ORDERED (QSORT X))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (NOT (CONSP X))
         (ORDERED (QSORT X))).

But simplification reduces this to T, using the :definition QSORT and
the :executable-counterpart of ORDERED.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-111-B depends upon the :type-prescription rule
ORDERED.

Summary
Form:  ( DEFTHM PROBLEM-111-B ...)
Rules: ((:CONGRUENCE PROBLEM-111W)
        (:DEFINITION ENDP)
        (:DEFINITION NOT)
        (:DEFINITION ORDERED)
        (:DEFINITION QSORT)
        (:EXECUTABLE-COUNTERPART ORDERED)
        (:INDUCTION QSORT)
        (:REWRITE PROBLEM-111-A)
        (:REWRITE PROBLEM-111P)
        (:REWRITE PROBLEM-111Q)
        (:REWRITE PROBLEM-111R)
        (:TYPE-PRESCRIPTION ORDERED))
Splitter rules (see :DOC splitter):
  if-intro: ((:REWRITE PROBLEM-111P))
PROBLEM-111-B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-111-B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-111-B)
PROBLEM-111-B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-111-B ...) ...)
Rules: NIL
 PROBLEM-111-B
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 112.
"
ACL2 !>>(DEFUN NO-DUPS (X)
          (IF (ENDP X)
              T
            (IF (MEM (CAR X) (CDR X))
                NIL
              (NO-DUPS (CDR X)))))

The admission of NO-DUPS is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of NO-DUPS is described by
the theorem (OR (EQUAL (NO-DUPS X) T) (EQUAL (NO-DUPS X) NIL)).  

Summary
Form:  ( DEFUN NO-DUPS ...)
Rules: NIL
 NO-DUPS
ACL2 !>>(DEFUN LIST-OF-NATSP (LST)
          (COND ((ENDP LST) T)
                (T (AND (NATP (CAR LST))
                        (LIST-OF-NATSP (CDR LST))))))

The admission of LIST-OF-NATSP is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT LST).  We observe that the type of LIST-OF-NATSP
is described by the theorem 
(OR (EQUAL (LIST-OF-NATSP LST) T) (EQUAL (LIST-OF-NATSP LST) NIL)).

Summary
Form:  ( DEFUN LIST-OF-NATSP ...)
Rules: NIL
 LIST-OF-NATSP
ACL2 !>>(DEFUN MAXIMAL (LST)
          (COND ((ENDP LST) -1)
                (T (MAX (CAR LST) (MAXIMAL (CDR LST))))))

The admission of MAXIMAL is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT LST).  We could deduce no constraints on the type of MAXIMAL.

Summary
Form:  ( DEFUN MAXIMAL ...)
Rules: NIL
 MAXIMAL
ACL2 !>>(THEOREM PROBLEM-112A
                 (IMPLIES (LIST-OF-NATSP LST)
                          (IFF (MEM (MAXIMAL LST) LST)
                               (CONSP LST)))
                 :HINTS (("Goal" :INDUCT (MEM (MAXIMAL LST) LST))))


ACL2 !>>>(DEFTHM PROBLEM-112A
           (IMPLIES (LIST-OF-NATSP LST)
                    (IFF (MEM (MAXIMAL LST) LST)
                         (CONSP LST)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MEM (MAXIMAL LST) LST))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  Two induction schemes are suggested
by the induction hint.  These merge into one derived induction scheme.

We will induct according to a scheme suggested by (MEM (MAXIMAL LST) LST).

This suggestion was produced using the :induction rules MAXIMAL and
MEM.  If we let (:P LST) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP LST)) (:P LST))
     (IMPLIES (AND (CONSP LST)
                   (NOT (EQUAL (MAXIMAL LST) (CAR LST)))
                   (:P (CDR LST)))
              (:P LST))
     (IMPLIES (AND (CONSP LST)
                   (EQUAL (MAXIMAL LST) (CAR LST)))
              (:P LST))).
This induction is justified by the same argument used to admit MEM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP LST))
         (IMPLIES (LIST-OF-NATSP LST)
                  (IFF (MEM (MAXIMAL LST) LST)
                       (CONSP LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP LST))
              (LIST-OF-NATSP LST))
         (COND ((MEM (MAXIMAL LST) LST) (CONSP LST))
               ((CONSP LST) NIL)
               (T T))).

But simplification reduces this to T, using the :definitions LIST-OF-NATSP,
MAXIMAL and MEM.

Subgoal *1/2
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL (MAXIMAL LST) (CAR LST)))
              (IMPLIES (LIST-OF-NATSP (CDR LST))
                       (IFF (MEM (MAXIMAL (CDR LST)) (CDR LST))
                            (CONSP (CDR LST)))))
         (IMPLIES (LIST-OF-NATSP LST)
                  (IFF (MEM (MAXIMAL LST) LST)
                       (CONSP LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL (MAXIMAL LST) (CAR LST)))
              (IMPLIES (LIST-OF-NATSP (CDR LST))
                       (COND ((MEM (MAXIMAL (CDR LST)) (CDR LST))
                              (AND (CONSP (CDR LST)) T))
                             ((CONSP (CDR LST)) NIL)
                             (T T)))
              (LIST-OF-NATSP LST))
         (COND ((MEM (MAXIMAL LST) LST) (CONSP LST))
               ((CONSP LST) NIL)
               (T T))).

This simplifies (dropping false conclusion; see :DOC clause), using
the :compound-recognizer rule NATP-COMPOUND-RECOGNIZER, the :definitions
LIST-OF-NATSP, MAX, MAXIMAL and MEM and the :type-prescription rules
MEM and NATP, to

Subgoal *1/2''
(IMPLIES (AND (CONSP LST)
              (<= (CAR LST) (MAXIMAL (CDR LST)))
              (NOT (EQUAL (MAXIMAL (CDR LST)) (CAR LST)))
              (NOT (MEM (MAXIMAL (CDR LST)) (CDR LST)))
              (NOT (CONSP (CDR LST))))
         (NOT (NATP (CAR LST)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER and the :definition MAXIMAL.

Subgoal *1/1
(IMPLIES (AND (CONSP LST)
              (EQUAL (MAXIMAL LST) (CAR LST)))
         (IMPLIES (LIST-OF-NATSP LST)
                  (IFF (MEM (MAXIMAL LST) LST)
                       (CONSP LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP LST)
              (EQUAL (MAXIMAL LST) (CAR LST))
              (LIST-OF-NATSP LST))
         (COND ((MEM (MAXIMAL LST) LST) (CONSP LST))
               ((CONSP LST) NIL)
               (T T))).

But simplification reduces this to T, using the :definitions MAX, MAXIMAL
and MEM and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-112A depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-112A ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION IFF)
        (:DEFINITION LIST-OF-NATSP)
        (:DEFINITION MAX)
        (:DEFINITION MAXIMAL)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MAXIMAL)
        (:INDUCTION MEM)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION NATP))
PROBLEM-112A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112A)
PROBLEM-112A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112A ...) ...)
Rules: NIL
 PROBLEM-112A
ACL2 !>>(THEOREM PROBLEM-112B
                 (IMPLIES (LIST-OF-NATSP LST)
                          (LIST-OF-NATSP (DEL E LST)))
                 :HINTS (("Goal" :INDUCT (DEL E LST))))


ACL2 !>>>(DEFTHM PROBLEM-112B
           (IMPLIES (LIST-OF-NATSP LST)
                    (LIST-OF-NATSP (DEL E LST)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (DEL E LST))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (DEL E LST).

This suggestion was produced using the :induction rule DEL.  If we
let (:P E LST) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP LST)) (:P E LST))
     (IMPLIES (AND (CONSP LST)
                   (NOT (EQUAL E (CAR LST)))
                   (:P E (CDR LST)))
              (:P E LST))
     (IMPLIES (AND (CONSP LST) (EQUAL E (CAR LST)))
              (:P E LST))).
This induction is justified by the same argument used to admit DEL.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP LST))
         (IMPLIES (LIST-OF-NATSP LST)
                  (LIST-OF-NATSP (DEL E LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP LST))
              (LIST-OF-NATSP LST))
         (LIST-OF-NATSP (DEL E LST))).

But simplification reduces this to T, using the :definitions DEL and
LIST-OF-NATSP.

Subgoal *1/2
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL E (CAR LST)))
              (IMPLIES (LIST-OF-NATSP (CDR LST))
                       (LIST-OF-NATSP (DEL E (CDR LST)))))
         (IMPLIES (LIST-OF-NATSP LST)
                  (LIST-OF-NATSP (DEL E LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL E (CAR LST)))
              (IMPLIES (LIST-OF-NATSP (CDR LST))
                       (LIST-OF-NATSP (DEL E (CDR LST))))
              (LIST-OF-NATSP LST))
         (LIST-OF-NATSP (DEL E LST))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions DEL and LIST-OF-NATSP,
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule LIST-OF-NATSP.

Subgoal *1/1
(IMPLIES (AND (CONSP LST) (EQUAL E (CAR LST)))
         (IMPLIES (LIST-OF-NATSP LST)
                  (LIST-OF-NATSP (DEL E LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP LST)
              (EQUAL E (CAR LST))
              (LIST-OF-NATSP LST))
         (LIST-OF-NATSP (DEL E LST))).

This simplifies, using the :definition DEL and primitive type reasoning,
to

Subgoal *1/1''
(IMPLIES (AND (CONSP LST) (LIST-OF-NATSP LST))
         (LIST-OF-NATSP (CDR LST))).

But simplification reduces this to T, using the :definition LIST-OF-NATSP.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-112B depends upon the :type-prescription rule
LIST-OF-NATSP.

Summary
Form:  ( DEFTHM PROBLEM-112B ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION DEL)
        (:DEFINITION LIST-OF-NATSP)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION DEL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION LIST-OF-NATSP))
PROBLEM-112B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112B)
PROBLEM-112B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112B ...) ...)
Rules: NIL
 PROBLEM-112B
ACL2 !>>(THEOREM
             PROBLEM-112C
             (IMPLIES (NO-DUPS LST)
                      (NO-DUPS (RM E LST)))
             :HINTS (("Goal" :INDUCT (RM E LST)
                             :IN-THEORY (ENABLE PROBLEM-55A PROBLEM-111E))))


ACL2 !>>>(DEFTHM PROBLEM-112C
           (IMPLIES (NO-DUPS LST)
                    (NO-DUPS (RM E LST)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RM E LST)
                           :IN-THEORY (ENABLE PROBLEM-55A PROBLEM-111E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RM E LST).

This suggestion was produced using the :induction rule RM.  If we let
(:P E LST) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP LST)) (:P E LST))
     (IMPLIES (AND (CONSP LST)
                   (NOT (EQUAL E (CAR LST)))
                   (:P E (CDR LST)))
              (:P E LST))
     (IMPLIES (AND (CONSP LST) (EQUAL E (CAR LST)))
              (:P E LST))).
This induction is justified by the same argument used to admit RM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP LST))
         (IMPLIES (NO-DUPS LST)
                  (NO-DUPS (RM E LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP LST)) (NO-DUPS LST))
         (NO-DUPS (RM E LST))).

But simplification reduces this to T, using the :definitions MEM and
NO-DUPS and the :rewrite rule PROBLEM-111E.

Subgoal *1/2
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL E (CAR LST)))
              (IMPLIES (NO-DUPS (CDR LST))
                       (NO-DUPS (RM E (CDR LST)))))
         (IMPLIES (NO-DUPS LST)
                  (NO-DUPS (RM E LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL E (CAR LST)))
              (IMPLIES (NO-DUPS (CDR LST))
                       (NO-DUPS (RM E (CDR LST))))
              (NO-DUPS LST))
         (NO-DUPS (RM E LST))).

This simplifies, using the :definitions NO-DUPS and RM, primitive type
reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rule NO-DUPS, to

Subgoal *1/2''
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL E (CAR LST)))
              (NO-DUPS (RM E (CDR LST)))
              (NOT (MEM (CAR LST) (CDR LST)))
              (NO-DUPS (CDR LST)))
         (NOT (MEM (CAR LST) (RM E (CDR LST))))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-55A
and the :type-prescription rule MEM.

Subgoal *1/1
(IMPLIES (AND (CONSP LST) (EQUAL E (CAR LST)))
         (IMPLIES (NO-DUPS LST)
                  (NO-DUPS (RM E LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP LST)
              (EQUAL E (CAR LST))
              (NO-DUPS LST))
         (NO-DUPS (RM E LST))).

This simplifies, using the :definition RM and primitive type reasoning,
to

Subgoal *1/1''
(IMPLIES (AND (CONSP LST) (NO-DUPS LST))
         (NO-DUPS (CDR LST))).

But simplification reduces this to T, using the :definition NO-DUPS.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-112C depends upon the :type-prescription rule
NO-DUPS.

Summary
Form:  ( DEFTHM PROBLEM-112C ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NO-DUPS)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-111E)
        (:REWRITE PROBLEM-55A)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION NO-DUPS))
PROBLEM-112C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112C)
PROBLEM-112C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112C ...) ...)
Rules: NIL
 PROBLEM-112C
ACL2 !>>(THEOREM PROBLEM-112D
                 (IMPLIES (LIST-OF-NATSP LST)
                          (AND (INTEGERP (MAXIMAL LST))
                               (<= -1 (MAXIMAL LST))))
                 :HINTS (("Goal" :INDUCT (LIST-OF-NATSP LST)))
                 :RULE-CLASSES :FORWARD-CHAINING)


ACL2 !>>>(DEFTHM PROBLEM-112D
           (IMPLIES (LIST-OF-NATSP LST)
                    (AND (INTEGERP (MAXIMAL LST))
                         (<= -1 (MAXIMAL LST))))
           :RULE-CLASSES :FORWARD-CHAINING
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LIST-OF-NATSP LST))))

ACL2 Observation in ( DEFTHM PROBLEM-112D ...):  The :TRIGGER-TERMS
for the :FORWARD-CHAINING rule PROBLEM-112D will consist of the list
containing (LIST-OF-NATSP LST).

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LIST-OF-NATSP LST).

This suggestion was produced using the :induction rule LIST-OF-NATSP.
If we let (:P LST) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (ENDP LST))
                   (NOT (NATP (CAR LST))))
              (:P LST))
     (IMPLIES (AND (NOT (ENDP LST))
                   (NATP (CAR LST))
                   (:P (CDR LST)))
              (:P LST))
     (IMPLIES (ENDP LST) (:P LST))).
This induction is justified by the same argument used to admit LIST-OF-NATSP.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP LST))
              (NOT (NATP (CAR LST))))
         (IMPLIES (LIST-OF-NATSP LST)
                  (AND (INTEGERP (MAXIMAL LST))
                       (<= -1 (MAXIMAL LST))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP LST)
              (NOT (NATP (CAR LST)))
              (LIST-OF-NATSP LST))
         (AND (INTEGERP (MAXIMAL LST))
              (<= -1 (MAXIMAL LST)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER and the :definition LIST-OF-NATSP.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP LST))
              (NATP (CAR LST))
              (IMPLIES (LIST-OF-NATSP (CDR LST))
                       (AND (INTEGERP (MAXIMAL (CDR LST)))
                            (<= -1 (MAXIMAL (CDR LST))))))
         (IMPLIES (LIST-OF-NATSP LST)
                  (AND (INTEGERP (MAXIMAL LST))
                       (<= -1 (MAXIMAL LST))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP LST)
              (NATP (CAR LST))
              (IMPLIES (LIST-OF-NATSP (CDR LST))
                       (AND (INTEGERP (MAXIMAL (CDR LST)))
                            (<= -1 (MAXIMAL (CDR LST)))))
              (LIST-OF-NATSP LST))
         (AND (INTEGERP (MAXIMAL LST))
              (<= -1 (MAXIMAL LST)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions LIST-OF-NATSP, MAX,
MAXIMAL and NOT and primitive type reasoning.

Subgoal *1/1
(IMPLIES (ENDP LST)
         (IMPLIES (LIST-OF-NATSP LST)
                  (AND (INTEGERP (MAXIMAL LST))
                       (<= -1 (MAXIMAL LST))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP LST))
              (LIST-OF-NATSP LST))
         (AND (INTEGERP (MAXIMAL LST))
              (<= -1 (MAXIMAL LST)))).

But simplification reduces this to T, using the :definitions LIST-OF-NATSP
and MAXIMAL and the :executable-counterparts of <, INTEGERP and NOT.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-112D ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ENDP)
        (:DEFINITION LIST-OF-NATSP)
        (:DEFINITION MAX)
        (:DEFINITION MAXIMAL)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART INTEGERP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LIST-OF-NATSP))
PROBLEM-112D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112D)
PROBLEM-112D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112D ...) ...)
Rules: NIL
 PROBLEM-112D
ACL2 !>>(THEOREM
             PROBLEM-112E
             (IMPLIES (AND (LIST-OF-NATSP LST)
                           (NO-DUPS LST)
                           (CONSP LST))
                      (< (MAXIMAL (RM (MAXIMAL LST) LST))
                         (MAXIMAL LST)))
             :HINTS (("Goal" :INDUCT (RM (MAXIMAL LST) LST)
                             :IN-THEORY (ENABLE PROBLEM-112A PROBLEM-112D)))
             :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-112E
           (IMPLIES (AND (LIST-OF-NATSP LST)
                         (NO-DUPS LST)
                         (CONSP LST))
                    (< (MAXIMAL (RM (MAXIMAL LST) LST))
                       (MAXIMAL LST)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RM (MAXIMAL LST) LST)
                           :IN-THEORY (ENABLE PROBLEM-112A PROBLEM-112D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  Two induction schemes are suggested
by the induction hint.  These merge into one derived induction scheme.

We will induct according to a scheme suggested by (RM (MAXIMAL LST) LST).

This suggestion was produced using the :induction rules MAXIMAL and
RM.  If we let (:P LST) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (NOT (CONSP LST)) (:P LST))
     (IMPLIES (AND (CONSP LST)
                   (NOT (EQUAL (MAXIMAL LST) (CAR LST)))
                   (:P (CDR LST)))
              (:P LST))
     (IMPLIES (AND (CONSP LST)
                   (EQUAL (MAXIMAL LST) (CAR LST)))
              (:P LST))).
This induction is justified by the same argument used to admit RM.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL (MAXIMAL LST) (CAR LST)))
              (IMPLIES (AND (LIST-OF-NATSP (CDR LST))
                            (NO-DUPS (CDR LST))
                            (CONSP (CDR LST)))
                       (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                          (MAXIMAL (CDR LST)))))
         (IMPLIES (AND (LIST-OF-NATSP LST)
                       (NO-DUPS LST)
                       (CONSP LST))
                  (< (MAXIMAL (RM (MAXIMAL LST) LST))
                     (MAXIMAL LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL (MAXIMAL LST) (CAR LST)))
              (IMPLIES (AND (LIST-OF-NATSP (CDR LST))
                            (NO-DUPS (CDR LST))
                            (CONSP (CDR LST)))
                       (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                          (MAXIMAL (CDR LST))))
              (LIST-OF-NATSP LST)
              (NO-DUPS LST))
         (< (MAXIMAL (RM (MAXIMAL LST) LST))
            (MAXIMAL LST))).

This simplifies, using the :compound-recognizer rule NATP-COMPOUND-RECOGNIZER,
the :definitions LIST-OF-NATSP (if-intro), MAX (if-intro), MAXIMAL
(if-intro), MEM, NO-DUPS (if-intro) and RM, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule NATP, to the following three conjectures.

Subgoal *1/2.3
(IMPLIES (AND (CONSP LST)
              (<= (CAR LST) (MAXIMAL (CDR LST)))
              (NOT (EQUAL (MAXIMAL (CDR LST)) (CAR LST)))
              (NOT (CONSP (CDR LST)))
              (NATP (CAR LST))
              (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                 (CAR LST)))
         (< (CAR LST) (MAXIMAL (CDR LST)))).

But forced simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :executable-counterpart of FORCE
and linear arithmetic.

Subgoal *1/2.2
(IMPLIES (AND (CONSP LST)
              (<= (CAR LST) (MAXIMAL (CDR LST)))
              (NOT (EQUAL (MAXIMAL (CDR LST)) (CAR LST)))
              (NOT (CONSP (CDR LST)))
              (NATP (CAR LST))
              (<= (CAR LST)
                  (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))))
         (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
            (MAXIMAL (CDR LST)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER and the :definition MAXIMAL.

Subgoal *1/2.1
(IMPLIES (AND (CONSP LST)
              (<= (CAR LST) (MAXIMAL (CDR LST)))
              (NOT (EQUAL (MAXIMAL (CDR LST)) (CAR LST)))
              (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                 (MAXIMAL (CDR LST)))
              (NATP (CAR LST))
              (LIST-OF-NATSP (CDR LST))
              (NOT (MEM (CAR LST) (CDR LST)))
              (NO-DUPS (CDR LST))
              (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                 (CAR LST)))
         (< (CAR LST) (MAXIMAL (CDR LST)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, linear arithmetic, the :forward-chaining
rule PROBLEM-112D and the :type-prescription rule LIST-OF-NATSP.

Subgoal *1/1
(IMPLIES (AND (CONSP LST)
              (EQUAL (MAXIMAL LST) (CAR LST)))
         (IMPLIES (AND (LIST-OF-NATSP LST)
                       (NO-DUPS LST)
                       (CONSP LST))
                  (< (MAXIMAL (RM (MAXIMAL LST) LST))
                     (MAXIMAL LST)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP LST)
              (EQUAL (MAXIMAL LST) (CAR LST))
              (LIST-OF-NATSP LST)
              (NO-DUPS LST))
         (< (MAXIMAL (RM (MAXIMAL LST) LST))
            (MAXIMAL LST))).

This simplifies, using the :definitions MAX, MAXIMAL and RM and primitive
type reasoning, to

Subgoal *1/1''
(IMPLIES (AND (CONSP LST)
              (EQUAL (MAXIMAL (CDR LST)) (CAR LST))
              (LIST-OF-NATSP LST)
              (NO-DUPS LST))
         (< (CAR LST) (CAR LST))).

This simplifies, using the :definitions LIST-OF-NATSP and NO-DUPS,
to

Subgoal *1/1'''
(IMPLIES (AND (CONSP LST)
              (EQUAL (MAXIMAL (CDR LST)) (CAR LST))
              (NATP (CAR LST))
              (LIST-OF-NATSP (CDR LST))
              (NOT (MEM (CAR LST) (CDR LST)))
              (NO-DUPS (CDR LST)))
         (< (CAR LST) (CAR LST))).

The destructor terms (CAR LST) and (CDR LST) can be eliminated by using
CAR-CDR-ELIM to replace LST by (CONS LST1 LST2), (CAR LST) by LST1
and (CDR LST) by LST2 and restrict the type of the new variable LST1
to be that of the term it replaces, as established by the :compound-
recognizer rule NATP-COMPOUND-RECOGNIZER.  This produces the following
goal.

Subgoal *1/1'4'
(IMPLIES (AND (INTEGERP LST1)
              (<= 0 LST1)
              (CONSP (CONS LST1 LST2))
              (EQUAL (MAXIMAL LST2) LST1)
              (NATP LST1)
              (LIST-OF-NATSP LST2)
              (NOT (MEM LST1 LST2))
              (NO-DUPS LST2))
         (< LST1 LST1)).

By case analysis we reduce the conjecture to

Subgoal *1/1'5'
(IMPLIES (AND (INTEGERP LST1)
              (<= 0 LST1)
              (CONSP (CONS LST1 LST2))
              (EQUAL (MAXIMAL LST2) LST1)
              (NATP LST1)
              (LIST-OF-NATSP LST2)
              (NOT (MEM LST1 LST2))
              (NO-DUPS LST2))
         (< LST1 LST1)).

This simplifies (dropping false conclusion; see :DOC clause), using
the :compound-recognizer rule NATP-COMPOUND-RECOGNIZER, the :definitions
MAXIMAL and NO-DUPS, the :executable-counterpart of <, primitive type
reasoning, the :forward-chaining rule PROBLEM-112D, the :rewrite rule
PROBLEM-112A and the :type-prescription rule LIST-OF-NATSP, to

Subgoal *1/1'6'
(IMPLIES (AND (<= 0 (MAXIMAL LST2))
              (LIST-OF-NATSP LST2))
         (CONSP LST2)).

But simplification reduces this to T, using the :definition MAXIMAL
and the :executable-counterpart of <.

That completes the proof of *1.

q.e.d. (given one forced hypothesis)

Modulo the following forced goal, that completes the proof of the input
Goal.  See :DOC forcing-round.

[1]Goal, below, will focus on
(ACL2-NUMBERP (MAXIMAL (CDR LST))),
which was forced in
 Subgoal *1/2.3
  by the use of linear arithmetic on
  (EQUAL (MAXIMAL (CDR LST)) (CAR LST)).

We now undertake Forcing Round 1.

[1]Goal
(IMPLIES (AND (CONSP LST)
              (<= (CAR LST) (MAXIMAL (CDR LST)))
              (NOT (EQUAL (MAXIMAL (CDR LST)) (CAR LST)))
              (NOT (CONSP (CDR LST)))
              (AND (INTEGERP (CAR LST))
                   (<= 0 (CAR LST)))
              (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                 (CAR LST))
              (<= (MAXIMAL (CDR LST)) (CAR LST)))
         (ACL2-NUMBERP (MAXIMAL (CDR LST)))).

By case analysis we reduce the conjecture to

[1]Goal'
(IMPLIES (AND (CONSP LST)
              (<= (CAR LST) (MAXIMAL (CDR LST)))
              (NOT (EQUAL (MAXIMAL (CDR LST)) (CAR LST)))
              (NOT (CONSP (CDR LST)))
              (INTEGERP (CAR LST))
              (<= 0 (CAR LST))
              (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                 (CAR LST))
              (<= (MAXIMAL (CDR LST)) (CAR LST)))
         (ACL2-NUMBERP (MAXIMAL (CDR LST)))).

This simplifies, using the :executable-counterparts of <, INTEGERP
and NOT and linear arithmetic, to

[1]Goal''
(IMPLIES (AND (EQUAL 0 (CAR LST))
              (CONSP LST)
              (<= 0 (MAXIMAL (CDR LST)))
              (NOT (EQUAL (MAXIMAL (CDR LST)) 0))
              (NOT (CONSP (CDR LST)))
              (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                 0)
              (<= (MAXIMAL (CDR LST)) 0))
         (ACL2-NUMBERP (MAXIMAL (CDR LST)))).

This simplifies, using the :executable-counterpart of <, primitive
type reasoning and the :rewrite rules DEFAULT-<-1 and DEFAULT-<-2,
to

[1]Goal'''
(IMPLIES (AND (EQUAL 0 (CAR LST))
              (CONSP LST)
              (NOT (CONSP (CDR LST)))
              (< (MAXIMAL (RM (MAXIMAL (CDR LST)) (CDR LST)))
                 0))
         (ACL2-NUMBERP (MAXIMAL (CDR LST)))).

But simplification reduces this to T, using the :definitions MAXIMAL
and RM and the :executable-counterparts of < and ACL2-NUMBERP.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-112E ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION LIST-OF-NATSP)
        (:DEFINITION MAX)
        (:DEFINITION MAXIMAL)
        (:DEFINITION MEM)
        (:DEFINITION NO-DUPS)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART ACL2-NUMBERP)
        (:EXECUTABLE-COUNTERPART FORCE)
        (:EXECUTABLE-COUNTERPART INTEGERP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING PROBLEM-112D)
        (:INDUCTION MAXIMAL)
        (:INDUCTION RM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-<-1)
        (:REWRITE DEFAULT-<-2)
        (:REWRITE PROBLEM-112A)
        (:TYPE-PRESCRIPTION LIST-OF-NATSP)
        (:TYPE-PRESCRIPTION NATP))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION LIST-OF-NATSP)
             (:DEFINITION MAX)
             (:DEFINITION MAXIMAL)
             (:DEFINITION NO-DUPS))
PROBLEM-112E


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112E))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112E)
PROBLEM-112E

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112E ...) ...)
Rules: NIL
 PROBLEM-112E
ACL2 !>>(THEOREM PROBLEM-112F
                 (EQUAL (LEN (RM E LST))
                        (IF (MEM E LST)
                            (- (LEN LST) 1)
                          (LEN LST)))
                 :HINTS (("Goal" :INDUCT (RM E LST)
                                 :IN-THEORY (ENABLE PROBLEM-111E))))


ACL2 !>>>(DEFTHM PROBLEM-112F
           (EQUAL (LEN (RM E LST))
                  (IF (MEM E LST)
                      (- (LEN LST) 1)
                    (LEN LST)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RM E LST)
                           :IN-THEORY (ENABLE PROBLEM-111E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RM E LST).

This suggestion was produced using the :induction rule RM.  If we let
(:P E LST) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP LST)) (:P E LST))
     (IMPLIES (AND (CONSP LST)
                   (NOT (EQUAL E (CAR LST)))
                   (:P E (CDR LST)))
              (:P E LST))
     (IMPLIES (AND (CONSP LST) (EQUAL E (CAR LST)))
              (:P E LST))).
This induction is justified by the same argument used to admit RM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP LST))
         (EQUAL (LEN (RM E LST))
                (IF (MEM E LST)
                    (+ -1 (LEN LST))
                  (LEN LST)))).

But simplification reduces this to T, using the :definitions LEN and
MEM, the :executable-counterpart of EQUAL and the :rewrite rule PROBLEM-111E.

Subgoal *1/2
(IMPLIES (AND (CONSP LST)
              (NOT (EQUAL E (CAR LST)))
              (EQUAL (LEN (RM E (CDR LST)))
                     (IF (MEM E (CDR LST))
                         (+ -1 (LEN (CDR LST)))
                       (LEN (CDR LST)))))
         (EQUAL (LEN (RM E LST))
                (IF (MEM E LST)
                    (+ -1 (LEN LST))
                  (LEN LST)))).

But simplification reduces this to T, using the :definitions FIX, LEN,
MEM, RM and SYNP, the :executable-counterpart of BINARY-+, primitive
type reasoning, the :rewrite rules CDR-CONS, FOLD-CONSTS-IN-+, 
MINUS-CANCELLATION-ON-LEFT, PROBLEM-111E and UNICITY-OF-0 and the :type-
prescription rules LEN and MEM.

Subgoal *1/1
(IMPLIES (AND (CONSP LST) (EQUAL E (CAR LST)))
         (EQUAL (LEN (RM E LST))
                (IF (MEM E LST)
                    (+ -1 (LEN LST))
                  (LEN LST)))).

This simplifies, using the :definitions MEM and RM and primitive type
reasoning, to

Subgoal *1/1'
(IMPLIES (CONSP LST)
         (EQUAL (LEN (CDR LST))
                (+ -1 (LEN LST)))).

But simplification reduces this to T, using the :definitions FIX, LEN
and SYNP, the :executable-counterpart of BINARY-+, primitive type reasoning,
the :rewrite rules FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-
prescription rule LEN.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-112F ...)
Rules: ((:DEFINITION FIX)
        (:DEFINITION LEN)
        (:DEFINITION MEM)
        (:DEFINITION RM)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RM)
        (:REWRITE CDR-CONS)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE MINUS-CANCELLATION-ON-LEFT)
        (:REWRITE PROBLEM-111E)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION LEN)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-112F


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112F))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112F)
PROBLEM-112F

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112F ...) ...)
Rules: NIL
 PROBLEM-112F
ACL2 !>>(DEFUN INDUCTION-HINT (LST N)
          (DECLARE (XARGS :MEASURE (ACL2-COUNT N)))
          (COND ((ZP N) (LIST LST N))
                ((ENDP LST) (LIST LST N))
                (T (INDUCTION-HINT (RM (MAXIMAL LST) LST)
                                   (- N 1)))))

The admission of INDUCTION-HINT is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT N).  We observe that the type of INDUCTION-HINT
is described by the theorem 
(AND (CONSP (INDUCTION-HINT LST N)) (TRUE-LISTP (INDUCTION-HINT LST N))).
We used primitive type reasoning.

Summary
Form:  ( DEFUN INDUCTION-HINT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 INDUCTION-HINT
ACL2 !>>(THEOREM PROBLEM-112G
                 (IMPLIES (LIST-OF-NATSP X)
                          (LIST-OF-NATSP (RM E X)))
                 :HINTS (("Goal" :INDUCT (RM E X)
                                 :IN-THEORY (ENABLE PROBLEM-111E))))


ACL2 !>>>(DEFTHM PROBLEM-112G
           (IMPLIES (LIST-OF-NATSP X)
                    (LIST-OF-NATSP (RM E X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RM E X)
                           :IN-THEORY (ENABLE PROBLEM-111E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RM E X).

This suggestion was produced using the :induction rule RM.  If we let
(:P E X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P E X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL E (CAR X)))
                   (:P E (CDR X)))
              (:P E X))
     (IMPLIES (AND (CONSP X) (EQUAL E (CAR X)))
              (:P E X))).
This induction is justified by the same argument used to admit RM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (LIST-OF-NATSP X)
                  (LIST-OF-NATSP (RM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (LIST-OF-NATSP X))
         (LIST-OF-NATSP (RM E X))).

But simplification reduces this to T, using the :definitions LIST-OF-NATSP
and MEM and the :rewrite rule PROBLEM-111E.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (IMPLIES (LIST-OF-NATSP (CDR X))
                       (LIST-OF-NATSP (RM E (CDR X)))))
         (IMPLIES (LIST-OF-NATSP X)
                  (LIST-OF-NATSP (RM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (IMPLIES (LIST-OF-NATSP (CDR X))
                       (LIST-OF-NATSP (RM E (CDR X))))
              (LIST-OF-NATSP X))
         (LIST-OF-NATSP (RM E X))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions LIST-OF-NATSP and RM,
primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule LIST-OF-NATSP.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (EQUAL E (CAR X)))
         (IMPLIES (LIST-OF-NATSP X)
                  (LIST-OF-NATSP (RM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL E (CAR X))
              (LIST-OF-NATSP X))
         (LIST-OF-NATSP (RM E X))).

This simplifies, using the :definition RM and primitive type reasoning,
to

Subgoal *1/1''
(IMPLIES (AND (CONSP X) (LIST-OF-NATSP X))
         (LIST-OF-NATSP (CDR X))).

But simplification reduces this to T, using the :definition LIST-OF-NATSP.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-112G depends upon the :type-prescription rule
LIST-OF-NATSP.

Summary
Form:  ( DEFTHM PROBLEM-112G ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION LIST-OF-NATSP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION RM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-111E)
        (:TYPE-PRESCRIPTION LIST-OF-NATSP))
PROBLEM-112G


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112G))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112G)
PROBLEM-112G

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112G ...) ...)
Rules: NIL
 PROBLEM-112G
ACL2 !>>(THEOREM PROBLEM-112H
                 (IMPLIES (AND (CONSP X) (LIST-OF-NATSP X))
                          (<= 0 (MAXIMAL X)))
                 :HINTS (("Goal" :INDUCT (LIST-OF-NATSP X)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-112H
           (IMPLIES (AND (CONSP X) (LIST-OF-NATSP X))
                    (<= 0 (MAXIMAL X)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LIST-OF-NATSP X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LIST-OF-NATSP X).

This suggestion was produced using the :induction rule LIST-OF-NATSP.
If we let (:P X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (NOT (NATP (CAR X))))
              (:P X))
     (IMPLIES (AND (NOT (ENDP X))
                   (NATP (CAR X))
                   (:P (CDR X)))
              (:P X))
     (IMPLIES (ENDP X) (:P X))).
This induction is justified by the same argument used to admit LIST-OF-NATSP.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP X))
              (NOT (NATP (CAR X))))
         (IMPLIES (AND (CONSP X) (LIST-OF-NATSP X))
                  (<= 0 (MAXIMAL X)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (NOT (NATP (CAR X)))
              (LIST-OF-NATSP X))
         (<= 0 (MAXIMAL X))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER and the :definition LIST-OF-NATSP.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (NATP (CAR X))
              (IMPLIES (AND (CONSP (CDR X))
                            (LIST-OF-NATSP (CDR X)))
                       (<= 0 (MAXIMAL (CDR X)))))
         (IMPLIES (AND (CONSP X) (LIST-OF-NATSP X))
                  (<= 0 (MAXIMAL X)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NATP (CAR X))
              (IMPLIES (AND (CONSP (CDR X))
                            (LIST-OF-NATSP (CDR X)))
                       (<= 0 (MAXIMAL (CDR X))))
              (LIST-OF-NATSP X))
         (<= 0 (MAXIMAL X))).

This simplifies, using the :compound-recognizer rule NATP-COMPOUND-RECOGNIZER,
the :definitions LIST-OF-NATSP, MAX (if-intro), MAXIMAL (if-intro)
and NOT (if-intro) and primitive type reasoning, to the following two
conjectures.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (NATP (CAR X))
              (NOT (CONSP (CDR X)))
              (LIST-OF-NATSP (CDR X)))
         (<= 0 (CAR X))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (NATP (CAR X))
              (<= 0 (MAXIMAL (CDR X)))
              (LIST-OF-NATSP (CDR X))
              (< (MAXIMAL (CDR X)) (CAR X)))
         (<= 0 (CAR X))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (ENDP X)
         (IMPLIES (AND (CONSP X) (LIST-OF-NATSP X))
                  (<= 0 (MAXIMAL X)))).

But we reduce the conjecture to T, by case analysis.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-112H ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ENDP)
        (:DEFINITION LIST-OF-NATSP)
        (:DEFINITION MAX)
        (:DEFINITION MAXIMAL)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LIST-OF-NATSP))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION MAX)
             (:DEFINITION MAXIMAL)
             (:DEFINITION NOT))
PROBLEM-112H


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112H))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112H)
PROBLEM-112H

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112H ...) ...)
Rules: NIL
 PROBLEM-112H
ACL2 !>>(THEOREM PROBLEM-112I
                 (EQUAL (< 0 (LEN X)) (CONSP X))
                 :HINTS (("Goal" :INDUCT (LEN X))))


ACL2 !>>>(DEFTHM PROBLEM-112I
           (EQUAL (< 0 (LEN X)) (CONSP X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LEN X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LEN X).

This suggestion was produced using the :induction rule LEN.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit LEN.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (< 0 (LEN X)) (CONSP X))).

But simplification reduces this to T, using the :definition LEN and
the :executable-counterparts of < and EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (< 0 (LEN (CDR X)))
                     (CONSP (CDR X))))
         (EQUAL (< 0 (LEN X)) (CONSP X))).

But simplification reduces this to T, using the :definition LEN, primitive
type reasoning and the :type-prescription rule LEN.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-112I ...)
Rules: ((:DEFINITION LEN)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN)
        (:TYPE-PRESCRIPTION LEN))
PROBLEM-112I


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112I))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112I)
PROBLEM-112I

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112I ...) ...)
Rules: NIL
 PROBLEM-112I
ACL2 !>>(THEOREM
           PROBLEM-112J
           (IMPLIES (AND (NATP N)
                         (LIST-OF-NATSP LST)
                         (NO-DUPS LST)
                         (< (MAXIMAL LST) N))
                    (<= (LEN LST) N))
           :HINTS
           (("Goal" :INDUCT (INDUCTION-HINT LST N)
                    :IN-THEORY (ENABLE PROBLEM-112A PROBLEM-112C PROBLEM-112D
                                       PROBLEM-112E PROBLEM-112F PROBLEM-112G
                                       PROBLEM-112H PROBLEM-112I))))


ACL2 !>>>(DEFTHM PROBLEM-112J
           (IMPLIES (AND (NATP N)
                         (LIST-OF-NATSP LST)
                         (NO-DUPS LST)
                         (< (MAXIMAL LST) N))
                    (<= (LEN LST) N))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (INDUCTION-HINT LST N)
                    :IN-THEORY (ENABLE PROBLEM-112A PROBLEM-112C PROBLEM-112D
                                       PROBLEM-112E PROBLEM-112F PROBLEM-112G
                                       PROBLEM-112H PROBLEM-112I))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (INDUCTION-HINT LST N).

This suggestion was produced using the :induction rule INDUCTION-HINT.
If we let (:P LST N) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (ZP N))
                   (NOT (ENDP LST))
                   (:P (RM (MAXIMAL LST) LST) (+ -1 N)))
              (:P LST N))
     (IMPLIES (AND (NOT (ZP N)) (ENDP LST))
              (:P LST N))
     (IMPLIES (ZP N) (:P LST N))).
This induction is justified by the same argument used to admit 
INDUCTION-HINT.  Note, however, that the unmeasured variable LST is
being instantiated.  When applied to the goal at hand the above induction
scheme produces three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ZP N))
              (NOT (ENDP LST))
              (IMPLIES (AND (NATP (+ -1 N))
                            (LIST-OF-NATSP (RM (MAXIMAL LST) LST))
                            (NO-DUPS (RM (MAXIMAL LST) LST))
                            (< (MAXIMAL (RM (MAXIMAL LST) LST))
                               (+ -1 N)))
                       (<= (LEN (RM (MAXIMAL LST) LST))
                           (+ -1 N))))
         (IMPLIES (AND (NATP N)
                       (LIST-OF-NATSP LST)
                       (NO-DUPS LST)
                       (< (MAXIMAL LST) N))
                  (<= (LEN LST) N))).

By the simple :definition ENDP and the simple :rewrite rule NATP-POSP--1
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (ZP N))
              (CONSP LST)
              (IMPLIES (AND (POSP N)
                            (LIST-OF-NATSP (RM (MAXIMAL LST) LST))
                            (NO-DUPS (RM (MAXIMAL LST) LST))
                            (< (MAXIMAL (RM (MAXIMAL LST) LST))
                               (+ -1 N)))
                       (<= (LEN (RM (MAXIMAL LST) LST))
                           (+ -1 N)))
              (NATP N)
              (LIST-OF-NATSP LST)
              (NO-DUPS LST)
              (< (MAXIMAL LST) N))
         (<= (LEN LST) N)).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, POSP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER,
the :executable-counterpart of NOT, the :meta rule CANCEL_PLUS-LESSP-CORRECT,
the :rewrite rules PROBLEM-112A, PROBLEM-112C, PROBLEM-112F and PROBLEM-112G
and the :type-prescription rules LIST-OF-NATSP and NO-DUPS, to

Subgoal *1/3''
(IMPLIES (AND (NOT (ZP N))
              (CONSP LST)
              (<= (+ -1 N)
                  (MAXIMAL (RM (MAXIMAL LST) LST)))
              (LIST-OF-NATSP LST)
              (NO-DUPS LST)
              (< (MAXIMAL LST) N))
         (<= (LEN LST) N)).

But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, linear arithmetic, the :forward-chaining
rule PROBLEM-112D, the :linear rule PROBLEM-112E and the :type-prescription
rules LIST-OF-NATSP and NO-DUPS.

Subgoal *1/2
(IMPLIES (AND (NOT (ZP N)) (ENDP LST))
         (IMPLIES (AND (NATP N)
                       (LIST-OF-NATSP LST)
                       (NO-DUPS LST)
                       (< (MAXIMAL LST) N))
                  (<= (LEN LST) N))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (ZP N))
              (NOT (CONSP LST))
              (NATP N)
              (LIST-OF-NATSP LST)
              (NO-DUPS LST)
              (< (MAXIMAL LST) N))
         (<= (LEN LST) N)).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER and the :definitions
LEN, LIST-OF-NATSP, MAXIMAL and NO-DUPS, to

Subgoal *1/2''
(IMPLIES (AND (NOT (ZP N))
              (NOT (CONSP LST))
              (< -1 N))
         (<= 0 N)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (ZP N)
         (IMPLIES (AND (NATP N)
                       (LIST-OF-NATSP LST)
                       (NO-DUPS LST)
                       (< (MAXIMAL LST) N))
                  (<= (LEN LST) N))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (ZP N)
              (NATP N)
              (LIST-OF-NATSP LST)
              (NO-DUPS LST)
              (< (MAXIMAL LST) N))
         (<= (LEN LST) N)).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :executable-
counterparts of <, NATP, NOT and ZP, linear arithmetic, the :forward-
chaining rules NATP-FC-1 and PROBLEM-112D and the :type-prescription
rule LIST-OF-NATSP, to

Subgoal *1/1''
(IMPLIES (AND (EQUAL (MAXIMAL LST) -1)
              (LIST-OF-NATSP LST)
              (NO-DUPS LST))
         (<= (LEN LST) 0)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM and the simple :rewrite rule PROBLEM-112I.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-112J ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION ENDP)
        (:DEFINITION LEN)
        (:DEFINITION LIST-OF-NATSP)
        (:DEFINITION MAXIMAL)
        (:DEFINITION NO-DUPS)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FORWARD-CHAINING NATP-FC-1)
        (:FORWARD-CHAINING PROBLEM-112D)
        (:INDUCTION INDUCTION-HINT)
        (:LINEAR PROBLEM-112E)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE NATP-POSP--1)
        (:REWRITE PROBLEM-112A)
        (:REWRITE PROBLEM-112C)
        (:REWRITE PROBLEM-112F)
        (:REWRITE PROBLEM-112G)
        (:REWRITE PROBLEM-112I)
        (:TYPE-PRESCRIPTION LIST-OF-NATSP)
        (:TYPE-PRESCRIPTION NO-DUPS))
PROBLEM-112J


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112J))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112J)
PROBLEM-112J

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112J ...) ...)
Rules: NIL
 PROBLEM-112J
ACL2 !>>(THEOREM
             PROBLEM-112
             (IMPLIES (AND (LIST-OF-NATSP LST) (NO-DUPS LST))
                      (<= (LEN LST) (+ 1 (MAXIMAL LST))))
             :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-112D PROBLEM-112J))))


ACL2 !>>>(DEFTHM PROBLEM-112
           (IMPLIES (AND (LIST-OF-NATSP LST) (NO-DUPS LST))
                    (<= (LEN LST) (+ 1 (MAXIMAL LST))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-112D PROBLEM-112J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :forward-chaining rule PROBLEM-112D, the :rewrite
rules NATP-RW and PROBLEM-112J and the :type-prescription rules LIST-OF-NATSP
and NO-DUPS.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-112 ...)
Rules: ((:DEFINITION NOT)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING PROBLEM-112D)
        (:REWRITE NATP-RW)
        (:REWRITE PROBLEM-112J)
        (:TYPE-PRESCRIPTION LIST-OF-NATSP)
        (:TYPE-PRESCRIPTION NO-DUPS))
PROBLEM-112


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-112))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-112)
PROBLEM-112

Summary
Form:  ( PROGN (DEFTHM PROBLEM-112 ...) ...)
Rules: NIL
 PROBLEM-112
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 113.
"
ACL2 !>>(DEFUN ADDRESSP (PTR M)
          (AND (NATP PTR) (< PTR (LEN M))))

Since ADDRESSP is non-recursive, its admission is trivial.  We observe
that the type of ADDRESSP is described by the theorem 
(OR (EQUAL (ADDRESSP PTR M) T) (EQUAL (ADDRESSP PTR M) NIL)).  

Summary
Form:  ( DEFUN ADDRESSP ...)
Rules: NIL
 ADDRESSP
ACL2 !>>(DEFUN INC (X)
          (IF (INTEGERP X) (+ 1 X) 'INFINITE))

Since INC is non-recursive, its admission is trivial.  We observe that
the type of INC is described by the theorem 
(OR (INTEGERP (INC X))
    (AND (SYMBOLP (INC X))
         (NOT (EQUAL (INC X) T))
         (NOT (EQUAL (INC X) NIL)))).
We used primitive type reasoning.

Summary
Form:  ( DEFUN INC ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 INC
ACL2 !>>(DEFUN LEN-DIFF (MEM SEEN)
          (IF (CONSP MEM)
              (IF (MEM (CAR MEM) SEEN)
                  (LEN-DIFF (CDR MEM) SEEN)
                (+ 1 (LEN-DIFF (CDR MEM) SEEN)))
            0))

The admission of LEN-DIFF is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT MEM).  We observe that the type of LEN-DIFF is
described by the theorem 
(AND (INTEGERP (LEN-DIFF MEM SEEN)) (<= 0 (LEN-DIFF MEM SEEN))).  We
used primitive type reasoning.

Summary
Form:  ( DEFUN LEN-DIFF ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 LEN-DIFF
ACL2 !>>(THEOREM PROBLEM-113A
                 (IMPLIES (AND (NATP N) (< N (LEN M)))
                          (MEM (NTH N M) M))
                 :HINTS (("Goal" :INDUCT (NTH N M)
                                 :IN-THEORY (ENABLE PROBLEM-112I))))


ACL2 !>>>(DEFTHM PROBLEM-113A
           (IMPLIES (AND (NATP N) (< N (LEN M)))
                    (MEM (NTH N M) M))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (NTH N M)
                           :IN-THEORY (ENABLE PROBLEM-112I))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (NTH N M).

This suggestion was produced using the :induction rule NTH.  If we
let (:P M N) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ENDP M))
                   (NOT (ZP N))
                   (:P (CDR M) (+ -1 N)))
              (:P M N))
     (IMPLIES (AND (NOT (ENDP M)) (ZP N))
              (:P M N))
     (IMPLIES (ENDP M) (:P M N))).
This induction is justified by the same argument used to admit NTH.
Note, however, that the unmeasured variable M is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP M))
              (NOT (ZP N))
              (IMPLIES (AND (NATP (+ -1 N))
                            (< (+ -1 N) (LEN (CDR M))))
                       (MEM (NTH (+ -1 N) (CDR M)) (CDR M))))
         (IMPLIES (AND (NATP N) (< N (LEN M)))
                  (MEM (NTH N M) M))).

By the simple :definition ENDP and the simple :rewrite rule NATP-POSP--1
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP M)
              (NOT (ZP N))
              (IMPLIES (AND (POSP N)
                            (< (+ -1 N) (LEN (CDR M))))
                       (MEM (NTH (+ -1 N) (CDR M)) (CDR M)))
              (NATP N)
              (< N (LEN M)))
         (MEM (NTH N M) M)).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, POSP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER,
the :definitions LEN, MEM and NTH and the :type-prescription rule MEM,
to

Subgoal *1/3''
(IMPLIES (AND (CONSP M)
              (NOT (ZP N))
              (<= (LEN (CDR M)) (+ -1 N))
              (< N (+ 1 (LEN (CDR M))))
              (NOT (EQUAL (NTH (+ -1 N) (CDR M)) (CAR M))))
         (MEM (NTH (+ -1 N) (CDR M)) (CDR M))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP M)) (ZP N))
         (IMPLIES (AND (NATP N) (< N (LEN M)))
                  (MEM (NTH N M) M))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP M)
              (ZP N)
              (NATP N)
              (< N (LEN M)))
         (MEM (NTH N M) M)).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :executable-
counterparts of NATP, NOT and ZP, linear arithmetic and the :forward-
chaining rule NATP-FC-1, to

Subgoal *1/2''
(IMPLIES (AND (CONSP M) (< 0 (LEN M)))
         (MEM (NTH 0 M) M)).

By the simple :rewrite rule PROBLEM-112I we reduce the conjecture to

Subgoal *1/2'''
(IMPLIES (CONSP M) (MEM (NTH 0 M) M)).

But simplification reduces this to T, using the :definitions MEM and
NTH, the :executable-counterpart of ZP and primitive type reasoning.

Subgoal *1/1
(IMPLIES (ENDP M)
         (IMPLIES (AND (NATP N) (< N (LEN M)))
                  (MEM (NTH N M) M))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP M))
              (NATP N)
              (< N (LEN M)))
         (MEM (NTH N M) M)).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definition LEN and primitive type
reasoning.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-113A depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-113A ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION ENDP)
        (:DEFINITION LEN)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION NTH)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING NATP-FC-1)
        (:INDUCTION NTH)
        (:REWRITE NATP-POSP--1)
        (:REWRITE PROBLEM-112I)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-113A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-113A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-113A)
PROBLEM-113A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-113A ...) ...)
Rules: NIL
 PROBLEM-113A
ACL2 !>>(THEOREM PROBLEM-113B
                 (<= (LEN-DIFF MEM (CONS PTR SEEN))
                     (LEN-DIFF MEM SEEN))
                 :HINTS (("Goal" :INDUCT (LEN-DIFF MEM (CONS PTR SEEN))
                                 :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-113B
           (<= (LEN-DIFF MEM (CONS PTR SEEN))
               (LEN-DIFF MEM SEEN))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LEN-DIFF MEM (CONS PTR SEEN))
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by 
(LEN-DIFF MEM (CONS PTR SEEN)).

This suggestion was produced using the :induction rule LEN-DIFF.  If
we let (:P MEM PTR SEEN) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP MEM))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (CONSP MEM)
                   (NOT (MEM (CAR MEM) (CONS PTR SEEN)))
                   (:P (CDR MEM) PTR SEEN))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (CONSP MEM)
                   (MEM (CAR MEM) (CONS PTR SEEN))
                   (:P (CDR MEM) PTR SEEN))
              (:P MEM PTR SEEN))).
This induction is justified by the same argument used to admit LEN-DIFF.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP MEM))
         (<= (LEN-DIFF MEM (CONS PTR SEEN))
             (LEN-DIFF MEM SEEN))).

But simplification reduces this to T, using the :definition LEN-DIFF
and the :executable-counterpart of <.

Subgoal *1/2
(IMPLIES (AND (CONSP MEM)
              (NOT (MEM (CAR MEM) (CONS PTR SEEN)))
              (<= (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                  (LEN-DIFF (CDR MEM) SEEN)))
         (<= (LEN-DIFF MEM (CONS PTR SEEN))
             (LEN-DIFF MEM SEEN))).

But simplification reduces this to T, using the :definitions LEN-DIFF
and MEM, primitive type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT
and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP MEM)
              (MEM (CAR MEM) (CONS PTR SEEN))
              (<= (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                  (LEN-DIFF (CDR MEM) SEEN)))
         (<= (LEN-DIFF MEM (CONS PTR SEEN))
             (LEN-DIFF MEM SEEN))).

This simplifies, using the :definitions LEN-DIFF and MEM, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, PROBLEM-48 and
PROBLEM-49A and the :type-prescription rule MEM, to

Subgoal *1/1'
(IMPLIES (AND (CONSP MEM)
              (EQUAL (CAR MEM) PTR)
              (<= (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                  (LEN-DIFF (CDR MEM) SEEN))
              (NOT (MEM PTR SEEN)))
         (<= (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
             (+ 1 (LEN-DIFF (CDR MEM) SEEN)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-113B ...)
Rules: ((:DEFINITION LEN-DIFF)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN-DIFF)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-113B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-113B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-113B)
PROBLEM-113B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-113B ...) ...)
Rules: NIL
 PROBLEM-113B
ACL2 !>>(THEOREM
           PROBLEM-113C
           (IMPLIES (AND (MEM PTR MEM) (NOT (MEM PTR SEEN)))
                    (< (LEN-DIFF MEM (CONS PTR SEEN))
                       (LEN-DIFF MEM SEEN)))
           :HINTS
           (("Goal" :INDUCT (LEN-DIFF MEM SEEN)
                    :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A PROBLEM-113B)))
           :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-113C
          (IMPLIES (AND (MEM PTR MEM) (NOT (MEM PTR SEEN)))
                   (< (LEN-DIFF MEM (CONS PTR SEEN))
                      (LEN-DIFF MEM SEEN)))
          :RULE-CLASSES :LINEAR
          :HINTS
          (("Goal" :DO-NOT-INDUCT T
                   :DO-NOT '(GENERALIZE)
                   :INDUCT (LEN-DIFF MEM SEEN)
                   :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A PROBLEM-113B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LEN-DIFF MEM SEEN).

This suggestion was produced using the :induction rule LEN-DIFF.  If
we let (:P MEM PTR SEEN) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP MEM))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (CONSP MEM)
                   (NOT (MEM (CAR MEM) SEEN))
                   (:P (CDR MEM) PTR SEEN))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (CONSP MEM)
                   (MEM (CAR MEM) SEEN)
                   (:P (CDR MEM) PTR SEEN))
              (:P MEM PTR SEEN))).
This induction is justified by the same argument used to admit LEN-DIFF.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP MEM))
         (IMPLIES (AND (MEM PTR MEM) (NOT (MEM PTR SEEN)))
                  (< (LEN-DIFF MEM (CONS PTR SEEN))
                     (LEN-DIFF MEM SEEN)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP MEM))
              (MEM PTR MEM)
              (NOT (MEM PTR SEEN)))
         (< (LEN-DIFF MEM (CONS PTR SEEN))
            (LEN-DIFF MEM SEEN))).

This simplifies, using linear arithmetic, the :linear rule PROBLEM-113B
and the :type-prescription rule LEN-DIFF, to

Subgoal *1/3''
(IMPLIES (AND (EQUAL (LEN-DIFF MEM (CONS PTR SEEN))
                     (LEN-DIFF MEM SEEN))
              (NOT (CONSP MEM))
              (MEM PTR MEM)
              (NOT (MEM PTR SEEN)))
         (< (LEN-DIFF MEM (CONS PTR SEEN))
            (LEN-DIFF MEM SEEN))).

But simplification reduces this to T, using the :definitions LEN-DIFF
and MEM and the :executable-counterpart of EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP MEM)
              (NOT (MEM (CAR MEM) SEEN))
              (IMPLIES (AND (MEM PTR (CDR MEM))
                            (NOT (MEM PTR SEEN)))
                       (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                          (LEN-DIFF (CDR MEM) SEEN))))
         (IMPLIES (AND (MEM PTR MEM) (NOT (MEM PTR SEEN)))
                  (< (LEN-DIFF MEM (CONS PTR SEEN))
                     (LEN-DIFF MEM SEEN)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP MEM)
              (NOT (MEM (CAR MEM) SEEN))
              (IMPLIES (AND (MEM PTR (CDR MEM))
                            (NOT (MEM PTR SEEN)))
                       (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                          (LEN-DIFF (CDR MEM) SEEN)))
              (MEM PTR MEM)
              (NOT (MEM PTR SEEN)))
         (< (LEN-DIFF MEM (CONS PTR SEEN))
            (LEN-DIFF MEM SEEN))).

This simplifies, using the :definitions LEN-DIFF (if-intro) and MEM
(if-intro), the :executable-counterpart of NOT, primitive type reasoning,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule MEM, to the following four conjectures.

Subgoal *1/2.4
(IMPLIES (AND (CONSP MEM)
              (NOT (MEM (CAR MEM) SEEN))
              (NOT (MEM PTR (CDR MEM)))
              (EQUAL PTR (CAR MEM))
              (NOT (MEM PTR SEEN)))
         (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
            (+ 1 (LEN-DIFF (CDR MEM) SEEN)))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-113B and the :type-prescription
rule LEN-DIFF.

Subgoal *1/2.3
(IMPLIES (AND (CONSP MEM)
              (NOT (MEM (CAR MEM) SEEN))
              (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                 (LEN-DIFF (CDR MEM) SEEN))
              (EQUAL PTR (CAR MEM))
              (NOT (MEM PTR SEEN)))
         (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
            (+ 1 (LEN-DIFF (CDR MEM) SEEN)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.2
(IMPLIES (AND (CONSP MEM)
              (NOT (MEM (CAR MEM) SEEN))
              (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                 (LEN-DIFF (CDR MEM) SEEN))
              (MEM PTR (CDR MEM))
              (NOT (MEM PTR SEEN))
              (EQUAL (CAR MEM) PTR))
         (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
            (+ 1 (LEN-DIFF (CDR MEM) SEEN)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.1
(IMPLIES (AND (CONSP MEM)
              (NOT (MEM (CAR MEM) SEEN))
              (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                 (LEN-DIFF (CDR MEM) SEEN))
              (MEM PTR (CDR MEM))
              (NOT (MEM PTR SEEN))
              (NOT (EQUAL (CAR MEM) PTR)))
         (< (+ 1 (LEN-DIFF (CDR MEM) (CONS PTR SEEN)))
            (+ 1 (LEN-DIFF (CDR MEM) SEEN)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP MEM)
              (MEM (CAR MEM) SEEN)
              (IMPLIES (AND (MEM PTR (CDR MEM))
                            (NOT (MEM PTR SEEN)))
                       (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                          (LEN-DIFF (CDR MEM) SEEN))))
         (IMPLIES (AND (MEM PTR MEM) (NOT (MEM PTR SEEN)))
                  (< (LEN-DIFF MEM (CONS PTR SEEN))
                     (LEN-DIFF MEM SEEN)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP MEM)
              (MEM (CAR MEM) SEEN)
              (IMPLIES (AND (MEM PTR (CDR MEM))
                            (NOT (MEM PTR SEEN)))
                       (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                          (LEN-DIFF (CDR MEM) SEEN)))
              (MEM PTR MEM)
              (NOT (MEM PTR SEEN)))
         (< (LEN-DIFF MEM (CONS PTR SEEN))
            (LEN-DIFF MEM SEEN))).

This simplifies, using the :definitions LEN-DIFF and MEM (if-intro),
the :executable-counterpart of NOT, primitive type reasoning, the :rewrite
rules CAR-CONS, CDR-CONS, PROBLEM-48 and PROBLEM-49A and the :type-
prescription rule MEM, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP MEM)
              (MEM (CAR MEM) SEEN)
              (NOT (MEM PTR (CDR MEM)))
              (EQUAL PTR (CAR MEM))
              (NOT (MEM PTR SEEN)))
         (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
            (+ 1 (LEN-DIFF (CDR MEM) SEEN)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.1
(IMPLIES (AND (CONSP MEM)
              (MEM (CAR MEM) SEEN)
              (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
                 (LEN-DIFF (CDR MEM) SEEN))
              (EQUAL PTR (CAR MEM))
              (NOT (MEM PTR SEEN)))
         (< (LEN-DIFF (CDR MEM) (CONS PTR SEEN))
            (+ 1 (LEN-DIFF (CDR MEM) SEEN)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-113C ...)
Rules: ((:DEFINITION LEN-DIFF)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN-DIFF)
        (:LINEAR PROBLEM-113B)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION LEN-DIFF)
        (:TYPE-PRESCRIPTION MEM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION LEN-DIFF)
             (:DEFINITION MEM))
PROBLEM-113C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-113C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-113C)
PROBLEM-113C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-113C ...) ...)
Rules: NIL
 PROBLEM-113C
ACL2 !>>(DEFUN DEREF-CNT (PTR MEM SEEN)
         (DECLARE
          (XARGS
            :MEASURE (M2 (IF (MEM PTR MEM) 1 2)
                         (LEN-DIFF MEM SEEN))
            :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-113A PROBLEM-113C)))))
         (IF (ADDRESSP PTR MEM)
             (IF (MEM PTR SEEN)
                 'INFINITE
               (INC (DEREF-CNT (NTH PTR MEM)
                               MEM (CONS PTR SEEN))))
           0))

For the admission of DEREF-CNT we will use the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(M2 (IF (MEM PTR MEM) 1 2) (LEN-DIFF MEM SEEN)).  The non-trivial part
of the measure conjecture is

Goal
(AND (O-P (M2 (IF (MEM PTR MEM) 1 2)
              (LEN-DIFF MEM SEEN)))
     (IMPLIES (AND (ADDRESSP PTR MEM)
                   (NOT (MEM PTR SEEN)))
              (O< (M2 (IF (MEM (NTH PTR MEM) MEM) 1 2)
                      (LEN-DIFF MEM (CONS PTR SEEN)))
                  (M2 (IF (MEM PTR MEM) 1 2)
                      (LEN-DIFF MEM SEEN))))).

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions ADDRESSP and M2 we reduce the conjecture
to the following two conjectures.

Subgoal 2
(O-P (CONS (CONS 1 (+ 1 (IF (MEM PTR MEM) 1 2)))
           (LEN-DIFF MEM SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER, O-FINP-CR and POSP-COMPOUND-RECOGNIZER,
the :definitions O-FIRST-COEFF, O-FIRST-EXPT, O-P and O-RST, the :executable-
counterparts of EQUAL, O-P and O<, primitive type reasoning, the :rewrite
rules CAR-CONS, CDR-CONS, O-FIRST-EXPT-DEF-O-FINP and O-P-DEF-O-FINP-1
and the :type-prescription rule LEN-DIFF.

Subgoal 1
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (NOT (MEM PTR SEEN)))
         (O< (CONS (CONS 1
                         (+ 1 (IF (MEM (NTH PTR MEM) MEM) 1 2)))
                   (LEN-DIFF MEM (CONS PTR SEEN)))
             (CONS (CONS 1 (+ 1 (IF (MEM PTR MEM) 1 2)))
                   (LEN-DIFF MEM SEEN)))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :definitions O-FIRST-COEFF,
O-FIRST-EXPT, O-RST, O< and SYNP, the :executable-counterparts of 
ACL2-NUMBERP, BINARY-+, CAR, CDR, CONS, EQUAL and UNARY--, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, EQUAL-CONSTANT-+
and PROBLEM-113A and the :type-prescription rule LEN-DIFF, to

Subgoal 1'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (NOT (MEM PTR SEEN))
              (MEM PTR MEM))
         (< (LEN-DIFF MEM (CONS PTR SEEN))
            (LEN-DIFF MEM SEEN))).

But simplification reduces this to T, using linear arithmetic, the
:linear rule PROBLEM-113C and the :type-prescription rules LEN-DIFF
and MEM.

Q.E.D.

That completes the proof of the measure theorem for DEREF-CNT.  Thus,
we admit this function under the principle of definition.  We observe
that the type of DEREF-CNT is described by the theorem 
(OR (INTEGERP (DEREF-CNT PTR MEM SEEN))
    (AND (SYMBOLP (DEREF-CNT PTR MEM SEEN))
         (NOT (EQUAL (DEREF-CNT PTR MEM SEEN) T))
         (NOT (EQUAL (DEREF-CNT PTR MEM SEEN) NIL)))).
We used the :type-prescription rule INC.

Summary
Form:  ( DEFUN DEREF-CNT ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:DEFINITION ADDRESSP)
        (:DEFINITION M2)
        (:DEFINITION NOT)
        (:DEFINITION O-FIRST-COEFF)
        (:DEFINITION O-FIRST-EXPT)
        (:DEFINITION O-P)
        (:DEFINITION O-RST)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART ACL2-NUMBERP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART O-P)
        (:EXECUTABLE-COUNTERPART O<)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR PROBLEM-113C)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE EQUAL-CONSTANT-+)
        (:REWRITE O-FIRST-EXPT-DEF-O-FINP)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE PROBLEM-113A)
        (:TYPE-PRESCRIPTION INC)
        (:TYPE-PRESCRIPTION LEN-DIFF)
        (:TYPE-PRESCRIPTION MEM))
 DEREF-CNT
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 114.
"
ACL2 !>>(DEFUN PATH (PTR MEM SEEN)
         (DECLARE
          (XARGS
            :MEASURE (M2 (IF (MEM PTR MEM) 1 2)
                         (LEN-DIFF MEM SEEN))
            :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-113A PROBLEM-113C)))))
         (IF (ADDRESSP PTR MEM)
             (IF (MEM PTR SEEN)
                 'INFINITE
               (PATH (NTH PTR MEM)
                     MEM (CONS PTR SEEN)))
           (CONS PTR SEEN)))

For the admission of PATH we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(M2 (IF (MEM PTR MEM) 1 2) (LEN-DIFF MEM SEEN)).  The non-trivial part
of the measure conjecture is

Goal
(AND (O-P (M2 (IF (MEM PTR MEM) 1 2)
              (LEN-DIFF MEM SEEN)))
     (IMPLIES (AND (ADDRESSP PTR MEM)
                   (NOT (MEM PTR SEEN)))
              (O< (M2 (IF (MEM (NTH PTR MEM) MEM) 1 2)
                      (LEN-DIFF MEM (CONS PTR SEEN)))
                  (M2 (IF (MEM PTR MEM) 1 2)
                      (LEN-DIFF MEM SEEN))))).

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions ADDRESSP and M2 we reduce the conjecture
to the following two conjectures.

Subgoal 2
(O-P (CONS (CONS 1 (+ 1 (IF (MEM PTR MEM) 1 2)))
           (LEN-DIFF MEM SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER, O-FINP-CR and POSP-COMPOUND-RECOGNIZER,
the :definitions O-FIRST-COEFF, O-FIRST-EXPT, O-P and O-RST, the :executable-
counterparts of EQUAL, O-P and O<, primitive type reasoning, the :rewrite
rules CAR-CONS, CDR-CONS, O-FIRST-EXPT-DEF-O-FINP and O-P-DEF-O-FINP-1
and the :type-prescription rule LEN-DIFF.

Subgoal 1
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (NOT (MEM PTR SEEN)))
         (O< (CONS (CONS 1
                         (+ 1 (IF (MEM (NTH PTR MEM) MEM) 1 2)))
                   (LEN-DIFF MEM (CONS PTR SEEN)))
             (CONS (CONS 1 (+ 1 (IF (MEM PTR MEM) 1 2)))
                   (LEN-DIFF MEM SEEN)))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :definitions O-FIRST-COEFF,
O-FIRST-EXPT, O-RST, O< and SYNP, the :executable-counterparts of 
ACL2-NUMBERP, BINARY-+, CAR, CDR, CONS, EQUAL and UNARY--, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, EQUAL-CONSTANT-+
and PROBLEM-113A and the :type-prescription rule LEN-DIFF, to

Subgoal 1'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (NOT (MEM PTR SEEN))
              (MEM PTR MEM))
         (< (LEN-DIFF MEM (CONS PTR SEEN))
            (LEN-DIFF MEM SEEN))).

But simplification reduces this to T, using linear arithmetic, the
:linear rule PROBLEM-113C and the :type-prescription rules LEN-DIFF
and MEM.

Q.E.D.

That completes the proof of the measure theorem for PATH.  Thus, we
admit this function under the principle of definition.  We observe
that the type of PATH is described by the theorem 
(OR (CONSP (PATH PTR MEM SEEN))
    (AND (SYMBOLP (PATH PTR MEM SEEN))
         (NOT (EQUAL (PATH PTR MEM SEEN) T))
         (NOT (EQUAL (PATH PTR MEM SEEN) NIL)))).
We used primitive type reasoning.

Summary
Form:  ( DEFUN PATH ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:DEFINITION ADDRESSP)
        (:DEFINITION M2)
        (:DEFINITION NOT)
        (:DEFINITION O-FIRST-COEFF)
        (:DEFINITION O-FIRST-EXPT)
        (:DEFINITION O-P)
        (:DEFINITION O-RST)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART ACL2-NUMBERP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART O-P)
        (:EXECUTABLE-COUNTERPART O<)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR PROBLEM-113C)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE EQUAL-CONSTANT-+)
        (:REWRITE O-FIRST-EXPT-DEF-O-FINP)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE PROBLEM-113A)
        (:TYPE-PRESCRIPTION LEN-DIFF)
        (:TYPE-PRESCRIPTION MEM))
 PATH
ACL2 !>>(THEOREM
             PROBLEM-114A
             (EQUAL (DEREF-CNT PTR MEM SEEN)
                    (IF (EQUAL (PATH PTR MEM SEEN) 'INFINITE)
                        'INFINITE
                      (- (LEN (PATH PTR MEM SEEN))
                         (+ 1 (LEN SEEN)))))
             :HINTS (("Goal" :INDUCT (PATH PTR MEM SEEN)
                             :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A))))


ACL2 !>>>(DEFTHM PROBLEM-114A
           (EQUAL (DEREF-CNT PTR MEM SEEN)
                  (IF (EQUAL (PATH PTR MEM SEEN) 'INFINITE)
                      'INFINITE
                    (- (LEN (PATH PTR MEM SEEN))
                       (+ 1 (LEN SEEN)))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PATH PTR MEM SEEN)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PATH PTR MEM SEEN).

This suggestion was produced using the :induction rule PATH.  If we
let (:P MEM PTR SEEN) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (NOT (ADDRESSP PTR MEM))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR MEM)
                   (NOT (MEM PTR SEEN))
                   (:P MEM (NTH PTR MEM) (CONS PTR SEEN)))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR MEM) (MEM PTR SEEN))
              (:P MEM PTR SEEN))).
This induction is justified by the same argument used to admit PATH.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (ADDRESSP PTR MEM))
         (EQUAL (DEREF-CNT PTR MEM SEEN)
                (IF (EQUAL (PATH PTR MEM SEEN) 'INFINITE)
                    'INFINITE
                  (+ (LEN (PATH PTR MEM SEEN))
                     (- (+ 1 (LEN SEEN))))))).

By the :executable-counterpart of UNARY-- and the simple :rewrite rule
DISTRIBUTIVITY-OF-MINUS-OVER-+ we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (NOT (ADDRESSP PTR MEM))
         (EQUAL (DEREF-CNT PTR MEM SEEN)
                (IF (EQUAL (PATH PTR MEM SEEN) 'INFINITE)
                    'INFINITE
                  (+ (LEN (PATH PTR MEM SEEN))
                     -1 (- (LEN SEEN)))))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP, DEREF-CNT,
LEN and PATH, the :executable-counterparts of BINARY-+ and EQUAL, primitive
type reasoning and the :rewrite rules CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+ and INVERSE-OF-+.

Subgoal *1/2
(IMPLIES (AND (ADDRESSP PTR MEM)
              (NOT (MEM PTR SEEN))
              (EQUAL (DEREF-CNT (NTH PTR MEM)
                                MEM (CONS PTR SEEN))
                     (IF (EQUAL (PATH (NTH PTR MEM) MEM (CONS PTR SEEN))
                                'INFINITE)
                         'INFINITE
                       (+ (LEN (PATH (NTH PTR MEM)
                                     MEM (CONS PTR SEEN)))
                          (- (+ 1 (LEN (CONS PTR SEEN))))))))
         (EQUAL (DEREF-CNT PTR MEM SEEN)
                (IF (EQUAL (PATH PTR MEM SEEN) 'INFINITE)
                    'INFINITE
                  (+ (LEN (PATH PTR MEM SEEN))
                     (- (+ 1 (LEN SEEN))))))).

By the simple :definition ADDRESSP, the :executable-counterpart of
UNARY-- and the simple :rewrite rule DISTRIBUTIVITY-OF-MINUS-OVER-+
we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (NOT (MEM PTR SEEN))
              (EQUAL (DEREF-CNT (NTH PTR MEM)
                                MEM (CONS PTR SEEN))
                     (IF (EQUAL (PATH (NTH PTR MEM) MEM (CONS PTR SEEN))
                                'INFINITE)
                         'INFINITE
                       (+ (LEN (PATH (NTH PTR MEM)
                                     MEM (CONS PTR SEEN)))
                          -1 (- (LEN (CONS PTR SEEN)))))))
         (EQUAL (DEREF-CNT PTR MEM SEEN)
                (IF (EQUAL (PATH PTR MEM SEEN) 'INFINITE)
                    'INFINITE
                  (+ (LEN (PATH PTR MEM SEEN))
                     -1 (- (LEN SEEN)))))).

This simplifies, using the :compound-recognizer rule NATP-COMPOUND-RECOGNIZER,
the :definitions ADDRESSP, DEREF-CNT, INC, LEN, PATH and SYNP, the
:executable-counterparts of BINARY-+, EQUAL, INC and UNARY--, primitive
type reasoning, the :rewrite rules CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DISTRIBUTIVITY-OF-MINUS-OVER-+ and FOLD-CONSTS-IN-+
and the :type-prescription rules DEREF-CNT and LEN, to

Subgoal *1/2''
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (NOT (MEM PTR SEEN))
              (NOT (EQUAL (PATH (NTH PTR MEM) MEM (CONS PTR SEEN))
                          'INFINITE))
              (EQUAL (DEREF-CNT (NTH PTR MEM)
                                MEM (CONS PTR SEEN))
                     (+ -2 (- (LEN SEEN))
                        (LEN (PATH (NTH PTR MEM)
                                   MEM (CONS PTR SEEN))))))
         (EQUAL (+ 1
                   (DEREF-CNT (NTH PTR MEM)
                              MEM (CONS PTR SEEN)))
                (+ -1 (- (LEN SEEN))
                   (LEN (PATH (NTH PTR MEM)
                              MEM (CONS PTR SEEN)))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (ADDRESSP PTR MEM) (MEM PTR SEEN))
         (EQUAL (DEREF-CNT PTR MEM SEEN)
                (IF (EQUAL (PATH PTR MEM SEEN) 'INFINITE)
                    'INFINITE
                  (+ (LEN (PATH PTR MEM SEEN))
                     (- (+ 1 (LEN SEEN))))))).

By the simple :definition ADDRESSP, the :executable-counterpart of
UNARY-- and the simple :rewrite rule DISTRIBUTIVITY-OF-MINUS-OVER-+
we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (MEM PTR SEEN))
         (EQUAL (DEREF-CNT PTR MEM SEEN)
                (IF (EQUAL (PATH PTR MEM SEEN) 'INFINITE)
                    'INFINITE
                  (+ (LEN (PATH PTR MEM SEEN))
                     -1 (- (LEN SEEN)))))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP, DEREF-CNT
and PATH, the :executable-counterpart of EQUAL, the :rewrite rules
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-114A ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ADDRESSP)
        (:DEFINITION DEREF-CNT)
        (:DEFINITION INC)
        (:DEFINITION LEN)
        (:DEFINITION NOT)
        (:DEFINITION PATH)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART INC)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PATH)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DISTRIBUTIVITY-OF-MINUS-OVER-+)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE INVERSE-OF-+)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION DEREF-CNT)
        (:TYPE-PRESCRIPTION LEN)
        (:TYPE-PRESCRIPTION MEM))
PROBLEM-114A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114A)
PROBLEM-114A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114A ...) ...)
Rules: NIL
 PROBLEM-114A
ACL2 !>>(DEFUN ADDRESSESP (X MEM)
          (IF (ENDP X)
              T
            (AND (ADDRESSP (CAR X) MEM)
                 (ADDRESSESP (CDR X) MEM))))

The admission of ADDRESSESP is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We observe that the type of ADDRESSESP is
described by the theorem 
(OR (EQUAL (ADDRESSESP X MEM) T) (EQUAL (ADDRESSESP X MEM) NIL)). 

Summary
Form:  ( DEFUN ADDRESSESP ...)
Rules: NIL
 ADDRESSESP
ACL2 !>>(THEOREM PROBLEM-114B
                 (IMPLIES (AND (ADDRESSESP X MEM) (NOT (NATP E)))
                          (NOT (MEM E X)))
                 :HINTS (("Goal" :INDUCT (MEM E X))))


ACL2 !>>>(DEFTHM PROBLEM-114B
           (IMPLIES (AND (ADDRESSESP X MEM) (NOT (NATP E)))
                    (NOT (MEM E X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MEM E X))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-114B ...):  A :REWRITE rule
generated from PROBLEM-114B contains the free variable MEM.  This variable
will be chosen by searching for an instance of (ADDRESSESP X MEM) in
the context of the term being rewritten.  This is generally a severe
restriction on the applicability of a :REWRITE rule.  See :DOC free-
variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MEM E X).

This suggestion was produced using the :induction rule MEM.  If we
let (:P E MEM X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P E MEM X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL E (CAR X)))
                   (:P E MEM (CDR X)))
              (:P E MEM X))
     (IMPLIES (AND (CONSP X) (EQUAL E (CAR X)))
              (:P E MEM X))).
This induction is justified by the same argument used to admit MEM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (AND (ADDRESSESP X MEM) (NOT (NATP E)))
                  (NOT (MEM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X))
              (ADDRESSESP X MEM)
              (NOT (NATP E)))
         (NOT (MEM E X))).

But simplification reduces this to T, using the :definitions ADDRESSESP
and MEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (IMPLIES (AND (ADDRESSESP (CDR X) MEM)
                            (NOT (NATP E)))
                       (NOT (MEM E (CDR X)))))
         (IMPLIES (AND (ADDRESSESP X MEM) (NOT (NATP E)))
                  (NOT (MEM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (IMPLIES (AND (ADDRESSESP (CDR X) MEM)
                            (NOT (NATP E)))
                       (NOT (MEM E (CDR X))))
              (ADDRESSESP X MEM)
              (NOT (NATP E)))
         (NOT (MEM E X))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSESP, ADDRESSP,
MEM and NOT, the :executable-counterpart of NOT, primitive type reasoning
and the :type-prescription rule ADDRESSESP.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (EQUAL E (CAR X)))
         (IMPLIES (AND (ADDRESSESP X MEM) (NOT (NATP E)))
                  (NOT (MEM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL E (CAR X))
              (ADDRESSESP X MEM)
              (NOT (NATP E)))
         (NOT (MEM E X))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER and the :definitions ADDRESSESP and ADDRESSP.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-114B ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ADDRESSESP)
        (:DEFINITION ADDRESSP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MEM)
        (:TYPE-PRESCRIPTION ADDRESSESP))
Warnings:  Free
PROBLEM-114B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114B)
PROBLEM-114B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114B ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-114B
ACL2 !>>(THEOREM PROBLEM-114C
                 (IMPLIES (AND (ADDRESSESP X MEM)
                               (>= E (LEN MEM)))
                          (NOT (MEM E X)))
                 :HINTS (("Goal" :INDUCT (MEM E X))))


ACL2 !>>>(DEFTHM PROBLEM-114C
           (IMPLIES (AND (ADDRESSESP X MEM)
                         (>= E (LEN MEM)))
                    (NOT (MEM E X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (MEM E X))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-114C ...):  A :REWRITE rule
generated from PROBLEM-114C contains the free variable MEM.  This variable
will be chosen by searching for an instance of (ADDRESSESP X MEM) in
the context of the term being rewritten.  This is generally a severe
restriction on the applicability of a :REWRITE rule.  See :DOC free-
variables.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (MEM E X).

This suggestion was produced using the :induction rule MEM.  If we
let (:P E MEM X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P E MEM X))
     (IMPLIES (AND (CONSP X)
                   (NOT (EQUAL E (CAR X)))
                   (:P E MEM (CDR X)))
              (:P E MEM X))
     (IMPLIES (AND (CONSP X) (EQUAL E (CAR X)))
              (:P E MEM X))).
This induction is justified by the same argument used to admit MEM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (AND (ADDRESSESP X MEM)
                       (<= (LEN MEM) E))
                  (NOT (MEM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X))
              (ADDRESSESP X MEM)
              (<= (LEN MEM) E))
         (NOT (MEM E X))).

But simplification reduces this to T, using the :definitions ADDRESSESP
and MEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (IMPLIES (AND (ADDRESSESP (CDR X) MEM)
                            (<= (LEN MEM) E))
                       (NOT (MEM E (CDR X)))))
         (IMPLIES (AND (ADDRESSESP X MEM)
                       (<= (LEN MEM) E))
                  (NOT (MEM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL E (CAR X)))
              (IMPLIES (AND (ADDRESSESP (CDR X) MEM)
                            (<= (LEN MEM) E))
                       (NOT (MEM E (CDR X))))
              (ADDRESSESP X MEM)
              (<= (LEN MEM) E))
         (NOT (MEM E X))).

But simplification reduces this to T, using the :definitions ADDRESSESP,
ADDRESSP, MEM and NOT, the :executable-counterpart of NOT, primitive
type reasoning and the :type-prescription rule ADDRESSESP.

Subgoal *1/1
(IMPLIES (AND (CONSP X) (EQUAL E (CAR X)))
         (IMPLIES (AND (ADDRESSESP X MEM)
                       (<= (LEN MEM) E))
                  (NOT (MEM E X)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL E (CAR X))
              (ADDRESSESP X MEM)
              (<= (LEN MEM) E))
         (NOT (MEM E X))).

But simplification reduces this to T, using the :definitions ADDRESSESP
and ADDRESSP.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-114C ...)
Rules: ((:DEFINITION ADDRESSESP)
        (:DEFINITION ADDRESSP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION MEM)
        (:TYPE-PRESCRIPTION ADDRESSESP))
Warnings:  Free
PROBLEM-114C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114C)
PROBLEM-114C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114C ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-114C
ACL2 !>>(THEOREM
             PROBLEM-114D
             (IMPLIES (AND (NO-DUPS SEEN)
                           (ADDRESSESP SEEN MEM))
                      (NO-DUPS (PATH PTR MEM SEEN)))
             :HINTS (("Goal" :INDUCT (PATH PTR MEM SEEN)
                             :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                                PROBLEM-114B PROBLEM-114C))))


ACL2 !>>>(DEFTHM PROBLEM-114D
           (IMPLIES (AND (NO-DUPS SEEN)
                         (ADDRESSESP SEEN MEM))
                    (NO-DUPS (PATH PTR MEM SEEN)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PATH PTR MEM SEEN)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                              PROBLEM-114B PROBLEM-114C))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PATH PTR MEM SEEN).

This suggestion was produced using the :induction rule PATH.  If we
let (:P MEM PTR SEEN) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (NOT (ADDRESSP PTR MEM))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR MEM)
                   (NOT (MEM PTR SEEN))
                   (:P MEM (NTH PTR MEM) (CONS PTR SEEN)))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR MEM) (MEM PTR SEEN))
              (:P MEM PTR SEEN))).
This induction is justified by the same argument used to admit PATH.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (ADDRESSP PTR MEM))
         (IMPLIES (AND (NO-DUPS SEEN)
                       (ADDRESSESP SEEN MEM))
                  (NO-DUPS (PATH PTR MEM SEEN)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (ADDRESSP PTR MEM))
              (NO-DUPS SEEN)
              (ADDRESSESP SEEN MEM))
         (NO-DUPS (PATH PTR MEM SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP, NO-DUPS and
PATH, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
PROBLEM-114B and PROBLEM-114C and the :type-prescription rules ADDRESSESP
and NO-DUPS.

Subgoal *1/2
(IMPLIES (AND (ADDRESSP PTR MEM)
              (NOT (MEM PTR SEEN))
              (IMPLIES (AND (NO-DUPS (CONS PTR SEEN))
                            (ADDRESSESP (CONS PTR SEEN) MEM))
                       (NO-DUPS (PATH (NTH PTR MEM)
                                      MEM (CONS PTR SEEN)))))
         (IMPLIES (AND (NO-DUPS SEEN)
                       (ADDRESSESP SEEN MEM))
                  (NO-DUPS (PATH PTR MEM SEEN)))).

By the simple :definition ADDRESSP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (NOT (MEM PTR SEEN))
              (IMPLIES (AND (NO-DUPS (CONS PTR SEEN))
                            (ADDRESSESP (CONS PTR SEEN) MEM))
                       (NO-DUPS (PATH (NTH PTR MEM)
                                      MEM (CONS PTR SEEN))))
              (NO-DUPS SEEN)
              (ADDRESSESP SEEN MEM))
         (NO-DUPS (PATH PTR MEM SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSESP, ADDRESSP,
NO-DUPS and PATH, primitive type reasoning, the :rewrite rules CAR-CONS
and CDR-CONS and the :type-prescription rules ADDRESSESP and NO-DUPS.

Subgoal *1/1
(IMPLIES (AND (ADDRESSP PTR MEM) (MEM PTR SEEN))
         (IMPLIES (AND (NO-DUPS SEEN)
                       (ADDRESSESP SEEN MEM))
                  (NO-DUPS (PATH PTR MEM SEEN)))).

By the simple :definition ADDRESSP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (MEM PTR SEEN)
              (NO-DUPS SEEN)
              (ADDRESSESP SEEN MEM))
         (NO-DUPS (PATH PTR MEM SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP and PATH,
the :executable-counterpart of NO-DUPS, the :rewrite rules PROBLEM-48
and PROBLEM-49A and the :type-prescription rule MEM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-114D depends upon the :type-prescription rule
NO-DUPS.

Summary
Form:  ( DEFTHM PROBLEM-114D ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ADDRESSESP)
        (:DEFINITION ADDRESSP)
        (:DEFINITION NO-DUPS)
        (:DEFINITION NOT)
        (:DEFINITION PATH)
        (:EXECUTABLE-COUNTERPART NO-DUPS)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PATH)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-114B)
        (:REWRITE PROBLEM-114C)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION ADDRESSESP)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION NO-DUPS))
PROBLEM-114D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114D)
PROBLEM-114D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114D ...) ...)
Rules: NIL
 PROBLEM-114D
ACL2 !>>(THEOREM
            PROBLEM-114E
            (IMPLIES (SUB A B) (SUB A (CONS E B)))
            :HINTS
            (("Goal" :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-48 PROBLEM-49))))


ACL2 !>>>(DEFTHM PROBLEM-114E
           (IMPLIES (SUB A B) (SUB A (CONS E B)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-48 PROBLEM-49))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But simplification reduces this to T, using the :rewrite rules CDR-CONS,
PROBLEM-48, PROBLEM-48A and PROBLEM-49 and the :type-prescription rule
SUB.

Q.E.D.

The storage of PROBLEM-114E depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-114E ...)
Rules: ((:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-48A)
        (:REWRITE PROBLEM-49)
        (:TYPE-PRESCRIPTION SUB))
PROBLEM-114E


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114E))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114E)
PROBLEM-114E

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114E ...) ...)
Rules: NIL
 PROBLEM-114E
ACL2 !>>(THEOREM
             PROBLEM-114F (SUB A (APP A B))
             :HINTS (("Goal" :INDUCT (SUB A (APP A B))
                             :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-114E))))


ACL2 !>>>(DEFTHM PROBLEM-114F
           (SUB A (APP A B))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (SUB A (APP A B))
                           :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-114E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  Two induction schemes are suggested
by the induction hint.  These merge into one derived induction scheme.

We will induct according to a scheme suggested by (SUB A (APP A B)),
but modified to accommodate (APP A B).

These suggestions were produced using the :induction rules APP and
SUB.  If we let (:P A B) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A)
                   (NOT (MEM (CAR A) (APP A B))))
              (:P A B))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) (APP A B))
                   (:P (CDR A) B))
              (:P A B))).
This induction is justified by the same argument used to admit SUB.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (SUB A (APP A B))).

But simplification reduces this to T, using the :definitions APP and
SUB and the :rewrite rule PROBLEM-48A.

Subgoal *1/2
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) (APP A B))))
         (SUB A (APP A B))).

But simplification reduces this to T, using the :definitions APP and
MEM, primitive type reasoning and the :rewrite rule CAR-CONS.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) (APP A B))
              (SUB (CDR A) (APP (CDR A) B)))
         (SUB A (APP A B))).

But simplification reduces this to T, using the :definitions APP, MEM
and SUB, primitive type reasoning, the :rewrite rules CAR-CONS and
PROBLEM-114E and the :type-prescription rule SUB.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-114F depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-114F ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION MEM)
        (:DEFINITION SUB)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:INDUCTION SUB)
        (:REWRITE CAR-CONS)
        (:REWRITE PROBLEM-114E)
        (:REWRITE PROBLEM-48A)
        (:TYPE-PRESCRIPTION SUB))
PROBLEM-114F


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114F))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114F)
PROBLEM-114F

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114F ...) ...)
Rules: NIL
 PROBLEM-114F
ACL2 !>>(THEOREM
             PROBLEM-114G (SUB B (APP A B))
             :HINTS (("Goal" :INDUCT (APP A B)
                             :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-114E))))


ACL2 !>>>(DEFTHM PROBLEM-114G
           (SUB B (APP A B))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP A B)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-114E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B))
              (:P A B))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (SUB B (APP A B))).

But simplification reduces this to T, using the :definition APP and
the :rewrite rule PROBLEM-48.

Subgoal *1/1
(IMPLIES (AND (CONSP A) (SUB B (APP (CDR A) B)))
         (SUB B (APP A B))).

But simplification reduces this to T, using the :definition APP, the
:rewrite rule PROBLEM-114E and the :type-prescription rule SUB.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-114G depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-114G ...)
Rules: ((:DEFINITION APP)
        (:INDUCTION APP)
        (:REWRITE PROBLEM-114E)
        (:REWRITE PROBLEM-48)
        (:TYPE-PRESCRIPTION SUB))
PROBLEM-114G


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114G))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114G)
PROBLEM-114G

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114G ...) ...)
Rules: NIL
 PROBLEM-114G
ACL2 !>>(THEOREM
             PROBLEM-114H
             (SUB (PATH PTR MEM SEEN)
                  (CONS PTR (APP SEEN MEM)))
             :HINTS
             (("Goal" :INDUCT (PATH PTR MEM SEEN)
                      :IN-THEORY (ENABLE PROBLEM-46 PROBLEM-48
                                         PROBLEM-49 PROBLEM-49A PROBLEM-113A
                                         PROBLEM-114E PROBLEM-114F))))


ACL2 !>>>(DEFTHM PROBLEM-114H
           (SUB (PATH PTR MEM SEEN)
                (CONS PTR (APP SEEN MEM)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (PATH PTR MEM SEEN)
                    :IN-THEORY (ENABLE PROBLEM-46 PROBLEM-48
                                       PROBLEM-49 PROBLEM-49A PROBLEM-113A
                                       PROBLEM-114E PROBLEM-114F))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PATH PTR MEM SEEN).

This suggestion was produced using the :induction rule PATH.  If we
let (:P MEM PTR SEEN) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (NOT (ADDRESSP PTR MEM))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR MEM)
                   (NOT (MEM PTR SEEN))
                   (:P MEM (NTH PTR MEM) (CONS PTR SEEN)))
              (:P MEM PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR MEM) (MEM PTR SEEN))
              (:P MEM PTR SEEN))).
This induction is justified by the same argument used to admit PATH.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (ADDRESSP PTR MEM))
         (SUB (PATH PTR MEM SEEN)
              (CONS PTR (APP SEEN MEM)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP, MEM, PATH
and SUB, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS, PROBLEM-114E and PROBLEM-114F.

Subgoal *1/2
(IMPLIES (AND (ADDRESSP PTR MEM)
              (NOT (MEM PTR SEEN))
              (SUB (PATH (NTH PTR MEM) MEM (CONS PTR SEEN))
                   (CONS (NTH PTR MEM)
                         (APP (CONS PTR SEEN) MEM))))
         (SUB (PATH PTR MEM SEEN)
              (CONS PTR (APP SEEN MEM)))).

By the simple :definition ADDRESSP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (NOT (MEM PTR SEEN))
              (SUB (PATH (NTH PTR MEM) MEM (CONS PTR SEEN))
                   (CONS (NTH PTR MEM)
                         (APP (CONS PTR SEEN) MEM))))
         (SUB (PATH PTR MEM SEEN)
              (CONS PTR (APP SEEN MEM)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP, APP, MEM,
PATH and SUB, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, PROBLEM-113A, PROBLEM-46, PROBLEM-48 and PROBLEM-49 and the
:type-prescription rule SUB.

Subgoal *1/1
(IMPLIES (AND (ADDRESSP PTR MEM) (MEM PTR SEEN))
         (SUB (PATH PTR MEM SEEN)
              (CONS PTR (APP SEEN MEM)))).

By the simple :definition ADDRESSP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN MEM))
              (MEM PTR SEEN))
         (SUB (PATH PTR MEM SEEN)
              (CONS PTR (APP SEEN MEM)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP, PATH and
SUB, the :executable-counterpart of CONSP, the :rewrite rules PROBLEM-114E,
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-114H depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-114H ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ADDRESSP)
        (:DEFINITION APP)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION PATH)
        (:DEFINITION SUB)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PATH)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-113A)
        (:REWRITE PROBLEM-114E)
        (:REWRITE PROBLEM-114F)
        (:REWRITE PROBLEM-46)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
PROBLEM-114H


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114H))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114H)
PROBLEM-114H

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114H ...) ...)
Rules: NIL
 PROBLEM-114H
ACL2 !>>(THEOREM
          PROBLEM-114I
          (IMPLIES (AND (NOT (MEM E A)) (SUB A B))
                   (SUB A (RM E B)))
          :HINTS
          (("Goal" :INDUCT (SUB A B)
                   :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-55A PROBLEM-55D))))


ACL2 !>>>(DEFTHM PROBLEM-114I
          (IMPLIES (AND (NOT (MEM E A)) (SUB A B))
                   (SUB A (RM E B)))
          :HINTS
          (("Goal" :DO-NOT-INDUCT T
                   :DO-NOT '(GENERALIZE)
                   :INDUCT (SUB A B)
                   :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-55A PROBLEM-55D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SUB A B).

This suggestion was produced using the :induction rule SUB.  If we
let (:P A B E) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B E))
     (IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
              (:P A B E))
     (IMPLIES (AND (CONSP A)
                   (MEM (CAR A) B)
                   (:P (CDR A) B E))
              (:P A B E))).
This induction is justified by the same argument used to admit SUB.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP A))
         (IMPLIES (AND (NOT (MEM E A)) (SUB A B))
                  (SUB A (RM E B)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP A))
              (NOT (MEM E A))
              (SUB A B))
         (SUB A (RM E B))).

But simplification reduces this to T, using the :definitions MEM and
SUB and the :rewrite rule PROBLEM-48A.

Subgoal *1/2
(IMPLIES (AND (CONSP A) (NOT (MEM (CAR A) B)))
         (IMPLIES (AND (NOT (MEM E A)) (SUB A B))
                  (SUB A (RM E B)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP A)
              (NOT (MEM (CAR A) B))
              (NOT (MEM E A))
              (SUB A B))
         (SUB A (RM E B))).

But simplification reduces this to T, using the :definition SUB.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (AND (NOT (MEM E (CDR A)))
                            (SUB (CDR A) B))
                       (SUB (CDR A) (RM E B))))
         (IMPLIES (AND (NOT (MEM E A)) (SUB A B))
                  (SUB A (RM E B)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (MEM (CAR A) B)
              (IMPLIES (AND (NOT (MEM E (CDR A)))
                            (SUB (CDR A) B))
                       (SUB (CDR A) (RM E B)))
              (NOT (MEM E A))
              (SUB A B))
         (SUB A (RM E B))).

But simplification reduces this to T, using the :definitions MEM, NOT
and SUB, primitive type reasoning, the :rewrite rule PROBLEM-55D and
the :type-prescription rules MEM and SUB.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-114I depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-114I ...)
Rules: ((:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION SUB)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SUB)
        (:REWRITE PROBLEM-48A)
        (:REWRITE PROBLEM-55D)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
PROBLEM-114I


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114I))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114I)
PROBLEM-114I

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114I ...) ...)
Rules: NIL
 PROBLEM-114I
ACL2 !>>(THEOREM
         PROBLEM-114J
         (IMPLIES (AND (NO-DUPS X) (SUB X Y))
                  (<= (LEN X) (LEN Y)))
         :HINTS
         (("Goal" :INDUCT (PERM X Y)
                  :IN-THEORY (ENABLE PROBLEM-48A PROBLEM-48
                                     PROBLEM-49A PROBLEM-112F PROBLEM-114I)))
         :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PERM X Y).

This suggestion was produced using the :induction rule PERM.  If we
let (:P X Y) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X Y))
     (IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
              (:P X Y))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) Y)
                   (:P (CDR X) (RM (CAR X) Y)))
              (:P X Y))).
This induction is justified by the same argument used to admit PERM.
Note, however, that the unmeasured variable Y is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (AND (NO-DUPS X) (SUB X Y))
                  (<= (LEN X) (LEN Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X))
              (NO-DUPS X)
              (SUB X Y))
         (<= (LEN X) (LEN Y))).

This simplifies, using the :definitions LEN, NO-DUPS and SUB and the
:rewrite rule PROBLEM-48A, to

Subgoal *1/3''
(IMPLIES (NOT (CONSP X))
         (<= 0 (LEN Y))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (MEM (CAR X) Y)))
         (IMPLIES (AND (NO-DUPS X) (SUB X Y))
                  (<= (LEN X) (LEN Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) Y))
              (NO-DUPS X)
              (SUB X Y))
         (<= (LEN X) (LEN Y))).

But simplification reduces this to T, using the :definition SUB.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (AND (NO-DUPS (CDR X))
                            (SUB (CDR X) (RM (CAR X) Y)))
                       (<= (LEN (CDR X))
                           (LEN (RM (CAR X) Y)))))
         (IMPLIES (AND (NO-DUPS X) (SUB X Y))
                  (<= (LEN X) (LEN Y)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (IMPLIES (AND (NO-DUPS (CDR X))
                            (SUB (CDR X) (RM (CAR X) Y)))
                       (<= (LEN (CDR X)) (LEN (RM (CAR X) Y))))
              (NO-DUPS X)
              (SUB X Y))
         (<= (LEN X) (LEN Y))).

This simplifies, using the :definitions LEN, NO-DUPS (if-intro), NOT
(if-intro) and SUB, the :rewrite rules PROBLEM-112F, PROBLEM-48 and
PROBLEM-49A and the :type-prescription rule MEM, to the following two
conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (<= (LEN (CDR X)) (+ -1 (LEN Y)))
              (NOT (MEM (CAR X) (CDR X)))
              (NO-DUPS (CDR X))
              (SUB (CDR X) Y))
         (<= (+ 1 (LEN (CDR X))) (LEN Y))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) Y)
              (NOT (SUB (CDR X) (RM (CAR X) Y)))
              (NOT (MEM (CAR X) (CDR X)))
              (NO-DUPS (CDR X))
              (SUB (CDR X) Y))
         (<= (+ 1 (LEN (CDR X))) (LEN Y))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-114I
and the :type-prescription rule SUB.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-114J ...)
Rules: ((:DEFINITION LEN)
        (:DEFINITION NO-DUPS)
        (:DEFINITION NOT)
        (:DEFINITION SUB)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:INDUCTION PERM)
        (:REWRITE PROBLEM-112F)
        (:REWRITE PROBLEM-114I)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-48A)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION NO-DUPS)
             (:DEFINITION NOT))
 PROBLEM-114J
ACL2 !>>(THEOREM PROBLEM-114K
                 (EQUAL (LEN (APP A B))
                        (+ (LEN A) (LEN B)))
                 :HINTS (("Goal" :INDUCT (APP A B))))


ACL2 !>>>(DEFTHM PROBLEM-114K
           (EQUAL (LEN (APP A B))
                  (+ (LEN A) (LEN B)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP A B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B))
              (:P A B))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (EQUAL (LEN (APP A B))
                (+ (LEN A) (LEN B)))).

But simplification reduces this to T, using the :definitions APP, FIX
and LEN, primitive type reasoning, the :rewrite rule UNICITY-OF-0 and
the :type-prescription rule LEN.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (EQUAL (LEN (APP (CDR A) B))
                     (+ (LEN (CDR A)) (LEN B))))
         (EQUAL (LEN (APP A B))
                (+ (LEN A) (LEN B)))).

But simplification reduces this to T, using the :definitions APP and
LEN, primitive type reasoning and the :rewrite rules CDR-CONS, 
COMMUTATIVITY-2-OF-+ and COMMUTATIVITY-OF-+.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-114K ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION FIX)
        (:DEFINITION LEN)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION LEN))
PROBLEM-114K


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114K))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114K)
PROBLEM-114K

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114K ...) ...)
Rules: NIL
 PROBLEM-114K
ACL2 !>>(THEOREM
          PROBLEM-114L
          (IMPLIES (AND (ADDRESSESP SEEN MEM)
                        (NO-DUPS SEEN))
                   (<= (LEN (PATH PTR MEM SEEN))
                       (+ 1 (LEN SEEN) (LEN MEM))))
          :HINTS
          (("Goal" :IN-THEORY (ENABLE PROBLEM-114D PROBLEM-114H PROBLEM-114K)
                   :USE (:INSTANCE PROBLEM-114J (X (PATH PTR MEM SEEN))
                                   (Y (CONS PTR (APP SEEN MEM))))))
          :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-114L
          (IMPLIES (AND (ADDRESSESP SEEN MEM)
                        (NO-DUPS SEEN))
                   (<= (LEN (PATH PTR MEM SEEN))
                       (+ 1 (LEN SEEN) (LEN MEM))))
          :RULE-CLASSES :LINEAR
          :HINTS
          (("Goal" :DO-NOT-INDUCT T
                   :DO-NOT '(GENERALIZE)
                   :IN-THEORY (ENABLE PROBLEM-114D PROBLEM-114H PROBLEM-114K)
                   :USE (:INSTANCE PROBLEM-114J (X (PATH PTR MEM SEEN))
                                   (Y (CONS PTR (APP SEEN MEM)))))))

[Note:  A hint was supplied for the goal above.  Thanks!]

We augment the goal with the hypothesis provided by the :USE hint.
The hypothesis can be derived from PROBLEM-114J via instantiation.
We are left with the following subgoal.

Goal'
(IMPLIES (IMPLIES (AND (NO-DUPS (PATH PTR MEM SEEN))
                       (SUB (PATH PTR MEM SEEN)
                            (CONS PTR (APP SEEN MEM))))
                  (<= (LEN (PATH PTR MEM SEEN))
                      (LEN (CONS PTR (APP SEEN MEM)))))
         (IMPLIES (AND (ADDRESSESP SEEN MEM)
                       (NO-DUPS SEEN))
                  (<= (LEN (PATH PTR MEM SEEN))
                      (+ 1 (LEN SEEN) (LEN MEM))))).

By the simple :rewrite rule PROBLEM-114H we reduce the conjecture to

Goal''
(IMPLIES (AND (IMPLIES (AND (NO-DUPS (PATH PTR MEM SEEN)) T)
                       (<= (LEN (PATH PTR MEM SEEN))
                           (LEN (CONS PTR (APP SEEN MEM)))))
              (ADDRESSESP SEEN MEM)
              (NO-DUPS SEEN))
         (<= (LEN (PATH PTR MEM SEEN))
             (+ 1 (LEN SEEN) (LEN MEM)))).

But simplification reduces this to T, using the :definitions LEN and
NOT, primitive type reasoning, the :rewrite rules CDR-CONS, 
COMMUTATIVITY-OF-+, PROBLEM-114D and PROBLEM-114K and the :type-prescription
rules ADDRESSESP, LEN and NO-DUPS.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-114L ...)
Rules: ((:DEFINITION LEN)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE PROBLEM-114D)
        (:REWRITE PROBLEM-114H)
        (:REWRITE PROBLEM-114K)
        (:TYPE-PRESCRIPTION ADDRESSESP)
        (:TYPE-PRESCRIPTION LEN)
        (:TYPE-PRESCRIPTION NO-DUPS))
Hint-events: ((:USE PROBLEM-114J))
PROBLEM-114L


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114L))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114L)
PROBLEM-114L

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114L ...) ...)
Rules: NIL
 PROBLEM-114L
ACL2 !>>(THEOREM
             PROBLEM-114
             (<= (DEREF-CNT PTR MEM NIL)
                 (+ 1 (LEN MEM)))
             :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-114A PROBLEM-114L))))


ACL2 !>>>(DEFTHM PROBLEM-114
           (<= (DEREF-CNT PTR MEM NIL)
               (+ 1 (LEN MEM)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-114A PROBLEM-114L))))

[Note:  A hint was supplied for the goal above.  Thanks!]

This simplifies, using the :executable-counterparts of BINARY-+, LEN
and UNARY-- and the :rewrite rules COMMUTATIVITY-OF-+ and PROBLEM-114A
(if-intro), to the following two conjectures.

Subgoal 2
(IMPLIES (EQUAL (PATH PTR MEM NIL) 'INFINITE)
         (<= 'INFINITE (+ 1 (LEN MEM)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 1
(IMPLIES (NOT (EQUAL (PATH PTR MEM NIL) 'INFINITE))
         (<= (+ -1 (LEN (PATH PTR MEM NIL)))
             (+ 1 (LEN MEM)))).

But simplification reduces this to T, using the :definitions ADDRESSESP
and FIX, the :executable-counterparts of CONSP, LEN and NO-DUPS, linear
arithmetic, primitive type reasoning, the :linear rule PROBLEM-114L,
the :rewrite rule UNICITY-OF-0 and the :type-prescription rule LEN.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-114 ...)
Rules: ((:DEFINITION ADDRESSESP)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART LEN)
        (:EXECUTABLE-COUNTERPART NO-DUPS)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR PROBLEM-114L)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE PROBLEM-114A)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION LEN))
Splitter rules (see :DOC splitter):
  if-intro: ((:REWRITE PROBLEM-114A))
PROBLEM-114


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-114))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-114)
PROBLEM-114

Summary
Form:  ( PROGN (DEFTHM PROBLEM-114 ...) ...)
Rules: NIL
 PROBLEM-114
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 115.
"
ACL2 !>>(DEFUN FIB (I)
          (IF (ZP I)
              0
            (IF (EQUAL I 1)
                1
              (+ (FIB (- I 1)) (FIB (- I 2))))))

For the admission of FIB we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT I).  The non-trivial part of the measure conjecture is

Goal
(IMPLIES (AND (NOT (ZP I)) (NOT (EQUAL I 1)))
         (O< (ACL2-COUNT (+ -2 I))
             (ACL2-COUNT I))).

By case analysis we reduce the conjecture to

Goal'
(IMPLIES (AND (NOT (ZP I)) (NOT (EQUAL I 1)))
         (O< (ACL2-COUNT (+ -2 I))
             (ACL2-COUNT I))).

But simplification reduces this to T, using the :compound-recognizer
rules O-FINP-CR and ZP-COMPOUND-RECOGNIZER, the :definitions ACL2-COUNT
and INTEGER-ABS, linear arithmetic, primitive type reasoning and the
:rewrite rules <-+-NEGATIVE-0-1 and O-FINP-<.

Q.E.D.

That completes the proof of the measure theorem for FIB.  Thus, we
admit this function under the principle of definition.  We observe
that the type of FIB is described by the theorem 
(AND (INTEGERP (FIB I)) (<= 0 (FIB I))).  We used primitive type reasoning.

Summary
Form:  ( DEFUN FIB ...)
Rules: ((:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION ACL2-COUNT)
        (:DEFINITION INTEGER-ABS)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE <-+-NEGATIVE-0-1)
        (:REWRITE O-FINP-<))
 FIB
ACL2 !>>(DEFUN FFIB (I J K)
          (IF (ZP I)
              J
            (IF (EQUAL I 1)
                K
              (FFIB (- I 1) K (+ J K)))))

The admission of FFIB is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT I).  We observe that the type of FFIB is described by the
theorem 
(OR (ACL2-NUMBERP (FFIB I J K))
    (EQUAL (FFIB I J K) J)
    (EQUAL (FFIB I J K) K)).
We used primitive type reasoning.

Summary
Form:  ( DEFUN FFIB ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 FFIB
ACL2 !>>(THEOREM PROBLEM-115A
                 (EQUAL (FFIB 2 I J) (+ I J))
                 :HINTS (("Goal" :EXPAND (FFIB 2 I J))))


ACL2 !>>>(DEFTHM PROBLEM-115A
           (EQUAL (FFIB 2 I J) (+ I J))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :EXPAND (FFIB 2 I J))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But simplification reduces this to T, using the :definition FFIB, the
:executable-counterparts of BINARY-+, EQUAL and ZP and primitive type
reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-115A ...)
Rules: ((:DEFINITION FFIB)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
PROBLEM-115A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-115A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-115A)
PROBLEM-115A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-115A ...) ...)
Rules: NIL
 PROBLEM-115A
ACL2 !>>(THEOREM PROBLEM-115B
                 (IMPLIES (AND (NATP N) (< 0 N) (NATP I) (NATP J))
                          (EQUAL (FFIB N I J)
                                 (+ (* (FIB (- N 1)) I) (* (FIB N) J))))
                 :HINTS (("Goal" :INDUCT (FFIB N I J)
                                 :IN-THEORY (ENABLE PROBLEM-115A))))


ACL2 !>>>(DEFTHM PROBLEM-115B
           (IMPLIES (AND (NATP N) (< 0 N) (NATP I) (NATP J))
                    (EQUAL (FFIB N I J)
                           (+ (* (FIB (- N 1)) I) (* (FIB N) J))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FFIB N I J)
                           :IN-THEORY (ENABLE PROBLEM-115A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FFIB N I J).

This suggestion was produced using the :induction rule FFIB.  If we
let (:P I J N) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ZP N))
                   (NOT (EQUAL N 1))
                   (:P J (+ I J) (+ -1 N)))
              (:P I J N))
     (IMPLIES (AND (NOT (ZP N)) (EQUAL N 1))
              (:P I J N))
     (IMPLIES (ZP N) (:P I J N))).
This induction is justified by the same argument used to admit FFIB.
Note, however, that the unmeasured variables I and J are being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ZP N))
              (NOT (EQUAL N 1))
              (IMPLIES (AND (NATP (+ -1 N))
                            (< 0 (+ -1 N))
                            (NATP J)
                            (NATP (+ I J)))
                       (EQUAL (FFIB (+ -1 N) J (+ I J))
                              (+ (* (FIB (+ -1 -1 N)) J)
                                 (* (FIB (+ -1 N)) (+ I J))))))
         (IMPLIES (AND (NATP N) (< 0 N) (NATP I) (NATP J))
                  (EQUAL (FFIB N I J)
                         (+ (* (FIB (+ -1 N)) I)
                            (* (FIB N) J))))).

By the simple :rewrite rules <-0-+-NEGATIVE-1 and NATP-POSP--1 we reduce
the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (ZP N))
              (NOT (EQUAL N 1))
              (IMPLIES (AND (POSP N)
                            (< 1 N)
                            (NATP J)
                            (NATP (+ I J)))
                       (EQUAL (FFIB (+ -1 N) J (+ I J))
                              (+ (* (FIB (+ -1 -1 N)) J)
                                 (* (FIB (+ -1 N)) (+ I J)))))
              (NATP N)
              (< 0 N)
              (NATP I)
              (NATP J))
         (EQUAL (FFIB N I J)
                (+ (* (FIB (+ -1 N)) I)
                   (* (FIB N) J)))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, POSP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER,
the :definitions FFIB and SYNP, the :executable-counterpart of BINARY-+,
primitive type reasoning and the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-*, COMMUTATIVITY-OF-+, DISTRIBUTIVITY and FOLD-CONSTS-IN-+,
to

Subgoal *1/3''
(IMPLIES (AND (NOT (EQUAL N 1))
              (EQUAL (FFIB (+ -1 N) J (+ I J))
                     (+ (* I (FIB (+ -1 N)))
                        (* J (FIB (+ -1 N)))
                        (* J (FIB (+ -2 N)))))
              (NATP N)
              (< 0 N)
              (NATP I)
              (NATP J))
         (EQUAL (FFIB (+ -1 N) J (+ I J))
                (+ (* J (FIB N))
                   (* I (FIB (+ -1 N)))))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :definition
FIB, primitive type reasoning and the :rewrite rules COMMUTATIVITY-OF-+
and DISTRIBUTIVITY.

Subgoal *1/2
(IMPLIES (AND (NOT (ZP N)) (EQUAL N 1))
         (IMPLIES (AND (NATP N) (< 0 N) (NATP I) (NATP J))
                  (EQUAL (FFIB N I J)
                         (+ (* (FIB (+ -1 N)) I)
                            (* (FIB N) J))))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (ZP N))
              (EQUAL N 1)
              (NATP N)
              (< 0 N)
              (NATP I)
              (NATP J))
         (EQUAL (FFIB N I J)
                (+ (* (FIB (+ -1 N)) I)
                   (* (FIB N) J)))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions FFIB and FIX, the :executable-
counterparts of <, BINARY-+, EQUAL, FIB, NATP, NOT and ZP, primitive
type reasoning and the :rewrite rules TIMES-ZERO, UNICITY-OF-0 and
UNICITY-OF-1.

Subgoal *1/1
(IMPLIES (ZP N)
         (IMPLIES (AND (NATP N) (< 0 N) (NATP I) (NATP J))
                  (EQUAL (FFIB N I J)
                         (+ (* (FIB (+ -1 N)) I)
                            (* (FIB N) J))))).

But we reduce the conjecture to T, by the :compound-recognizer rules
NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER and primitive type
reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-115B ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION FFIB)
        (:DEFINITION FIB)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART FIB)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FFIB)
        (:REWRITE <-0-+-NEGATIVE-1)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-*)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DISTRIBUTIVITY)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE NATP-POSP--1)
        (:REWRITE TIMES-ZERO)
        (:REWRITE UNICITY-OF-0)
        (:REWRITE UNICITY-OF-1))
PROBLEM-115B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-115B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-115B)
PROBLEM-115B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-115B ...) ...)
Rules: NIL
 PROBLEM-115B
ACL2 !>>(THEOREM PROBLEM-115 (EQUAL (FFIB N 0 1) (FIB N))
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-115B)
                                 :CASES ((ZP N)))))


ACL2 !>>>(DEFTHM PROBLEM-115
           (EQUAL (FFIB N 0 1) (FIB N))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-115B)
                           :CASES ((ZP N)))))

[Note:  A hint was supplied for the goal above.  Thanks!]

We now split the goal into the cases specified by the :CASES hint to
produce two new non-trivial subgoals.

Subgoal 2
(IMPLIES (NOT (ZP N))
         (EQUAL (FFIB N 0 1) (FIB N))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :definition
FIX, primitive type reasoning, the :rewrite rules COMMUTATIVITY-OF-*,
PROBLEM-115B, TIMES-ZERO, UNICITY-OF-0 and UNICITY-OF-1 and the :type-
prescription rule FIB.

Subgoal 1
(IMPLIES (ZP N)
         (EQUAL (FFIB N 0 1) (FIB N))).

But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definitions FFIB and FIB and the
:executable-counterpart of EQUAL.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-115 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION FFIB)
        (:DEFINITION FIB)
        (:DEFINITION FIX)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE COMMUTATIVITY-OF-*)
        (:REWRITE PROBLEM-115B)
        (:REWRITE TIMES-ZERO)
        (:REWRITE UNICITY-OF-0)
        (:REWRITE UNICITY-OF-1)
        (:TYPE-PRESCRIPTION FIB))
PROBLEM-115


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-115))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-115)
PROBLEM-115

Summary
Form:  ( PROGN (DEFTHM PROBLEM-115 ...) ...)
Rules: NIL
 PROBLEM-115
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 116.
"
ACL2 !>>(DEFUN ROT (X)
          (IF (ENDP X)
              NIL
            (APP (CDR X) (LIST (CAR X)))))

Since ROT is non-recursive, its admission is trivial.  We observe that
the type of ROT is described by the theorem 
(OR (CONSP (ROT X)) (EQUAL (ROT X) NIL)).  We used primitive type reasoning
and the :type-prescription rule APP.

Summary
Form:  ( DEFUN ROT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION APP))
 ROT
ACL2 !>>(DEFUN ROTN (N X)
          (IF (ZP N) X (ROTN (- N 1) (ROT X))))

The admission of ROTN is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT N).  We observe that the type of ROTN is described by the
theorem 
(OR (OR (CONSP (ROTN N X)) (EQUAL (ROTN N X) NIL)) (EQUAL (ROTN N X) X)).
We used the :type-prescription rule ROT.

Summary
Form:  ( DEFUN ROTN ...)
Rules: ((:TYPE-PRESCRIPTION ROT))
 ROTN
ACL2 !>>(THEOREM PROBLEM-116-COUNTEREXAMPLE
                 (NOT (EQUAL (ROTN (LEN '(1 2 3 . 4)) '(1 2 3 . 4))
                             '(1 2 3 . 4)))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But we reduce the conjecture to T, by the :executable-counterparts
of EQUAL, LEN and ROTN.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-116-COUNTEREXAMPLE ...)
Rules: ((:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART LEN)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART ROTN))
 PROBLEM-116-COUNTEREXAMPLE
ACL2 !>>(DEFUN ROT-HINT (X Y)
          (IF (CONSP X)
              (ROT-HINT (CDR X)
                        (APP Y (CONS (CAR X) NIL)))
            Y))

The admission of ROT-HINT is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We observe that the type of ROT-HINT is described
by the theorem (OR (CONSP (ROT-HINT X Y)) (EQUAL (ROT-HINT X Y) Y)).
We used primitive type reasoning and the :type-prescription rule APP.

Summary
Form:  ( DEFUN ROT-HINT ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:TYPE-PRESCRIPTION APP))
 ROT-HINT
ACL2 !>>(THEOREM
             PROBLEM-116A
             (IMPLIES (AND (PROPER X) (PROPER Y))
                      (EQUAL (ROTN (LEN X) (APP X Y))
                             (APP Y X)))
             :HINTS
             (("Goal" :INDUCT (ROT-HINT X Y)
                      :IN-THEORY (ENABLE PROBLEM-40 PROBLEM-41 PROBLEM-44C)))
             :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (ROT-HINT X Y).

This suggestion was produced using the :induction rule ROT-HINT.  If
we let (:P X Y) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P X Y))
     (IMPLIES (AND (CONSP X)
                   (:P (CDR X) (APP Y (LIST (CAR X)))))
              (:P X Y))).
This induction is justified by the same argument used to admit ROT-HINT.
Note, however, that the unmeasured variable Y is being instantiated.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (IMPLIES (AND (PROPER X) (PROPER Y))
                  (EQUAL (ROTN (LEN X) (APP X Y))
                         (APP Y X)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP X))
              (PROPER X)
              (PROPER Y))
         (EQUAL (ROTN (LEN X) (APP X Y))
                (APP Y X))).

But simplification reduces this to T, using the :definitions APP, PROPER
and ROTN, the :executable-counterparts of CONSP, LEN and ZP, primitive
type reasoning, the :rewrite rule PROBLEM-41 and the :type-prescription
rule PROPER.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (IMPLIES (AND (PROPER (CDR X))
                            (PROPER (APP Y (LIST (CAR X)))))
                       (EQUAL (ROTN (LEN (CDR X))
                                    (APP (CDR X) (APP Y (LIST (CAR X)))))
                              (APP (APP Y (LIST (CAR X))) (CDR X)))))
         (IMPLIES (AND (PROPER X) (PROPER Y))
                  (EQUAL (ROTN (LEN X) (APP X Y))
                         (APP Y X)))).

By the simple :rewrite rules PROBLEM-40 and PROBLEM-44C we reduce the
conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (IMPLIES (AND (PROPER (CDR X))
                            (PROPER (LIST (CAR X))))
                       (EQUAL (ROTN (LEN (CDR X))
                                    (APP (CDR X) (APP Y (LIST (CAR X)))))
                              (APP Y (APP (LIST (CAR X)) (CDR X)))))
              (PROPER X)
              (PROPER Y))
         (EQUAL (ROTN (LEN X) (APP X Y))
                (APP Y X))).

But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER, the :definitions APP, FIX, LEN, PROPER,
ROT, ROTN and SYNP, the :executable-counterparts of BINARY-+, CONSP
and PROPER, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, CONS-CAR-CDR, FOLD-CONSTS-IN-+, PROBLEM-40 and UNICITY-OF-0
and the :type-prescription rules LEN and PROPER.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-116A ...)
Rules: ((:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION APP)
        (:DEFINITION FIX)
        (:DEFINITION LEN)
        (:DEFINITION NOT)
        (:DEFINITION PROPER)
        (:DEFINITION ROT)
        (:DEFINITION ROTN)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART LEN)
        (:EXECUTABLE-COUNTERPART PROPER)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION ROT-HINT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE CONS-CAR-CDR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE PROBLEM-40)
        (:REWRITE PROBLEM-41)
        (:REWRITE PROBLEM-44C)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION LEN)
        (:TYPE-PRESCRIPTION PROPER))
 PROBLEM-116A
ACL2 !>>(THEOREM PROBLEM-116
                 (IMPLIES (PROPER X)
                          (EQUAL (ROTN (LEN X) X) X))
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-41)
                                 :USE (:INSTANCE PROBLEM-116A (X X)
                                                 (Y NIL)))))


ACL2 !>>>(DEFTHM PROBLEM-116
           (IMPLIES (PROPER X)
                    (EQUAL (ROTN (LEN X) X) X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-41)
                           :USE (:INSTANCE PROBLEM-116A (X X)
                                           (Y NIL)))))

[Note:  A hint was supplied for the goal above.  Thanks!]

We augment the goal with the hypothesis provided by the :USE hint.
The hypothesis can be derived from PROBLEM-116A via instantiation.
We are left with the following subgoal.

Goal'
(IMPLIES (IMPLIES (AND (PROPER X) (PROPER NIL))
                  (EQUAL (ROTN (LEN X) (APP X NIL))
                         (APP NIL X)))
         (IMPLIES (PROPER X)
                  (EQUAL (ROTN (LEN X) X) X))).

By the :executable-counterpart of PROPER we reduce the conjecture to

Goal''
(IMPLIES (AND (IMPLIES (AND (PROPER X) T)
                       (EQUAL (ROTN (LEN X) (APP X NIL))
                              (APP NIL X)))
              (PROPER X))
         (EQUAL (ROTN (LEN X) X) X)).

But simplification reduces this to T, using the :definition APP, the
:executable-counterpart of CONSP, the :rewrite rule PROBLEM-41 and
the :type-prescription rule PROPER.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-116 ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART PROPER)
        (:REWRITE PROBLEM-41)
        (:TYPE-PRESCRIPTION PROPER))
Hint-events: ((:USE PROBLEM-116A))
PROBLEM-116


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-116))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-116)
PROBLEM-116

Summary
Form:  ( PROGN (DEFTHM PROBLEM-116 ...) ...)
Rules: NIL
 PROBLEM-116
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 117.
"
ACL2 !>>(DEFUN N (V)
          (COND ((ENDP V) 0)
                ((CAR V) (+ 1 (* 2 (N (CDR V)))))
                (T (* 2 (N (CDR V))))))

The admission of N is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT V).  We observe that the type of N is described by the
theorem (AND (INTEGERP (N V)) (<= 0 (N V))).  We used primitive type
reasoning.

Summary
Form:  ( DEFUN N ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 N
ACL2 !>>(DEFUN BAND (P Q)
          (IF P (IF Q T NIL) NIL))

Since BAND is non-recursive, its admission is trivial.  We observe
that the type of BAND is described by the theorem 
(OR (EQUAL (BAND P Q) T) (EQUAL (BAND P Q) NIL)).  

Summary
Form:  ( DEFUN BAND ...)
Rules: NIL
 BAND
ACL2 !>>(DEFUN BNOT (P) (IF P NIL T))

Since BNOT is non-recursive, its admission is trivial.  We observe
that the type of BNOT is described by the theorem 
(OR (EQUAL (BNOT P) T) (EQUAL (BNOT P) NIL)).  

Summary
Form:  ( DEFUN BNOT ...)
Rules: NIL
 BNOT
ACL2 !>>(DEFUN BOR (P Q) (IF P T (IF Q T NIL)))

Since BOR is non-recursive, its admission is trivial.  We observe that
the type of BOR is described by the theorem 
(OR (EQUAL (BOR P Q) T) (EQUAL (BOR P Q) NIL)).  

Summary
Form:  ( DEFUN BOR ...)
Rules: NIL
 BOR
ACL2 !>>(DEFUN BXOR (P Q)
          (IF P (IF Q NIL T) (IF Q T NIL)))

Since BXOR is non-recursive, its admission is trivial.  We observe
that the type of BXOR is described by the theorem 
(OR (EQUAL (BXOR P Q) T) (EQUAL (BXOR P Q) NIL)).  

Summary
Form:  ( DEFUN BXOR ...)
Rules: NIL
 BXOR
ACL2 !>>(DEFUN BMAJ (P Q C)
          (BOR (BAND P Q)
               (BOR (BAND P C) (BAND Q C))))

Since BMAJ is non-recursive, its admission is trivial.  We observe
that the type of BMAJ is described by the theorem 
(OR (EQUAL (BMAJ P Q C) T) (EQUAL (BMAJ P Q C) NIL)).  We used the
:type-prescription rule BOR.

Summary
Form:  ( DEFUN BMAJ ...)
Rules: ((:TYPE-PRESCRIPTION BOR))
 BMAJ
ACL2 !>>(DEFUN VADD1 (X Y C)
          (IF (ENDP X)
              (CONS C NIL)
            (CONS (BXOR (CAR X) (BXOR (CAR Y) C))
                  (VADD1 (CDR X)
                         (CDR Y)
                         (BMAJ (CAR X) (CAR Y) C)))))

The admission of VADD1 is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of VADD1 is described by
the theorem (AND (CONSP (VADD1 X Y C)) (TRUE-LISTP (VADD1 X Y C))).
We used primitive type reasoning.

Summary
Form:  ( DEFUN VADD1 ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 VADD1
ACL2 !>>(THEOREM PROBLEM-117A
                 (EQUAL (EQUAL (LEN X) 0)
                        (NOT (CONSP X)))
                 :HINTS (("Goal" :INDUCT (LEN X))))


ACL2 !>>>(DEFTHM PROBLEM-117A
           (EQUAL (EQUAL (LEN X) 0)
                  (NOT (CONSP X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LEN X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LEN X).

This suggestion was produced using the :induction rule LEN.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit LEN.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (EQUAL (LEN X) 0)
                (NOT (CONSP X)))).

But simplification reduces this to T, using the :definition LEN and
the :executable-counterparts of EQUAL and NOT.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (EQUAL (LEN (CDR X)) 0)
                     (NOT (CONSP (CDR X)))))
         (EQUAL (EQUAL (LEN X) 0)
                (NOT (CONSP X)))).

But simplification reduces this to T, using the :definitions LEN and
NOT, the :executable-counterparts of BINARY-+, EQUAL and NOT, primitive
type reasoning and the :type-prescription rule LEN.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-117A ...)
Rules: ((:DEFINITION LEN)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN)
        (:TYPE-PRESCRIPTION LEN))
PROBLEM-117A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-117A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-117A)
PROBLEM-117A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-117A ...) ...)
Rules: NIL
 PROBLEM-117A
ACL2 !>>(THEOREM PROBLEM-117B
                 (IMPLIES (EQUAL (LEN X) (LEN Y))
                          (EQUAL (N (VADD1 X Y C))
                                 (+ (N X) (N Y) (IF C 1 0))))
                 :HINTS (("Goal" :INDUCT (VADD1 X Y C)
                                 :IN-THEORY (ENABLE PROBLEM-117A))))


ACL2 !>>>(DEFTHM PROBLEM-117B
           (IMPLIES (EQUAL (LEN X) (LEN Y))
                    (EQUAL (N (VADD1 X Y C))
                           (+ (N X) (N Y) (IF C 1 0))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (VADD1 X Y C)
                           :IN-THEORY (ENABLE PROBLEM-117A))))

ACL2 Warning [Double-rewrite] in ( DEFTHM PROBLEM-117B ...):  In a
:REWRITE rule generated from PROBLEM-117B, equivalence relation IFF
is maintained at one problematic occurrence of variable C in the right-
hand side, but not at any binding occurrence of C.  Consider replacing
that occurrence of C in the right-hand side with (DOUBLE-REWRITE C).
See :doc double-rewrite for more information on this issue.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (VADD1 X Y C).

This suggestion was produced using the :induction rule VADD1.  If we
let (:P C X Y) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP X))
                   (:P (BMAJ (CAR X) (CAR Y) C)
                       (CDR X)
                       (CDR Y)))
              (:P C X Y))
     (IMPLIES (ENDP X) (:P C X Y))).
This induction is justified by the same argument used to admit VADD1.
Note, however, that the unmeasured variables Y and C are being instantiated.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP X))
              (IMPLIES (EQUAL (LEN (CDR X)) (LEN (CDR Y)))
                       (EQUAL (N (VADD1 (CDR X)
                                        (CDR Y)
                                        (BMAJ (CAR X) (CAR Y) C)))
                              (+ (N (CDR X))
                                 (N (CDR Y))
                                 (IF (BMAJ (CAR X) (CAR Y) C) 1 0)))))
         (IMPLIES (EQUAL (LEN X) (LEN Y))
                  (EQUAL (N (VADD1 X Y C))
                         (+ (N X) (N Y) (IF C 1 0))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (IMPLIES (EQUAL (LEN (CDR X)) (LEN (CDR Y)))
                       (EQUAL (N (VADD1 (CDR X)
                                        (CDR Y)
                                        (BMAJ (CAR X) (CAR Y) C)))
                              (+ (N (CDR X))
                                 (N (CDR Y))
                                 (IF (BMAJ (CAR X) (CAR Y) C) 1 0))))
              (EQUAL (LEN X) (LEN Y)))
         (EQUAL (N (VADD1 X Y C))
                (+ (N X) (N Y) (IF C 1 0)))).

This simplifies, using the :definitions BAND (if-intro), BMAJ, BOR
(if-intro), BXOR (if-intro), FIX (if-intro), LEN (if-intro), N (if-
intro), SYNP and VADD1 (if-intro), the :executable-counterparts of
BAND, BINARY-*, BINARY-+, BOR and BXOR, primitive type reasoning, the
:rewrite rules ASSOCIATIVITY-OF-+, CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DISTRIBUTIVITY, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rules LEN, N and VADD1, to the following
18 conjectures.

Subgoal *1/2.18
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (CAR X)
              (CAR Y)
              C)
         (EQUAL (+ 1
                   (* 2
                      (N (VADD1 (CDR X)
                                (CDR Y)
                                (BMAJ (CAR X) (CAR Y) C)))))
                (+ 1 (+ 1 (* 2 (N (CDR X))))
                   1 (* 2 (N (CDR Y)))))).

By the simple :rewrite rules ASSOCIATIVITY-OF-+ and LEFT-CANCELLATION-FOR-+
we reduce the conjecture to

Subgoal *1/2.18'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (CAR X)
              (CAR Y)
              C)
         (EQUAL (FIX (* 2
                        (N (VADD1 (CDR X)
                                  (CDR Y)
                                  (BMAJ (CAR X) (CAR Y) C)))))
                (FIX (+ 1 (* 2 (N (CDR X)))
                        1 (* 2 (N (CDR Y))))))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning and the :type-prescription rule LEN.

Subgoal *1/2.17
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT (CAR X))
              (CAR Y)
              C)
         (EQUAL (* 2
                   (N (VADD1 (CDR X)
                             (CDR Y)
                             (BMAJ (CAR X) (CAR Y) C))))
                (+ 1 (* 2 (N (CDR X)))
                   1 (* 2 (N (CDR Y)))))).

By the simple :rewrite rule LEFT-CANCELLATION-FOR-+ we reduce the conjecture
to

Subgoal *1/2.17'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT (CAR X))
              (CAR Y)
              C)
         (EQUAL (* 2
                   (N (VADD1 (CDR X)
                             (CDR Y)
                             (BMAJ (CAR X) (CAR Y) C))))
                (+ 1 (* 2 (N (CDR X)))
                   1 (* 2 (N (CDR Y)))))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning and the :type-prescription rule LEN.

Subgoal *1/2.16
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (CAR X)
              (NOT (CAR Y))
              C)
         (EQUAL (* 2
                   (N (VADD1 (CDR X)
                             (CDR Y)
                             (BMAJ (CAR X) (CAR Y) C))))
                (+ 1 (+ 1 (* 2 (N (CDR X))))
                   (* 2 (N (CDR Y)))))).

By the simple :rewrite rules ASSOCIATIVITY-OF-+ and LEFT-CANCELLATION-FOR-+
we reduce the conjecture to

Subgoal *1/2.16'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (CAR X)
              (NOT (CAR Y))
              C)
         (EQUAL (* 2
                   (N (VADD1 (CDR X)
                             (CDR Y)
                             (BMAJ (CAR X) (CAR Y) C))))
                (+ 1 1 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning and the :type-prescription rule LEN.

Subgoal *1/2.15
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT (CAR X))
              (NOT (CAR Y))
              C)
         (EQUAL (+ 1
                   (* 2
                      (N (VADD1 (CDR X)
                                (CDR Y)
                                (BMAJ (CAR X) (CAR Y) C)))))
                (+ 1 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

By the simple :rewrite rule LEFT-CANCELLATION-FOR-+ we reduce the conjecture
to

Subgoal *1/2.15'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT (CAR X))
              (NOT (CAR Y))
              C)
         (EQUAL (FIX (* 2
                        (N (VADD1 (CDR X)
                                  (CDR Y)
                                  (BMAJ (CAR X) (CAR Y) C)))))
                (FIX (+ (* 2 (N (CDR X)))
                        (* 2 (N (CDR Y))))))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning and the :type-prescription rule LEN.

Subgoal *1/2.14
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (CAR X)
              (CAR Y)
              (NOT C))
         (EQUAL (* 2
                   (N (VADD1 (CDR X)
                             (CDR Y)
                             (BMAJ (CAR X) (CAR Y) NIL))))
                (+ 0 (+ 1 (* 2 (N (CDR X))))
                   1 (* 2 (N (CDR Y)))))).

By the simple :rewrite rules ASSOCIATIVITY-OF-+, LEFT-CANCELLATION-FOR-+
and UNICITY-OF-0 we reduce the conjecture to

Subgoal *1/2.14'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (CAR X)
              (CAR Y)
              (NOT C))
         (EQUAL (* 2
                   (N (VADD1 (CDR X)
                             (CDR Y)
                             (BMAJ (CAR X) (CAR Y) NIL))))
                (FIX (+ 1 (* 2 (N (CDR X)))
                        1 (* 2 (N (CDR Y))))))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning and the :type-prescription rule LEN.

Subgoal *1/2.13
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT (CAR X))
              (CAR Y)
              (NOT C))
         (EQUAL (+ 1
                   (* 2
                      (N (VADD1 (CDR X)
                                (CDR Y)
                                (BMAJ (CAR X) (CAR Y) NIL)))))
                (+ 0 (* 2 (N (CDR X)))
                   1 (* 2 (N (CDR Y)))))).

By the simple :rewrite rules LEFT-CANCELLATION-FOR-+ and UNICITY-OF-0
we reduce the conjecture to

Subgoal *1/2.13'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT (CAR X))
              (CAR Y)
              (NOT C))
         (EQUAL (+ 1
                   (* 2
                      (N (VADD1 (CDR X)
                                (CDR Y)
                                (BMAJ (CAR X) (CAR Y) NIL)))))
                (FIX (+ (* 2 (N (CDR X)))
                        1 (* 2 (N (CDR Y))))))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning and the :type-prescription rule LEN.

Subgoal *1/2.12
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (CAR X)
              (NOT (CAR Y))
              (NOT C))
         (EQUAL (+ 1
                   (* 2
                      (N (VADD1 (CDR X)
                                (CDR Y)
                                (BMAJ (CAR X) (CAR Y) NIL)))))
                (+ 0 (+ 1 (* 2 (N (CDR X))))
                   (* 2 (N (CDR Y)))))).

By the simple :rewrite rules ASSOCIATIVITY-OF-+, LEFT-CANCELLATION-FOR-+
and UNICITY-OF-0 we reduce the conjecture to

Subgoal *1/2.12'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (CAR X)
              (NOT (CAR Y))
              (NOT C))
         (EQUAL (+ 1
                   (* 2
                      (N (VADD1 (CDR X)
                                (CDR Y)
                                (BMAJ (CAR X) (CAR Y) NIL)))))
                (FIX (+ 1 (* 2 (N (CDR X)))
                        (* 2 (N (CDR Y))))))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning and the :type-prescription rule LEN.

Subgoal *1/2.11
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT (CAR X))
              (NOT (CAR Y))
              (NOT C))
         (EQUAL (* 2
                   (N (VADD1 (CDR X)
                             (CDR Y)
                             (BMAJ (CAR X) (CAR Y) NIL))))
                (+ 0 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

By the simple :rewrite rules LEFT-CANCELLATION-FOR-+ and UNICITY-OF-0
we reduce the conjecture to

Subgoal *1/2.11'
(IMPLIES (AND (CONSP X)
              (NOT (EQUAL (LEN (CDR X)) (LEN (CDR Y))))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT (CAR X))
              (NOT (CAR Y))
              (NOT C))
         (EQUAL (* 2
                   (N (VADD1 (CDR X)
                             (CDR Y)
                             (BMAJ (CAR X) (CAR Y) NIL))))
                (FIX (+ (* 2 (N (CDR X)))
                        (* 2 (N (CDR Y))))))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning and the :type-prescription rule LEN.

Subgoal *1/2.10
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (NOT C)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (CAR Y))
         (EQUAL (+ 1 (* 2 (N (VADD1 (CDR X) (CDR Y) NIL))))
                (+ (* 2 (N (CDR X)))
                   1 (* 2 (N (CDR Y)))))).

By the simple :rewrite rule LEFT-CANCELLATION-FOR-+ we reduce the conjecture
to

Subgoal *1/2.10'
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (NOT C)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (CAR Y))
         (EQUAL (+ 1 (* 2 (N (VADD1 (CDR X) (CDR Y) NIL))))
                (+ (* 2 (N (CDR X)))
                   1 (* 2 (N (CDR Y)))))).

This simplifies, using the :definitions BAND, BMAJ and FIX, the :executable-
counterparts of BAND and BOR, primitive type reasoning, the :meta rule
CANCEL_PLUS-EQUAL-CORRECT, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription rules
LEN and N, to

Subgoal *1/2.10''
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (EQUAL (N (VADD1 (CDR X) (CDR Y) NIL))
                     (+ (N (CDR X)) (N (CDR Y))))
              (CONSP Y)
              (EQUAL (LEN (CDR X)) (LEN (CDR Y)))
              (CAR Y))
         (EQUAL (* 2 (N (VADD1 (CDR X) (CDR Y) NIL)))
                (+ (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule N.

Subgoal *1/2.9
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (NOT C)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT (CAR Y)))
         (EQUAL (* 2 (N (VADD1 (CDR X) (CDR Y) NIL)))
                (+ (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

By the simple :rewrite rule LEFT-CANCELLATION-FOR-+ we reduce the conjecture
to

Subgoal *1/2.9'
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (NOT C)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT (CAR Y)))
         (EQUAL (* 2 (N (VADD1 (CDR X) (CDR Y) NIL)))
                (+ (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

This simplifies, using the :definition FIX, the :executable-counterpart
of BMAJ, the :rewrite rules COMMUTATIVITY-OF-+ and UNICITY-OF-0 and
the :type-prescription rules LEN and N, to

Subgoal *1/2.9''
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (EQUAL (N (VADD1 (CDR X) (CDR Y) NIL))
                     (+ (N (CDR X)) (N (CDR Y))))
              (CONSP Y)
              (EQUAL (LEN (CDR X)) (LEN (CDR Y)))
              (NOT (CAR Y)))
         (EQUAL (* 2 (N (VADD1 (CDR X) (CDR Y) NIL)))
                (+ (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule N.

Subgoal *1/2.8
(IMPLIES (AND (CONSP X)
              (CAR X)
              C
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) C)))
                     (+ (N (CDR X)) (N (CDR Y)) 1))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (CAR Y))
         (EQUAL (+ 3 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y))))
                (+ 2 (* 2 (N (CDR X)))
                   1 (* 2 (N (CDR Y)))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM and the simple :rewrite rule LEFT-CANCELLATION-FOR-+.

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (CAR X)
              (CAR Y)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) C)))
                     (+ (N (CDR X)) (N (CDR Y)) 1))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              C)
         (EQUAL (+ 3 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y))))
                (+ 2 1 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM and the simple :rewrite rule LEFT-CANCELLATION-FOR-+.

Subgoal *1/2.6
(IMPLIES (AND (CONSP X)
              (CAR X)
              (CAR Y)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 1))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT C))
         (EQUAL (+ 2 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y))))
                (+ 2 0 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

By the simple :rewrite rules LEFT-CANCELLATION-FOR-+ and UNICITY-OF-0
we reduce the conjecture to

Subgoal *1/2.6'
(IMPLIES (AND (CONSP X)
              (CAR X)
              (CAR Y)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 1))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT C))
         (EQUAL (FIX (+ (* 2 (N (CDR X))) (* 2 (N (CDR Y)))))
                (FIX (FIX (+ (* 2 (N (CDR X)))
                             (* 2 (N (CDR Y)))))))).

But simplification reduces this to T, using the :definitions BAND,
BMAJ and FIX, the :executable-counterpart of BOR, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-2-OF-+ and COMMUTATIVITY-OF-+ and
the :type-prescription rules LEN and N.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (NOT (CAR Y))
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT C))
         (EQUAL (+ (* 2 (N (CDR X))) (* 2 (N (CDR Y))))
                (+ 0 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

By the simple :rewrite rules LEFT-CANCELLATION-FOR-+ and UNICITY-OF-0
we reduce the conjecture to

Subgoal *1/2.5'
(IMPLIES (AND (CONSP X)
              (NOT (CAR X))
              (NOT (CAR Y))
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT C))
         (EQUAL (+ (* 2 (N (CDR X))) (* 2 (N (CDR Y))))
                (FIX (+ (* 2 (N (CDR X)))
                        (* 2 (N (CDR Y))))))).

But simplification reduces this to T, using the :definition FIX, the
:executable-counterpart of BMAJ, primitive type reasoning, the :rewrite
rules COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription
rules LEN and N.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (NOT (CAR Y))
              (NOT C)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (CAR X))
         (EQUAL (+ 1 (* 2 (N (VADD1 (CDR X) (CDR Y) NIL))))
                (+ (* 2 (N (CDR Y)))
                   1 (* 2 (N (CDR X)))))).

By the simple :rewrite rule LEFT-CANCELLATION-FOR-+ we reduce the conjecture
to

Subgoal *1/2.4'
(IMPLIES (AND (CONSP X)
              (NOT (CAR Y))
              (NOT C)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (CAR X))
         (EQUAL (+ 1 (* 2 (N (VADD1 (CDR X) (CDR Y) NIL))))
                (+ (* 2 (N (CDR Y)))
                   1 (* 2 (N (CDR X)))))).

This simplifies, using the :definitions BAND, BMAJ and FIX, the :executable-
counterparts of BAND and BOR, primitive type reasoning, the :meta rule
CANCEL_PLUS-EQUAL-CORRECT, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription rules
LEN and N, to

Subgoal *1/2.4''
(IMPLIES (AND (CONSP X)
              (NOT (CAR Y))
              (EQUAL (N (VADD1 (CDR X) (CDR Y) NIL))
                     (+ (N (CDR X)) (N (CDR Y))))
              (CONSP Y)
              (EQUAL (LEN (CDR X)) (LEN (CDR Y)))
              (CAR X))
         (EQUAL (* 2 (N (VADD1 (CDR X) (CDR Y) NIL)))
                (+ (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule N.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (NOT (CAR Y))
              (NOT C)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT (CAR X)))
         (EQUAL (* 2 (N (VADD1 (CDR X) (CDR Y) NIL)))
                (+ (* 2 (N (CDR Y)))
                   (* 2 (N (CDR X)))))).

By the simple :rewrite rule LEFT-CANCELLATION-FOR-+ we reduce the conjecture
to

Subgoal *1/2.3'
(IMPLIES (AND (CONSP X)
              (NOT (CAR Y))
              (NOT C)
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) NIL)))
                     (+ (N (CDR X)) (N (CDR Y)) 0))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT (CAR X)))
         (EQUAL (* 2 (N (VADD1 (CDR X) (CDR Y) NIL)))
                (+ (* 2 (N (CDR Y)))
                   (* 2 (N (CDR X)))))).

This simplifies, using the :definition FIX, the :executable-counterpart
of BMAJ, the :rewrite rules COMMUTATIVITY-OF-+ and UNICITY-OF-0 and
the :type-prescription rules LEN and N, to

Subgoal *1/2.3''
(IMPLIES (AND (CONSP X)
              (NOT (CAR Y))
              (EQUAL (N (VADD1 (CDR X) (CDR Y) NIL))
                     (+ (N (CDR X)) (N (CDR Y))))
              (CONSP Y)
              (EQUAL (LEN (CDR X)) (LEN (CDR Y)))
              (NOT (CAR X)))
         (EQUAL (* 2 (N (VADD1 (CDR X) (CDR Y) NIL)))
                (+ (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning and the :type-prescription rule N.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (CAR Y)
              C
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) C)))
                     (+ (N (CDR X)) (N (CDR Y)) 1))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (CAR X))
         (EQUAL (+ 3 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y))))
                (+ 2 (* 2 (N (CDR Y)))
                   1 (* 2 (N (CDR X)))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM and the simple :rewrite rule LEFT-CANCELLATION-FOR-+.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (CAR Y)
              C
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) C)))
                     (+ (N (CDR X)) (N (CDR Y)) 1))
              (CONSP Y)
              (EQUAL (+ 1 (LEN (CDR X)))
                     (+ 1 (LEN (CDR Y))))
              (NOT (CAR X)))
         (EQUAL (+ 2 (* 2 (N (CDR X)))
                   (* 2 (N (CDR Y))))
                (+ 2 (* 2 (N (CDR Y)))
                   (* 2 (N (CDR X)))))).

By the simple :rewrite rule LEFT-CANCELLATION-FOR-+ we reduce the conjecture
to

Subgoal *1/2.1'
(IMPLIES (AND (CONSP X)
              (CAR Y)
              C
              (EQUAL (N (VADD1 (CDR X)
                               (CDR Y)
                               (BMAJ (CAR X) (CAR Y) C)))
                     (+ (N (CDR X)) (N (CDR Y)) 1))
              (CONSP Y)
              (EQUAL (FIX (LEN (CDR X)))
                     (FIX (LEN (CDR Y))))
              (NOT (CAR X)))
         (EQUAL (FIX (+ (* 2 (N (CDR X))) (* 2 (N (CDR Y)))))
                (FIX (+ (* 2 (N (CDR Y)))
                        (* 2 (N (CDR X))))))).

But simplification reduces this to T, using the :definitions BAND,
BMAJ and FIX, the :executable-counterpart of BOR, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-2-OF-+ and COMMUTATIVITY-OF-+ and
the :type-prescription rules LEN and N.

Subgoal *1/1
(IMPLIES (ENDP X)
         (IMPLIES (EQUAL (LEN X) (LEN Y))
                  (EQUAL (N (VADD1 X Y C))
                         (+ (N X) (N Y) (IF C 1 0))))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP X))
              (EQUAL (LEN X) (LEN Y)))
         (EQUAL (N (VADD1 X Y C))
                (+ (N X) (N Y) (IF C 1 0)))).

But simplification reduces this to T, using the :definitions FIX, LEN,
N, NOT and VADD1, the :executable-counterparts of BINARY-*, BINARY-+
and N, primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
PROBLEM-117A and UNICITY-OF-0.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-117B ...)
Rules: ((:DEFINITION BAND)
        (:DEFINITION BMAJ)
        (:DEFINITION BOR)
        (:DEFINITION BXOR)
        (:DEFINITION ENDP)
        (:DEFINITION FIX)
        (:DEFINITION LEN)
        (:DEFINITION N)
        (:DEFINITION NOT)
        (:DEFINITION SYNP)
        (:DEFINITION VADD1)
        (:EXECUTABLE-COUNTERPART BAND)
        (:EXECUTABLE-COUNTERPART BINARY-*)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART BMAJ)
        (:EXECUTABLE-COUNTERPART BOR)
        (:EXECUTABLE-COUNTERPART BXOR)
        (:EXECUTABLE-COUNTERPART N)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION VADD1)
        (:META CANCEL_PLUS-EQUAL-CORRECT)
        (:REWRITE ASSOCIATIVITY-OF-+)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DISTRIBUTIVITY)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE LEFT-CANCELLATION-FOR-+)
        (:REWRITE PROBLEM-117A)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION LEN)
        (:TYPE-PRESCRIPTION N)
        (:TYPE-PRESCRIPTION VADD1))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION BAND)
             (:DEFINITION BOR)
             (:DEFINITION BXOR)
             (:DEFINITION FIX)
             (:DEFINITION LEN)
             (:DEFINITION N)
             (:DEFINITION VADD1))
Warnings:  Double-rewrite
PROBLEM-117B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-117B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-117B)
PROBLEM-117B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-117B ...) ...)
Rules: NIL
Warnings:  Double-rewrite
 PROBLEM-117B
ACL2 !>>(DEFUN VADD (X Y) (VADD1 X Y NIL))

Since VADD is non-recursive, its admission is trivial.  We observe
that the type of VADD is described by the theorem 
(AND (CONSP (VADD X Y)) (TRUE-LISTP (VADD X Y))).  We used the :type-
prescription rule VADD1.

Summary
Form:  ( DEFUN VADD ...)
Rules: ((:TYPE-PRESCRIPTION VADD1))
 VADD
ACL2 !>>(THEOREM PROBLEM-117
                 (IMPLIES (EQUAL (LEN X) (LEN Y))
                          (EQUAL (N (VADD X Y)) (+ (N X) (N Y))))
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-117B))))


ACL2 !>>>(DEFTHM PROBLEM-117
           (IMPLIES (EQUAL (LEN X) (LEN Y))
                    (EQUAL (N (VADD X Y)) (+ (N X) (N Y))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-117B))))

ACL2 Warning [Non-rec] in ( DEFTHM PROBLEM-117 ...):  A :REWRITE rule
generated from PROBLEM-117 will be triggered only by terms containing
the function symbol VADD, which has a non-recursive definition.  Unless
this definition is disabled, this rule is unlikely ever to be used.


[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definition VADD we reduce the conjecture to

Goal'
(IMPLIES (EQUAL (LEN X) (LEN Y))
         (EQUAL (N (VADD1 X Y NIL))
                (+ (N X) (N Y)))).

But simplification reduces this to T, using the :definition FIX, primitive
type reasoning, the :rewrite rules COMMUTATIVITY-OF-+, PROBLEM-117B
and UNICITY-OF-0 and the :type-prescription rule N.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-117 ...)
Rules: ((:DEFINITION FIX)
        (:DEFINITION VADD)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE PROBLEM-117B)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION N))
Warnings:  Non-rec
PROBLEM-117


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-117))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-117)
PROBLEM-117

Summary
Form:  ( PROGN (DEFTHM PROBLEM-117 ...) ...)
Rules: NIL
Warnings:  Non-rec
 PROBLEM-117
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 118.

; This problem supposes we have two mutually recursive equations.
; To get mutually recursive definitions admitted into ACL2, we
; use this form:
"
ACL2 !>>(MUTUAL-RECURSION
          (DEFUN FX (X)
            (IF (CONSP X)
                (CONS (FX (CAR X)) (GX (CDR X)))
              X))
          (DEFUN GX (X)
            (IF (CONSP X)
                (CONS (GX (CAR X)) (FX (CDR X)))
              X)))

The admission of FX and GX are trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X) for FX and (ACL2-COUNT X) for GX.  We could
deduce no constraints on the type of any of the functions in the clique.
However, in normalizing the definitions we used primitive type reasoning.

Summary
Form:  ( MUTUAL-RECURSION ( DEFUN FX ...) ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 (FX GX)
ACL2 !>>(DEFUN TREE-COPY (X)
          (IF (CONSP X)
              (CONS (TREE-COPY (CAR X))
                    (TREE-COPY (CDR X)))
            X))

The admission of TREE-COPY is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We could deduce no constraints on the type
of TREE-COPY.  However, in normalizing the definition we used primitive
type reasoning.

Summary
Form:  ( DEFUN TREE-COPY ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 TREE-COPY
ACL2 !>>(THEOREM PROBLEM-118
                 (AND (EQUAL (FX X) X) (EQUAL (GX X) X))
                 :HINTS (("Goal" :INDUCT (TREE-COPY X))))


ACL2 !>>>(DEFTHM PROBLEM-118
           (AND (EQUAL (FX X) X) (EQUAL (GX X) X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TREE-COPY X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TREE-COPY X).

This suggestion was produced using the :induction rule TREE-COPY. 
If we let (:P X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X)
                   (:P (CAR X))
                   (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit TREE-COPY.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (AND (EQUAL (FX X) X)
              (EQUAL (GX X) X))).

But simplification reduces this to T, using the :definitions FX and
GX and primitive type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (AND (EQUAL (FX (CAR X)) (CAR X))
                   (EQUAL (GX (CAR X)) (CAR X)))
              (AND (EQUAL (FX (CDR X)) (CDR X))
                   (EQUAL (GX (CDR X)) (CDR X))))
         (AND (EQUAL (FX X) X)
              (EQUAL (GX X) X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL (FX (CAR X)) (CAR X))
              (EQUAL (GX (CAR X)) (CAR X))
              (EQUAL (FX (CDR X)) (CDR X))
              (EQUAL (GX (CDR X)) (CDR X)))
         (AND (EQUAL (FX X) X)
              (EQUAL (GX X) X))).

But simplification reduces this to T, using the :definitions FX and
GX, primitive type reasoning and the :rewrite rule CONS-CAR-CDR.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-118 ...)
Rules: ((:DEFINITION FX)
        (:DEFINITION GX)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION TREE-COPY)
        (:REWRITE CONS-CAR-CDR))
PROBLEM-118


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-118))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-118)
PROBLEM-118

Summary
Form:  ( PROGN (DEFTHM PROBLEM-118 ...) ...)
Rules: NIL
 PROBLEM-118
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 119.

; This problem calls for us to develop a methodology for introducing
; mutually recursive functions and to use it to introduce fx and gx
; above.  But to solve the previous problem we introduced the names fx
; and gx and cannot re-introduce them.  So we will demonstrate our
; methodology to introduce a renamed pair of functions:

; (mutual-recursion
;  (defun fz (x)
;    (if (consp x)
;        (cons (fz (car x))
;              (gz (cdr x)))
;      x))
; 
;  (defun gz (x)
;    (if (consp x)
;        (cons (gz (car x))
;              (fz (cdr x)))
;      x))
;  )

; Step 1 of the methodology is to introduce a singly recursive
; function that has a flag argument that determines which of the
; mutually recursive functions it is supposed to compute.
; When fn is 'fz it computes fz; otherwise it computes gz.
"
ACL2 !>>(DEFUN FZGZ (FN X)
          (IF (EQUAL FN 'FZ)
              (IF (CONSP X)
                  (CONS (FZGZ 'FZ (CAR X))
                        (FZGZ 'GZ (CDR X)))
                X)
            (IF (CONSP X)
                (CONS (FZGZ 'GZ (CAR X))
                      (FZGZ 'FZ (CDR X)))
              X)))

The admission of FZGZ is trivial, using the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We could deduce no constraints on the type of FZGZ.
However, in normalizing the definition we used primitive type reasoning.

Summary
Form:  ( DEFUN FZGZ ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 FZGZ
ACL2 !>>:----- 
"
; Step 2 is to define the individual functions using the singly
; recursive function.
"
ACL2 !>>(DEFUN FZ (X) (FZGZ 'FZ X))

Since FZ is non-recursive, its admission is trivial.  We could deduce
no constraints on the type of FZ.

Summary
Form:  ( DEFUN FZ ...)
Rules: NIL
 FZ
ACL2 !>>(DEFUN GZ (X) (FZGZ 'GZ X))

Since GZ is non-recursive, its admission is trivial.  We could deduce
no constraints on the type of GZ.

Summary
Form:  ( DEFUN GZ ...)
Rules: NIL
 GZ
ACL2 !>>:----- 
"
; Step 3 is to prove that fz and gz each satisfy the desired
; equations.
"
ACL2 !>>(THEOREM PROBLEM-119-A
                 (EQUAL (FZ X)
                        (IF (CONSP X)
                            (CONS (FZ (CAR X)) (GZ (CDR X)))
                          X))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions FZ and GZ we reduce the conjecture to

Goal'
(EQUAL (FZGZ 'FZ X)
       (IF (CONSP X)
           (CONS (FZGZ 'FZ (CAR X))
                 (FZGZ 'GZ (CDR X)))
         X)).

But simplification reduces this to T, using the :definition FZGZ, the
:executable-counterpart of EQUAL and primitive type reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-119-A ...)
Rules: ((:DEFINITION FZ)
        (:DEFINITION FZGZ)
        (:DEFINITION GZ)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 PROBLEM-119-A
ACL2 !>>(THEOREM PROBLEM-119-B
                 (EQUAL (GZ X)
                        (IF (CONSP X)
                            (CONS (GZ (CAR X)) (FZ (CDR X)))
                          X))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions FZ and GZ we reduce the conjecture to

Goal'
(EQUAL (FZGZ 'GZ X)
       (IF (CONSP X)
           (CONS (FZGZ 'GZ (CAR X))
                 (FZGZ 'FZ (CDR X)))
         X)).

But simplification reduces this to T, using the :definition FZGZ, the
:executable-counterpart of EQUAL and primitive type reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-119-B ...)
Rules: ((:DEFINITION FZ)
        (:DEFINITION FZGZ)
        (:DEFINITION GZ)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 PROBLEM-119-B
ACL2 !>>:----- 
"
; Note that we could now behave as though those equations had
; been added as definitional axioms rather than theorems and
; we could simply ignore the earlier definitions of fz and gz.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 120.
"
ACL2 !>>(DEFUN EXPR-FN (FN X)
          (IF (EQUAL FN 'EXPR)
              (IF (ATOM X)
                  (SYMBOLP X)
                (AND (SYMBOLP (CAR X))
                     (EXPR-FN 'LIST (CDR X))))
            (IF (ATOM X)
                (EQUAL X NIL)
              (AND (EXPR-FN 'EXPR (CAR X))
                   (EXPR-FN 'LIST (CDR X))))))

The admission of EXPR-FN is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT X).  We observe that the type of EXPR-FN is described by
the theorem (OR (EQUAL (EXPR-FN FN X) T) (EQUAL (EXPR-FN FN X) NIL)).
We used primitive type reasoning.

Summary
Form:  ( DEFUN EXPR-FN ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 EXPR-FN
ACL2 !>>(DEFUN EXPR (X) (EXPR-FN 'EXPR X))

Since EXPR is non-recursive, its admission is trivial.  We observe
that the type of EXPR is described by the theorem 
(OR (EQUAL (EXPR X) T) (EQUAL (EXPR X) NIL)).  We used the :type-prescription
rule EXPR-FN.

Summary
Form:  ( DEFUN EXPR ...)
Rules: ((:TYPE-PRESCRIPTION EXPR-FN))
 EXPR
ACL2 !>>(DEFUN EXPR-LIST (X) (EXPR-FN 'LIST X))

Since EXPR-LIST is non-recursive, its admission is trivial.  We observe
that the type of EXPR-LIST is described by the theorem 
(OR (EQUAL (EXPR-LIST X) T) (EQUAL (EXPR-LIST X) NIL)).  We used the
:type-prescription rule EXPR-FN.

Summary
Form:  ( DEFUN EXPR-LIST ...)
Rules: ((:TYPE-PRESCRIPTION EXPR-FN))
 EXPR-LIST
ACL2 !>>(THEOREM PROBLEM-120-A
                 (EQUAL (EXPR X)
                        (IF (ATOM X)
                            (SYMBOLP X)
                          (AND (SYMBOLP (CAR X))
                               (EXPR-LIST (CDR X)))))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions EXPR and EXPR-LIST we reduce the conjecture
to

Goal'
(EQUAL (EXPR-FN 'EXPR X)
       (COND ((ATOM X) (SYMBOLP X))
             ((SYMBOLP (CAR X))
              (EXPR-FN 'LIST (CDR X)))
             (T NIL))).

But simplification reduces this to T, using the :definitions ATOM and
EXPR-FN, the :executable-counterpart of EQUAL and primitive type reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-120-A ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION EXPR)
        (:DEFINITION EXPR-FN)
        (:DEFINITION EXPR-LIST)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 PROBLEM-120-A
ACL2 !>>(THEOREM PROBLEM-120-B
                 (EQUAL (EXPR-LIST X)
                        (IF (ATOM X)
                            (EQUAL X NIL)
                          (AND (EXPR (CAR X))
                               (EXPR-LIST (CDR X)))))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions EXPR and EXPR-LIST we reduce the conjecture
to

Goal'
(EQUAL (EXPR-FN 'LIST X)
       (COND ((ATOM X) (EQUAL X NIL))
             ((EXPR-FN 'EXPR (CAR X))
              (EXPR-FN 'LIST (CDR X)))
             (T NIL))).

But simplification reduces this to T, using the :definitions ATOM and
EXPR-FN, the :executable-counterpart of EQUAL and primitive type reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-120-B ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION EXPR)
        (:DEFINITION EXPR-FN)
        (:DEFINITION EXPR-LIST)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 PROBLEM-120-B
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 121.
"
ACL2 !>>(DEFUN SUBSTITUTION (S)
          (IF (ENDP S)
              (EQUAL S NIL)
            (AND (TRUE-LISTP (CAR S))
                 (EQUAL (LEN (CAR S)) 2)
                 (SYMBOLP (CAR (CAR S)))
                 (EXPR (CAR (CDR (CAR S))))
                 (SUBSTITUTION (CDR S)))))

The admission of SUBSTITUTION is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT S).  We observe that the type of SUBSTITUTION is
described by the theorem 
(OR (EQUAL (SUBSTITUTION S) T) (EQUAL (SUBSTITUTION S) NIL)).  We used
primitive type reasoning.

Summary
Form:  ( DEFUN SUBSTITUTION ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 SUBSTITUTION
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 122.
"
ACL2 !>>(DEFUN LOOKUP (VAR ALIST)
          (IF (ENDP ALIST)
              VAR
            (IF (EQUAL VAR (CAR (CAR ALIST)))
                (CAR (CDR (CAR ALIST)))
              (LOOKUP VAR (CDR ALIST)))))

The admission of LOOKUP is trivial, using the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(ACL2-COUNT ALIST).  We could deduce no constraints on the type of
LOOKUP.

Summary
Form:  ( DEFUN LOOKUP ...)
Rules: NIL
 LOOKUP
ACL2 !>>(DEFUN SLASH-FN (FN X S)
          (IF (EQUAL FN 'EXPR)
              (IF (ATOM X)
                  (LOOKUP X S)
                (CONS (CAR X)
                      (SLASH-FN 'LIST (CDR X) S)))
            (IF (ATOM X)
                NIL
              (CONS (SLASH-FN 'EXPR (CAR X) S)
                    (SLASH-FN 'LIST (CDR X) S)))))

The admission of SLASH-FN is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We could deduce no constraints on the type
of SLASH-FN.

Summary
Form:  ( DEFUN SLASH-FN ...)
Rules: NIL
 SLASH-FN
ACL2 !>>(DEFUN SLASH (X S) (SLASH-FN 'EXPR X S))

Since SLASH is non-recursive, its admission is trivial.  We could deduce
no constraints on the type of SLASH.

Summary
Form:  ( DEFUN SLASH ...)
Rules: NIL
 SLASH
ACL2 !>>(DEFUN SLASH-LIST (LST S)
          (SLASH-FN 'LIST LST S))

Since SLASH-LIST is non-recursive, its admission is trivial.  We could
deduce no constraints on the type of SLASH-LIST.

Summary
Form:  ( DEFUN SLASH-LIST ...)
Rules: NIL
 SLASH-LIST
ACL2 !>>(THEOREM PROBLEM-122-A
                 (EQUAL (SLASH X S)
                        (IF (ATOM X)
                            (LOOKUP X S)
                          (CONS (CAR X) (SLASH-LIST (CDR X) S))))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions SLASH and SLASH-LIST we reduce the conjecture
to

Goal'
(EQUAL (SLASH-FN 'EXPR X S)
       (IF (ATOM X)
           (LOOKUP X S)
         (CONS (CAR X)
               (SLASH-FN 'LIST (CDR X) S)))).

But simplification reduces this to T, using the :definitions ATOM and
SLASH-FN, the :executable-counterpart of EQUAL and primitive type reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-122-A ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION SLASH)
        (:DEFINITION SLASH-FN)
        (:DEFINITION SLASH-LIST)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 PROBLEM-122-A
ACL2 !>>(THEOREM PROBLEM-122-B
                 (EQUAL (SLASH-LIST LST S)
                        (IF (ATOM LST)
                            NIL
                          (CONS (SLASH (CAR LST) S)
                                (SLASH-LIST (CDR LST) S))))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions SLASH and SLASH-LIST we reduce the conjecture
to

Goal'
(EQUAL (SLASH-FN 'LIST LST S)
       (AND (NOT (ATOM LST))
            (CONS (SLASH-FN 'EXPR (CAR LST) S)
                  (SLASH-FN 'LIST (CDR LST) S)))).

But simplification reduces this to T, using the :definitions ATOM and
SLASH-FN, the :executable-counterpart of EQUAL and primitive type reasoning.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-122-B ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION SLASH)
        (:DEFINITION SLASH-FN)
        (:DEFINITION SLASH-LIST)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 PROBLEM-122-B
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 123.
"
ACL2 !>>(THEOREM PROBLEM-123A
                 (IMPLIES (AND (SYMBOLP X) (SUBSTITUTION S))
                          (EXPR-FN 'EXPR (LOOKUP X S)))
                 :HINTS (("Goal" :INDUCT (LOOKUP X S))))


ACL2 !>>>(DEFTHM PROBLEM-123A
           (IMPLIES (AND (SYMBOLP X) (SUBSTITUTION S))
                    (EXPR-FN 'EXPR (LOOKUP X S)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LOOKUP X S))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LOOKUP X S).

This suggestion was produced using the :induction rule LOOKUP.  If
we let (:P S X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP S))
                   (NOT (EQUAL X (CAR (CAR S))))
                   (:P (CDR S) X))
              (:P S X))
     (IMPLIES (AND (NOT (ENDP S))
                   (EQUAL X (CAR (CAR S))))
              (:P S X))
     (IMPLIES (ENDP S) (:P S X))).
This induction is justified by the same argument used to admit LOOKUP.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP S))
              (NOT (EQUAL X (CAR (CAR S))))
              (IMPLIES (AND (SYMBOLP X) (SUBSTITUTION (CDR S)))
                       (EXPR-FN 'EXPR (LOOKUP X (CDR S)))))
         (IMPLIES (AND (SYMBOLP X) (SUBSTITUTION S))
                  (EXPR-FN 'EXPR (LOOKUP X S)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP S)
              (NOT (EQUAL X (CAR (CAR S))))
              (IMPLIES (AND (SYMBOLP X) (SUBSTITUTION (CDR S)))
                       (EXPR-FN 'EXPR (LOOKUP X (CDR S))))
              (SYMBOLP X)
              (SUBSTITUTION S))
         (EXPR-FN 'EXPR (LOOKUP X S))).

But simplification reduces this to T, using the :definitions EXPR,
LOOKUP and SUBSTITUTION, primitive type reasoning and the :type-prescription
rule EXPR-FN.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP S))
              (EQUAL X (CAR (CAR S))))
         (IMPLIES (AND (SYMBOLP X) (SUBSTITUTION S))
                  (EXPR-FN 'EXPR (LOOKUP X S)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP S)
              (EQUAL X (CAR (CAR S)))
              (SYMBOLP X)
              (SUBSTITUTION S))
         (EXPR-FN 'EXPR (LOOKUP X S))).

This simplifies, using the :definition LOOKUP and primitive type reasoning,
to

Subgoal *1/2''
(IMPLIES (AND (CONSP S)
              (SYMBOLP (CAR (CAR S)))
              (SUBSTITUTION S))
         (EXPR-FN 'EXPR (CADR (CAR S)))).

But simplification reduces this to T, using the :definitions EXPR,
LEN, SUBSTITUTION and TRUE-LISTP and primitive type reasoning.

Subgoal *1/1
(IMPLIES (ENDP S)
         (IMPLIES (AND (SYMBOLP X) (SUBSTITUTION S))
                  (EXPR-FN 'EXPR (LOOKUP X S)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP S))
              (SYMBOLP X)
              (SUBSTITUTION S))
         (EXPR-FN 'EXPR (LOOKUP X S))).

But simplification reduces this to T, using the :definitions EXPR-FN,
LOOKUP and SUBSTITUTION, the :executable-counterparts of CONSP and
EQUAL and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-123A depends upon the :type-prescription rule
EXPR-FN.

Summary
Form:  ( DEFTHM PROBLEM-123A ...)
Rules: ((:DEFINITION ENDP)
        (:DEFINITION EXPR)
        (:DEFINITION EXPR-FN)
        (:DEFINITION LEN)
        (:DEFINITION LOOKUP)
        (:DEFINITION NOT)
        (:DEFINITION SUBSTITUTION)
        (:DEFINITION TRUE-LISTP)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LOOKUP)
        (:TYPE-PRESCRIPTION EXPR-FN))
PROBLEM-123A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-123A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-123A)
PROBLEM-123A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-123A ...) ...)
Rules: NIL
 PROBLEM-123A
ACL2 !>>(THEOREM PROBLEM-123B
                 (IMPLIES (AND (EXPR-FN FN X) (SUBSTITUTION S))
                          (EXPR-FN FN (SLASH-FN FN X S)))
                 :HINTS (("Goal" :INDUCT (SLASH-FN FN X S)
                                 :IN-THEORY (ENABLE PROBLEM-123A))))


ACL2 !>>>(DEFTHM PROBLEM-123B
           (IMPLIES (AND (EXPR-FN FN X) (SUBSTITUTION S))
                    (EXPR-FN FN (SLASH-FN FN X S)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (SLASH-FN FN X S)
                           :IN-THEORY (ENABLE PROBLEM-123A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (SLASH-FN FN X S).

This suggestion was produced using the :induction rule SLASH-FN.  If
we let (:P FN S X) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (EQUAL FN 'EXPR))
                   (NOT (ATOM X))
                   (:P 'EXPR S (CAR X))
                   (:P 'LIST S (CDR X)))
              (:P FN S X))
     (IMPLIES (AND (NOT (EQUAL FN 'EXPR)) (ATOM X))
              (:P FN S X))
     (IMPLIES (AND (EQUAL FN 'EXPR)
                   (NOT (ATOM X))
                   (:P 'LIST S (CDR X)))
              (:P FN S X))
     (IMPLIES (AND (EQUAL FN 'EXPR) (ATOM X))
              (:P FN S X))).
This induction is justified by the same argument used to admit SLASH-FN.
Note, however, that the unmeasured variable FN is being instantiated.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1/4
(IMPLIES (AND (NOT (EQUAL FN 'EXPR))
              (NOT (ATOM X))
              (IMPLIES (AND (EXPR-FN 'EXPR (CAR X))
                            (SUBSTITUTION S))
                       (EXPR-FN 'EXPR
                                (SLASH-FN 'EXPR (CAR X) S)))
              (IMPLIES (AND (EXPR-FN 'LIST (CDR X))
                            (SUBSTITUTION S))
                       (EXPR-FN 'LIST
                                (SLASH-FN 'LIST (CDR X) S))))
         (IMPLIES (AND (EXPR-FN FN X) (SUBSTITUTION S))
                  (EXPR-FN FN (SLASH-FN FN X S)))).

By the simple :definition ATOM we reduce the conjecture to

Subgoal *1/4'
(IMPLIES (AND (NOT (EQUAL FN 'EXPR))
              (CONSP X)
              (IMPLIES (AND (EXPR-FN 'EXPR (CAR X))
                            (SUBSTITUTION S))
                       (EXPR-FN 'EXPR
                                (SLASH-FN 'EXPR (CAR X) S)))
              (IMPLIES (AND (EXPR-FN 'LIST (CDR X))
                            (SUBSTITUTION S))
                       (EXPR-FN 'LIST
                                (SLASH-FN 'LIST (CDR X) S)))
              (EXPR-FN FN X)
              (SUBSTITUTION S))
         (EXPR-FN FN (SLASH-FN FN X S))).

But simplification reduces this to T, using the :definitions EXPR-FN
and SLASH-FN, primitive type reasoning, the :rewrite rules CAR-CONS
and CDR-CONS and the :type-prescription rules EXPR-FN and SUBSTITUTION.

Subgoal *1/3
(IMPLIES (AND (NOT (EQUAL FN 'EXPR)) (ATOM X))
         (IMPLIES (AND (EXPR-FN FN X) (SUBSTITUTION S))
                  (EXPR-FN FN (SLASH-FN FN X S)))).

By the simple :definition ATOM we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (EQUAL FN 'EXPR))
              (NOT (CONSP X))
              (EXPR-FN FN X)
              (SUBSTITUTION S))
         (EXPR-FN FN (SLASH-FN FN X S))).

But simplification reduces this to T, using the :definitions EXPR-FN
and SLASH-FN, the :executable-counterparts of CONSP and EQUAL and primitive
type reasoning.

Subgoal *1/2
(IMPLIES (AND (EQUAL FN 'EXPR)
              (NOT (ATOM X))
              (IMPLIES (AND (EXPR-FN 'LIST (CDR X))
                            (SUBSTITUTION S))
                       (EXPR-FN 'LIST
                                (SLASH-FN 'LIST (CDR X) S))))
         (IMPLIES (AND (EXPR-FN FN X) (SUBSTITUTION S))
                  (EXPR-FN FN (SLASH-FN FN X S)))).

By the simple :definition ATOM we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (EQUAL FN 'EXPR)
              (CONSP X)
              (IMPLIES (AND (EXPR-FN 'LIST (CDR X))
                            (SUBSTITUTION S))
                       (EXPR-FN 'LIST
                                (SLASH-FN 'LIST (CDR X) S)))
              (EXPR-FN FN X)
              (SUBSTITUTION S))
         (EXPR-FN FN (SLASH-FN FN X S))).

But simplification reduces this to T, using the :definitions EXPR-FN
and SLASH-FN, the :executable-counterpart of EQUAL, primitive type
reasoning, the :rewrite rules CAR-CONS and CDR-CONS and the :type-
prescription rules EXPR-FN and SUBSTITUTION.

Subgoal *1/1
(IMPLIES (AND (EQUAL FN 'EXPR) (ATOM X))
         (IMPLIES (AND (EXPR-FN FN X) (SUBSTITUTION S))
                  (EXPR-FN FN (SLASH-FN FN X S)))).

By the simple :definition ATOM we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (EQUAL FN 'EXPR)
              (NOT (CONSP X))
              (EXPR-FN FN X)
              (SUBSTITUTION S))
         (EXPR-FN FN (SLASH-FN FN X S))).

But simplification reduces this to T, using the :definitions EXPR-FN
and SLASH-FN, the :executable-counterpart of EQUAL, the :rewrite rule
PROBLEM-123A and the :type-prescription rule SUBSTITUTION.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-123B depends upon the :type-prescription rule
EXPR-FN.

Summary
Form:  ( DEFTHM PROBLEM-123B ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION EXPR-FN)
        (:DEFINITION NOT)
        (:DEFINITION SLASH-FN)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION SLASH-FN)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-123A)
        (:TYPE-PRESCRIPTION EXPR-FN)
        (:TYPE-PRESCRIPTION SUBSTITUTION))
PROBLEM-123B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-123B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-123B)
PROBLEM-123B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-123B ...) ...)
Rules: NIL
 PROBLEM-123B
ACL2 !>>(THEOREM PROBLEM-123
                 (IMPLIES (AND (EXPR X) (SUBSTITUTION S))
                          (EXPR (SLASH X S)))
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-123B))))


ACL2 !>>>(DEFTHM PROBLEM-123
           (IMPLIES (AND (EXPR X) (SUBSTITUTION S))
                    (EXPR (SLASH X S)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-123B))))

ACL2 Warning [Non-rec] in ( DEFTHM PROBLEM-123 ...):  A :REWRITE rule
generated from PROBLEM-123 will be triggered only by terms containing
the function symbols EXPR and SLASH, which have non-recursive definitions.
Unless these definitions are disabled, this rule is unlikely ever to
be used.


ACL2 Warning [Subsume] in ( DEFTHM PROBLEM-123 ...):  The previously
added rule EXPR subsumes a newly proposed :REWRITE rule generated from
PROBLEM-123, in the sense that the old rule rewrites a more general
target.  Because the new rule will be tried first, it may nonetheless
find application.


[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions EXPR and SLASH we reduce the conjecture
to

Goal'
(IMPLIES (AND (EXPR-FN 'EXPR X) (SUBSTITUTION S))
         (EXPR-FN 'EXPR (SLASH-FN 'EXPR X S))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-123B
and the :type-prescription rules EXPR-FN and SUBSTITUTION.

Q.E.D.

The storage of PROBLEM-123 depends upon the :type-prescription rule
EXPR.

Summary
Form:  ( DEFTHM PROBLEM-123 ...)
Rules: ((:DEFINITION EXPR)
        (:DEFINITION SLASH)
        (:REWRITE PROBLEM-123B)
        (:TYPE-PRESCRIPTION EXPR)
        (:TYPE-PRESCRIPTION EXPR-FN)
        (:TYPE-PRESCRIPTION SUBSTITUTION))
Warnings:  Subsume and Non-rec
PROBLEM-123


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-123))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-123)
PROBLEM-123

Summary
Form:  ( PROGN (DEFTHM PROBLEM-123 ...) ...)
Rules: NIL
Warnings:  Subsume and Non-rec
 PROBLEM-123
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 124.

; The definition of f5 cannot be admitted because of the recursive
; call (f5 (f5 (- x 1))).  We can prove that a measure of the argument
; decreases in the inner recursive call.  (The measure would be cc.)
; But we cannot prove that ANY measure decreases in the outer
; recursive call, because the actual is (f5 (- x 1)) and we do not
; have ANY axiom about f5 yet.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 125.

; The nested recursion in mcflatten is admissible because it occurs in
; an argument position that is not being measured.  We admit mcflatten
; by measuring the first argument, x.  We do not care what term is in
; the second position, a.

; The nested recursion in ack is more problematic but still
; acceptable.  Recall why ack terminates: either the second argument,
; y, decreases or else the second argument stays fixed and the first,
; x, decreases.  Note that when y decreases, we don't care what x
; does.  So if x is occupied by a nested recursive call, it is ok.
"
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 126.
"
ACL2 !>>(DEFUN F5 (X)
          (DECLARE (XARGS :MEASURE (NFIX X)))
          (IF (ZP X)
              0
            (IF (< (NFIX (F5 (- X 1))) (NFIX X))
                (+ 1 (F5 (F5 (- X 1))))
              'UNDEF)))

For the admission of F5 we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(NFIX X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (NFIX X))
     (IMPLIES (NOT (ZP X))
              (O< (NFIX (+ -1 X)) (NFIX X)))
     (IMPLIES (AND (NOT (ZP X))
                   (< (NFIX (F5 (+ -1 X))) (NFIX X)))
              (O< (NFIX (F5 (+ -1 X))) (NFIX X)))).

By case analysis we reduce the conjecture to the following three conjectures.

Subgoal 3
(O-P (NFIX X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :definition NFIX
and the :rewrite rule O-P-DEF-O-FINP-1.

Subgoal 2
(IMPLIES (NOT (ZP X))
         (O< (NFIX (+ -1 X)) (NFIX X))).

But simplification reduces this to T, using the :compound-recognizer
rules O-FINP-CR and ZP-COMPOUND-RECOGNIZER, the :definition NFIX, linear
arithmetic, primitive type reasoning and the :rewrite rules <-+-NEGATIVE-0-1
and O-FINP-<.

Subgoal 1
(IMPLIES (AND (NOT (ZP X))
              (< (NFIX (F5 (+ -1 X))) (NFIX X)))
         (O< (NFIX (F5 (+ -1 X))) (NFIX X))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER, O-FINP-CR and ZP-COMPOUND-RECOGNIZER,
the :definition NFIX, the :executable-counterpart of NOT, primitive
type reasoning and the :rewrite rules |0 < a  =  ~(a = 0)|, O-FINP-<
and O-P-DEF-O-FINP-1.

Q.E.D.

That completes the proof of the measure theorem for F5.  Thus, we admit
this function under the principle of definition.  We observe that the
type of F5 is described by the theorem 
(OR (AND (INTEGERP (F5 X)) (<= 0 (F5 X)))
    (AND (SYMBOLP (F5 X))
         (NOT (EQUAL (F5 X) T))
         (NOT (EQUAL (F5 X) NIL)))).
We used primitive type reasoning.

Summary
Form:  ( DEFUN F5 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION NFIX)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE |0 < a  =  ~(a = 0)|)
        (:REWRITE <-+-NEGATIVE-0-1)
        (:REWRITE O-FINP-<)
        (:REWRITE O-P-DEF-O-FINP-1))
 F5
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 127.
"
ACL2 !>>(THEOREM PROBLEM-127
                 (IMPLIES (NATP X) (<= (F5 X) X))
                 :HINTS (("Goal" :INDUCT (F5 X)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-127
           (IMPLIES (NATP X) (<= (F5 X) X))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (F5 X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (F5 X).

This suggestion was produced using the :induction rule F5.  If we let
(:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ZP X))
                   (<= (NFIX X) (NFIX (F5 (+ -1 X))))
                   (:P (+ -1 X)))
              (:P X))
     (IMPLIES (AND (NOT (ZP X))
                   (< (NFIX (F5 (+ -1 X))) (NFIX X))
                   (:P (F5 (+ -1 X)))
                   (:P (+ -1 X)))
              (:P X))
     (IMPLIES (ZP X) (:P X))).
This induction is justified by the same argument used to admit F5.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ZP X))
              (<= (NFIX X) (NFIX (F5 (+ -1 X))))
              (IMPLIES (NATP (+ -1 X))
                       (<= (F5 (+ -1 X)) (+ -1 X))))
         (IMPLIES (NATP X) (<= (F5 X) X))).

By the simple :rewrite rule NATP-POSP--1 we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (ZP X))
              (<= (NFIX X) (NFIX (F5 (+ -1 X))))
              (IMPLIES (POSP X)
                       (<= (F5 (+ -1 X)) (+ -1 X)))
              (NATP X))
         (<= (F5 X) X)).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, POSP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER,
the :definitions F5, NFIX and NOT, primitive type reasoning, the :rewrite
rule DEFAULT-<-2 and the :type-prescription rule F5, to

Subgoal *1/3''
(IMPLIES (AND (NOT (ZP X))
              (INTEGERP (F5 (+ -1 X)))
              (<= X (F5 (+ -1 X)))
              (<= (F5 (+ -1 X)) (+ -1 X)))
         (<= 0 X)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2
(IMPLIES (AND (NOT (ZP X))
              (< (NFIX (F5 (+ -1 X))) (NFIX X))
              (IMPLIES (NATP (F5 (+ -1 X)))
                       (<= (F5 (F5 (+ -1 X))) (F5 (+ -1 X))))
              (IMPLIES (NATP (+ -1 X))
                       (<= (F5 (+ -1 X)) (+ -1 X))))
         (IMPLIES (NATP X) (<= (F5 X) X))).

By the simple :rewrite rule NATP-POSP--1 we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (ZP X))
              (< (NFIX (F5 (+ -1 X))) (NFIX X))
              (IMPLIES (NATP (F5 (+ -1 X)))
                       (<= (F5 (F5 (+ -1 X))) (F5 (+ -1 X))))
              (IMPLIES (POSP X)
                       (<= (F5 (+ -1 X)) (+ -1 X)))
              (NATP X))
         (<= (F5 X) X)).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, POSP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER,
the :definitions F5, NFIX (if-intro) and NOT (if-intro), primitive
type reasoning, the :rewrite rules <-+-NEGATIVE-0-1 and DEFAULT-<-2
and the :type-prescription rule F5, to the following two conjectures.

Subgoal *1/2.2
(IMPLIES (AND (NOT (ZP X))
              (INTEGERP (F5 (+ -1 X)))
              (< (F5 (+ -1 X)) X)
              (<= (F5 (F5 (+ -1 X))) (F5 (+ -1 X)))
              (<= (F5 (+ -1 X)) (+ -1 X)))
         (<= (+ 1 (F5 (F5 (+ -1 X)))) X)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.1
(IMPLIES (AND (NOT (ZP X))
              (NOT (INTEGERP (F5 (+ -1 X))))
              (< 0 X))
         (<= (+ 1 (F5 (F5 (+ -1 X)))) X)).

This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :definition F5, the :executable-counterpart of BINARY-+ and the
:type-prescription rule F5, to

Subgoal *1/2.1'
(IMPLIES (AND (NOT (ZP X))
              (NOT (INTEGERP (F5 (+ -1 X))))
              (< 0 X))
         (<= 1 X)).

But simplification reduces this to T, using the :compound-recognizer
rule ZP-COMPOUND-RECOGNIZER and primitive type reasoning.

Subgoal *1/1
(IMPLIES (ZP X)
         (IMPLIES (NATP X) (<= (F5 X) X))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (ZP X) (NATP X))
         (<= (F5 X) X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :executable-
counterparts of <, F5, NATP, NOT and ZP, linear arithmetic and the
:forward-chaining rule NATP-FC-1.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-127 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION F5)
        (:DEFINITION NFIX)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART F5)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING NATP-FC-1)
        (:INDUCTION F5)
        (:REWRITE <-+-NEGATIVE-0-1)
        (:REWRITE DEFAULT-<-2)
        (:REWRITE NATP-POSP--1)
        (:TYPE-PRESCRIPTION F5))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION NFIX) (:DEFINITION NOT))
PROBLEM-127


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-127))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-127)
PROBLEM-127

Summary
Form:  ( PROGN (DEFTHM PROBLEM-127 ...) ...)
Rules: NIL
 PROBLEM-127
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 128.
"
ACL2 !>>(THEOREM PROBLEM-128
                 (EQUAL (F5 X)
                        (IF (ZP X) 0 (+ 1 (F5 (F5 (- X 1))))))
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-127)))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

This simplifies, using the :compound-recognizer rule ZP-COMPOUND-RECOGNIZER,
the :definitions F5 (if-intro) and NFIX (if-intro), primitive type
reasoning and the :type-prescription rule F5, to the following two
conjectures.

Subgoal 2
(IMPLIES (AND (NOT (ZP X))
              (INTEGERP (F5 (+ -1 X)))
              (<= X (F5 (+ -1 X))))
         (EQUAL 'UNDEF
                (+ 1 (F5 (F5 (+ -1 X)))))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, linear arithmetic,
primitive type reasoning, the :linear rule PROBLEM-127 and the :type-
prescription rule F5.

Subgoal 1
(IMPLIES (AND (NOT (ZP X))
              (NOT (INTEGERP (F5 (+ -1 X))))
              (<= X 0))
         (EQUAL 'UNDEF
                (+ 1 (F5 (F5 (+ -1 X)))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-128 ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION F5)
        (:DEFINITION NFIX)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR PROBLEM-127)
        (:TYPE-PRESCRIPTION F5))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION F5) (:DEFINITION NFIX))
 PROBLEM-128
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 129.
"
ACL2 !>>(DEFUN FLATTEN-M (X)
          (IF (CONSP X)
              (IF (CONSP (CAR X))
                  (CONS (CAR (CAR X))
                        (CONS (CDR (CAR X))
                              (FLATTEN-M (CDR X))))
                (CONS (CAR X) (FLATTEN-M (CDR X))))
            NIL))

The admission of FLATTEN-M is trivial, using the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (ACL2-COUNT X).  We observe that the type of FLATTEN-M is described
by the theorem (TRUE-LISTP (FLATTEN-M X)).  We used primitive type
reasoning.

Summary
Form:  ( DEFUN FLATTEN-M ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 FLATTEN-M
ACL2 !>>(THEOREM
             PROBLEM-129A
             (IMPLIES (AND (NATP PTR)
                           (< PTR (LEN G))
                           (CONSP (NTH PTR G)))
                      (MEM (CAR (NTH PTR G)) (FLATTEN-M G)))
             :HINTS (("Goal" :INDUCT (NTH PTR G)
                             :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                                PROBLEM-112I PROBLEM-114E))))


ACL2 !>>>(DEFTHM PROBLEM-129A
           (IMPLIES (AND (NATP PTR)
                         (< PTR (LEN G))
                         (CONSP (NTH PTR G)))
                    (MEM (CAR (NTH PTR G)) (FLATTEN-M G)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (NTH PTR G)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                              PROBLEM-112I PROBLEM-114E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (NTH PTR G).

This suggestion was produced using the :induction rule NTH.  If we
let (:P G PTR) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP G))
                   (NOT (ZP PTR))
                   (:P (CDR G) (+ -1 PTR)))
              (:P G PTR))
     (IMPLIES (AND (NOT (ENDP G)) (ZP PTR))
              (:P G PTR))
     (IMPLIES (ENDP G) (:P G PTR))).
This induction is justified by the same argument used to admit NTH.
Note, however, that the unmeasured variable G is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP G))
              (NOT (ZP PTR))
              (IMPLIES (AND (NATP (+ -1 PTR))
                            (< (+ -1 PTR) (LEN (CDR G)))
                            (CONSP (NTH (+ -1 PTR) (CDR G))))
                       (MEM (CAR (NTH (+ -1 PTR) (CDR G)))
                            (FLATTEN-M (CDR G)))))
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (CONSP (NTH PTR G)))
                  (MEM (CAR (NTH PTR G)) (FLATTEN-M G)))).

By the simple :definition ENDP and the simple :rewrite rule NATP-POSP--1
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (IMPLIES (AND (POSP PTR)
                            (< (+ -1 PTR) (LEN (CDR G)))
                            (CONSP (NTH (+ -1 PTR) (CDR G))))
                       (MEM (CAR (NTH (+ -1 PTR) (CDR G)))
                            (FLATTEN-M (CDR G))))
              (NATP PTR)
              (< PTR (LEN G))
              (CONSP (NTH PTR G)))
         (MEM (CAR (NTH PTR G)) (FLATTEN-M G))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, POSP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER
and the :definitions FLATTEN-M (if-intro), LEN and NTH, to the following
four conjectures.

Subgoal *1/3.4
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (<= (LEN (CDR G)) (+ -1 PTR))
              (< PTR (+ 1 (LEN (CDR G))))
              (CONSP (NTH (+ -1 PTR) (CDR G)))
              (CONSP (CAR G)))
         (MEM (CAR (NTH (+ -1 PTR) (CDR G)))
              (LIST* (CAR (CAR G))
                     (CDR (CAR G))
                     (FLATTEN-M (CDR G))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.3
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (<= (LEN (CDR G)) (+ -1 PTR))
              (< PTR (+ 1 (LEN (CDR G))))
              (CONSP (NTH (+ -1 PTR) (CDR G)))
              (NOT (CONSP (CAR G))))
         (MEM (CAR (NTH (+ -1 PTR) (CDR G)))
              (CONS (CAR G) (FLATTEN-M (CDR G))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.2
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (MEM (CAR (NTH (+ -1 PTR) (CDR G)))
                   (FLATTEN-M (CDR G)))
              (< PTR (+ 1 (LEN (CDR G))))
              (CONSP (NTH (+ -1 PTR) (CDR G)))
              (CONSP (CAR G)))
         (MEM (CAR (NTH (+ -1 PTR) (CDR G)))
              (LIST* (CAR (CAR G))
                     (CDR (CAR G))
                     (FLATTEN-M (CDR G))))).

But simplification reduces this to T, using the :rewrite rules PROBLEM-114E,
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

Subgoal *1/3.1
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (MEM (CAR (NTH (+ -1 PTR) (CDR G)))
                   (FLATTEN-M (CDR G)))
              (< PTR (+ 1 (LEN (CDR G))))
              (CONSP (NTH (+ -1 PTR) (CDR G)))
              (NOT (CONSP (CAR G))))
         (MEM (CAR (NTH (+ -1 PTR) (CDR G)))
              (CONS (CAR G) (FLATTEN-M (CDR G))))).

But simplification reduces this to T, using the :rewrite rules PROBLEM-114E,
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP G)) (ZP PTR))
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (CONSP (NTH PTR G)))
                  (MEM (CAR (NTH PTR G)) (FLATTEN-M G)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP G)
              (ZP PTR)
              (NATP PTR)
              (< PTR (LEN G))
              (CONSP (NTH PTR G)))
         (MEM (CAR (NTH PTR G)) (FLATTEN-M G))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :executable-
counterparts of NATP, NOT and ZP, linear arithmetic and the :forward-
chaining rule NATP-FC-1, to

Subgoal *1/2''
(IMPLIES (AND (CONSP G)
              (< 0 (LEN G))
              (CONSP (NTH 0 G)))
         (MEM (CAR (NTH 0 G)) (FLATTEN-M G))).

By the simple :rewrite rule PROBLEM-112I we reduce the conjecture to

Subgoal *1/2'''
(IMPLIES (AND (CONSP G) (CONSP (NTH 0 G)))
         (MEM (CAR (NTH 0 G)) (FLATTEN-M G))).

This simplifies, using the :definition NTH and the :executable-counterpart
of ZP, to

Subgoal *1/2'4'
(IMPLIES (AND (CONSP G) (CONSP (CAR G)))
         (MEM (CAR (CAR G)) (FLATTEN-M G))).

The destructor terms (CAR G) and (CDR G) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace G by (CONS G1 G2), (CAR G)
by G1 and (CDR G) by G2.  (2) Use CAR-CDR-ELIM, again, to replace G1
by (CONS G3 G4), (CAR G1) by G3 and (CDR G1) by G4.  These steps produce
the following goal.

Subgoal *1/2'5'
(IMPLIES (AND (CONSP (CONS G3 G4))
              (CONSP (CONS (CONS G3 G4) G2)))
         (MEM G3 (FLATTEN-M (CONS (CONS G3 G4) G2)))).

But simplification reduces this to T, using the :definitions FLATTEN-M
and MEM, primitive type reasoning, the :rewrite rules CAR-CONS and
CDR-CONS and the :type-prescription rule FLATTEN-M.

Subgoal *1/1
(IMPLIES (ENDP G)
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (CONSP (NTH PTR G)))
                  (MEM (CAR (NTH PTR G)) (FLATTEN-M G)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP G))
              (NATP PTR)
              (< PTR (LEN G))
              (CONSP (NTH PTR G)))
         (MEM (CAR (NTH PTR G)) (FLATTEN-M G))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definition LEN and primitive type
reasoning.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-129A depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-129A ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION ENDP)
        (:DEFINITION FLATTEN-M)
        (:DEFINITION LEN)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION NTH)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING NATP-FC-1)
        (:INDUCTION NTH)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE NATP-POSP--1)
        (:REWRITE PROBLEM-112I)
        (:REWRITE PROBLEM-114E)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION FLATTEN-M)
        (:TYPE-PRESCRIPTION MEM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FLATTEN-M))
PROBLEM-129A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-129A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-129A)
PROBLEM-129A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-129A ...) ...)
Rules: NIL
 PROBLEM-129A
ACL2 !>>(THEOREM
             PROBLEM-129B
             (IMPLIES (AND (NATP PTR)
                           (< PTR (LEN G))
                           (CONSP (NTH PTR G)))
                      (MEM (CDR (NTH PTR G)) (FLATTEN-M G)))
             :HINTS (("Goal" :INDUCT (NTH PTR G)
                             :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                                PROBLEM-112I PROBLEM-114E))))


ACL2 !>>>(DEFTHM PROBLEM-129B
           (IMPLIES (AND (NATP PTR)
                         (< PTR (LEN G))
                         (CONSP (NTH PTR G)))
                    (MEM (CDR (NTH PTR G)) (FLATTEN-M G)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (NTH PTR G)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                              PROBLEM-112I PROBLEM-114E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (NTH PTR G).

This suggestion was produced using the :induction rule NTH.  If we
let (:P G PTR) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP G))
                   (NOT (ZP PTR))
                   (:P (CDR G) (+ -1 PTR)))
              (:P G PTR))
     (IMPLIES (AND (NOT (ENDP G)) (ZP PTR))
              (:P G PTR))
     (IMPLIES (ENDP G) (:P G PTR))).
This induction is justified by the same argument used to admit NTH.
Note, however, that the unmeasured variable G is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP G))
              (NOT (ZP PTR))
              (IMPLIES (AND (NATP (+ -1 PTR))
                            (< (+ -1 PTR) (LEN (CDR G)))
                            (CONSP (NTH (+ -1 PTR) (CDR G))))
                       (MEM (CDR (NTH (+ -1 PTR) (CDR G)))
                            (FLATTEN-M (CDR G)))))
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (CONSP (NTH PTR G)))
                  (MEM (CDR (NTH PTR G)) (FLATTEN-M G)))).

By the simple :definition ENDP and the simple :rewrite rule NATP-POSP--1
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (IMPLIES (AND (POSP PTR)
                            (< (+ -1 PTR) (LEN (CDR G)))
                            (CONSP (NTH (+ -1 PTR) (CDR G))))
                       (MEM (CDR (NTH (+ -1 PTR) (CDR G)))
                            (FLATTEN-M (CDR G))))
              (NATP PTR)
              (< PTR (LEN G))
              (CONSP (NTH PTR G)))
         (MEM (CDR (NTH PTR G)) (FLATTEN-M G))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, POSP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER
and the :definitions FLATTEN-M (if-intro), LEN and NTH, to the following
four conjectures.

Subgoal *1/3.4
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (<= (LEN (CDR G)) (+ -1 PTR))
              (< PTR (+ 1 (LEN (CDR G))))
              (CONSP (NTH (+ -1 PTR) (CDR G)))
              (CONSP (CAR G)))
         (MEM (CDR (NTH (+ -1 PTR) (CDR G)))
              (LIST* (CAR (CAR G))
                     (CDR (CAR G))
                     (FLATTEN-M (CDR G))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.3
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (<= (LEN (CDR G)) (+ -1 PTR))
              (< PTR (+ 1 (LEN (CDR G))))
              (CONSP (NTH (+ -1 PTR) (CDR G)))
              (NOT (CONSP (CAR G))))
         (MEM (CDR (NTH (+ -1 PTR) (CDR G)))
              (CONS (CAR G) (FLATTEN-M (CDR G))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.2
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (MEM (CDR (NTH (+ -1 PTR) (CDR G)))
                   (FLATTEN-M (CDR G)))
              (< PTR (+ 1 (LEN (CDR G))))
              (CONSP (NTH (+ -1 PTR) (CDR G)))
              (CONSP (CAR G)))
         (MEM (CDR (NTH (+ -1 PTR) (CDR G)))
              (LIST* (CAR (CAR G))
                     (CDR (CAR G))
                     (FLATTEN-M (CDR G))))).

But simplification reduces this to T, using the :rewrite rules PROBLEM-114E,
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

Subgoal *1/3.1
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (MEM (CDR (NTH (+ -1 PTR) (CDR G)))
                   (FLATTEN-M (CDR G)))
              (< PTR (+ 1 (LEN (CDR G))))
              (CONSP (NTH (+ -1 PTR) (CDR G)))
              (NOT (CONSP (CAR G))))
         (MEM (CDR (NTH (+ -1 PTR) (CDR G)))
              (CONS (CAR G) (FLATTEN-M (CDR G))))).

But simplification reduces this to T, using the :rewrite rules PROBLEM-114E,
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP G)) (ZP PTR))
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (CONSP (NTH PTR G)))
                  (MEM (CDR (NTH PTR G)) (FLATTEN-M G)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP G)
              (ZP PTR)
              (NATP PTR)
              (< PTR (LEN G))
              (CONSP (NTH PTR G)))
         (MEM (CDR (NTH PTR G)) (FLATTEN-M G))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :executable-
counterparts of NATP, NOT and ZP, linear arithmetic and the :forward-
chaining rule NATP-FC-1, to

Subgoal *1/2''
(IMPLIES (AND (CONSP G)
              (< 0 (LEN G))
              (CONSP (NTH 0 G)))
         (MEM (CDR (NTH 0 G)) (FLATTEN-M G))).

By the simple :rewrite rule PROBLEM-112I we reduce the conjecture to

Subgoal *1/2'''
(IMPLIES (AND (CONSP G) (CONSP (NTH 0 G)))
         (MEM (CDR (NTH 0 G)) (FLATTEN-M G))).

This simplifies, using the :definition NTH and the :executable-counterpart
of ZP, to

Subgoal *1/2'4'
(IMPLIES (AND (CONSP G) (CONSP (CAR G)))
         (MEM (CDR (CAR G)) (FLATTEN-M G))).

The destructor terms (CAR G) and (CDR G) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace G by (CONS G1 G2), (CAR G)
by G1 and (CDR G) by G2.  (2) Use CAR-CDR-ELIM, again, to replace G1
by (CONS G3 G4), (CAR G1) by G3 and (CDR G1) by G4.  These steps produce
the following goal.

Subgoal *1/2'5'
(IMPLIES (AND (CONSP (CONS G3 G4))
              (CONSP (CONS (CONS G3 G4) G2)))
         (MEM G4 (FLATTEN-M (CONS (CONS G3 G4) G2)))).

But simplification reduces this to T, using the :definitions FLATTEN-M
and MEM, primitive type reasoning, the :rewrite rules CAR-CONS and
CDR-CONS and the :type-prescription rule FLATTEN-M.

Subgoal *1/1
(IMPLIES (ENDP G)
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (CONSP (NTH PTR G)))
                  (MEM (CDR (NTH PTR G)) (FLATTEN-M G)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP G))
              (NATP PTR)
              (< PTR (LEN G))
              (CONSP (NTH PTR G)))
         (MEM (CDR (NTH PTR G)) (FLATTEN-M G))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definition LEN and primitive type
reasoning.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-129B depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-129B ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION ENDP)
        (:DEFINITION FLATTEN-M)
        (:DEFINITION LEN)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION NTH)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING NATP-FC-1)
        (:INDUCTION NTH)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE NATP-POSP--1)
        (:REWRITE PROBLEM-112I)
        (:REWRITE PROBLEM-114E)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION FLATTEN-M)
        (:TYPE-PRESCRIPTION MEM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FLATTEN-M))
PROBLEM-129B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-129B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-129B)
PROBLEM-129B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-129B ...) ...)
Rules: NIL
 PROBLEM-129B
ACL2 !>>(THEOREM
             PROBLEM-129C
             (IMPLIES (AND (NATP PTR)
                           (< PTR (LEN G))
                           (NOT (CONSP (NTH PTR G))))
                      (MEM (NTH PTR G) (FLATTEN-M G)))
             :HINTS (("Goal" :INDUCT (NTH PTR G)
                             :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                                PROBLEM-112I PROBLEM-114E))))


ACL2 !>>>(DEFTHM PROBLEM-129C
           (IMPLIES (AND (NATP PTR)
                         (< PTR (LEN G))
                         (NOT (CONSP (NTH PTR G))))
                    (MEM (NTH PTR G) (FLATTEN-M G)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (NTH PTR G)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A
                                              PROBLEM-112I PROBLEM-114E))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (NTH PTR G).

This suggestion was produced using the :induction rule NTH.  If we
let (:P G PTR) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (ENDP G))
                   (NOT (ZP PTR))
                   (:P (CDR G) (+ -1 PTR)))
              (:P G PTR))
     (IMPLIES (AND (NOT (ENDP G)) (ZP PTR))
              (:P G PTR))
     (IMPLIES (ENDP G) (:P G PTR))).
This induction is justified by the same argument used to admit NTH.
Note, however, that the unmeasured variable G is being instantiated.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (NOT (ENDP G))
              (NOT (ZP PTR))
              (IMPLIES (AND (NATP (+ -1 PTR))
                            (< (+ -1 PTR) (LEN (CDR G)))
                            (NOT (CONSP (NTH (+ -1 PTR) (CDR G)))))
                       (MEM (NTH (+ -1 PTR) (CDR G))
                            (FLATTEN-M (CDR G)))))
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (NOT (CONSP (NTH PTR G))))
                  (MEM (NTH PTR G) (FLATTEN-M G)))).

By the simple :definition ENDP and the simple :rewrite rule NATP-POSP--1
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (IMPLIES (AND (POSP PTR)
                            (< (+ -1 PTR) (LEN (CDR G)))
                            (NOT (CONSP (NTH (+ -1 PTR) (CDR G)))))
                       (MEM (NTH (+ -1 PTR) (CDR G))
                            (FLATTEN-M (CDR G))))
              (NATP PTR)
              (< PTR (LEN G))
              (NOT (CONSP (NTH PTR G))))
         (MEM (NTH PTR G) (FLATTEN-M G))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER, POSP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER
and the :definitions FLATTEN-M (if-intro), LEN, NOT (if-intro) and
NTH, to the following four conjectures.

Subgoal *1/3.4
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (<= (LEN (CDR G)) (+ -1 PTR))
              (< PTR (+ 1 (LEN (CDR G))))
              (NOT (CONSP (NTH (+ -1 PTR) (CDR G))))
              (CONSP (CAR G)))
         (MEM (NTH (+ -1 PTR) (CDR G))
              (LIST* (CAR (CAR G))
                     (CDR (CAR G))
                     (FLATTEN-M (CDR G))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.3
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (<= (LEN (CDR G)) (+ -1 PTR))
              (< PTR (+ 1 (LEN (CDR G))))
              (NOT (CONSP (NTH (+ -1 PTR) (CDR G))))
              (NOT (CONSP (CAR G))))
         (MEM (NTH (+ -1 PTR) (CDR G))
              (CONS (CAR G) (FLATTEN-M (CDR G))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3.2
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (MEM (NTH (+ -1 PTR) (CDR G))
                   (FLATTEN-M (CDR G)))
              (< PTR (+ 1 (LEN (CDR G))))
              (NOT (CONSP (NTH (+ -1 PTR) (CDR G))))
              (CONSP (CAR G)))
         (MEM (NTH (+ -1 PTR) (CDR G))
              (LIST* (CAR (CAR G))
                     (CDR (CAR G))
                     (FLATTEN-M (CDR G))))).

But simplification reduces this to T, using the :rewrite rules PROBLEM-114E,
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

Subgoal *1/3.1
(IMPLIES (AND (CONSP G)
              (NOT (ZP PTR))
              (MEM (NTH (+ -1 PTR) (CDR G))
                   (FLATTEN-M (CDR G)))
              (< PTR (+ 1 (LEN (CDR G))))
              (NOT (CONSP (NTH (+ -1 PTR) (CDR G))))
              (NOT (CONSP (CAR G))))
         (MEM (NTH (+ -1 PTR) (CDR G))
              (CONS (CAR G) (FLATTEN-M (CDR G))))).

But simplification reduces this to T, using the :rewrite rules PROBLEM-114E,
PROBLEM-48 and PROBLEM-49A and the :type-prescription rule MEM.

Subgoal *1/2
(IMPLIES (AND (NOT (ENDP G)) (ZP PTR))
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (NOT (CONSP (NTH PTR G))))
                  (MEM (NTH PTR G) (FLATTEN-M G)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP G)
              (ZP PTR)
              (NATP PTR)
              (< PTR (LEN G))
              (NOT (CONSP (NTH PTR G))))
         (MEM (NTH PTR G) (FLATTEN-M G))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and ZP-COMPOUND-RECOGNIZER, the :executable-
counterparts of NATP, NOT and ZP, linear arithmetic and the :forward-
chaining rule NATP-FC-1, to

Subgoal *1/2''
(IMPLIES (AND (CONSP G)
              (< 0 (LEN G))
              (NOT (CONSP (NTH 0 G))))
         (MEM (NTH 0 G) (FLATTEN-M G))).

By the simple :rewrite rule PROBLEM-112I we reduce the conjecture to

Subgoal *1/2'''
(IMPLIES (AND (CONSP G) (NOT (CONSP (NTH 0 G))))
         (MEM (NTH 0 G) (FLATTEN-M G))).

This simplifies, using the :definition NTH and the :executable-counterpart
of ZP, to

Subgoal *1/2'4'
(IMPLIES (AND (CONSP G) (NOT (CONSP (CAR G))))
         (MEM (CAR G) (FLATTEN-M G))).

The destructor terms (CAR G) and (CDR G) can be eliminated by using
CAR-CDR-ELIM to replace G by (CONS G1 G2), (CAR G) by G1 and (CDR G)
by G2.  This produces the following goal.

Subgoal *1/2'5'
(IMPLIES (AND (CONSP (CONS G1 G2))
              (NOT (CONSP G1)))
         (MEM G1 (FLATTEN-M (CONS G1 G2)))).

But simplification reduces this to T, using the :definitions FLATTEN-M
and MEM, primitive type reasoning, the :rewrite rules CAR-CONS and
CDR-CONS and the :type-prescription rule FLATTEN-M.

Subgoal *1/1
(IMPLIES (ENDP G)
         (IMPLIES (AND (NATP PTR)
                       (< PTR (LEN G))
                       (NOT (CONSP (NTH PTR G))))
                  (MEM (NTH PTR G) (FLATTEN-M G)))).

By the simple :definition ENDP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NOT (CONSP G))
              (NATP PTR)
              (< PTR (LEN G))
              (NOT (CONSP (NTH PTR G))))
         (MEM (NTH PTR G) (FLATTEN-M G))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definition LEN and primitive type
reasoning.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-129C depends upon the :type-prescription rule
MEM.

Summary
Form:  ( DEFTHM PROBLEM-129C ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER ZP-COMPOUND-RECOGNIZER)
        (:DEFINITION ENDP)
        (:DEFINITION FLATTEN-M)
        (:DEFINITION LEN)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION NTH)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING NATP-FC-1)
        (:INDUCTION NTH)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE NATP-POSP--1)
        (:REWRITE PROBLEM-112I)
        (:REWRITE PROBLEM-114E)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION FLATTEN-M)
        (:TYPE-PRESCRIPTION MEM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION FLATTEN-M)
             (:DEFINITION NOT))
PROBLEM-129C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-129C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-129C)
PROBLEM-129C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-129C ...) ...)
Rules: NIL
 PROBLEM-129C
ACL2 !>>(THEOREM PROBLEM-129D
                 (IMPLIES (SUB SEEN1 SEEN2)
                          (<= (LEN-DIFF X SEEN2)
                              (LEN-DIFF X SEEN1)))
                 :HINTS (("Goal" :INDUCT (LEN-DIFF X SEEN2)
                                 :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-129D
           (IMPLIES (SUB SEEN1 SEEN2)
                    (<= (LEN-DIFF X SEEN2)
                        (LEN-DIFF X SEEN1)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (LEN-DIFF X SEEN2)
                           :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49A))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-129D ...):  A :LINEAR rule
generated from PROBLEM-129D will be triggered by the terms (LEN-DIFF X SEEN2)
and (LEN-DIFF X SEEN1).  When PROBLEM-129D is triggered by (LEN-DIFF X SEEN2)
the variable SEEN1 will be chosen by searching for an instance of 
(SUB SEEN1 SEEN2) among the hypotheses of the conjecture being rewritten.
When PROBLEM-129D is triggered by (LEN-DIFF X SEEN1) the variable SEEN2
will be chosen by searching for an instance of (SUB SEEN1 SEEN2) among
the hypotheses of the conjecture being rewritten.  This is generally
a severe restriction on the applicability of the :LINEAR rule.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LEN-DIFF X SEEN2).

This suggestion was produced using the :induction rule LEN-DIFF.  If
we let (:P SEEN1 SEEN2 X) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP X))
              (:P SEEN1 SEEN2 X))
     (IMPLIES (AND (CONSP X)
                   (NOT (MEM (CAR X) SEEN2))
                   (:P SEEN1 SEEN2 (CDR X)))
              (:P SEEN1 SEEN2 X))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) SEEN2)
                   (:P SEEN1 SEEN2 (CDR X)))
              (:P SEEN1 SEEN2 X))).
This induction is justified by the same argument used to admit LEN-DIFF.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (SUB SEEN1 SEEN2)
                  (<= (LEN-DIFF X SEEN2)
                      (LEN-DIFF X SEEN1)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X)) (SUB SEEN1 SEEN2))
         (<= (LEN-DIFF X SEEN2)
             (LEN-DIFF X SEEN1))).

But simplification reduces this to T, using the :definition LEN-DIFF
and the :executable-counterpart of <.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN2))
              (IMPLIES (SUB SEEN1 SEEN2)
                       (<= (LEN-DIFF (CDR X) SEEN2)
                           (LEN-DIFF (CDR X) SEEN1))))
         (IMPLIES (SUB SEEN1 SEEN2)
                  (<= (LEN-DIFF X SEEN2)
                      (LEN-DIFF X SEEN1)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN2))
              (IMPLIES (SUB SEEN1 SEEN2)
                       (<= (LEN-DIFF (CDR X) SEEN2)
                           (LEN-DIFF (CDR X) SEEN1)))
              (SUB SEEN1 SEEN2))
         (<= (LEN-DIFF X SEEN2)
             (LEN-DIFF X SEEN1))).

This simplifies, using the :definitions LEN-DIFF (if-intro) and NOT
(if-intro) and the :type-prescription rule SUB, to the following two
conjectures.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN2))
              (<= (LEN-DIFF (CDR X) SEEN2)
                  (LEN-DIFF (CDR X) SEEN1))
              (SUB SEEN1 SEEN2)
              (MEM (CAR X) SEEN1))
         (<= (+ 1 (LEN-DIFF (CDR X) SEEN2))
             (LEN-DIFF (CDR X) SEEN1))).

This simplifies, using linear arithmetic, primitive type reasoning
and the :type-prescription rule LEN-DIFF, to

Subgoal *1/2.2'
(IMPLIES (AND (EQUAL (LEN-DIFF (CDR X) SEEN2)
                     (LEN-DIFF (CDR X) SEEN1))
              (CONSP X)
              (NOT (MEM (CAR X) SEEN2))
              (<= (LEN-DIFF (CDR X) SEEN2)
                  (LEN-DIFF (CDR X) SEEN1))
              (SUB SEEN1 SEEN2)
              (MEM (CAR X) SEEN1))
         (<= (+ 1 (LEN-DIFF (CDR X) SEEN2))
             (LEN-DIFF (CDR X) SEEN1))).

But simplification reduces this to T, using the :rewrite rule PROBLEM-49A
and the :type-prescription rules MEM and SUB.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN2))
              (<= (LEN-DIFF (CDR X) SEEN2)
                  (LEN-DIFF (CDR X) SEEN1))
              (SUB SEEN1 SEEN2)
              (NOT (MEM (CAR X) SEEN1)))
         (<= (+ 1 (LEN-DIFF (CDR X) SEEN2))
             (+ 1 (LEN-DIFF (CDR X) SEEN1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) SEEN2)
              (IMPLIES (SUB SEEN1 SEEN2)
                       (<= (LEN-DIFF (CDR X) SEEN2)
                           (LEN-DIFF (CDR X) SEEN1))))
         (IMPLIES (SUB SEEN1 SEEN2)
                  (<= (LEN-DIFF X SEEN2)
                      (LEN-DIFF X SEEN1)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) SEEN2)
              (IMPLIES (SUB SEEN1 SEEN2)
                       (<= (LEN-DIFF (CDR X) SEEN2)
                           (LEN-DIFF (CDR X) SEEN1)))
              (SUB SEEN1 SEEN2))
         (<= (LEN-DIFF X SEEN2)
             (LEN-DIFF X SEEN1))).

This simplifies, using the :definitions LEN-DIFF and NOT, the :rewrite
rules PROBLEM-48 and PROBLEM-49A and the :type-prescription rules MEM
and SUB, to

Subgoal *1/1''
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) SEEN2)
              (<= (LEN-DIFF (CDR X) SEEN2)
                  (LEN-DIFF (CDR X) SEEN1))
              (SUB SEEN1 SEEN2)
              (NOT (MEM (CAR X) SEEN1)))
         (<= (LEN-DIFF (CDR X) SEEN2)
             (+ 1 (LEN-DIFF (CDR X) SEEN1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-129D ...)
Rules: ((:DEFINITION LEN-DIFF)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN-DIFF)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION LEN-DIFF)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION LEN-DIFF)
             (:DEFINITION NOT))
Warnings:  Free
PROBLEM-129D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-129D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-129D)
PROBLEM-129D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-129D ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-129D
ACL2 !>>(THEOREM
           PROBLEM-129E
           (IMPLIES (AND (NOT (MEM PTR SEEN1))
                         (MEM PTR SEEN2)
                         (SUB SEEN1 SEEN2)
                         (MEM PTR X))
                    (< (LEN-DIFF X SEEN2)
                       (LEN-DIFF X SEEN1)))
           :HINTS
           (("Goal" :INDUCT (LEN-DIFF X SEEN1)
                    :IN-THEORY (ENABLE PROBLEM-48
                                       PROBLEM-49 PROBLEM-49A PROBLEM-129D)))
           :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-129E
          (IMPLIES (AND (NOT (MEM PTR SEEN1))
                        (MEM PTR SEEN2)
                        (SUB SEEN1 SEEN2)
                        (MEM PTR X))
                   (< (LEN-DIFF X SEEN2)
                      (LEN-DIFF X SEEN1)))
          :RULE-CLASSES :LINEAR
          :HINTS
          (("Goal" :DO-NOT-INDUCT T
                   :DO-NOT '(GENERALIZE)
                   :INDUCT (LEN-DIFF X SEEN1)
                   :IN-THEORY (ENABLE PROBLEM-48
                                      PROBLEM-49 PROBLEM-49A PROBLEM-129D))))

ACL2 Warning [Free] in ( DEFTHM PROBLEM-129E ...):  A :LINEAR rule
generated from PROBLEM-129E will be triggered by the terms (LEN-DIFF X SEEN2)
and (LEN-DIFF X SEEN1).  When PROBLEM-129E is triggered by (LEN-DIFF X SEEN2)
the variables SEEN1 and PTR will be chosen by searching for an instance
of (NOT (MEM PTR SEEN1)) among the hypotheses of the conjecture being
rewritten.  When PROBLEM-129E is triggered by (LEN-DIFF X SEEN1) the
variables PTR and SEEN2 will be chosen by searching for instances of
(NOT (MEM PTR SEEN1)) and (MEM PTR SEEN2) among the hypotheses of the
conjecture being rewritten.  This is generally a severe restriction
on the applicability of the :LINEAR rule.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (LEN-DIFF X SEEN1).

This suggestion was produced using the :induction rule LEN-DIFF.  If
we let (:P PTR SEEN1 SEEN2 X) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (CONSP X))
              (:P PTR SEEN1 SEEN2 X))
     (IMPLIES (AND (CONSP X)
                   (NOT (MEM (CAR X) SEEN1))
                   (:P PTR SEEN1 SEEN2 (CDR X)))
              (:P PTR SEEN1 SEEN2 X))
     (IMPLIES (AND (CONSP X)
                   (MEM (CAR X) SEEN1)
                   (:P PTR SEEN1 SEEN2 (CDR X)))
              (:P PTR SEEN1 SEEN2 X))).
This induction is justified by the same argument used to admit LEN-DIFF.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (IMPLIES (AND (NOT (MEM PTR SEEN1))
                       (MEM PTR SEEN2)
                       (SUB SEEN1 SEEN2)
                       (MEM PTR X))
                  (< (LEN-DIFF X SEEN2)
                     (LEN-DIFF X SEEN1)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (CONSP X))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (MEM PTR X))
         (< (LEN-DIFF X SEEN2)
            (LEN-DIFF X SEEN1))).

This simplifies, using linear arithmetic, the :linear rule PROBLEM-129D
and the :type-prescription rules LEN-DIFF and SUB, to

Subgoal *1/3''
(IMPLIES (AND (EQUAL (LEN-DIFF X SEEN2)
                     (LEN-DIFF X SEEN1))
              (NOT (CONSP X))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (MEM PTR X))
         (< (LEN-DIFF X SEEN2)
            (LEN-DIFF X SEEN1))).

But simplification reduces this to T, using the :definitions LEN-DIFF
and SUB, the :executable-counterpart of EQUAL, the :rewrite rule PROBLEM-49A
and the :type-prescription rule MEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN1))
              (IMPLIES (AND (NOT (MEM PTR SEEN1))
                            (MEM PTR SEEN2)
                            (SUB SEEN1 SEEN2)
                            (MEM PTR (CDR X)))
                       (< (LEN-DIFF (CDR X) SEEN2)
                          (LEN-DIFF (CDR X) SEEN1))))
         (IMPLIES (AND (NOT (MEM PTR SEEN1))
                       (MEM PTR SEEN2)
                       (SUB SEEN1 SEEN2)
                       (MEM PTR X))
                  (< (LEN-DIFF X SEEN2)
                     (LEN-DIFF X SEEN1)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN1))
              (IMPLIES (AND (NOT (MEM PTR SEEN1))
                            (MEM PTR SEEN2)
                            (SUB SEEN1 SEEN2)
                            (MEM PTR (CDR X)))
                       (< (LEN-DIFF (CDR X) SEEN2)
                          (LEN-DIFF (CDR X) SEEN1)))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (MEM PTR X))
         (< (LEN-DIFF X SEEN2)
            (LEN-DIFF X SEEN1))).

This simplifies, using the :definitions LEN-DIFF (if-intro) and MEM
(if-intro), the :executable-counterpart of NOT, primitive type reasoning,
the :rewrite rules PROBLEM-48, PROBLEM-49 and PROBLEM-49A and the :type-
prescription rules MEM and SUB, to the following four conjectures.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN1))
              (NOT (MEM PTR (CDR X)))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (EQUAL PTR (CAR X)))
         (< (LEN-DIFF (CDR X) SEEN2)
            (+ 1 (LEN-DIFF (CDR X) SEEN1)))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-129D and the :type-prescription
rules LEN-DIFF and SUB.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN1))
              (< (LEN-DIFF (CDR X) SEEN2)
                 (LEN-DIFF (CDR X) SEEN1))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (EQUAL PTR (CAR X)))
         (< (LEN-DIFF (CDR X) SEEN2)
            (+ 1 (LEN-DIFF (CDR X) SEEN1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN1))
              (< (LEN-DIFF (CDR X) SEEN2)
                 (LEN-DIFF (CDR X) SEEN1))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (MEM PTR (CDR X))
              (MEM (CAR X) SEEN2))
         (< (LEN-DIFF (CDR X) SEEN2)
            (+ 1 (LEN-DIFF (CDR X) SEEN1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (NOT (MEM (CAR X) SEEN1))
              (< (LEN-DIFF (CDR X) SEEN2)
                 (LEN-DIFF (CDR X) SEEN1))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (MEM PTR (CDR X))
              (NOT (MEM (CAR X) SEEN2)))
         (< (+ 1 (LEN-DIFF (CDR X) SEEN2))
            (+ 1 (LEN-DIFF (CDR X) SEEN1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) SEEN1)
              (IMPLIES (AND (NOT (MEM PTR SEEN1))
                            (MEM PTR SEEN2)
                            (SUB SEEN1 SEEN2)
                            (MEM PTR (CDR X)))
                       (< (LEN-DIFF (CDR X) SEEN2)
                          (LEN-DIFF (CDR X) SEEN1))))
         (IMPLIES (AND (NOT (MEM PTR SEEN1))
                       (MEM PTR SEEN2)
                       (SUB SEEN1 SEEN2)
                       (MEM PTR X))
                  (< (LEN-DIFF X SEEN2)
                     (LEN-DIFF X SEEN1)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) SEEN1)
              (IMPLIES (AND (NOT (MEM PTR SEEN1))
                            (MEM PTR SEEN2)
                            (SUB SEEN1 SEEN2)
                            (MEM PTR (CDR X)))
                       (< (LEN-DIFF (CDR X) SEEN2)
                          (LEN-DIFF (CDR X) SEEN1)))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (MEM PTR X))
         (< (LEN-DIFF X SEEN2)
            (LEN-DIFF X SEEN1))).

This simplifies, using the :definitions LEN-DIFF and MEM (if-intro),
the :executable-counterpart of NOT, primitive type reasoning, the :rewrite
rules PROBLEM-48, PROBLEM-49 and PROBLEM-49A and the :type-prescription
rules MEM and SUB, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) SEEN1)
              (NOT (MEM PTR (CDR X)))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (EQUAL PTR (CAR X)))
         (< (LEN-DIFF (CDR X) SEEN2)
            (+ 1 (LEN-DIFF (CDR X) SEEN1)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (MEM (CAR X) SEEN1)
              (< (LEN-DIFF (CDR X) SEEN2)
                 (LEN-DIFF (CDR X) SEEN1))
              (NOT (MEM PTR SEEN1))
              (MEM PTR SEEN2)
              (SUB SEEN1 SEEN2)
              (EQUAL PTR (CAR X)))
         (< (LEN-DIFF (CDR X) SEEN2)
            (+ 1 (LEN-DIFF (CDR X) SEEN1)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-129E ...)
Rules: ((:DEFINITION LEN-DIFF)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION SUB)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN-DIFF)
        (:LINEAR PROBLEM-129D)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION LEN-DIFF)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION LEN-DIFF)
             (:DEFINITION MEM))
Warnings:  Free
PROBLEM-129E


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-129E))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-129E)
PROBLEM-129E

Summary
Form:  ( PROGN (DEFTHM PROBLEM-129E ...) ...)
Rules: NIL
Warnings:  Free
 PROBLEM-129E
ACL2 !>>(DEFUN REACHABLES (PTR M SEEN)
         (DECLARE
          (XARGS
           :MEASURE (M2 (IF (MEM PTR (FLATTEN-M M)) 1 2)
                        (LEN-DIFF (FLATTEN-M M) SEEN))
           :HINTS
           (("Goal" :IN-THEORY (ENABLE PROBLEM-48
                                       PROBLEM-114E PROBLEM-129A PROBLEM-129B
                                       PROBLEM-129C PROBLEM-129E)))))
         (IF (ADDRESSP PTR M)
             (IF (MEM PTR SEEN)
                 SEEN
               (IF (CONSP (NTH PTR M))
                   (IF (SUB (CONS PTR SEEN)
                            (REACHABLES (CDR (NTH PTR M))
                                        M (CONS PTR SEEN)))
                       (REACHABLES (CAR (NTH PTR M))
                                   M
                                   (REACHABLES (CDR (NTH PTR M))
                                               M (CONS PTR SEEN)))
                     'UNDEF)
                 (REACHABLES (NTH PTR M)
                             M (CONS PTR SEEN))))
           SEEN))

For the admission of REACHABLES we will use the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (M2 (IF (MEM PTR (FLATTEN-M M)) 1 2) (LEN-DIFF (FLATTEN-M M) SEEN)).
The non-trivial part of the measure conjecture is

Goal
(AND (O-P (M2 (IF (MEM PTR (FLATTEN-M M)) 1 2)
              (LEN-DIFF (FLATTEN-M M) SEEN)))
     (IMPLIES (AND (ADDRESSP PTR M)
                   (NOT (MEM PTR SEEN))
                   (NOT (CONSP (NTH PTR M))))
              (O< (M2 (IF (MEM (NTH PTR M) (FLATTEN-M M)) 1 2)
                      (LEN-DIFF (FLATTEN-M M)
                                (CONS PTR SEEN)))
                  (M2 (IF (MEM PTR (FLATTEN-M M)) 1 2)
                      (LEN-DIFF (FLATTEN-M M) SEEN))))
     (IMPLIES (AND (ADDRESSP PTR M)
                   (NOT (MEM PTR SEEN))
                   (CONSP (NTH PTR M)))
              (O< (M2 (IF (MEM (CDR (NTH PTR M)) (FLATTEN-M M))
                          1
                        2)
                      (LEN-DIFF (FLATTEN-M M)
                                (CONS PTR SEEN)))
                  (M2 (IF (MEM PTR (FLATTEN-M M)) 1 2)
                      (LEN-DIFF (FLATTEN-M M) SEEN))))
     (IMPLIES (AND (ADDRESSP PTR M)
                   (NOT (MEM PTR SEEN))
                   (CONSP (NTH PTR M))
                   (SUB (CONS PTR SEEN)
                        (REACHABLES (CDR (NTH PTR M))
                                    M (CONS PTR SEEN))))
              (O< (M2 (IF (MEM (CAR (NTH PTR M)) (FLATTEN-M M))
                          1
                        2)
                      (LEN-DIFF (FLATTEN-M M)
                                (REACHABLES (CDR (NTH PTR M))
                                            M (CONS PTR SEEN))))
                  (M2 (IF (MEM PTR (FLATTEN-M M)) 1 2)
                      (LEN-DIFF (FLATTEN-M M) SEEN))))).

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions ADDRESSP and M2 we reduce the conjecture
to the following four conjectures.

Subgoal 4
(O-P (CONS (CONS 1
                 (+ 1 (IF (MEM PTR (FLATTEN-M M)) 1 2)))
           (LEN-DIFF (FLATTEN-M M) SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER, O-FINP-CR and POSP-COMPOUND-RECOGNIZER,
the :definitions O-FIRST-COEFF, O-FIRST-EXPT, O-P and O-RST, the :executable-
counterparts of EQUAL, O-P and O<, primitive type reasoning, the :rewrite
rules CAR-CONS, CDR-CONS, O-FIRST-EXPT-DEF-O-FINP and O-P-DEF-O-FINP-1
and the :type-prescription rule LEN-DIFF.

Subgoal 3
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (NOT (MEM PTR SEEN))
              (NOT (CONSP (NTH PTR M))))
         (O< (CONS (CONS 1
                         (+ 1
                            (IF (MEM (NTH PTR M) (FLATTEN-M M))
                                1
                              2)))
                   (LEN-DIFF (FLATTEN-M M)
                             (CONS PTR SEEN)))
             (CONS (CONS 1
                         (+ 1 (IF (MEM PTR (FLATTEN-M M)) 1 2)))
                   (LEN-DIFF (FLATTEN-M M) SEEN)))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :definitions O-FIRST-COEFF,
O-FIRST-EXPT, O-RST, O< and SYNP, the :executable-counterparts of 
ACL2-NUMBERP, BINARY-+, CAR, CDR, CONS, EQUAL and UNARY--, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, EQUAL-CONSTANT-+
and PROBLEM-129C and the :type-prescription rule LEN-DIFF, to

Subgoal 3'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (NOT (MEM PTR SEEN))
              (NOT (CONSP (NTH PTR M)))
              (MEM PTR (FLATTEN-M M)))
         (< (LEN-DIFF (FLATTEN-M M) (CONS PTR SEEN))
            (LEN-DIFF (FLATTEN-M M) SEEN))).

But simplification reduces this to T, using the :definition MEM, linear
arithmetic, primitive type reasoning, the :linear rule PROBLEM-129E,
the :rewrite rules CAR-CONS, PROBLEM-114E and PROBLEM-48 and the :type-
prescription rules LEN-DIFF and MEM.

Subgoal 2
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (NOT (MEM PTR SEEN))
              (CONSP (NTH PTR M)))
         (O< (CONS (CONS 1
                         (+ 1
                            (IF (MEM (CDR (NTH PTR M)) (FLATTEN-M M))
                                1
                              2)))
                   (LEN-DIFF (FLATTEN-M M)
                             (CONS PTR SEEN)))
             (CONS (CONS 1
                         (+ 1 (IF (MEM PTR (FLATTEN-M M)) 1 2)))
                   (LEN-DIFF (FLATTEN-M M) SEEN)))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :definitions O-FIRST-COEFF,
O-FIRST-EXPT, O-RST, O< and SYNP, the :executable-counterparts of 
ACL2-NUMBERP, BINARY-+, CAR, CDR, CONS, EQUAL and UNARY--, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, EQUAL-CONSTANT-+
and PROBLEM-129B and the :type-prescription rule LEN-DIFF, to

Subgoal 2'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (NOT (MEM PTR SEEN))
              (CONSP (NTH PTR M))
              (MEM PTR (FLATTEN-M M)))
         (< (LEN-DIFF (FLATTEN-M M) (CONS PTR SEEN))
            (LEN-DIFF (FLATTEN-M M) SEEN))).

But simplification reduces this to T, using the :definition MEM, linear
arithmetic, primitive type reasoning, the :linear rule PROBLEM-129E,
the :rewrite rules CAR-CONS, PROBLEM-114E and PROBLEM-48 and the :type-
prescription rules LEN-DIFF and MEM.

Subgoal 1
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (NOT (MEM PTR SEEN))
              (CONSP (NTH PTR M))
              (SUB (CONS PTR SEEN)
                   (REACHABLES (CDR (NTH PTR M))
                               M (CONS PTR SEEN))))
         (O< (CONS (CONS 1
                         (+ 1
                            (IF (MEM (CAR (NTH PTR M)) (FLATTEN-M M))
                                1
                              2)))
                   (LEN-DIFF (FLATTEN-M M)
                             (REACHABLES (CDR (NTH PTR M))
                                         M (CONS PTR SEEN))))
             (CONS (CONS 1
                         (+ 1 (IF (MEM PTR (FLATTEN-M M)) 1 2)))
                   (LEN-DIFF (FLATTEN-M M) SEEN)))).

This simplifies, using the :compound-recognizer rules 
NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :definitions O-FIRST-COEFF,
O-FIRST-EXPT, O-RST, O<, SUB and SYNP, the :executable-counterparts
of ACL2-NUMBERP, BINARY-+, CAR, CDR, CONS, EQUAL and UNARY--, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, EQUAL-CONSTANT-+
and PROBLEM-129A and the :type-prescription rule LEN-DIFF, to

Subgoal 1'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (NOT (MEM PTR SEEN))
              (CONSP (NTH PTR M))
              (MEM PTR
                   (REACHABLES (CDR (NTH PTR M))
                               M (CONS PTR SEEN)))
              (SUB SEEN
                   (REACHABLES (CDR (NTH PTR M))
                               M (CONS PTR SEEN)))
              (MEM PTR (FLATTEN-M M)))
         (< (LEN-DIFF (FLATTEN-M M)
                      (REACHABLES (CDR (NTH PTR M))
                                  M (CONS PTR SEEN)))
            (LEN-DIFF (FLATTEN-M M) SEEN))).

But simplification reduces this to T, using linear arithmetic, the
:linear rule PROBLEM-129E and the :type-prescription rules LEN-DIFF,
MEM and SUB.

Q.E.D.

That completes the proof of the measure theorem for REACHABLES.  Thus,
we admit this function under the principle of definition.  We observe
that the type of REACHABLES is described by the theorem 
(OR (OR (CONSP (REACHABLES PTR M SEEN))
        (AND (SYMBOLP (REACHABLES PTR M SEEN))
             (NOT (EQUAL (REACHABLES PTR M SEEN) T))
             (NOT (EQUAL (REACHABLES PTR M SEEN) NIL))))
    (EQUAL (REACHABLES PTR M SEEN) SEEN)).
We used primitive type reasoning.

Summary
Form:  ( DEFUN REACHABLES ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:DEFINITION ADDRESSP)
        (:DEFINITION M2)
        (:DEFINITION MEM)
        (:DEFINITION NOT)
        (:DEFINITION O-FIRST-COEFF)
        (:DEFINITION O-FIRST-EXPT)
        (:DEFINITION O-P)
        (:DEFINITION O-RST)
        (:DEFINITION O<)
        (:DEFINITION SUB)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART ACL2-NUMBERP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART O-P)
        (:EXECUTABLE-COUNTERPART O<)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR PROBLEM-129E)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE EQUAL-CONSTANT-+)
        (:REWRITE O-FIRST-EXPT-DEF-O-FINP)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE PROBLEM-114E)
        (:REWRITE PROBLEM-129A)
        (:REWRITE PROBLEM-129B)
        (:REWRITE PROBLEM-129C)
        (:REWRITE PROBLEM-48)
        (:TYPE-PRESCRIPTION LEN-DIFF)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
 REACHABLES
ACL2 !>>:----- 
"
; This is the key fact about reachables: it doesn't unmark any nodes!
"
ACL2 !>>(THEOREM
             PROBLEM-129F
             (SUB SEEN (REACHABLES PTR M SEEN))
             :HINTS
             (("Goal" :INDUCT (REACHABLES PTR M SEEN)
                      :IN-THEORY (ENABLE PROBLEM-48 PROBLEM-49 PROBLEM-49A)))
             :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (REACHABLES PTR M SEEN).

This suggestion was produced using the :induction rule REACHABLES.
If we let (:P M PTR SEEN) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (ADDRESSP PTR M))
              (:P M PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR M)
                   (NOT (MEM PTR SEEN))
                   (NOT (CONSP (NTH PTR M)))
                   (:P M (NTH PTR M) (CONS PTR SEEN)))
              (:P M PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR M)
                   (NOT (MEM PTR SEEN))
                   (CONSP (NTH PTR M))
                   (NOT (SUB (CONS PTR SEEN)
                             (REACHABLES (CDR (NTH PTR M))
                                         M (CONS PTR SEEN))))
                   (:P M (CDR (NTH PTR M))
                       (CONS PTR SEEN)))
              (:P M PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR M)
                   (NOT (MEM PTR SEEN))
                   (CONSP (NTH PTR M))
                   (SUB (CONS PTR SEEN)
                        (REACHABLES (CDR (NTH PTR M))
                                    M (CONS PTR SEEN)))
                   (:P M (CAR (NTH PTR M))
                       (REACHABLES (CDR (NTH PTR M))
                                   M (CONS PTR SEEN)))
                   (:P M (CDR (NTH PTR M))
                       (CONS PTR SEEN)))
              (:P M PTR SEEN))
     (IMPLIES (AND (ADDRESSP PTR M) (MEM PTR SEEN))
              (:P M PTR SEEN))).
This induction is justified by the same argument used to admit REACHABLES.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1/4
(IMPLIES (NOT (ADDRESSP PTR M))
         (SUB SEEN (REACHABLES PTR M SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP and REACHABLES
and the :rewrite rule PROBLEM-48.

Subgoal *1/3
(IMPLIES (AND (ADDRESSP PTR M)
              (NOT (MEM PTR SEEN))
              (NOT (CONSP (NTH PTR M)))
              (SUB (CONS PTR SEEN)
                   (REACHABLES (NTH PTR M)
                               M (CONS PTR SEEN))))
         (SUB SEEN (REACHABLES PTR M SEEN))).

By the simple :definition ADDRESSP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (NOT (MEM PTR SEEN))
              (NOT (CONSP (NTH PTR M)))
              (SUB (CONS PTR SEEN)
                   (REACHABLES (NTH PTR M)
                               M (CONS PTR SEEN))))
         (SUB SEEN (REACHABLES PTR M SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP, REACHABLES
and SUB, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
PROBLEM-48 and PROBLEM-49 and the :type-prescription rule SUB.

Subgoal *1/2
(IMPLIES (AND (ADDRESSP PTR M)
              (NOT (MEM PTR SEEN))
              (CONSP (NTH PTR M))
              (SUB (CONS PTR SEEN)
                   (REACHABLES (CDR (NTH PTR M))
                               M (CONS PTR SEEN)))
              (SUB (REACHABLES (CDR (NTH PTR M))
                               M (CONS PTR SEEN))
                   (REACHABLES (CAR (NTH PTR M))
                               M
                               (REACHABLES (CDR (NTH PTR M))
                                           M (CONS PTR SEEN)))))
         (SUB SEEN (REACHABLES PTR M SEEN))).

By the simple :definition ADDRESSP we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (NOT (MEM PTR SEEN))
              (CONSP (NTH PTR M))
              (SUB (CONS PTR SEEN)
                   (REACHABLES (CDR (NTH PTR M))
                               M (CONS PTR SEEN)))
              (SUB (REACHABLES (CDR (NTH PTR M))
                               M (CONS PTR SEEN))
                   (REACHABLES (CAR (NTH PTR M))
                               M
                               (REACHABLES (CDR (NTH PTR M))
                                           M (CONS PTR SEEN)))))
         (SUB SEEN (REACHABLES PTR M SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP, REACHABLES
and SUB, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
PROBLEM-48, PROBLEM-49 and PROBLEM-49A and the :type-prescription rules
MEM and SUB.

Subgoal *1/1
(IMPLIES (AND (ADDRESSP PTR M) (MEM PTR SEEN))
         (SUB SEEN (REACHABLES PTR M SEEN))).

By the simple :definition ADDRESSP we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (NATP PTR)
              (< PTR (LEN M))
              (MEM PTR SEEN))
         (SUB SEEN (REACHABLES PTR M SEEN))).

But simplification reduces this to T, using the :compound-recognizer
rule NATP-COMPOUND-RECOGNIZER, the :definitions ADDRESSP and REACHABLES,
the :rewrite rules PROBLEM-48 and PROBLEM-49A and the :type-prescription
rule MEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-129F ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ADDRESSP)
        (:DEFINITION NOT)
        (:DEFINITION REACHABLES)
        (:DEFINITION SUB)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REACHABLES)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-48)
        (:REWRITE PROBLEM-49)
        (:REWRITE PROBLEM-49A)
        (:TYPE-PRESCRIPTION MEM)
        (:TYPE-PRESCRIPTION SUB))
 PROBLEM-129F
ACL2 !>>(THEOREM
         PROBLEM-129G
         (SUB (CONS PTR SEEN)
              (REACHABLES (CDR (NTH PTR M))
                          M (CONS PTR SEEN)))
         :HINTS (("Goal" :USE (:INSTANCE PROBLEM-129F (PTR (CDR (NTH PTR M)))
                                         (M M)
                                         (SEEN (CONS PTR SEEN))))))


ACL2 !>>>(DEFTHM PROBLEM-129G
           (SUB (CONS PTR SEEN)
                (REACHABLES (CDR (NTH PTR M))
                            M (CONS PTR SEEN)))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :USE (:INSTANCE PROBLEM-129F (PTR (CDR (NTH PTR M)))
                                    (M M)
                                    (SEEN (CONS PTR SEEN))))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But we augment the goal with the hypothesis provided by the :USE hint.
The hypothesis can be derived from PROBLEM-129F via instantiation.
This reduces the goal to T.

Q.E.D.

The storage of PROBLEM-129G depends upon the :type-prescription rule
SUB.

Summary
Form:  ( DEFTHM PROBLEM-129G ...)
Rules: ((:TYPE-PRESCRIPTION SUB))
Hint-events: ((:USE PROBLEM-129F))
PROBLEM-129G


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-129G))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-129G)
PROBLEM-129G

Summary
Form:  ( PROGN (DEFTHM PROBLEM-129G ...) ...)
Rules: NIL
 PROBLEM-129G
ACL2 !>>(THEOREM PROBLEM-129
                 (EQUAL (REACHABLES PTR M SEEN)
                        (IF (ADDRESSP PTR M)
                            (IF (MEM PTR SEEN)
                                SEEN
                              (IF (CONSP (NTH PTR M))
                                  (REACHABLES (CAR (NTH PTR M))
                                              M
                                              (REACHABLES (CDR (NTH PTR M))
                                                          M (CONS PTR SEEN)))
                                (REACHABLES (NTH PTR M)
                                            M (CONS PTR SEEN))))
                          SEEN))
                 :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-129G)))
                 :RULE-CLASSES NIL)

[Note:  A hint was supplied for the goal above.  Thanks!]

But simplification reduces this to T, using the :definitions ADDRESSP
and REACHABLES, primitive type reasoning and the :rewrite rule PROBLEM-129G.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-129 ...)
Rules: ((:DEFINITION ADDRESSP)
        (:DEFINITION REACHABLES)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE PROBLEM-129G))
 PROBLEM-129
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 130.
"
ACL2 !>>(DEFUN RMB (X)
          (DECLARE (XARGS :MEASURE (CC X)))
          (IF (CONSP X)
              (IF (CONSP (CDR X))
                  (IF (< (CC (CDR (RMB (CDR X)))) (CC X))
                      (IF (< (CC (CONS (CAR X)
                                       (RMB (CDR (RMB (CDR X))))))
                             (CC X))
                          (CONS (CAR (RMB (CDR X)))
                                (RMB (CONS (CAR X)
                                           (RMB (CDR (RMB (CDR X)))))))
                        'UNDEF)
                    'UNDEF)
                (CONS (CAR X) NIL))
            NIL))

For the admission of RMB we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (AND (CONSP X) (CONSP (CDR X)))
              (O< (CC (CDR X)) (CC X)))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (< (CC (CDR (RMB (CDR X)))) (CC X)))
              (O< (CC (CDR (RMB (CDR X)))) (CC X)))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (< (CC (CDR (RMB (CDR X)))) (CC X))
                   (< (CC (CONS (CAR X)
                                (RMB (CDR (RMB (CDR X))))))
                      (CC X)))
              (O< (CC (CONS (CAR X)
                            (RMB (CDR (RMB (CDR X))))))
                  (CC X)))).

By case analysis we reduce the conjecture to the following four conjectures.

Subgoal 4
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 3
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (CC (CDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definition O< and the :type-prescription rule CC, to

Subgoal 3'
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (< (CC (CDR X)) (CC X))).

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following goal.

Subgoal 3''
(IMPLIES (AND (CONSP (CONS X1 X2)) (CONSP X2))
         (< (CC X2) (CC (CONS X1 X2)))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS
and CDR-CONS, to

Subgoal 3'''
(IMPLIES (CONSP X2)
         (< 0 (+ 1 (CC X1)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X)))) (CC X)))
         (O< (CC (CDR (RMB (CDR X)))) (CC X))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, the :rewrite rule O-FINP-< and the :type-prescription
rule CC.

Subgoal 1
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X)))) (CC X))
              (< (CC (CONS (CAR X)
                           (RMB (CDR (RMB (CDR X))))))
                 (CC X)))
         (O< (CC (CONS (CAR X)
                       (RMB (CDR (RMB (CDR X))))))
             (CC X))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, the :definition CC, primitive type reasoning, the :meta
rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS
and O-FINP-< and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for RMB.  Thus, we
admit this function under the principle of definition.  We observe
that the type of RMB is described by the theorem 
(OR (CONSP (RMB X))
    (AND (SYMBOLP (RMB X))
         (NOT (EQUAL (RMB X) T))
         (NOT (EQUAL (RMB X) NIL)))
    (EQUAL (RMB X) NIL)).
We used primitive type reasoning.

Summary
Form:  ( DEFUN RMB ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION CC)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:ELIM CAR-CDR-ELIM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE O-FINP-<)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:TYPE-PRESCRIPTION CC))
 RMB
ACL2 !>>(THEOREM PROBLEM-130A (<= (CC (CDR X)) (CC X))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-130A
           (<= (CC (CDR X)) (CC X))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE))))

[Note:  A hint was supplied for the goal above.  Thanks!]

The destructor terms (CAR X) and (CDR X) can be eliminated by using
CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X) by X1 and (CDR X)
by X2.  This produces the following two goals.

Subgoal 2
(IMPLIES (NOT (CONSP X))
         (<= (CC (CDR X)) (CC X))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of < and CC and the :rewrite rule DEFAULT-CDR.

Subgoal 1
(IMPLIES (CONSP (CONS X1 X2))
         (<= (CC X2) (CC (CONS X1 X2)))).

This simplifies, using the :definition CC, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS
and CDR-CONS, to

Subgoal 1'
(<= 0 (+ 1 (CC X1))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-130A ...)
Rules: ((:DEFINITION CC)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART CC)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-CDR)
        (:TYPE-PRESCRIPTION CC))
PROBLEM-130A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-130A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-130A)
PROBLEM-130A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-130A ...) ...)
Rules: NIL
 PROBLEM-130A
ACL2 !>>(THEOREM PROBLEM-130B (<= (CC (RMB X)) (CC X))
                 :HINTS (("Goal" :INDUCT (RMB X)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-130B
           (<= (CC (RMB X)) (CC X))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RMB X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RMB X).

This suggestion was produced using the :induction rule RMB.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (<= (CC X) (CC (CDR (RMB (CDR X)))))
                   (:P (CDR X)))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (< (CC (CDR (RMB (CDR X)))) (CC X))
                   (<= (CC X)
                       (CC (CONS (CAR X)
                                 (RMB (CDR (RMB (CDR X)))))))
                   (:P (CDR (RMB (CDR X))))
                   (:P (CDR X)))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (< (CC (CDR (RMB (CDR X)))) (CC X))
                   (< (CC (CONS (CAR X)
                                (RMB (CDR (RMB (CDR X))))))
                      (CC X))
                   (:P (CDR X))
                   (:P (CONS (CAR X)
                             (RMB (CDR (RMB (CDR X))))))
                   (:P (CDR (RMB (CDR X)))))
              (:P X))).
This induction is justified by the same argument used to admit RMB.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.

Subgoal *1/5
(IMPLIES (NOT (CONSP X))
         (<= (CC (RMB X)) (CC X))).

But simplification reduces this to T, using the :definitions CC and
RMB and the :executable-counterparts of < and CC.

Subgoal *1/4
(IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
         (<= (CC (RMB X)) (CC X))).

This simplifies, using the :definitions CC, FIX and RMB, the :executable-
counterpart of CC, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal *1/4'
(IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
         (<= (+ 1 (CC (CAR X))) (CC X))).

But simplification reduces this to T, using the :definitions CC and
FIX, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules 
COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription rule
CC.

Subgoal *1/3
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (<= (CC X) (CC (CDR (RMB (CDR X)))))
              (<= (CC (RMB (CDR X))) (CC (CDR X))))
         (<= (CC (RMB X)) (CC X))).

This simplifies, using the :definition RMB and the :executable-counterpart
of CC, to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (<= (CC X) (CC (CDR (RMB (CDR X)))))
              (<= (CC (RMB (CDR X))) (CC (CDR X))))
         (<= 0 (CC X))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X)))) (CC X))
              (<= (CC X)
                  (CC (CONS (CAR X)
                            (RMB (CDR (RMB (CDR X)))))))
              (<= (CC (RMB (CDR (RMB (CDR X)))))
                  (CC (CDR (RMB (CDR X)))))
              (<= (CC (RMB (CDR X))) (CC (CDR X))))
         (<= (CC (RMB X)) (CC X))).

This simplifies, using the :definitions CC and RMB, the :executable-
counterpart of CC, primitive type reasoning, the :meta rule 
CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS and CDR-CONS,
to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X))))
                 (+ 1 (CC (CAR X)) (CC (CDR X))))
              (<= (CC (CDR X))
                  (CC (RMB (CDR (RMB (CDR X))))))
              (<= (CC (RMB (CDR (RMB (CDR X)))))
                  (CC (CDR (RMB (CDR X)))))
              (<= (CC (RMB (CDR X))) (CC (CDR X))))
         (<= 0 (+ 1 (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X)))) (CC X))
              (< (CC (CONS (CAR X)
                           (RMB (CDR (RMB (CDR X))))))
                 (CC X))
              (<= (CC (RMB (CDR X))) (CC (CDR X)))
              (<= (CC (RMB (CONS (CAR X)
                                 (RMB (CDR (RMB (CDR X)))))))
                  (CC (CONS (CAR X)
                            (RMB (CDR (RMB (CDR X)))))))
              (<= (CC (RMB (CDR (RMB (CDR X)))))
                  (CC (CDR (RMB (CDR X))))))
         (<= (CC (RMB X)) (CC X))).

This simplifies, using the :definitions CC and RMB, primitive type
reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite
rules CAR-CONS and CDR-CONS, to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X))))
                 (+ 1 (CC (CAR X)) (CC (CDR X))))
              (< (CC (RMB (CDR (RMB (CDR X)))))
                 (CC (CDR X)))
              (<= (CC (RMB (CDR X))) (CC (CDR X)))
              (<= (CC (RMB (CONS (CAR X)
                                 (RMB (CDR (RMB (CDR X)))))))
                  (+ 1 (CC (CAR X))
                     (CC (RMB (CDR (RMB (CDR X)))))))
              (<= (CC (RMB (CDR (RMB (CDR X)))))
                  (CC (CDR (RMB (CDR X))))))
         (<= (+ (CC (CAR (RMB (CDR X))))
                (CC (RMB (CONS (CAR X)
                               (RMB (CDR (RMB (CDR X))))))))
             (+ (CC (CAR X)) (CC (CDR X))))).

This simplifies, using the :definitions CC (if-intro), FIX, RMB and
SYNP, the :executable-counterparts of <, BINARY-+, CC, CONSP and RMB,
primitive type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT,
the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-+, DEFAULT-CAR,
DEFAULT-CDR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription
rules CC and RMB, to the following two conjectures.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X))))
                 (+ 1 (CC (CAR X)) (CC (CDR X))))
              (< (CC (RMB (CDR (RMB (CDR X)))))
                 (CC (CDR X)))
              (CONSP (RMB (CDR X)))
              (<= (+ 1 (CC (CAR (RMB (CDR X))))
                     (CC (CDR (RMB (CDR X)))))
                  (CC (CDR X)))
              (<= (CC (RMB (CONS (CAR X)
                                 (RMB (CDR (RMB (CDR X)))))))
                  (+ 1 (CC (CAR X))
                     (CC (RMB (CDR (RMB (CDR X)))))))
              (<= (CC (RMB (CDR (RMB (CDR X)))))
                  (CC (CDR (RMB (CDR X))))))
         (<= (+ (CC (CAR (RMB (CDR X))))
                (CC (RMB (CONS (CAR X)
                               (RMB (CDR (RMB (CDR X))))))))
             (+ (CC (CAR X)) (CC (CDR X))))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X))))
                 (+ 1 (CC (CAR X)) (CC (CDR X))))
              (< (CC (RMB (CDR (RMB (CDR X)))))
                 (CC (CDR X)))
              (NOT (CONSP (RMB (CDR X))))
              (<= 0 (CC (CDR X))))
         (<= 1 (CC (CDR X)))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-130B ...)
Rules: ((:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION RMB)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART RMB)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RMB)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC)
        (:TYPE-PRESCRIPTION RMB))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION CC))
PROBLEM-130B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-130B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-130B)
PROBLEM-130B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-130B ...) ...)
Rules: NIL
 PROBLEM-130B
ACL2 !>>(THEOREM
             PROBLEM-130C
             (IMPLIES (CONSP X) (CONSP (RMB X)))
             :HINTS (("Goal" :INDUCT (RMB X)
                             :IN-THEORY (ENABLE PROBLEM-108C
                                                PROBLEM-130A PROBLEM-130B))))


ACL2 !>>>(DEFTHM PROBLEM-130C
           (IMPLIES (CONSP X) (CONSP (RMB X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (RMB X)
                           :IN-THEORY (ENABLE PROBLEM-108C
                                              PROBLEM-130A PROBLEM-130B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RMB X).

This suggestion was produced using the :induction rule RMB.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (<= (CC X) (CC (CDR (RMB (CDR X)))))
                   (:P (CDR X)))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (< (CC (CDR (RMB (CDR X)))) (CC X))
                   (<= (CC X)
                       (CC (CONS (CAR X)
                                 (RMB (CDR (RMB (CDR X)))))))
                   (:P (CDR (RMB (CDR X))))
                   (:P (CDR X)))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (< (CC (CDR (RMB (CDR X)))) (CC X))
                   (< (CC (CONS (CAR X)
                                (RMB (CDR (RMB (CDR X))))))
                      (CC X))
                   (:P (CDR X))
                   (:P (CONS (CAR X)
                             (RMB (CDR (RMB (CDR X))))))
                   (:P (CDR (RMB (CDR X)))))
              (:P X))).
This induction is justified by the same argument used to admit RMB.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.

Subgoal *1/4
(IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
         (IMPLIES (CONSP X) (CONSP (RMB X)))).

By case analysis we reduce the conjecture to

Subgoal *1/4'
(IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
         (CONSP (RMB X))).

But simplification reduces this to T, using the :definition RMB and
primitive type reasoning.

Subgoal *1/3
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (<= (CC X) (CC (CDR (RMB (CDR X)))))
              (IMPLIES (CONSP (CDR X))
                       (CONSP (RMB (CDR X)))))
         (IMPLIES (CONSP X) (CONSP (RMB X)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (<= (CC X) (CC (CDR (RMB (CDR X)))))
              (IMPLIES (CONSP (CDR X))
                       (CONSP (RMB (CDR X)))))
         (CONSP (RMB X))).

But simplification reduces this to T, using linear arithmetic, the
:linear rules PROBLEM-108C, PROBLEM-130A and PROBLEM-130B and the :type-
prescription rules CC and RMB.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X)))) (CC X))
              (<= (CC X)
                  (CC (CONS (CAR X)
                            (RMB (CDR (RMB (CDR X)))))))
              (IMPLIES (CONSP (CDR (RMB (CDR X))))
                       (CONSP (RMB (CDR (RMB (CDR X))))))
              (IMPLIES (CONSP (CDR X))
                       (CONSP (RMB (CDR X)))))
         (IMPLIES (CONSP X) (CONSP (RMB X)))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X)))) (CC X))
              (<= (CC X)
                  (CC (CONS (CAR X)
                            (RMB (CDR (RMB (CDR X)))))))
              (IMPLIES (CONSP (CDR (RMB (CDR X))))
                       (CONSP (RMB (CDR (RMB (CDR X))))))
              (IMPLIES (CONSP (CDR X))
                       (CONSP (RMB (CDR X)))))
         (CONSP (RMB X))).

This simplifies (dropping false conclusion; see :DOC clause), using
the :definitions CC and RMB, the :executable-counterpart of CONSP,
primitive type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule CC, to the following two conjectures.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X))))
                 (+ 1 (CC (CAR X)) (CC (CDR X))))
              (<= (CC (CDR X))
                  (CC (RMB (CDR (RMB (CDR X))))))
              (NOT (CONSP (CDR (RMB (CDR X))))))
         (NOT (CONSP (RMB (CDR X))))).

This simplifies (dropping false conclusion; see :DOC clause), using
the :definitions CC and RMB, the :executable-counterparts of CC and
CONSP, primitive type reasoning and the :type-prescription rule CC,
to

Subgoal *1/2.2'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< 0 (+ 1 (CC (CAR X)) (CC (CDR X))))
              (<= (CC (CDR X)) 0)
              (NOT (CONSP (CDDR X))))
         (CONSP (CDR (LIST (CADR X))))).

By the :executable-counterpart of CONSP and the simple :rewrite rule
CDR-CONS we reduce the conjecture to

Subgoal *1/2.2''
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< 0 (+ 1 (CC (CAR X)) (CC (CDR X))))
              (<= (CC (CDR X)) 0))
         (CONSP (CDDR X))).

This simplifies, using the :executable-counterpart of <, linear arithmetic
and the :type-prescription rule CC, to

Subgoal *1/2.2'''
(IMPLIES (AND (EQUAL (CC (CDR X)) 0)
              (CONSP X)
              (CONSP (CDR X))
              (< 0 (+ 1 (CC (CAR X)) 0)))
         (CONSP (CDDR X))).

This simplifies, using the :definition FIX, the :rewrite rules 
COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription rule
CC, to

Subgoal *1/2.2'4'
(IMPLIES (AND (EQUAL (CC (CDR X)) 0)
              (CONSP X)
              (CONSP (CDR X))
              (< 0 (+ 1 (CC (CAR X)))))
         (CONSP (CDDR X))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2.  (2) Use CAR-CDR-ELIM, again, to replace X2
by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  These steps produce
the following goal.

Subgoal *1/2.2'5'
(IMPLIES (AND (CONSP (CONS X3 X4))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL (CC (CONS X3 X4)) 0)
              (< 0 (+ 1 (CC X1))))
         (CONSP X4)).

But simplification reduces this to T, using the :definitions CC and
FIX, primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS,
COMMUTATIVITY-OF-+ and UNICITY-OF-0 and the :type-prescription rule
CC.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X))))
                 (+ 1 (CC (CAR X)) (CC (CDR X))))
              (<= (CC (CDR X))
                  (CC (RMB (CDR (RMB (CDR X))))))
              (CONSP (RMB (CDR (RMB (CDR X))))))
         (NOT (CONSP (RMB (CDR X))))).

But simplification reduces this to T, using linear arithmetic, the
:linear rules PROBLEM-108C and PROBLEM-130B and the :type-prescription
rules CC and RMB.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X)))) (CC X))
              (< (CC (CONS (CAR X)
                           (RMB (CDR (RMB (CDR X))))))
                 (CC X))
              (IMPLIES (CONSP (CDR X))
                       (CONSP (RMB (CDR X))))
              (IMPLIES (CONSP (CONS (CAR X)
                                    (RMB (CDR (RMB (CDR X))))))
                       (CONSP (RMB (CONS (CAR X)
                                         (RMB (CDR (RMB (CDR X))))))))
              (IMPLIES (CONSP (CDR (RMB (CDR X))))
                       (CONSP (RMB (CDR (RMB (CDR X)))))))
         (IMPLIES (CONSP X) (CONSP (RMB X)))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (< (CC (CDR (RMB (CDR X)))) (CC X))
              (< (CC (CONS (CAR X)
                           (RMB (CDR (RMB (CDR X))))))
                 (CC X))
              (IMPLIES (CONSP (CDR X))
                       (CONSP (RMB (CDR X))))
              (IMPLIES (CONSP (CONS (CAR X)
                                    (RMB (CDR (RMB (CDR X))))))
                       (CONSP (RMB (CONS (CAR X)
                                         (RMB (CDR (RMB (CDR X))))))))
              (IMPLIES (CONSP (CDR (RMB (CDR X))))
                       (CONSP (RMB (CDR (RMB (CDR X)))))))
         (CONSP (RMB X))).

But simplification reduces this to T, using the :definitions CC and
RMB, primitive type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT,
the :rewrite rules CAR-CONS and CDR-CONS and the :type-prescription
rule CC.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-130C ...)
Rules: ((:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION RMB)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RMB)
        (:LINEAR PROBLEM-108C)
        (:LINEAR PROBLEM-130A)
        (:LINEAR PROBLEM-130B)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC)
        (:TYPE-PRESCRIPTION RMB))
PROBLEM-130C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-130C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-130C)
PROBLEM-130C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-130C ...) ...)
Rules: NIL
 PROBLEM-130C
ACL2 !>>(THEOREM
             PROBLEM-130
             (EQUAL (RMB X)
                    (IF (CONSP X)
                        (IF (CONSP (CDR X))
                            (CONS (CAR (RMB (CDR X)))
                                  (RMB (CONS (CAR X)
                                             (RMB (CDR (RMB (CDR X)))))))
                          (CONS (CAR X) NIL))
                      NIL))
             :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-108C
                                                PROBLEM-130B PROBLEM-130C)))
             :RULE-CLASSES ((:DEFINITION :CONTROLLER-ALIST ((RMB T)))))


ACL2 !>>>(DEFTHM PROBLEM-130
           (EQUAL (RMB X)
                  (IF (CONSP X)
                      (IF (CONSP (CDR X))
                          (CONS (CAR (RMB (CDR X)))
                                (RMB (CONS (CAR X)
                                           (RMB (CDR (RMB (CDR X)))))))
                        (CONS (CAR X) NIL))
                    NIL))
           :RULE-CLASSES ((:DEFINITION :CONTROLLER-ALIST ((RMB T))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-108C
                                              PROBLEM-130B PROBLEM-130C))))

[Note:  A hint was supplied for the goal above.  Thanks!]

This simplifies, using the :definitions CC and RMB (if-intro), primitive
type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite
rules CAR-CONS and CDR-CONS, to the following two conjectures.

Subgoal 2
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (<= (+ 1 (CC (CAR X)) (CC (CDR X)))
                  (CC (CDR (RMB (CDR X))))))
         (EQUAL 'UNDEF
                (CONS (CAR (RMB (CDR X)))
                      (RMB (CONS (CAR X)
                                 (RMB (CDR (RMB (CDR X))))))))).

This simplifies (dropping false conclusion; see :DOC clause), using
primitive type reasoning, to

Subgoal 2'
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (< (CC (CDR (RMB (CDR X))))
            (+ 1 (CC (CAR X)) (CC (CDR X))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rules PROBLEM-108C and PROBLEM-130B, the
:rewrite rule PROBLEM-130C and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (<= (CC (CDR X))
                  (CC (RMB (CDR (RMB (CDR X)))))))
         (EQUAL 'UNDEF
                (CONS (CAR (RMB (CDR X)))
                      (RMB (CONS (CAR X)
                                 (RMB (CDR (RMB (CDR X))))))))).

This simplifies (dropping false conclusion; see :DOC clause), using
primitive type reasoning, to

Subgoal 1'
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (< (CC (RMB (CDR (RMB (CDR X)))))
            (CC (CDR X)))).

But simplification reduces this to T, using linear arithmetic, the
:linear rules PROBLEM-108C and PROBLEM-130B, the :rewrite rule PROBLEM-130C
and the :type-prescription rule CC.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-130 ...)
Rules: ((:DEFINITION CC)
        (:DEFINITION RMB)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR PROBLEM-108C)
        (:LINEAR PROBLEM-130B)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-130C)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION RMB))
PROBLEM-130


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-130))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-130)
PROBLEM-130

Summary
Form:  ( PROGN (DEFTHM PROBLEM-130 ...) ...)
Rules: NIL
 PROBLEM-130
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 131.

; Basically, just use the facts we already know about app and rev,
; plus induction hypotheses that the rmb calls are rev calls,
; to prove the theorem.  The proof requires some
; knowledge of proper lists, since our lemmas about app and rev
; involve that concept.  In particular, we need:
"
ACL2 !>>(THEOREM PROBLEM-131A
                 (EQUAL (PROPER (CDR X))
                        (OR (ATOM X) (PROPER X))))


ACL2 !>>>(DEFTHM PROBLEM-131A
           (EQUAL (PROPER (CDR X))
                  (OR (ATOM X) (PROPER X)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE))))

[Note:  A hint was supplied for the goal above.  Thanks!]

This simplifies, using the :definitions ATOM and PROPER, to

Goal'
(IMPLIES (NOT (CONSP X))
         (EQUAL (PROPER (CDR X)) T)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-131A ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION PROPER)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM))
PROBLEM-131A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-131A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-131A)
PROBLEM-131A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-131A ...) ...)
Rules: NIL
 PROBLEM-131A
ACL2 !>>:----- 
"
; Informally, that's enough to do the proof if you could just
; do an induction to unwind rmb.  But we haven't proved the
; measure conjectures about the rmb recursion.  Rather than
; try that, we take a nice short cut.  Since we are going to
; be proving that rmb is rev, we will prove the measure conjectures
; about the rmb recursion -- but we'll substitute rev calls for
; each rmb call.  That is what the hint below does.  We need
; a few lemmas.
"
ACL2 !>>(THEOREM PROBLEM-131B
                 (<= (CC (APP A B)) (+ (CC A) (CC B)))
                 :HINTS (("Goal" :INDUCT (CC A)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-131B
           (<= (CC (APP A B)) (+ (CC A) (CC B)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (CC A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (CC A).

This suggestion was produced using the :induction rule CC.  If we let
(:P A B) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP A)) (:P A B))
     (IMPLIES (AND (CONSP A)
                   (:P (CAR A) B)
                   (:P (CDR A) B))
              (:P A B))).
This induction is justified by the same argument used to admit CC.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (<= (CC (APP A B)) (+ (CC A) (CC B)))).

This simplifies, using the :definitions APP, CC and FIX, the :rewrite
rule UNICITY-OF-0 and the :type-prescription rule CC, to

Subgoal *1/2'
(IMPLIES (NOT (CONSP A))
         (<= (CC B) (CC B))).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (<= (CC (APP (CAR A) B))
                  (+ (CC (CAR A)) (CC B)))
              (<= (CC (APP (CDR A) B))
                  (+ (CC (CDR A)) (CC B))))
         (<= (CC (APP A B)) (+ (CC A) (CC B)))).

But simplification reduces this to T, using the :definitions APP and
CC, primitive type reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT
and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+ and
COMMUTATIVITY-OF-+.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-131B ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION CC)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
PROBLEM-131B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-131B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-131B)
PROBLEM-131B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-131B ...) ...)
Rules: NIL
 PROBLEM-131B
ACL2 !>>(THEOREM PROBLEM-131C (<= (CC (REV X)) (CC X))
                 :HINTS (("Goal" :INDUCT (CC X)
                                 :IN-THEORY (ENABLE PROBLEM-131B)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-131C
           (<= (CC (REV X)) (CC X))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (CC X)
                           :IN-THEORY (ENABLE PROBLEM-131B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (CC X).

This suggestion was produced using the :induction rule CC.  If we let
(:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X)
                   (:P (CAR X))
                   (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit CC.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (<= (CC (REV X)) (CC X))).

But simplification reduces this to T, using the :definitions CC and
REV and the :executable-counterparts of < and CC.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (<= (CC (REV (CAR X))) (CC (CAR X)))
              (<= (CC (REV (CDR X))) (CC (CDR X))))
         (<= (CC (REV X)) (CC X))).

This simplifies, using the :definitions CC and REV, to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (<= (CC (REV (CAR X))) (CC (CAR X)))
              (<= (CC (REV (CDR X))) (CC (CDR X))))
         (<= (CC (APP (REV (CDR X)) (LIST (CAR X))))
             (+ 1 (CC (CAR X)) (CC (CDR X))))).

But simplification reduces this to T, using the :definitions CC and
FIX, the :executable-counterpart of CC, linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-131B, the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and UNICITY-OF-0
and the :type-prescription rule CC.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-131C ...)
Rules: ((:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION REV)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART CC)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION CC)
        (:LINEAR PROBLEM-131B)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
PROBLEM-131C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-131C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-131C)
PROBLEM-131C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-131C ...) ...)
Rules: NIL
 PROBLEM-131C
ACL2 !>>(THEOREM PROBLEM-131D
                 (EQUAL (CONSP (REV X)) (CONSP X))
                 :HINTS (("Goal" :INDUCT (REV X))))


ACL2 !>>>(DEFTHM PROBLEM-131D
           (EQUAL (CONSP (REV X)) (CONSP X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (REV X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (REV X).

This suggestion was produced using the :induction rule REV.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit REV.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP X))
         (EQUAL (CONSP (REV X)) (CONSP X))).

But simplification reduces this to T, using the :definition REV and
the :executable-counterparts of CONSP and EQUAL.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (CONSP (REV (CDR X)))
                     (CONSP (CDR X))))
         (EQUAL (CONSP (REV X)) (CONSP X))).

But simplification reduces this to T, using the :definition REV, the
:executable-counterpart of EQUAL, primitive type reasoning and the
:type-prescription rule APP.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-131D ...)
Rules: ((:DEFINITION REV)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION REV)
        (:TYPE-PRESCRIPTION APP))
PROBLEM-131D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-131D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-131D)
PROBLEM-131D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-131D ...) ...)
Rules: NIL
 PROBLEM-131D
ACL2 !>>(DEFUN RMB-HINT (X)
         (DECLARE
          (XARGS
            :MEASURE (CC X)
            :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-108C PROBLEM-130A
                                               PROBLEM-131C PROBLEM-131D)))))
         (IF (CONSP X)
             (IF (CONSP (CDR X))
                 (LIST (RMB-HINT (CDR X))
                       (RMB-HINT (CDR (REV (CDR X))))
                       (RMB-HINT (CONS (CAR X)
                                       (REV (CDR (REV (CDR X)))))))
               X)
           X))

For the admission of RMB-HINT we will use the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (AND (CONSP X) (CONSP (CDR X)))
              (O< (CC (CDR (REV (CDR X)))) (CC X)))
     (IMPLIES (AND (CONSP X) (CONSP (CDR X)))
              (O< (CC (CDR X)) (CC X)))
     (IMPLIES (AND (CONSP X) (CONSP (CDR X)))
              (O< (CC (CONS (CAR X)
                            (REV (CDR (REV (CDR X))))))
                  (CC X)))).

[Note:  A hint was supplied for the goal above.  Thanks!]

By case analysis we reduce the conjecture to the following four conjectures.

Subgoal 4
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 3
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (CC (CDR (REV (CDR X)))) (CC X))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, linear arithmetic, the :linear rules PROBLEM-108C,
PROBLEM-130A and PROBLEM-131C, the :rewrite rules O-FINP-< and PROBLEM-131D
and the :type-prescription rule CC.

Subgoal 2
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (CC (CDR X)) (CC X))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, linear arithmetic, the :linear rule PROBLEM-108C, the
:rewrite rule O-FINP-< and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (AND (CONSP X) (CONSP (CDR X)))
         (O< (CC (CONS (CAR X)
                       (REV (CDR (REV (CDR X))))))
             (CC X))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, the :definition CC, linear arithmetic, primitive type
reasoning, the :linear rules PROBLEM-108C and PROBLEM-131C, the :rewrite
rules CAR-CONS, CDR-CONS, O-FINP-< and PROBLEM-131D and the :type-
prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for RMB-HINT.  Thus,
we admit this function under the principle of definition.  We observe
that the type of RMB-HINT is described by the theorem 
(OR (AND (CONSP (RMB-HINT X))
         (TRUE-LISTP (RMB-HINT X)))
    (EQUAL (RMB-HINT X) X)).
We used primitive type reasoning.

Summary
Form:  ( DEFUN RMB-HINT ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION CC)
        (:DEFINITION NOT)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:LINEAR PROBLEM-108C)
        (:LINEAR PROBLEM-130A)
        (:LINEAR PROBLEM-131C)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE O-FINP-<)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE PROBLEM-131D)
        (:TYPE-PRESCRIPTION CC))
 RMB-HINT
ACL2 !>>(THEOREM
             PROBLEM-131 (EQUAL (RMB X) (REV X))
             :HINTS
             (("Goal" :INDUCT (RMB-HINT X)
                      :IN-THEORY (ENABLE PROBLEM-44B PROBLEM-44 PROBLEM-130
                                         PROBLEM-131A PROBLEM-131D))))


ACL2 !>>>(DEFTHM PROBLEM-131
           (EQUAL (RMB X) (REV X))
           :HINTS
           (("Goal" :DO-NOT-INDUCT T
                    :DO-NOT '(GENERALIZE)
                    :INDUCT (RMB-HINT X)
                    :IN-THEORY (ENABLE PROBLEM-44B PROBLEM-44 PROBLEM-130
                                       PROBLEM-131A PROBLEM-131D))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (RMB-HINT X).

This suggestion was produced using the :induction rule RMB-HINT.  If
we let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
              (:P X))
     (IMPLIES (AND (CONSP X)
                   (CONSP (CDR X))
                   (:P (CDR X))
                   (:P (CDR (REV (CDR X))))
                   (:P (CONS (CAR X)
                             (REV (CDR (REV (CDR X)))))))
              (:P X))).
This induction is justified by the same argument used to admit RMB-HINT.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (CONSP X))
         (EQUAL (RMB X) (REV X))).

But simplification reduces this to T, using the :definitions PROBLEM-130
and REV and the :executable-counterpart of EQUAL.

Subgoal *1/2
(IMPLIES (AND (CONSP X) (NOT (CONSP (CDR X))))
         (EQUAL (RMB X) (REV X))).

But simplification reduces this to T, using the :definitions APP, PROBLEM-130
and REV, primitive type reasoning and the :rewrite rule PROBLEM-131D.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (EQUAL (RMB (CDR X)) (REV (CDR X)))
              (EQUAL (RMB (CDR (REV (CDR X))))
                     (REV (CDR (REV (CDR X)))))
              (EQUAL (RMB (CONS (CAR X)
                                (REV (CDR (REV (CDR X))))))
                     (REV (CONS (CAR X)
                                (REV (CDR (REV (CDR X))))))))
         (EQUAL (RMB X) (REV X))).

This simplifies, using the :definitions ATOM, PROBLEM-130 and REV,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
PROBLEM-131A, PROBLEM-131D, PROBLEM-44 and PROBLEM-44B, to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (CONSP (CDR X))
              (EQUAL (RMB (CDR X)) (REV (CDR X)))
              (EQUAL (RMB (CDR (REV (CDR X))))
                     (REV (CDR (REV (CDR X)))))
              (EQUAL (RMB (CONS (CAR X)
                                (REV (CDR (REV (CDR X))))))
                     (APP (CDR (REV (CDR X)))
                          (LIST (CAR X)))))
         (EQUAL (CONS (CAR (REV (CDR X)))
                      (APP (CDR (REV (CDR X)))
                           (LIST (CAR X))))
                (APP (REV (CDR X)) (LIST (CAR X))))).

But simplification reduces this to T, using the :definition APP, primitive
type reasoning and the :rewrite rule PROBLEM-131D.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-131 ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION ATOM)
        (:DEFINITION PROBLEM-130)
        (:DEFINITION REV)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION RMB-HINT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE PROBLEM-131A)
        (:REWRITE PROBLEM-131D)
        (:REWRITE PROBLEM-44)
        (:REWRITE PROBLEM-44B))
PROBLEM-131


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-131))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-131)
PROBLEM-131

Summary
Form:  ( PROGN (DEFTHM PROBLEM-131 ...) ...)
Rules: NIL
 PROBLEM-131
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 132.
"
ACL2 !>>(DEFUN IF-EXPRP (X)
          (AND (CONSP X) (EQUAL (CAR X) 'IF)))

Since IF-EXPRP is non-recursive, its admission is trivial.  We observe
that the type of IF-EXPRP is described by the theorem 
(OR (EQUAL (IF-EXPRP X) T) (EQUAL (IF-EXPRP X) NIL)).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN IF-EXPRP ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 IF-EXPRP
ACL2 !>>(DEFUN A1 (X) (CADR X))

Since A1 is non-recursive, its admission is trivial.  We could deduce
no constraints on the type of A1.

Summary
Form:  ( DEFUN A1 ...)
Rules: NIL
 A1
ACL2 !>>(DEFUN A2 (X) (CADDR X))

Since A2 is non-recursive, its admission is trivial.  We could deduce
no constraints on the type of A2.

Summary
Form:  ( DEFUN A2 ...)
Rules: NIL
 A2
ACL2 !>>(DEFUN A3 (X) (CADDDR X))

Since A3 is non-recursive, its admission is trivial.  We could deduce
no constraints on the type of A3.

Summary
Form:  ( DEFUN A3 ...)
Rules: NIL
 A3
ACL2 !>>:----- 
"
; In ACL2, (ASSOC-EQUAL x alist) finds the first pair in alist whose
; car is equal to x.  We use it below.
"
ACL2 !>>(DEFUN ASSIGNMENT (VAR ALIST)
          (IF (QUOTEP VAR)
              (CAR (CDR VAR))
            (CDR (ASSOC-EQUAL VAR ALIST))))

Since ASSIGNMENT is non-recursive, its admission is trivial.  We could
deduce no constraints on the type of ASSIGNMENT.

Summary
Form:  ( DEFUN ASSIGNMENT ...)
Rules: NIL
 ASSIGNMENT
ACL2 !>>:----- 
"
; We can't call our evaluator eval because that is a pre-defined
; Common Lisp function.  We use peval instead; it stands for
; ``propositional evaluator.''
"
ACL2 !>>(DEFUN PEVAL (X ALIST)
          (DECLARE (XARGS :MEASURE (CC X)))
          (COND ((IF-EXPRP X)
                 (IF (PEVAL (A1 X) ALIST)
                     (PEVAL (A2 X) ALIST)
                   (PEVAL (A3 X) ALIST)))
                (T (ASSIGNMENT X ALIST))))

For the admission of PEVAL we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (IF-EXPRP X)
              (O< (CC (A1 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X) (PEVAL (A1 X) ALIST))
              (O< (CC (A2 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (PEVAL (A1 X) ALIST)))
              (O< (CC (A3 X)) (CC X)))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to the following four conjectures.

Subgoal 4
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 3
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (O< (CC (CADR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC, FIX and O<, the :executable-counterpart of CC, primitive
type reasoning, the :rewrite rule UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3'
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (< (CC (CADR X)) (+ 1 (CC (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  These
steps produce the following two goals.

Subgoal 3.2
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CAR X2)) (+ 1 (CC X2)))).

By case analysis we reduce the conjecture to

Subgoal 3.2'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CAR X2)) (+ 1 (CC X2)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CAR.

Subgoal 3.1
(IMPLIES (AND (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC X3) (+ 1 (CC (CONS X3 X4))))).

By case analysis we reduce the conjecture to

Subgoal 3.1'
(IMPLIES (AND (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC X3) (+ 1 (CC (CONS X3 X4))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS and FOLD-CONSTS-IN-+, to

Subgoal 3.1''
(< 0 (+ 2 (CC X4))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST))
         (O< (CC (CADDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro), FIX and O< (if-intro), the :executable-
counterpart of CC, primitive type reasoning, the :rewrite rule UNICITY-OF-0
and the :type-prescription rule CC, to the following two conjectures.

Subgoal 2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 2.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following two goals.

Subgoal 2.2.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (PEVAL X3 ALIST))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 2.2.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (PEVAL X3 ALIST))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 2.2.2''
(IMPLIES (AND (NOT (CONSP X4)) (PEVAL X3 ALIST))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.2.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (PEVAL X3 ALIST))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.2.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (PEVAL X3 ALIST))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 2.2.1''
(IMPLIES (PEVAL X3 ALIST)
         (< 0 (+ 3 (CC X3) (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR and CC and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST)))
         (O< (CC (CADDDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro), FIX and O< (if-intro), the :executable-
counterpart of CC, primitive type reasoning, the :rewrite rule UNICITY-OF-0
and the :type-prescription rule CC, to the following two conjectures.

Subgoal 1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 1.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
three goals.

Subgoal 1.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (PEVAL X3 ALIST)))
         (< (CC (CADR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 1.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (PEVAL X3 ALIST)))
         (< (CC (CADR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CAR, CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CDR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.2.3''
(IMPLIES (AND (NOT (CONSP X4))
              (NOT (PEVAL X3 ALIST)))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (PEVAL X3 ALIST)))
         (< (CC (CAR X6))
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 1.2.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (PEVAL X3 ALIST)))
         (< (CC (CAR X6))
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.2.2''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (PEVAL X3 ALIST)))
         (< 0 (+ 3 (CC X3) (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (PEVAL X3 ALIST)))
         (< (CC X7)
            (+ 2 (CC X3) (CC (LIST* X5 X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.2.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (PEVAL X3 ALIST)))
         (< (CC X7)
            (+ 2 (CC X3) (CC (LIST* X5 X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 1.2.1''
(IMPLIES (NOT (PEVAL X3 ALIST))
         (< 0 (+ 4 (CC X3) (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and CDR and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Q.E.D.

That completes the proof of the measure theorem for PEVAL.  Thus, we
admit this function under the principle of definition.  We could deduce
no constraints on the type of PEVAL.

Summary
Form:  ( DEFUN PEVAL ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION CC) (:DEFINITION O<))
 PEVAL
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 133.

; Here is the definition of IF-normal form:
"
ACL2 !>>(DEFUN NORMP (X)
          (DECLARE (XARGS :MEASURE (CC X)))
          (IF (IF-EXPRP X)
              (AND (NOT (IF-EXPRP (A1 X)))
                   (NORMP (A2 X))
                   (NORMP (A3 X)))
            T))

For the admission of NORMP we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (IF-EXPRP (A1 X))))
              (O< (CC (A2 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (IF-EXPRP (A1 X)))
                   (NORMP (A2 X)))
              (O< (CC (A3 X)) (CC X)))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to the following three conjectures.

Subgoal 3
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (IF-EXPRP (CADR X))))
         (O< (CC (CADDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro), FIX, IF-EXPRP (if-intro) and O< (if-intro),
the :executable-counterpart of CC, primitive type reasoning, the :rewrite
rule UNICITY-OF-0 and the :type-prescription rule CC, to the following
four conjectures.

Subgoal 2.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 2.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDR X)) (+ 2 (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following two goals.

Subgoal 2.4.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 2.4.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CAR.

Subgoal 2.4.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.4.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS and FOLD-CONSTS-IN-+, to

Subgoal 2.4.1''
(IMPLIES (NOT (CONSP X3))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and CONSP and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 2.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
three goals.

Subgoal 2.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 2.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 2.2.3''
(IMPLIES (AND (NOT (CONSP X4))
              (NOT (EQUAL (CAR X3) 'IF)))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 2.2.2''
(IMPLIES (NOT (CONSP X3))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.2.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.2.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 2.2.1''
(IMPLIES (NOT (EQUAL X4 'IF))
         (< 0 (+ 4 (CC X4) (CC X6) (CC X7)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and EQUAL and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (IF-EXPRP (CADR X)))
              (NORMP (CADDR X)))
         (O< (CC (CADDDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro), FIX (if-intro), IF-EXPRP (if-intro) and
O< (if-intro), the :executable-counterpart of CC, primitive type reasoning,
the :rewrite rule UNICITY-OF-0 and the :type-prescription rule CC,
to the following six conjectures.

Subgoal 1.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :definition HIDE, the
:executable-counterparts of <, CAR, CC, CDR and CONSP and the :rewrite
rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 1 (CC (CADDR X))
               (CC (CDDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 1.5'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CADDR X)) (CC (CDDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
two goals.

Subgoal 1.5.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NORMP X5))
         (< (CC (CAR X6))
            (+ 3 (CC X5) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.5.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NORMP X5))
         (< (CC (CAR X6))
            (+ 3 (CC X5) (CC X6)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.5.2''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (CONSP X3))
              (NORMP X5))
         (< 0 (+ 3 (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.5.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NORMP X5))
         (< (CC X7)
            (+ 3 (CC X5) (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.5.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NORMP X5))
         (< (CC X7)
            (+ 3 (CC X5) (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 1.5.1''
(IMPLIES (AND (NOT (CONSP X3)) (NORMP X5))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< (CC (CADDDR X)) 2)).

But simplification reduces this to T, using the :definition HIDE, the
:executable-counterparts of <, CAR and CC and the :rewrite rules DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :definition HIDE, the
:executable-counterparts of <, CAR, CC, CDR and EQUAL and the :rewrite
rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X))
               1 (CC (CADDR X))
               (CC (CDDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 1.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CADR X))
               (CC (CADDR X))
               (CC (CDDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following three goals.

Subgoal 1.2.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NORMP X5))
         (< (CC (CAR X6))
            (+ 3 (CC X3) (CC X5) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.2.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NORMP X5))
         (< (CC (CAR X6))
            (+ 3 (CC X3) (CC X5) (CC X6)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.2.3''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (EQUAL (CAR X3) 'IF))
              (NORMP X5))
         (< 0 (+ 3 (CC X3) (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NORMP X5))
         (< (CC X7)
            (+ 3 (CC X3)
               (CC X5)
               (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NORMP X5))
         (< (CC X7)
            (+ 3 (CC X3)
               (CC X5)
               (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 1.2.2''
(IMPLIES (AND (NOT (CONSP X3)) (NORMP X5))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (NORMP X5))
         (< (CC X7)
            (+ 3 (CC (CONS X4 X6))
               (CC X5)
               (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.2.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (NORMP X5))
         (< (CC X7)
            (+ 3 (CC (CONS X4 X6))
               (CC X5)
               (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 1.2.1''
(IMPLIES (AND (NOT (EQUAL X4 'IF)) (NORMP X5))
         (< 0
            (+ 5 (CC X4) (CC X5) (CC X6) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) 0))).

This simplifies, using the :definitions FIX, HIDE and SYNP, the :executable-
counterparts of BINARY-+, CAR and CC, the :rewrite rules COMMUTATIVITY-OF-+,
DEFAULT-CAR, DEFAULT-CDR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the
:type-prescription rule CC, to

Subgoal 1.1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (HIDE (NORMP NIL))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< 0 (+ 2 (CC (CADR X))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for NORMP.  Thus, we
admit this function under the principle of definition.  We observe
that the type of NORMP is described by the theorem 
(OR (EQUAL (NORMP X) T) (EQUAL (NORMP X) NIL)).  

Summary
Form:  ( DEFUN NORMP ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION HIDE)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION CC)
             (:DEFINITION FIX)
             (:DEFINITION IF-EXPRP)
             (:DEFINITION O<))
 NORMP
ACL2 !>>:----- "
; To admit norm, we need some measures.
"
ACL2 !>>(DEFUN IF-DEPTH (X)
          (DECLARE (XARGS :MEASURE (CC X)))
          (IF (IF-EXPRP X)
              (+ 1 (IF-DEPTH (A1 X)))
            0))

For the admission of IF-DEPTH we will use the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (IF-EXPRP X)
              (O< (CC (A1 X)) (CC X)))).

By the simple :definitions A1 and IF-EXPRP we reduce the conjecture
to the following two conjectures.

Subgoal 2
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (O< (CC (CADR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC, FIX and O<, the :executable-counterpart of CC, primitive
type reasoning, the :rewrite rule UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 1'
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (< (CC (CADR X)) (+ 1 (CC (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  These
steps produce the following two goals.

Subgoal 1.2
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CAR X2)) (+ 1 (CC X2)))).

By case analysis we reduce the conjecture to

Subgoal 1.2'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CAR X2)) (+ 1 (CC X2)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CAR.

Subgoal 1.1
(IMPLIES (AND (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC X3) (+ 1 (CC (CONS X3 X4))))).

By case analysis we reduce the conjecture to

Subgoal 1.1'
(IMPLIES (AND (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC X3) (+ 1 (CC (CONS X3 X4))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS and FOLD-CONSTS-IN-+, to

Subgoal 1.1''
(< 0 (+ 2 (CC X4))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for IF-DEPTH.  Thus,
we admit this function under the principle of definition.  We observe
that the type of IF-DEPTH is described by the theorem 
(AND (INTEGERP (IF-DEPTH X)) (<= 0 (IF-DEPTH X))).  We used primitive
type reasoning.

Summary
Form:  ( DEFUN IF-DEPTH ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION A1)
        (:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
 IF-DEPTH
ACL2 !>>(DEFUN IF-COMPLEXITY (X)
          (DECLARE (XARGS :MEASURE (CC X)))
          (IF (IF-EXPRP X)
              (* (IF-COMPLEXITY (A1 X))
                 (+ (IF-COMPLEXITY (A2 X))
                    (IF-COMPLEXITY (A3 X))))
            1))

For the admission of IF-COMPLEXITY we will use the relation O< (which
is known to be well-founded on the domain recognized by O-P) and the
measure (CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (IF-EXPRP X)
              (O< (CC (A2 X)) (CC X)))
     (IMPLIES (IF-EXPRP X)
              (O< (CC (A1 X)) (CC X)))
     (IMPLIES (IF-EXPRP X)
              (O< (CC (A3 X)) (CC X)))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to the following four conjectures.

Subgoal 4
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 3
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (O< (CC (CADDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC, FIX and O<, the :executable-counterpart of CC, primitive
type reasoning, the :rewrite rule UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3'
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (< (CC (CADDR X)) (+ 1 (CC (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following three goals.

Subgoal 3.3
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CADR X2)) (+ 1 (CC X2)))).

By case analysis we reduce the conjecture to

Subgoal 3.3'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CADR X2)) (+ 1 (CC X2)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CAR, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CDR.

Subgoal 3.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC (CAR X4))
            (+ 1 (CC (CONS X3 X4))))).

By case analysis we reduce the conjecture to

Subgoal 3.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC (CAR X4))
            (+ 1 (CC (CONS X3 X4))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-+,
DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3.2''
(IMPLIES (NOT (CONSP X4))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF))
         (< (CC X5)
            (+ 1 (CC (LIST* X3 X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 3.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF))
         (< (CC X5)
            (+ 1 (CC (LIST* X3 X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 3.1''
(< 0 (+ 3 (CC X3) (CC X6))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (O< (CC (CADR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC, FIX and O<, the :executable-counterpart of CC, primitive
type reasoning, the :rewrite rule UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 2'
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (< (CC (CADR X)) (+ 1 (CC (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of two rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  These
steps produce the following two goals.

Subgoal 2.2
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CAR X2)) (+ 1 (CC X2)))).

By case analysis we reduce the conjecture to

Subgoal 2.2'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CAR X2)) (+ 1 (CC X2)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CAR.

Subgoal 2.1
(IMPLIES (AND (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC X3) (+ 1 (CC (CONS X3 X4))))).

By case analysis we reduce the conjecture to

Subgoal 2.1'
(IMPLIES (AND (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC X3) (+ 1 (CC (CONS X3 X4))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS and FOLD-CONSTS-IN-+, to

Subgoal 2.1''
(< 0 (+ 2 (CC X4))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (O< (CC (CADDDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC, FIX and O<, the :executable-counterpart of CC, primitive
type reasoning, the :rewrite rule UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 1'
(IMPLIES (AND (CONSP X) (EQUAL (CAR X) 'IF))
         (< (CC (CADDDR X)) (+ 1 (CC (CDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
four goals.

Subgoal 1.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CADDR X2)) (+ 1 (CC X2)))).

By case analysis we reduce the conjecture to

Subgoal 1.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF))
         (< (CC (CADDR X2)) (+ 1 (CC X2)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CAR, CC, CDR, EQUAL, NOT and
SYMBOLP, primitive type reasoning and the :rewrite rule DEFAULT-CDR.

Subgoal 1.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC (CADR X4))
            (+ 1 (CC (CONS X3 X4))))).

By case analysis we reduce the conjecture to

Subgoal 1.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF))
         (< (CC (CADR X4))
            (+ 1 (CC (CONS X3 X4))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CAR, CC, EQUAL, NOT and SYMBOLP, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-+,
DEFAULT-CDR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 1.3''
(IMPLIES (NOT (CONSP X4))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF))
         (< (CC (CAR X6))
            (+ 1 (CC (LIST* X3 X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 1.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF))
         (< (CC (CAR X6))
            (+ 1 (CC (LIST* X3 X5 X6))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.2''
(IMPLIES (NOT (CONSP X6))
         (< 0 (+ 3 (CC X3) (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF))
         (< (CC X7)
            (+ 1 (CC (LIST* X3 X5 X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF))
         (< (CC X7)
            (+ 1 (CC (LIST* X3 X5 X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 1.1''
(< 0 (+ 4 (CC X3) (CC X5) (CC X8))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for IF-COMPLEXITY.
Thus, we admit this function under the principle of definition.  We
observe that the type of IF-COMPLEXITY is described by the theorem
(AND (INTEGERP (IF-COMPLEXITY X)) (< 0 (IF-COMPLEXITY X))).  We used
primitive type reasoning.

Summary
Form:  ( DEFUN IF-COMPLEXITY ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
 IF-COMPLEXITY
ACL2 !>>(THEOREM PROBLEM-133A (<= 1 (IF-COMPLEXITY X))
                 :HINTS (("Goal" :INDUCT (IF-COMPLEXITY X)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-133A
           (<= 1 (IF-COMPLEXITY X))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (IF-COMPLEXITY X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (IF-COMPLEXITY X).

This suggestion was produced using the :induction rule IF-COMPLEXITY.
If we let (:P X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (IF-EXPRP X)) (:P X))
     (IMPLIES (AND (IF-EXPRP X)
                   (:P (A1 X))
                   (:P (A2 X))
                   (:P (A3 X)))
              (:P X))).
This induction is justified by the same argument used to admit IF-COMPLEXITY.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (IF-EXPRP X))
         (<= 1 (IF-COMPLEXITY X))).

But we reduce the conjecture to T, by primitive type reasoning and
the :type-prescription rule IF-COMPLEXITY.

Subgoal *1/1
(IMPLIES (AND (IF-EXPRP X)
              (<= 1 (IF-COMPLEXITY (A1 X)))
              (<= 1 (IF-COMPLEXITY (A2 X)))
              (<= 1 (IF-COMPLEXITY (A3 X))))
         (<= 1 (IF-COMPLEXITY X))).

But we reduce the conjecture to T, by primitive type reasoning and
the :type-prescription rule IF-COMPLEXITY.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-133A ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION IF-COMPLEXITY)
        (:TYPE-PRESCRIPTION IF-COMPLEXITY))
PROBLEM-133A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-133A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-133A)
PROBLEM-133A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-133A ...) ...)
Rules: NIL
 PROBLEM-133A
ACL2 !>>(THEOREM PROBLEM-133B
                 (IMPLIES (AND (RATIONALP X)
                               (RATIONALP Y)
                               (<= 1 X)
                               (< 0 Y))
                          (<= Y (* X Y)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-133B
           (IMPLIES (AND (RATIONALP X)
                         (RATIONALP Y)
                         (<= 1 X)
                         (< 0 Y))
                    (<= Y (* X Y)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE))))

[Note:  A hint was supplied for the goal above.  Thanks!]

But simplification reduces this to T, using primitive type reasoning
and the :rewrite rule <-*-X-Y-Y.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-133B ...)
Rules: ((:DEFINITION NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE <-*-X-Y-Y))
PROBLEM-133B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-133B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-133B)
PROBLEM-133B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-133B ...) ...)
Rules: NIL
 PROBLEM-133B
ACL2 !>>(THEOREM PROBLEM-133C
                 (IMPLIES (IF-EXPRP X)
                          (< (IF-COMPLEXITY (A2 X))
                             (IF-COMPLEXITY X)))
                 :HINTS (("Goal" :INDUCT (IF-COMPLEXITY X)
                                 :IN-THEORY (ENABLE PROBLEM-133B)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-133C
           (IMPLIES (IF-EXPRP X)
                    (< (IF-COMPLEXITY (A2 X))
                       (IF-COMPLEXITY X)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (IF-COMPLEXITY X)
                           :IN-THEORY (ENABLE PROBLEM-133B))))

ACL2 Warning [Non-rec] in ( DEFTHM PROBLEM-133C ...):  A :LINEAR rule
generated from PROBLEM-133C will be triggered only by terms containing
the function symbol A2, which has a non-recursive definition.  Unless
this definition is disabled, such triggering terms are unlikely to
arise and so PROBLEM-133C is unlikely to ever be used.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (IF-COMPLEXITY X).

This suggestion was produced using the :induction rule IF-COMPLEXITY.
If we let (:P X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (IF-EXPRP X)) (:P X))
     (IMPLIES (AND (IF-EXPRP X)
                   (:P (A1 X))
                   (:P (A2 X))
                   (:P (A3 X)))
              (:P X))).
This induction is justified by the same argument used to admit IF-COMPLEXITY.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.

Subgoal *1/
(IMPLIES (AND (IF-EXPRP X)
              (IMPLIES (IF-EXPRP (A1 X))
                       (< (IF-COMPLEXITY (A2 (A1 X)))
                          (IF-COMPLEXITY (A1 X))))
              (IMPLIES (IF-EXPRP (A2 X))
                       (< (IF-COMPLEXITY (A2 (A2 X)))
                          (IF-COMPLEXITY (A2 X))))
              (IMPLIES (IF-EXPRP (A3 X))
                       (< (IF-COMPLEXITY (A2 (A3 X)))
                          (IF-COMPLEXITY (A3 X)))))
         (IMPLIES (IF-EXPRP X)
                  (< (IF-COMPLEXITY (A2 X))
                     (IF-COMPLEXITY X)))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (IMPLIES (IF-EXPRP (CADR X))
                       (< (IF-COMPLEXITY (CADDR (CADR X)))
                          (IF-COMPLEXITY (CADR X))))
              (IMPLIES (IF-EXPRP (CADDR X))
                       (< (IF-COMPLEXITY (CADDR (CADDR X)))
                          (IF-COMPLEXITY (CADDR X))))
              (IMPLIES (IF-EXPRP (CADDDR X))
                       (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                          (IF-COMPLEXITY (CADDDR X)))))
         (< (IF-COMPLEXITY (CADDR X))
            (IF-COMPLEXITY X))).

This simplifies, using the :definitions IF-COMPLEXITY and IF-EXPRP
(if-intro), the :executable-counterpart of EQUAL and the :rewrite rule
DISTRIBUTIVITY, to the following 27 conjectures.

Subgoal *1/27
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (CONSP (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/26
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/25
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (CONSP (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/24
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/24'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/23
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/23'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/22
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/22'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/21
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/20
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/19
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/18
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (CONSP (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/17
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/16
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (CONSP (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/15
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/15'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/14
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/14'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/13
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/13'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/12
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/11
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/10
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/9
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (CONSP (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (CONSP (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/6'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/5'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< (IF-COMPLEXITY (CADDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-133C ...)
Rules: ((:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION IF-COMPLEXITY)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION IF-COMPLEXITY)
        (:LINEAR PROBLEM-133B)
        (:REWRITE DISTRIBUTIVITY)
        (:TYPE-PRESCRIPTION IF-COMPLEXITY))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION IF-EXPRP))
Warnings:  Non-rec
PROBLEM-133C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-133C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-133C)
PROBLEM-133C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-133C ...) ...)
Rules: NIL
Warnings:  Non-rec
 PROBLEM-133C
ACL2 !>>(THEOREM PROBLEM-133D
                 (IMPLIES (IF-EXPRP X)
                          (< (IF-COMPLEXITY (A3 X))
                             (IF-COMPLEXITY X)))
                 :HINTS (("Goal" :INDUCT (IF-COMPLEXITY X)
                                 :IN-THEORY (ENABLE PROBLEM-133B)))
                 :RULE-CLASSES :LINEAR)


ACL2 !>>>(DEFTHM PROBLEM-133D
           (IMPLIES (IF-EXPRP X)
                    (< (IF-COMPLEXITY (A3 X))
                       (IF-COMPLEXITY X)))
           :RULE-CLASSES :LINEAR
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (IF-COMPLEXITY X)
                           :IN-THEORY (ENABLE PROBLEM-133B))))

ACL2 Warning [Non-rec] in ( DEFTHM PROBLEM-133D ...):  A :LINEAR rule
generated from PROBLEM-133D will be triggered only by terms containing
the function symbol A3, which has a non-recursive definition.  Unless
this definition is disabled, such triggering terms are unlikely to
arise and so PROBLEM-133D is unlikely to ever be used.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (IF-COMPLEXITY X).

This suggestion was produced using the :induction rule IF-COMPLEXITY.
If we let (:P X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (IF-EXPRP X)) (:P X))
     (IMPLIES (AND (IF-EXPRP X)
                   (:P (A1 X))
                   (:P (A2 X))
                   (:P (A3 X)))
              (:P X))).
This induction is justified by the same argument used to admit IF-COMPLEXITY.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.

Subgoal *1/
(IMPLIES (AND (IF-EXPRP X)
              (IMPLIES (IF-EXPRP (A1 X))
                       (< (IF-COMPLEXITY (A3 (A1 X)))
                          (IF-COMPLEXITY (A1 X))))
              (IMPLIES (IF-EXPRP (A2 X))
                       (< (IF-COMPLEXITY (A3 (A2 X)))
                          (IF-COMPLEXITY (A2 X))))
              (IMPLIES (IF-EXPRP (A3 X))
                       (< (IF-COMPLEXITY (A3 (A3 X)))
                          (IF-COMPLEXITY (A3 X)))))
         (IMPLIES (IF-EXPRP X)
                  (< (IF-COMPLEXITY (A3 X))
                     (IF-COMPLEXITY X)))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (IMPLIES (IF-EXPRP (CADR X))
                       (< (IF-COMPLEXITY (CADDDR (CADR X)))
                          (IF-COMPLEXITY (CADR X))))
              (IMPLIES (IF-EXPRP (CADDR X))
                       (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                          (IF-COMPLEXITY (CADDR X))))
              (IMPLIES (IF-EXPRP (CADDDR X))
                       (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                          (IF-COMPLEXITY (CADDDR X)))))
         (< (IF-COMPLEXITY (CADDDR X))
            (IF-COMPLEXITY X))).

This simplifies, using the :definitions IF-COMPLEXITY and IF-EXPRP
(if-intro), the :executable-counterpart of EQUAL and the :rewrite rule
DISTRIBUTIVITY, to the following 27 conjectures.

Subgoal *1/27
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (CONSP (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/26
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/26'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/25
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (CONSP (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/24
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/23
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/23'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/22
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/21
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/20
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/20'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/19
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/18
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (CONSP (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/17
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/17'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/16
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (CONSP (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/15
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/14
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/14'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/13
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/12
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/11
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/11'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/10
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (< (IF-COMPLEXITY (CADDDR (CADR X)))
                 (IF-COMPLEXITY (CADR X)))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/9
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (CONSP (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/8'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (CONSP (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (CONSP (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/5'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDR X)))
                 (IF-COMPLEXITY (CADDR X)))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (CONSP (CADDDR X))))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

By the simple :definitions A1, A2 and A3 we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (< (IF-COMPLEXITY (CADDDR (CADDDR X)))
                 (IF-COMPLEXITY (CADDDR X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (+ (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDR X)))
               (* (IF-COMPLEXITY (CADR X))
                  (IF-COMPLEXITY (CADDDR X)))))).

But simplification reduces this to T, using linear arithmetic, primitive
type reasoning, the :linear rule PROBLEM-133B and the :type-prescription
rule IF-COMPLEXITY.

Subgoal *1/1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (CAR (CADDR X)) 'IF))
              (NOT (EQUAL (CAR (CADDDR X)) 'IF)))
         (< 1
            (+ (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A2 X)))
               (* (IF-COMPLEXITY (A1 X))
                  (IF-COMPLEXITY (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3 and the :executable-counterpart of TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-133D ...)
Rules: ((:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION IF-COMPLEXITY)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION IF-COMPLEXITY)
        (:LINEAR PROBLEM-133B)
        (:REWRITE DISTRIBUTIVITY)
        (:TYPE-PRESCRIPTION IF-COMPLEXITY))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION IF-EXPRP))
Warnings:  Non-rec
PROBLEM-133D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-133D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-133D)
PROBLEM-133D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-133D ...) ...)
Rules: NIL
Warnings:  Non-rec
 PROBLEM-133D
ACL2 !>>(DEFUN NORM (X)
         (DECLARE
          (XARGS
            :MEASURE (M2 (IF-COMPLEXITY X) (IF-DEPTH X))
            :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-133A
                                               PROBLEM-133C PROBLEM-133D)))))
         (COND ((NOT (IF-EXPRP X)) X)
               ((IF-EXPRP (A1 X))
                (NORM (LIST 'IF
                            (A1 (A1 X))
                            (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                            (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X)))))
               (T (LIST 'IF
                        (A1 X)
                        (NORM (A2 X))
                        (NORM (A3 X))))))

For the admission of NORM we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(M2 (IF-COMPLEXITY X) (IF-DEPTH X)).  The non-trivial part of the measure
conjecture is

Goal
(AND
 (O-P (M2 (IF-COMPLEXITY X) (IF-DEPTH X)))
 (IMPLIES (AND (IF-EXPRP X)
               (NOT (IF-EXPRP (A1 X))))
          (O< (M2 (IF-COMPLEXITY (A2 X))
                  (IF-DEPTH (A2 X)))
              (M2 (IF-COMPLEXITY X) (IF-DEPTH X))))
 (IMPLIES (AND (IF-EXPRP X) (IF-EXPRP (A1 X)))
          (O< (M2 (IF-COMPLEXITY (LIST 'IF
                                       (A1 (A1 X))
                                       (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                                       (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X))))
                  (IF-DEPTH (LIST 'IF
                                  (A1 (A1 X))
                                  (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                                  (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X)))))
              (M2 (IF-COMPLEXITY X) (IF-DEPTH X))))
 (IMPLIES (AND (IF-EXPRP X)
               (NOT (IF-EXPRP (A1 X))))
          (O< (M2 (IF-COMPLEXITY (A3 X))
                  (IF-DEPTH (A3 X)))
              (M2 (IF-COMPLEXITY X) (IF-DEPTH X))))).

[Note:  A hint was supplied for the goal above.  Thanks!]

By the simple :definitions A1, A2, A3, IF-EXPRP and M2 we reduce the
conjecture to the following four conjectures.

Subgoal 4
(O-P (CONS (CONS 1 (+ 1 (IF-COMPLEXITY X)))
           (IF-DEPTH X))).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER, O-FINP-CR and POSP-COMPOUND-RECOGNIZER,
the :definitions O-FIRST-COEFF, O-FIRST-EXPT, O-P and O-RST, the :executable-
counterparts of EQUAL, O-P and O<, primitive type reasoning, the :rewrite
rules CAR-CONS, CDR-CONS, O-FIRST-EXPT-DEF-O-FINP and O-P-DEF-O-FINP-1
and the :type-prescription rules IF-COMPLEXITY and IF-DEPTH.

Subgoal 3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (IF-EXPRP (CADR X))))
         (O< (CONS (CONS 1 (+ 1 (IF-COMPLEXITY (CADDR X))))
                   (IF-DEPTH (CADDR X)))
             (CONS (CONS 1 (+ 1 (IF-COMPLEXITY X)))
                   (IF-DEPTH X)))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions A1, FIX, IF-DEPTH, IF-EXPRP (if-intro), O-FIRST-COEFF,
O-FIRST-EXPT, O-RST and O< (if-intro), the :executable-counterparts
of BINARY-+, EQUAL and O-FINP, primitive type reasoning, the :meta
rules CANCEL_PLUS-EQUAL-CORRECT and CANCEL_PLUS-LESSP-CORRECT, the
:rewrite rules CAR-CONS and CDR-CONS and the :type-prescription rules
IF-COMPLEXITY and IF-DEPTH, to the following four conjectures.

Subgoal 3.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (EQUAL (IF-COMPLEXITY (CADDR X))
                     (IF-COMPLEXITY X)))
         (< (IF-DEPTH (CADDR X)) 1)).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following three goals.

Subgoal 3.4.3
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (EQUAL (IF-COMPLEXITY (CADR X2))
                     (IF-COMPLEXITY (CONS X1 X2))))
         (< (IF-DEPTH (CADR X2)) 1)).

By case analysis we reduce the conjecture to

Subgoal 3.4.3'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (EQUAL (IF-COMPLEXITY (CADR X2))
                     (IF-COMPLEXITY (CONS X1 X2))))
         (< (IF-DEPTH (CADR X2)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of BINARY-*,
BINARY-+, CAR, CDR, CONSP, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 3.4.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY (CAR X4))
                     (IF-COMPLEXITY (LIST* X1 X3 X4))))
         (< (IF-DEPTH (CAR X4)) 1)).

By case analysis we reduce the conjecture to

Subgoal 3.4.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY (CAR X4))
                     (IF-COMPLEXITY (LIST* X1 X3 X4))))
         (< (IF-DEPTH (CAR X4)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of BINARY-*,
BINARY-+, CAR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive type
reasoning and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 3.4.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY X5)
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X6))))
         (< (IF-DEPTH X5) 1)).

By case analysis we reduce the conjecture to

Subgoal 3.4.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY X5)
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X6))))
         (< (IF-DEPTH X5) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, FIX, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of
EQUAL, NOT and SYMBOLP, primitive type reasoning, the :meta rule 
CANCEL_PLUS-EQUAL-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription rule IF-COMPLEXITY.

Subgoal 3.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (IF-COMPLEXITY (CADDR X))
                          (IF-COMPLEXITY X))))
         (< (IF-COMPLEXITY (CADDR X))
            (IF-COMPLEXITY X))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following three goals.

Subgoal 3.3.3
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (NOT (EQUAL (IF-COMPLEXITY (CADR X2))
                          (IF-COMPLEXITY (CONS X1 X2)))))
         (< (IF-COMPLEXITY (CADR X2))
            (IF-COMPLEXITY (CONS X1 X2)))).

By case analysis we reduce the conjecture to

Subgoal 3.3.3'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (NOT (EQUAL (IF-COMPLEXITY (CADR X2))
                          (IF-COMPLEXITY (CONS X1 X2)))))
         (< (IF-COMPLEXITY (CADR X2))
            (IF-COMPLEXITY (CONS X1 X2)))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of <,
BINARY-*, BINARY-+, CAR, CDR, CONSP, EQUAL, IF-COMPLEXITY, NOT and
SYMBOLP, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and DEFAULT-CDR.

Subgoal 3.3.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY (CAR X4))
                          (IF-COMPLEXITY (LIST* X1 X3 X4)))))
         (< (IF-COMPLEXITY (CAR X4))
            (IF-COMPLEXITY (LIST* X1 X3 X4)))).

By case analysis we reduce the conjecture to

Subgoal 3.3.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY (CAR X4))
                          (IF-COMPLEXITY (LIST* X1 X3 X4)))))
         (< (IF-COMPLEXITY (CAR X4))
            (IF-COMPLEXITY (LIST* X1 X3 X4)))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of <,
BINARY-*, BINARY-+, CAR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 3.3.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY X5)
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))))
         (< (IF-COMPLEXITY X5)
            (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))).

By case analysis we reduce the conjecture to

Subgoal 3.3.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY X5)
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))))
         (< (IF-COMPLEXITY X5)
            (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))).

This simplifies, using the :definitions A1, A2, A3, FIX, IF-COMPLEXITY
and IF-EXPRP, the :executable-counterparts of EQUAL, NOT and SYMBOLP,
primitive type reasoning, the :meta rules CANCEL_PLUS-EQUAL-CORRECT
and CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS,
DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription rule IF-COMPLEXITY,
to

Subgoal 3.3.1''
(IMPLIES (NOT (CONSP X3))
         (< 0 (IF-COMPLEXITY (CAR X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule IF-COMPLEXITY.

Subgoal 3.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (EQUAL (IF-COMPLEXITY (CADDR X))
                     (IF-COMPLEXITY X)))
         (< (IF-DEPTH (CADDR X)) 1)).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
four goals.

Subgoal 3.2.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'IF))
              (EQUAL (IF-COMPLEXITY (CADR X2))
                     (IF-COMPLEXITY (CONS X1 X2))))
         (< (IF-DEPTH (CADR X2)) 1)).

By case analysis we reduce the conjecture to

Subgoal 3.2.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'IF))
              (EQUAL (IF-COMPLEXITY (CADR X2))
                     (IF-COMPLEXITY (CONS X1 X2))))
         (< (IF-DEPTH (CADR X2)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of BINARY-*,
BINARY-+, CAR, CDR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 3.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY (CAR X4))
                     (IF-COMPLEXITY (LIST* X1 X3 X4))))
         (< (IF-DEPTH (CAR X4)) 1)).

By case analysis we reduce the conjecture to

Subgoal 3.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY (CAR X4))
                     (IF-COMPLEXITY (LIST* X1 X3 X4))))
         (< (IF-DEPTH (CAR X4)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of BINARY-*,
BINARY-+, CAR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive type
reasoning and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 3.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY X5)
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X6))))
         (< (IF-DEPTH X5) 1)).

By case analysis we reduce the conjecture to

Subgoal 3.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY X5)
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X6))))
         (< (IF-DEPTH X5) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, FIX, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of
EQUAL, NOT and SYMBOLP, primitive type reasoning, the :meta rule 
CANCEL_PLUS-EQUAL-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
DEFAULT-CAR, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription
rule IF-COMPLEXITY.

Subgoal 3.2.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (EQUAL (IF-COMPLEXITY X5)
                     (IF-COMPLEXITY (LIST* X1 (CONS X4 X7) X5 X6))))
         (< (IF-DEPTH X5) 1)).

By case analysis we reduce the conjecture to

Subgoal 3.2.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (EQUAL (IF-COMPLEXITY X5)
                     (IF-COMPLEXITY (LIST* X1 (CONS X4 X7) X5 X6))))
         (< (IF-DEPTH X5) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, FIX, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of
EQUAL, NOT and SYMBOLP, primitive type reasoning, the :meta rule 
CANCEL_PLUS-EQUAL-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
COMMUTATIVITY-OF-*, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-
prescription rule IF-COMPLEXITY.

Subgoal 3.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CADDR X))
                          (IF-COMPLEXITY X))))
         (< (IF-COMPLEXITY (CADDR X))
            (IF-COMPLEXITY X))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
four goals.

Subgoal 3.1.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CADR X2))
                          (IF-COMPLEXITY (CONS X1 X2)))))
         (< (IF-COMPLEXITY (CADR X2))
            (IF-COMPLEXITY (CONS X1 X2)))).

By case analysis we reduce the conjecture to

Subgoal 3.1.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CADR X2))
                          (IF-COMPLEXITY (CONS X1 X2)))))
         (< (IF-COMPLEXITY (CADR X2))
            (IF-COMPLEXITY (CONS X1 X2)))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of <,
BINARY-*, BINARY-+, CAR, CDR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 3.1.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CAR X4))
                          (IF-COMPLEXITY (LIST* X1 X3 X4)))))
         (< (IF-COMPLEXITY (CAR X4))
            (IF-COMPLEXITY (LIST* X1 X3 X4)))).

By case analysis we reduce the conjecture to

Subgoal 3.1.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CAR X4))
                          (IF-COMPLEXITY (LIST* X1 X3 X4)))))
         (< (IF-COMPLEXITY (CAR X4))
            (IF-COMPLEXITY (LIST* X1 X3 X4)))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of <,
BINARY-*, BINARY-+, CAR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 3.1.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY X5)
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))))
         (< (IF-COMPLEXITY X5)
            (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))).

By case analysis we reduce the conjecture to

Subgoal 3.1.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY X5)
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))))
         (< (IF-COMPLEXITY X5)
            (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))).

This simplifies, using the :definitions A1, A2, A3, FIX, IF-COMPLEXITY
and IF-EXPRP, the :executable-counterparts of EQUAL, NOT and SYMBOLP,
primitive type reasoning, the :meta rules CANCEL_PLUS-EQUAL-CORRECT
and CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription
rule IF-COMPLEXITY, to

Subgoal 3.1.2''
(IMPLIES (NOT (CONSP X3))
         (< 0 (IF-COMPLEXITY (CAR X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule IF-COMPLEXITY.

Subgoal 3.1.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (NOT (EQUAL (IF-COMPLEXITY X5)
                          (IF-COMPLEXITY (LIST* X1 (CONS X4 X7) X5 X6)))))
         (< (IF-COMPLEXITY X5)
            (IF-COMPLEXITY (LIST* X1 (CONS X4 X7) X5 X6)))).

By case analysis we reduce the conjecture to

Subgoal 3.1.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (NOT (EQUAL (IF-COMPLEXITY X5)
                          (IF-COMPLEXITY (LIST* X1 (CONS X4 X7) X5 X6)))))
         (< (IF-COMPLEXITY X5)
            (IF-COMPLEXITY (LIST* X1 (CONS X4 X7) X5 X6)))).

This simplifies, using the :definitions A1, A2, A3, FIX, IF-COMPLEXITY
and IF-EXPRP, the :executable-counterparts of EQUAL, NOT and SYMBOLP,
primitive type reasoning, the :meta rules CANCEL_PLUS-EQUAL-CORRECT
and CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS,
COMMUTATIVITY-OF-*, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-
prescription rule IF-COMPLEXITY, to

Subgoal 3.1.1''
(IMPLIES (NOT (EQUAL X4 'IF))
         (< 0 (IF-COMPLEXITY (CAR X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule IF-COMPLEXITY.

Subgoal 2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'IF))
         (O< (CONS (CONS 1
                         (+ 1
                            (IF-COMPLEXITY (LIST 'IF
                                                 (CADR (CADR X))
                                                 (LIST 'IF
                                                       (CADDR (CADR X))
                                                       (CADDR X)
                                                       (CADDDR X))
                                                 (LIST 'IF
                                                       (CADDDR (CADR X))
                                                       (CADDR X)
                                                       (CADDDR X))))))
                   (IF-DEPTH (LIST 'IF
                                   (CADR (CADR X))
                                   (LIST 'IF
                                         (CADDR (CADR X))
                                         (CADDR X)
                                         (CADDDR X))
                                   (LIST 'IF
                                         (CADDDR (CADR X))
                                         (CADDR X)
                                         (CADDDR X)))))
             (CONS (CONS 1 (+ 1 (IF-COMPLEXITY X)))
                   (IF-DEPTH X)))).

But simplification reduces this to T, using the :compound-recognizer
rule O-FINP-CR, the :definitions A1, A2, A3, IF-COMPLEXITY, IF-DEPTH,
IF-EXPRP, O-FIRST-COEFF, O-FIRST-EXPT, O-RST, O< and SYNP, the :executable-
counterparts of BINARY-+ and EQUAL, linear arithmetic, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-*,
COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-*, COMMUTATIVITY-OF-+, DISTRIBUTIVITY,
FOLD-CONSTS-IN-+ and O-FINP-< and the :type-prescription rule IF-DEPTH.

Subgoal 1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (IF-EXPRP (CADR X))))
         (O< (CONS (CONS 1 (+ 1 (IF-COMPLEXITY (CADDDR X))))
                   (IF-DEPTH (CADDDR X)))
             (CONS (CONS 1 (+ 1 (IF-COMPLEXITY X)))
                   (IF-DEPTH X)))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions A1, FIX, IF-DEPTH, IF-EXPRP (if-intro), O-FIRST-COEFF,
O-FIRST-EXPT, O-RST and O< (if-intro), the :executable-counterparts
of BINARY-+, EQUAL and O-FINP, primitive type reasoning, the :meta
rules CANCEL_PLUS-EQUAL-CORRECT and CANCEL_PLUS-LESSP-CORRECT, the
:rewrite rules CAR-CONS and CDR-CONS and the :type-prescription rules
IF-COMPLEXITY and IF-DEPTH, to the following four conjectures.

Subgoal 1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (EQUAL (IF-COMPLEXITY (CADDDR X))
                     (IF-COMPLEXITY X)))
         (< (IF-DEPTH (CADDDR X)) 1)).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
four goals.

Subgoal 1.4.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (EQUAL (IF-COMPLEXITY (CADDR X2))
                     (IF-COMPLEXITY (CONS X1 X2))))
         (< (IF-DEPTH (CADDR X2)) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.4.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (EQUAL (IF-COMPLEXITY (CADDR X2))
                     (IF-COMPLEXITY (CONS X1 X2))))
         (< (IF-DEPTH (CADDR X2)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of BINARY-*,
BINARY-+, CAR, CDR, CONSP, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.4.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY (CADR X4))
                     (IF-COMPLEXITY (LIST* X1 X3 X4))))
         (< (IF-DEPTH (CADR X4)) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.4.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY (CADR X4))
                     (IF-COMPLEXITY (LIST* X1 X3 X4))))
         (< (IF-DEPTH (CADR X4)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of BINARY-*,
BINARY-+, CAR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive type
reasoning and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.4.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY (CAR X6))
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X6))))
         (< (IF-DEPTH (CAR X6)) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.4.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY (CAR X6))
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X6))))
         (< (IF-DEPTH (CAR X6)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, FIX, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of
EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive type reasoning, the
:rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*, COMMUTATIVITY-OF-+,
DEFAULT-CAR, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription
rule IF-COMPLEXITY.

Subgoal 1.4.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY X7)
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8))))
         (< (IF-DEPTH X7) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.4.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (EQUAL (IF-COMPLEXITY X7)
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8))))
         (< (IF-DEPTH X7) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, FIX, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of
EQUAL, NOT and SYMBOLP, primitive type reasoning, the :meta rule 
CANCEL_PLUS-EQUAL-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription rule IF-COMPLEXITY.

Subgoal 1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (EQUAL (IF-COMPLEXITY (CADDDR X))
                          (IF-COMPLEXITY X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (IF-COMPLEXITY X))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
four goals.

Subgoal 1.3.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (NOT (EQUAL (IF-COMPLEXITY (CADDR X2))
                          (IF-COMPLEXITY (CONS X1 X2)))))
         (< (IF-COMPLEXITY (CADDR X2))
            (IF-COMPLEXITY (CONS X1 X2)))).

By case analysis we reduce the conjecture to

Subgoal 1.3.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (NOT (EQUAL (IF-COMPLEXITY (CADDR X2))
                          (IF-COMPLEXITY (CONS X1 X2)))))
         (< (IF-COMPLEXITY (CADDR X2))
            (IF-COMPLEXITY (CONS X1 X2)))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of <,
BINARY-*, BINARY-+, CAR, CDR, CONSP, EQUAL, IF-COMPLEXITY, NOT and
SYMBOLP, primitive type reasoning and the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.3.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY (CADR X4))
                          (IF-COMPLEXITY (LIST* X1 X3 X4)))))
         (< (IF-COMPLEXITY (CADR X4))
            (IF-COMPLEXITY (LIST* X1 X3 X4)))).

By case analysis we reduce the conjecture to

Subgoal 1.3.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY (CADR X4))
                          (IF-COMPLEXITY (LIST* X1 X3 X4)))))
         (< (IF-COMPLEXITY (CADR X4))
            (IF-COMPLEXITY (LIST* X1 X3 X4)))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of <,
BINARY-*, BINARY-+, CAR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.3.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY (CAR X6))
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))))
         (< (IF-COMPLEXITY (CAR X6))
            (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.3.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY (CAR X6))
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))))
         (< (IF-COMPLEXITY (CAR X6))
            (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))).

This simplifies, using the :definitions A1, A2, A3, FIX, IF-COMPLEXITY
and IF-EXPRP, the :executable-counterparts of EQUAL, IF-COMPLEXITY,
NOT and SYMBOLP, primitive type reasoning, the :meta rule 
CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
COMMUTATIVITY-OF-*, COMMUTATIVITY-OF-+, DEFAULT-CAR, DISTRIBUTIVITY
and UNICITY-OF-1 and the :type-prescription rule IF-COMPLEXITY, to

Subgoal 1.3.2''
(IMPLIES (AND (NOT (CONSP X6)) (NOT (CONSP X3)))
         (< 0 (IF-COMPLEXITY X5))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule IF-COMPLEXITY.

Subgoal 1.3.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY X7)
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8)))))
         (< (IF-COMPLEXITY X7)
            (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8)))).

By case analysis we reduce the conjecture to

Subgoal 1.3.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (EQUAL (IF-COMPLEXITY X7)
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8)))))
         (< (IF-COMPLEXITY X7)
            (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8)))).

This simplifies, using the :definitions A1, A2, A3, FIX, IF-COMPLEXITY
and IF-EXPRP, the :executable-counterparts of EQUAL, NOT and SYMBOLP,
primitive type reasoning, the :meta rules CANCEL_PLUS-EQUAL-CORRECT
and CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS,
DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription rule IF-COMPLEXITY,
to

Subgoal 1.3.1''
(IMPLIES (NOT (CONSP X3))
         (< 0 (IF-COMPLEXITY X5))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule IF-COMPLEXITY.

Subgoal 1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (EQUAL (IF-COMPLEXITY (CADDDR X))
                     (IF-COMPLEXITY X)))
         (< (IF-DEPTH (CADDDR X)) 1)).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following five goals.

Subgoal 1.2.5
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'IF))
              (EQUAL (IF-COMPLEXITY (CADDR X2))
                     (IF-COMPLEXITY (CONS X1 X2))))
         (< (IF-DEPTH (CADDR X2)) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.2.5'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'IF))
              (EQUAL (IF-COMPLEXITY (CADDR X2))
                     (IF-COMPLEXITY (CONS X1 X2))))
         (< (IF-DEPTH (CADDR X2)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of BINARY-*,
BINARY-+, CAR, CDR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.2.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY (CADR X4))
                     (IF-COMPLEXITY (LIST* X1 X3 X4))))
         (< (IF-DEPTH (CADR X4)) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.2.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY (CADR X4))
                     (IF-COMPLEXITY (LIST* X1 X3 X4))))
         (< (IF-DEPTH (CADR X4)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of BINARY-*,
BINARY-+, CAR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive type
reasoning and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.2.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY (CAR X6))
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X6))))
         (< (IF-DEPTH (CAR X6)) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.2.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY (CAR X6))
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X6))))
         (< (IF-DEPTH (CAR X6)) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, FIX, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of
EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive type reasoning, the
:rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*, COMMUTATIVITY-OF-+,
DEFAULT-CAR, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription
rule IF-COMPLEXITY.

Subgoal 1.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY X7)
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8))))
         (< (IF-DEPTH X7) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (EQUAL (IF-COMPLEXITY X7)
                     (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8))))
         (< (IF-DEPTH X7) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, FIX, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of
EQUAL, NOT and SYMBOLP, primitive type reasoning, the :meta rule 
CANCEL_PLUS-EQUAL-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
DEFAULT-CAR, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription
rule IF-COMPLEXITY.

Subgoal 1.2.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (EQUAL (IF-COMPLEXITY X7)
                     (IF-COMPLEXITY (LIST* X1 (CONS X4 X6) X5 X7 X8))))
         (< (IF-DEPTH X7) 1)).

By case analysis we reduce the conjecture to

Subgoal 1.2.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (EQUAL (IF-COMPLEXITY X7)
                     (IF-COMPLEXITY (LIST* X1 (CONS X4 X6) X5 X7 X8))))
         (< (IF-DEPTH X7) 1)).

But simplification reduces this to T, using the :definitions A1, A2,
A3, FIX, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of
EQUAL, NOT and SYMBOLP, primitive type reasoning, the :meta rule 
CANCEL_PLUS-EQUAL-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
COMMUTATIVITY-OF-*, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-
prescription rule IF-COMPLEXITY.

Subgoal 1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CADDDR X))
                          (IF-COMPLEXITY X))))
         (< (IF-COMPLEXITY (CADDDR X))
            (IF-COMPLEXITY X))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following five goals.

Subgoal 1.1.5
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CADDR X2))
                          (IF-COMPLEXITY (CONS X1 X2)))))
         (< (IF-COMPLEXITY (CADDR X2))
            (IF-COMPLEXITY (CONS X1 X2)))).

By case analysis we reduce the conjecture to

Subgoal 1.1.5'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CADDR X2))
                          (IF-COMPLEXITY (CONS X1 X2)))))
         (< (IF-COMPLEXITY (CADDR X2))
            (IF-COMPLEXITY (CONS X1 X2)))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of <,
BINARY-*, BINARY-+, CAR, CDR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.1.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CADR X4))
                          (IF-COMPLEXITY (LIST* X1 X3 X4)))))
         (< (IF-COMPLEXITY (CADR X4))
            (IF-COMPLEXITY (LIST* X1 X3 X4)))).

By case analysis we reduce the conjecture to

Subgoal 1.1.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CADR X4))
                          (IF-COMPLEXITY (LIST* X1 X3 X4)))))
         (< (IF-COMPLEXITY (CADR X4))
            (IF-COMPLEXITY (LIST* X1 X3 X4)))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, IF-COMPLEXITY and IF-EXPRP, the :executable-counterparts of <,
BINARY-*, BINARY-+, CAR, EQUAL, IF-COMPLEXITY, NOT and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-*,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.1.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CAR X6))
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))))
         (< (IF-COMPLEXITY (CAR X6))
            (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.1.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY (CAR X6))
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))))
         (< (IF-COMPLEXITY (CAR X6))
            (IF-COMPLEXITY (LIST* X1 X3 X5 X6)))).

This simplifies, using the :definitions A1, A2, A3, FIX, IF-COMPLEXITY
and IF-EXPRP, the :executable-counterparts of EQUAL, IF-COMPLEXITY,
NOT and SYMBOLP, primitive type reasoning, the :meta rule 
CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS, 
COMMUTATIVITY-OF-*, COMMUTATIVITY-OF-+, DEFAULT-CAR, DISTRIBUTIVITY
and UNICITY-OF-1 and the :type-prescription rule IF-COMPLEXITY, to

Subgoal 1.1.3''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (EQUAL (CAR X3) 'IF)))
         (< 0 (IF-COMPLEXITY X5))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule IF-COMPLEXITY.

Subgoal 1.1.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY X7)
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8)))))
         (< (IF-COMPLEXITY X7)
            (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8)))).

By case analysis we reduce the conjecture to

Subgoal 1.1.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'IF))
              (NOT (EQUAL (IF-COMPLEXITY X7)
                          (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8)))))
         (< (IF-COMPLEXITY X7)
            (IF-COMPLEXITY (LIST* X1 X3 X5 X7 X8)))).

This simplifies, using the :definitions A1, A2, A3, FIX, IF-COMPLEXITY
and IF-EXPRP, the :executable-counterparts of EQUAL, NOT and SYMBOLP,
primitive type reasoning, the :meta rules CANCEL_PLUS-EQUAL-CORRECT
and CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-prescription
rule IF-COMPLEXITY, to

Subgoal 1.1.2''
(IMPLIES (NOT (CONSP X3))
         (< 0 (IF-COMPLEXITY X5))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule IF-COMPLEXITY.

Subgoal 1.1.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (NOT (EQUAL (IF-COMPLEXITY X7)
                          (IF-COMPLEXITY (LIST* X1 (CONS X4 X6) X5 X7 X8)))))
         (< (IF-COMPLEXITY X7)
            (IF-COMPLEXITY (LIST* X1 (CONS X4 X6) X5 X7 X8)))).

By case analysis we reduce the conjecture to

Subgoal 1.1.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'IF))
              (NOT (EQUAL (IF-COMPLEXITY X7)
                          (IF-COMPLEXITY (LIST* X1 (CONS X4 X6) X5 X7 X8)))))
         (< (IF-COMPLEXITY X7)
            (IF-COMPLEXITY (LIST* X1 (CONS X4 X6) X5 X7 X8)))).

This simplifies, using the :definitions A1, A2, A3, FIX, IF-COMPLEXITY
and IF-EXPRP, the :executable-counterparts of EQUAL, NOT and SYMBOLP,
primitive type reasoning, the :meta rules CANCEL_PLUS-EQUAL-CORRECT
and CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules CAR-CONS, CDR-CONS,
COMMUTATIVITY-OF-*, DISTRIBUTIVITY and UNICITY-OF-1 and the :type-
prescription rule IF-COMPLEXITY, to

Subgoal 1.1.1''
(IMPLIES (NOT (EQUAL X4 'IF))
         (< 0 (IF-COMPLEXITY X5))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule IF-COMPLEXITY.

Q.E.D.

That completes the proof of the measure theorem for NORM.  Thus, we
admit this function under the principle of definition.  We observe
that the type of NORM is described by the theorem 
(OR (AND (CONSP (NORM X)) (TRUE-LISTP (NORM X))) (EQUAL (NORM X) X)).
We used primitive type reasoning.

Summary
Form:  ( DEFUN NORM ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:COMPOUND-RECOGNIZER POSP-COMPOUND-RECOGNIZER)
        (:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION FIX)
        (:DEFINITION IF-COMPLEXITY)
        (:DEFINITION IF-DEPTH)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION M2)
        (:DEFINITION NOT)
        (:DEFINITION O-FIRST-COEFF)
        (:DEFINITION O-FIRST-EXPT)
        (:DEFINITION O-P)
        (:DEFINITION O-RST)
        (:DEFINITION O<)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-*)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART IF-COMPLEXITY)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART O-FINP)
        (:EXECUTABLE-COUNTERPART O-P)
        (:EXECUTABLE-COUNTERPART O<)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-EQUAL-CORRECT)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-*)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-*)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE DISTRIBUTIVITY)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-FINP-<)
        (:REWRITE O-FIRST-EXPT-DEF-O-FINP)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-1)
        (:TYPE-PRESCRIPTION IF-COMPLEXITY)
        (:TYPE-PRESCRIPTION IF-DEPTH))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION IF-EXPRP)
             (:DEFINITION O<))
 NORM
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 134.
"
ACL2 !>>(DEFUN ASSIGNEDP (VAR ALIST)
          (OR (QUOTEP VAR)
              (ASSOC-EQUAL VAR ALIST)))

Since ASSIGNEDP is non-recursive, its admission is trivial.  We could
deduce no constraints on the type of ASSIGNEDP.  However, in normalizing
the definition we used the :type-prescription rule QUOTEP.

Summary
Form:  ( DEFUN ASSIGNEDP ...)
Rules: ((:TYPE-PRESCRIPTION QUOTEP))
 ASSIGNEDP
ACL2 !>>(DEFUN ASSUME-TRUE (VAR ALIST)
          (CONS (CONS VAR T) ALIST))

Since ASSUME-TRUE is non-recursive, its admission is trivial.  We observe
that the type of ASSUME-TRUE is described by the theorem 
(CONSP (ASSUME-TRUE VAR ALIST)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN ASSUME-TRUE ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 ASSUME-TRUE
ACL2 !>>(DEFUN ASSUME-FALSE (VAR ALIST)
          (CONS (CONS VAR NIL) ALIST))

Since ASSUME-FALSE is non-recursive, its admission is trivial.  We
observe that the type of ASSUME-FALSE is described by the theorem 
(CONSP (ASSUME-FALSE VAR ALIST)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN ASSUME-FALSE ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 ASSUME-FALSE
ACL2 !>>(DEFUN TAUTP (X ALIST)
          (DECLARE (XARGS :MEASURE (CC X)))
          (IF (IF-EXPRP X)
              (IF (ASSIGNEDP (A1 X) ALIST)
                  (IF (ASSIGNMENT (A1 X) ALIST)
                      (TAUTP (A2 X) ALIST)
                    (TAUTP (A3 X) ALIST))
                (AND (TAUTP (A2 X)
                            (ASSUME-TRUE (A1 X) ALIST))
                     (TAUTP (A3 X)
                            (ASSUME-FALSE (A1 X) ALIST))))
            (ASSIGNMENT X ALIST)))

For the admission of TAUTP we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNMENT (A1 X) ALIST))
              (O< (CC (A2 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) ALIST)
                   (NOT (ASSIGNMENT (A1 X) ALIST)))
              (O< (CC (A3 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) ALIST)))
              (O< (CC (A2 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) ALIST))
                   (TAUTP (A2 X)
                          (ASSUME-TRUE (A1 X) ALIST)))
              (O< (CC (A3 X)) (CC X)))).

By the simple :definitions A1, A2, A3, ASSIGNEDP, ASSUME-TRUE and IF-EXPRP
we reduce the conjecture to the following five conjectures.

Subgoal 5
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNMENT (CADR X) ALIST))
         (O< (CC (CADDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions ASSIGNMENT (if-intro), CC (if-intro), FIX, O< (if-intro)
and QUOTEP (if-intro), the :executable-counterpart of CC, primitive
type reasoning, the :rewrite rule UNICITY-OF-0 and the :type-prescription
rule CC, to the following six conjectures.

Subgoal 4.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 4.6'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X)) (+ 2 (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following two goals.

Subgoal 4.6.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 4.6.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CAR.

Subgoal 4.6.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 4.6.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS and FOLD-CONSTS-IN-+, to

Subgoal 4.6.1''
(IMPLIES (AND (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and CONSP and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 4.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+ and CC, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-
prescription rule CC, to

Subgoal 4.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 3 (CC (CDDR X))
               (CC (CDR (CADR X)))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7 and restrict the types of the new
variables X4 and X7 to be those of the terms they replace.  (5) Finally,
use CAR-CDR-ELIM to replace X7 by (CONS X8 X9), (CAR X7) by X8 and
(CDR X7) by X9.  These steps produce the following three goals.

Subgoal 4.4.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3))
         (< (CC (CAR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 4.4.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3))
         (< (CC (CAR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules DEFAULT-CAR and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 4.4.3''
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3))
         (< 0 (+ 3 (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.4.2
(IMPLIES (AND (NOT (CONSP X7))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              X7 (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (CAR X7))
         (< (CC X5)
            (+ 3 (CC (CONS X5 X6)) (CC X7)))).

But we reduce the conjecture to T, by case analysis.

Subgoal 4.4.1
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              X8)
         (< (CC X5)
            (+ 3 (CC (CONS X5 X6))
               (CC (CONS X8 X9))))).

By case analysis we reduce the conjecture to

Subgoal 4.4.1'
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              X8)
         (< (CC X5)
            (+ 3 (CC (CONS X5 X6))
               (CC (CONS X8 X9))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 4.4.1''
(IMPLIES (AND (CONS X8 X9) X8)
         (< 0 (+ 5 (CC X6) (CC X8) (CC X9)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 4.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 4.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
three goals.

Subgoal 4.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 4.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 4.2.3''
(IMPLIES (AND (NOT (CONSP X4))
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 4.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 4.2.2''
(IMPLIES (AND (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.2.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 4.2.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 4.2.1''
(IMPLIES (AND (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< 0 (+ 4 (CC X4) (CC X6) (CC X7)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and EQUAL and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNEDP (CADR X) ALIST)
              (NOT (ASSIGNMENT (CADR X) ALIST)))
         (O< (CC (CADDDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions ASSIGNEDP (if-intro), ASSIGNMENT (if-intro), CC (if-intro),
FIX, O< (if-intro) and QUOTEP (if-intro), the :executable-counterparts
of CC and EQUAL, primitive type reasoning, the :rewrite rule UNICITY-OF-0
and the :type-prescription rule CC, to the following eight conjectures.

Subgoal 3.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 3.8'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 2 (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
three goals.

Subgoal 3.8.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CADR X4)) (+ 2 (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 3.8.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CADR X4)) (+ 2 (CC X4)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CAR, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CDR.

Subgoal 3.8.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CAR X6))
            (+ 2 (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 3.8.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CAR X6))
            (+ 2 (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-+,
DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3.8.2''
(IMPLIES (AND (NOT (CONSP X6))
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 3 (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.8.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC X7)
            (+ 2 (CC (LIST* X5 X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 3.8.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC X7)
            (+ 2 (CC (LIST* X5 X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 3.8.1''
(IMPLIES (AND (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR and CONSP and the :rewrite rules DEFAULT-CAR and
DEFAULT-CDR.

Subgoal 3.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+ and CC, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-
prescription rule CC, to

Subgoal 3.6'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CDDR X))
               (CC (CDR (CADR X)))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of six rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Use CAR-CDR-ELIM to replace
X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6 and restrict
the type of the new variable X4 to be that of the term it replaces.
(6) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X9 X10), (CAR X6)
by X9 and (CDR X6) by X10.  These steps produce the following four
goals.

Subgoal 3.6.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CADR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 3.6.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CADR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CAR, CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules DEFAULT-CDR and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3.6.4''
(IMPLIES (AND (NOT (CONSP X4))
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< 0 (+ 3 (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.6.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CAR X6))
            (+ 3 (CC (CONS X5 X6)) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 3.6.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CAR X6))
            (+ 3 (CC (CONS X5 X6)) (CC (CDR X3))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 3.6.3''
(IMPLIES (AND (NOT (CONSP X6))
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< 0 (+ 4 (CC X5) (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.6.2
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6)))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8)) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 3.6.2'
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6)))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8)) (CC X6)))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, DEFAULT-CAR and
FOLD-CONSTS-IN-+, to

Subgoal 3.6.2''
(IMPLIES (AND (NOT (CONSP X6))
              (ASSOC-EQUAL (CONS 'QUOTE X6) ALIST))
         (< 0 (+ 5 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.6.1
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X9 X10) ALIST)
              (EQUAL X4 'QUOTE)
              (NOT X9))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8))
               (CC (CONS X9 X10))))).

By case analysis we reduce the conjecture to

Subgoal 3.6.1'
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X9 X10) ALIST)
              (EQUAL X4 'QUOTE)
              (NOT X9))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8))
               (CC (CONS X9 X10))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules
CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription rule CC,
to

Subgoal 3.6.1''
(IMPLIES (ASSOC-EQUAL (LIST* 'QUOTE NIL X10)
                      ALIST)
         (< 0 (+ 6 (CC X10) (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 3.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 3.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following four goals.

Subgoal 3.4.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CADR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 3.4.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CADR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CAR, CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CDR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 3.4.4''
(IMPLIES (AND (NOT (CONSP X4))
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.4.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CAR X6))
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 3.4.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CAR X6))
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 3.4.3''
(IMPLIES (AND (NOT (CONSP X6))
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 3 (CC X3) (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.4.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC X7)
            (+ 2 (CC X3) (CC (LIST* X5 X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 3.4.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC X7)
            (+ 2 (CC X3) (CC (LIST* X5 X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 3.4.2''
(IMPLIES (AND (NOT (CONSP X3))
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.4.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) ALIST))))
         (< (CC X7)
            (+ 2 (CC (CONS X4 X6))
               (CC (LIST* X5 X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 3.4.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) ALIST))))
         (< (CC X7)
            (+ 2 (CC (CONS X4 X6))
               (CC (LIST* X5 X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 3.4.1''
(IMPLIES (AND (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) ALIST))))
         (< 0
            (+ 5 (CC X4) (CC X5) (CC X6) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR and EQUAL and the :rewrite rules DEFAULT-CAR and
DEFAULT-CDR.

Subgoal 3.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+ and CC, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-
prescription rule CC, to

Subgoal 3.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CDDR X))
               (CC (CDR (CADR X)))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of six rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Use CAR-CDR-ELIM to replace
X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6 and restrict
the type of the new variable X4 to be that of the term it replaces.
(6) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X9 X10), (CAR X6)
by X9 and (CDR X6) by X10.  These steps produce the following four
goals.

Subgoal 3.2.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CADR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 3.2.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CADR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CAR, CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules DEFAULT-CDR and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3.2.4''
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< 0 (+ 3 (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.2.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CAR X6))
            (+ 3 (CC (CONS X5 X6)) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 3.2.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CAR X6))
            (+ 3 (CC (CONS X5 X6)) (CC (CDR X3))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 3.2.3''
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< 0 (+ 4 (CC X5) (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.2.2
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6)))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8)) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 3.2.2'
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6)))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8)) (CC X6)))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, DEFAULT-CAR and
FOLD-CONSTS-IN-+, to

Subgoal 3.2.2''
(IMPLIES (NOT (CONSP X6))
         (< 0 (+ 5 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.2.1
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT X9))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8))
               (CC (CONS X9 X10))))).

By case analysis we reduce the conjecture to

Subgoal 3.2.1'
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT X9))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8))
               (CC (CONS X9 X10))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules
CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription rule CC,
to

Subgoal 3.2.1''
(< 0 (+ 6 (CC X10) (CC X5) (CC X8))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (QUOTEP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST)))
         (O< (CC (CADDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro), FIX, O< (if-intro) and QUOTEP (if-intro),
the :executable-counterpart of CC, primitive type reasoning, the :rewrite
rule UNICITY-OF-0 and the :type-prescription rule CC, to the following
four conjectures.

Subgoal 2.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 2.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X)) (+ 2 (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following two goals.

Subgoal 2.4.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 2.4.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CAR.

Subgoal 2.4.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.4.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS and FOLD-CONSTS-IN-+, to

Subgoal 2.4.1''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and CONSP and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 2.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
three goals.

Subgoal 2.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 2.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 2.2.3''
(IMPLIES (AND (NOT (CONSP X4))
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 2.2.2''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.2.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.2.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 2.2.1''
(IMPLIES (AND (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< 0 (+ 4 (CC X4) (CC X6) (CC X7)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and EQUAL and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (QUOTEP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST)))
         (O< (CC (CADDDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro), FIX (if-intro), O< (if-intro) and QUOTEP
(if-intro), the :executable-counterpart of CC, primitive type reasoning,
the :rewrite rule UNICITY-OF-0 and the :type-prescription rule CC,
to the following six conjectures.

Subgoal 1.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR, CONS and CONSP and the :rewrite rules DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 1 (CC (CADDR X))
               (CC (CDDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 1.5'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CADDR X)) (CC (CDDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
two goals.

Subgoal 1.5.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< (CC (CAR X6))
            (+ 3 (CC X5) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.5.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< (CC (CAR X6))
            (+ 3 (CC X5) (CC X6)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.5.2''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< 0 (+ 3 (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.5.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< (CC X7)
            (+ 3 (CC X5) (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.5.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< (CC X7)
            (+ 3 (CC X5) (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 1.5.1''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< (CC (CADDDR X)) 2)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR and CC and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR, CONS and EQUAL and the :rewrite rules DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X))
               1 (CC (CADDR X))
               (CC (CDDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 1.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CADR X))
               (CC (CADDR X))
               (CC (CDDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following three goals.

Subgoal 1.2.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< (CC (CAR X6))
            (+ 3 (CC X3) (CC X5) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.2.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< (CC (CAR X6))
            (+ 3 (CC X3) (CC X5) (CC X6)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.2.3''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< 0 (+ 3 (CC X3) (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< (CC X7)
            (+ 3 (CC X3)
               (CC X5)
               (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< (CC X7)
            (+ 3 (CC X3)
               (CC X5)
               (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 1.2.2''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (TAUTP X5 (CONS (CONS X3 T) ALIST)))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (TAUTP X5 (CONS (CONS (CONS X4 X6) T) ALIST)))
         (< (CC X7)
            (+ 3 (CC (CONS X4 X6))
               (CC X5)
               (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.2.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (TAUTP X5 (CONS (CONS (CONS X4 X6) T) ALIST)))
         (< (CC X7)
            (+ 3 (CC (CONS X4 X6))
               (CC X5)
               (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 1.2.1''
(IMPLIES (AND (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (TAUTP X5 (CONS (CONS (CONS X4 X6) T) ALIST)))
         (< 0
            (+ 5 (CC X4) (CC X5) (CC X6) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) ALIST))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) 0))).

This simplifies, using the :definitions FIX and SYNP, the :executable-
counterparts of BINARY-+, CAR and CC, the :rewrite rules COMMUTATIVITY-OF-+,
DEFAULT-CAR, DEFAULT-CDR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the
:type-prescription rule CC, to

Subgoal 1.1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (TAUTP NIL (CONS (CONS (CADR X) T) ALIST))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< 0 (+ 2 (CC (CADR X))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for TAUTP.  Thus, we
admit this function under the principle of definition.  We could deduce
no constraints on the type of TAUTP.

Summary
Form:  ( DEFUN TAUTP ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION ASSIGNEDP)
        (:DEFINITION ASSIGNMENT)
        (:DEFINITION ASSUME-TRUE)
        (:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:DEFINITION QUOTEP)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ASSIGNEDP)
             (:DEFINITION ASSIGNMENT)
             (:DEFINITION CC)
             (:DEFINITION FIX)
             (:DEFINITION O<)
             (:DEFINITION QUOTEP))
 TAUTP
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 135.
"
ACL2 !>>(DEFUN TAUTOLOGY-CHECKER (X)
          (TAUTP (NORM X) NIL))

Since TAUTOLOGY-CHECKER is non-recursive, its admission is trivial.
We could deduce no constraints on the type of TAUTOLOGY-CHECKER.

Summary
Form:  ( DEFUN TAUTOLOGY-CHECKER ...)
Rules: NIL
 TAUTOLOGY-CHECKER
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 136.
"
ACL2 !>>(THEOREM PROBLEM-136A
                 (IMPLIES (ALISTP A)
                          (EQUAL (ASSOC-EQUAL X (APP A B))
                                 (IF (ASSOC-EQUAL X A)
                                     (ASSOC-EQUAL X A)
                                   (ASSOC-EQUAL X B))))
                 :HINTS (("Goal" :INDUCT (APP A B))))


ACL2 !>>>(DEFTHM PROBLEM-136A
           (IMPLIES (ALISTP A)
                    (EQUAL (ASSOC-EQUAL X (APP A B))
                           (IF (ASSOC-EQUAL X A)
                               (ASSOC-EQUAL X A)
                             (ASSOC-EQUAL X B))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (APP A B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (APP A B).

This suggestion was produced using the :induction rule APP.  If we
let (:P A B X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (CONSP A)) (:P A B X))
     (IMPLIES (AND (CONSP A) (:P (CDR A) B X))
              (:P A B X))).
This induction is justified by the same argument used to admit APP.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.

Subgoal *1/2
(IMPLIES (NOT (CONSP A))
         (IMPLIES (ALISTP A)
                  (EQUAL (ASSOC-EQUAL X (APP A B))
                         (OR (ASSOC-EQUAL X A)
                             (ASSOC-EQUAL X B))))).

By case analysis we reduce the conjecture to

Subgoal *1/2'
(IMPLIES (AND (NOT (CONSP A)) (ALISTP A))
         (EQUAL (ASSOC-EQUAL X (APP A B))
                (OR (ASSOC-EQUAL X A)
                    (ASSOC-EQUAL X B)))).

But simplification reduces this to T, using the :definitions ALISTP,
APP and ASSOC-EQUAL, the :executable-counterpart of CONSP and primitive
type reasoning.

Subgoal *1/1
(IMPLIES (AND (CONSP A)
              (IMPLIES (ALISTP (CDR A))
                       (EQUAL (ASSOC-EQUAL X (APP (CDR A) B))
                              (OR (ASSOC-EQUAL X (CDR A))
                                  (ASSOC-EQUAL X B)))))
         (IMPLIES (ALISTP A)
                  (EQUAL (ASSOC-EQUAL X (APP A B))
                         (OR (ASSOC-EQUAL X A)
                             (ASSOC-EQUAL X B))))).

By case analysis we reduce the conjecture to

Subgoal *1/1'
(IMPLIES (AND (CONSP A)
              (IMPLIES (ALISTP (CDR A))
                       (EQUAL (ASSOC-EQUAL X (APP (CDR A) B))
                              (OR (ASSOC-EQUAL X (CDR A))
                                  (ASSOC-EQUAL X B))))
              (ALISTP A))
         (EQUAL (ASSOC-EQUAL X (APP A B))
                (OR (ASSOC-EQUAL X A)
                    (ASSOC-EQUAL X B)))).

But simplification reduces this to T, using the :definitions ALISTP,
APP and ASSOC-EQUAL, primitive type reasoning and the :rewrite rules
CAR-CONS and CDR-CONS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-136A ...)
Rules: ((:DEFINITION ALISTP)
        (:DEFINITION APP)
        (:DEFINITION ASSOC-EQUAL)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION APP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
PROBLEM-136A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-136A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-136A)
PROBLEM-136A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-136A ...) ...)
Rules: NIL
 PROBLEM-136A
ACL2 !>>(THEOREM PROBLEM-136B
                 (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                          (IFF (PEVAL X (CONS (CONS VAR VAL) ALIST))
                               (PEVAL X ALIST)))
                 :HINTS (("Goal" :INDUCT (PEVAL X ALIST))))


ACL2 !>>>(DEFTHM PROBLEM-136B
           (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                    (IFF (PEVAL X (CONS (CONS VAR VAL) ALIST))
                         (PEVAL X ALIST)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (PEVAL X ALIST))))

ACL2 Warning [Double-rewrite] in ( DEFTHM PROBLEM-136B ...):  In a
:REWRITE rule generated from PROBLEM-136B, equivalence relation IFF
is maintained at one problematic occurrence of variable VAL in the
first hypothesis, but not at any binding occurrence of VAL.  Consider
replacing that occurrence of VAL in the first hypothesis with 
(DOUBLE-REWRITE VAL).  See :doc double-rewrite for more information
on this issue.


[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (PEVAL X ALIST).

This suggestion was produced using the :induction rule PEVAL.  If we
let (:P ALIST VAL VAR X) denote *1 above then the induction scheme
we'll use is
(AND (IMPLIES (NOT (IF-EXPRP X))
              (:P ALIST VAL VAR X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (PEVAL (A1 X) ALIST))
                   (:P ALIST VAL VAR (A1 X))
                   (:P ALIST VAL VAR (A3 X)))
              (:P ALIST VAL VAR X))
     (IMPLIES (AND (IF-EXPRP X)
                   (PEVAL (A1 X) ALIST)
                   (:P ALIST VAL VAR (A1 X))
                   (:P ALIST VAL VAR (A2 X)))
              (:P ALIST VAL VAR X))).
This induction is justified by the same argument used to admit PEVAL.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (NOT (IF-EXPRP X))
         (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                  (IFF (PEVAL X (CONS (CONS VAR VAL) ALIST))
                       (PEVAL X ALIST)))).

By case analysis we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (COND ((CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                    (VAL NIL)
                    (T T)))
         (COND ((PEVAL X (CONS (CONS VAR VAL) ALIST))
                (PEVAL X ALIST))
               ((PEVAL X ALIST) NIL)
               (T T))).

This simplifies, using the :definitions ASSIGNMENT (if-intro), ASSOC-EQUAL
(if-intro), IF-EXPRP (if-intro), PEVAL (if-intro) and QUOTEP (if-intro),
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS,
to the following twelve conjectures.

Subgoal *1/3.12
(IMPLIES (AND (NOT (CONSP X))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (EQUAL X VAR)
              (NOT (CDR (LIST VAR))))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/3.12'
(IMPLIES (AND (NOT (CONSP X))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (EQUAL X VAR))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.11
(IMPLIES (AND (NOT (CONSP X))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (EQUAL X VAR)
              (CDR (LIST VAR)))
         (CDR (ASSOC-EQUAL X ALIST))).

But we reduce the conjecture to T, by the simple :rewrite rule CDR-CONS.

Subgoal *1/3.10
(IMPLIES (AND (NOT (CONSP X))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (EQUAL X VAR)
              (NOT (CDR (CONS VAR VAL))))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

But we reduce the conjecture to T, by the simple :rewrite rule CDR-CONS.

Subgoal *1/3.9
(IMPLIES (AND (NOT (CONSP X))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (EQUAL X VAR)
              (CDR (CONS VAR VAL)))
         (CDR (ASSOC-EQUAL X ALIST))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/3.9'
(IMPLIES (AND (NOT (CONSP X))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (EQUAL X VAR))
         (CDR (ASSOC-EQUAL X ALIST))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.8
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (NOT (CONSP X))
              (EQUAL X VAR)
              (CDR (LIST VAR)))
         (CDR (ASSOC-EQUAL X ALIST))).

But we reduce the conjecture to T, by the simple :rewrite rule CDR-CONS.

Subgoal *1/3.7
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (NOT (CONSP X))
              (EQUAL X VAR)
              (NOT (CDR (LIST VAR))))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/3.7'
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (NOT (CONSP X))
              (EQUAL X VAR))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.6
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (NOT (EQUAL (CAR X) 'QUOTE))
              (EQUAL X VAR)
              (CDR (LIST VAR)))
         (CDR (ASSOC-EQUAL X ALIST))).

But we reduce the conjecture to T, by the simple :rewrite rule CDR-CONS.

Subgoal *1/3.5
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (NOT (EQUAL (CAR X) 'QUOTE))
              (EQUAL X VAR)
              (NOT (CDR (LIST VAR))))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/3.5'
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT VAL)
              (NOT (EQUAL (CAR X) 'QUOTE))
              (EQUAL X VAR))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.4
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (NOT (CONSP X))
              (EQUAL X VAR)
              (CDR (CONS VAR VAL)))
         (CDR (ASSOC-EQUAL X ALIST))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/3.4'
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (NOT (CONSP X))
              (EQUAL X VAR))
         (CDR (ASSOC-EQUAL X ALIST))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.3
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (NOT (CONSP X))
              (EQUAL X VAR)
              (NOT (CDR (CONS VAR VAL))))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

But we reduce the conjecture to T, by the simple :rewrite rule CDR-CONS.

Subgoal *1/3.2
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (NOT (EQUAL (CAR X) 'QUOTE))
              (EQUAL X VAR)
              (CDR (CONS VAR VAL)))
         (CDR (ASSOC-EQUAL X ALIST))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/3.2'
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (NOT (EQUAL (CAR X) 'QUOTE))
              (EQUAL X VAR))
         (CDR (ASSOC-EQUAL X ALIST))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.1
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (CDR (ASSOC-EQUAL VAR ALIST))
              VAL (NOT (EQUAL (CAR X) 'QUOTE))
              (EQUAL X VAR)
              (NOT (CDR (CONS VAR VAL))))
         (NOT (CDR (ASSOC-EQUAL X ALIST)))).

But we reduce the conjecture to T, by the simple :rewrite rule CDR-CONS.

Subgoal *1/2
(IMPLIES (AND (IF-EXPRP X)
              (NOT (PEVAL (A1 X) ALIST))
              (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                       (IFF (PEVAL (A1 X)
                                   (CONS (CONS VAR VAL) ALIST))
                            (PEVAL (A1 X) ALIST)))
              (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                       (IFF (PEVAL (A3 X)
                                   (CONS (CONS VAR VAL) ALIST))
                            (PEVAL (A3 X) ALIST))))
         (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                  (IFF (PEVAL X (CONS (CONS VAR VAL) ALIST))
                       (PEVAL X ALIST)))).

By the simple :definitions A1, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (IMPLIES (COND ((CDR (ASSOC-EQUAL VAR ALIST))
                              (AND VAL T))
                             (VAL NIL)
                             (T T))
                       (COND ((PEVAL (CADR X)
                                     (CONS (CONS VAR VAL) ALIST))
                              (AND (PEVAL (CADR X) ALIST) T))
                             ((PEVAL (CADR X) ALIST) NIL)
                             (T T)))
              (IMPLIES (COND ((CDR (ASSOC-EQUAL VAR ALIST))
                              (AND VAL T))
                             (VAL NIL)
                             (T T))
                       (COND ((PEVAL (CADDDR X)
                                     (CONS (CONS VAR VAL) ALIST))
                              (AND (PEVAL (CADDDR X) ALIST) T))
                             ((PEVAL (CADDDR X) ALIST) NIL)
                             (T T)))
              (COND ((CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                    (VAL NIL)
                    (T T)))
         (COND ((PEVAL X (CONS (CONS VAR VAL) ALIST))
                (PEVAL X ALIST))
               ((PEVAL X ALIST) NIL)
               (T T))).

This simplifies, using the :congruence rule IFF-IMPLIES-EQUAL-NOT,
the :definitions A1, A3, IF-EXPRP and PEVAL (if-intro) and the :executable-
counterpart of EQUAL, to the following eight conjectures.

Subgoal *1/2.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (PEVAL (CADR X)
                          (CONS (LIST VAR) ALIST)))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (PEVAL (CADDDR X)
                     (CONS (LIST VAR) ALIST))
              (PEVAL (CADDDR X) ALIST)
              (NOT VAL)
              (PEVAL (A1 X) ALIST))
         (PEVAL (A2 X) ALIST)).

But we reduce the conjecture to T, by the simple :definitions A1 and
A2.

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (PEVAL (CADR X)
                          (CONS (LIST VAR) ALIST)))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (PEVAL (CADDDR X)
                     (CONS (LIST VAR) ALIST))
              (PEVAL (CADDDR X) ALIST)
              (NOT VAL)
              (NOT (PEVAL (A1 X) ALIST)))
         (PEVAL (A3 X) ALIST)).

But we reduce the conjecture to T, by the simple :definitions A1 and
A3.

Subgoal *1/2.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (PEVAL (CADR X)
                          (CONS (LIST VAR) ALIST)))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT (PEVAL (CADDDR X)
                          (CONS (LIST VAR) ALIST)))
              (NOT (PEVAL (CADDDR X) ALIST))
              (NOT VAL)
              (PEVAL (A1 X) ALIST))
         (NOT (PEVAL (A2 X) ALIST))).

But we reduce the conjecture to T, by the simple :definitions A1 and
A2.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (PEVAL (CADR X)
                          (CONS (LIST VAR) ALIST)))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT (PEVAL (CADDDR X)
                          (CONS (LIST VAR) ALIST)))
              (NOT (PEVAL (CADDDR X) ALIST))
              (NOT VAL)
              (NOT (PEVAL (A1 X) ALIST)))
         (NOT (PEVAL (A3 X) ALIST))).

But we reduce the conjecture to T, by the simple :definitions A1 and
A3.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (PEVAL (CADR X)
                          (CONS (CONS VAR VAL) ALIST)))
              VAL
              (PEVAL (CADDDR X)
                     (CONS (CONS VAR VAL) ALIST))
              (PEVAL (CADDDR X) ALIST)
              (CDR (ASSOC-EQUAL VAR ALIST))
              (PEVAL (A1 X) ALIST))
         (PEVAL (A2 X) ALIST)).

But we reduce the conjecture to T, by the simple :definitions A1 and
A2.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (PEVAL (CADR X)
                          (CONS (CONS VAR VAL) ALIST)))
              VAL
              (PEVAL (CADDDR X)
                     (CONS (CONS VAR VAL) ALIST))
              (PEVAL (CADDDR X) ALIST)
              (CDR (ASSOC-EQUAL VAR ALIST))
              (NOT (PEVAL (A1 X) ALIST)))
         (PEVAL (A3 X) ALIST)).

But we reduce the conjecture to T, by the simple :definitions A1 and
A3.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (PEVAL (CADR X)
                          (CONS (CONS VAR VAL) ALIST)))
              VAL
              (NOT (PEVAL (CADDDR X)
                          (CONS (CONS VAR VAL) ALIST)))
              (NOT (PEVAL (CADDDR X) ALIST))
              (CDR (ASSOC-EQUAL VAR ALIST))
              (PEVAL (A1 X) ALIST))
         (NOT (PEVAL (A2 X) ALIST))).

But we reduce the conjecture to T, by the simple :definitions A1 and
A2.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (PEVAL (CADR X) ALIST))
              (NOT (PEVAL (CADR X)
                          (CONS (CONS VAR VAL) ALIST)))
              VAL
              (NOT (PEVAL (CADDDR X)
                          (CONS (CONS VAR VAL) ALIST)))
              (NOT (PEVAL (CADDDR X) ALIST))
              (CDR (ASSOC-EQUAL VAR ALIST))
              (NOT (PEVAL (A1 X) ALIST)))
         (NOT (PEVAL (A3 X) ALIST))).

But we reduce the conjecture to T, by the simple :definitions A1 and
A3.

Subgoal *1/1
(IMPLIES (AND (IF-EXPRP X)
              (PEVAL (A1 X) ALIST)
              (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                       (IFF (PEVAL (A1 X)
                                   (CONS (CONS VAR VAL) ALIST))
                            (PEVAL (A1 X) ALIST)))
              (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                       (IFF (PEVAL (A2 X)
                                   (CONS (CONS VAR VAL) ALIST))
                            (PEVAL (A2 X) ALIST))))
         (IMPLIES (IFF (CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                  (IFF (PEVAL X (CONS (CONS VAR VAL) ALIST))
                       (PEVAL X ALIST)))).

By the simple :definitions A1, A2 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (IMPLIES (COND ((CDR (ASSOC-EQUAL VAR ALIST))
                              (AND VAL T))
                             (VAL NIL)
                             (T T))
                       (COND ((PEVAL (CADR X)
                                     (CONS (CONS VAR VAL) ALIST))
                              (AND (PEVAL (CADR X) ALIST) T))
                             ((PEVAL (CADR X) ALIST) NIL)
                             (T T)))
              (IMPLIES (COND ((CDR (ASSOC-EQUAL VAR ALIST))
                              (AND VAL T))
                             (VAL NIL)
                             (T T))
                       (COND ((PEVAL (CADDR X)
                                     (CONS (CONS VAR VAL) ALIST))
                              (AND (PEVAL (CADDR X) ALIST) T))
                             ((PEVAL (CADDR X) ALIST) NIL)
                             (T T)))
              (COND ((CDR (ASSOC-EQUAL VAR ALIST)) VAL)
                    (VAL NIL)
                    (T T)))
         (COND ((PEVAL X (CONS (CONS VAR VAL) ALIST))
                (PEVAL X ALIST))
               ((PEVAL X ALIST) NIL)
               (T T))).

This simplifies, using the :congruence rule IFF-IMPLIES-EQUAL-NOT,
the :definitions A1, A2, IF-EXPRP and PEVAL (if-intro) and the :executable-
counterpart of EQUAL, to the following eight conjectures.

Subgoal *1/1.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (PEVAL (CADR X) (CONS (LIST VAR) ALIST))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (PEVAL (CADDR X)
                     (CONS (LIST VAR) ALIST))
              (PEVAL (CADDR X) ALIST)
              (NOT VAL)
              (PEVAL (A1 X) ALIST))
         (PEVAL (A2 X) ALIST)).

But we reduce the conjecture to T, by the simple :definitions A1 and
A2.

Subgoal *1/1.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (PEVAL (CADR X) (CONS (LIST VAR) ALIST))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (PEVAL (CADDR X)
                     (CONS (LIST VAR) ALIST))
              (PEVAL (CADDR X) ALIST)
              (NOT VAL)
              (NOT (PEVAL (A1 X) ALIST)))
         (PEVAL (A3 X) ALIST)).

But we reduce the conjecture to T, by the simple :definitions A1 and
A3.

Subgoal *1/1.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (PEVAL (CADR X) (CONS (LIST VAR) ALIST))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT (PEVAL (CADDR X)
                          (CONS (LIST VAR) ALIST)))
              (NOT (PEVAL (CADDR X) ALIST))
              (NOT VAL)
              (PEVAL (A1 X) ALIST))
         (NOT (PEVAL (A2 X) ALIST))).

But we reduce the conjecture to T, by the simple :definitions A1 and
A2.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (PEVAL (CADR X) (CONS (LIST VAR) ALIST))
              (NOT (CDR (ASSOC-EQUAL VAR ALIST)))
              (NOT (PEVAL (CADDR X)
                          (CONS (LIST VAR) ALIST)))
              (NOT (PEVAL (CADDR X) ALIST))
              (NOT VAL)
              (NOT (PEVAL (A1 X) ALIST)))
         (NOT (PEVAL (A3 X) ALIST))).

But we reduce the conjecture to T, by the simple :definitions A1 and
A3.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (PEVAL (CADR X)
                     (CONS (CONS VAR VAL) ALIST))
              VAL
              (PEVAL (CADDR X)
                     (CONS (CONS VAR VAL) ALIST))
              (PEVAL (CADDR X) ALIST)
              (CDR (ASSOC-EQUAL VAR ALIST))
              (PEVAL (A1 X) ALIST))
         (PEVAL (A2 X) ALIST)).

But we reduce the conjecture to T, by the simple :definitions A1 and
A2.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (PEVAL (CADR X)
                     (CONS (CONS VAR VAL) ALIST))
              VAL
              (PEVAL (CADDR X)
                     (CONS (CONS VAR VAL) ALIST))
              (PEVAL (CADDR X) ALIST)
              (CDR (ASSOC-EQUAL VAR ALIST))
              (NOT (PEVAL (A1 X) ALIST)))
         (PEVAL (A3 X) ALIST)).

But we reduce the conjecture to T, by the simple :definitions A1 and
A3.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (PEVAL (CADR X)
                     (CONS (CONS VAR VAL) ALIST))
              VAL
              (NOT (PEVAL (CADDR X)
                          (CONS (CONS VAR VAL) ALIST)))
              (NOT (PEVAL (CADDR X) ALIST))
              (CDR (ASSOC-EQUAL VAR ALIST))
              (PEVAL (A1 X) ALIST))
         (NOT (PEVAL (A2 X) ALIST))).

But we reduce the conjecture to T, by the simple :definitions A1 and
A2.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (PEVAL (CADR X) ALIST)
              (PEVAL (CADR X)
                     (CONS (CONS VAR VAL) ALIST))
              VAL
              (NOT (PEVAL (CADDR X)
                          (CONS (CONS VAR VAL) ALIST)))
              (NOT (PEVAL (CADDR X) ALIST))
              (CDR (ASSOC-EQUAL VAR ALIST))
              (NOT (PEVAL (A1 X) ALIST)))
         (NOT (PEVAL (A3 X) ALIST))).

But we reduce the conjecture to T, by the simple :definitions A1 and
A3.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-136B ...)
Rules: ((:CONGRUENCE IFF-IMPLIES-EQUAL-NOT)
        (:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION ASSIGNMENT)
        (:DEFINITION ASSOC-EQUAL)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION IFF)
        (:DEFINITION NOT)
        (:DEFINITION PEVAL)
        (:DEFINITION QUOTEP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION PEVAL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ASSIGNMENT)
             (:DEFINITION ASSOC-EQUAL)
             (:DEFINITION IF-EXPRP)
             (:DEFINITION PEVAL)
             (:DEFINITION QUOTEP))
Warnings:  Double-rewrite
PROBLEM-136B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-136B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-136B)
PROBLEM-136B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-136B ...) ...)
Rules: NIL
Warnings:  Double-rewrite
 PROBLEM-136B
ACL2 !>>(THEOREM
             PROBLEM-136C
             (IMPLIES (AND (ALISTP A) (NORMP X) (TAUTP X A))
                      (PEVAL X (APP A B)))
             :HINTS (("Goal" :INDUCT (TAUTP X A)
                             :IN-THEORY (ENABLE PROBLEM-136A PROBLEM-136B))))


ACL2 !>>>(DEFTHM PROBLEM-136C
           (IMPLIES (AND (ALISTP A) (NORMP X) (TAUTP X A))
                    (PEVAL X (APP A B)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (TAUTP X A)
                           :IN-THEORY (ENABLE PROBLEM-136A PROBLEM-136B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (TAUTP X A).

This suggestion was produced using the :induction rule TAUTP.  If we
let (:P A B X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (NOT (IF-EXPRP X)) (:P A B X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) A))
                   (NOT (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A)))
                   (:P (ASSUME-TRUE (A1 X) A) B (A2 X)))
              (:P A B X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) A))
                   (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
                   (:P (ASSUME-TRUE (A1 X) A) B (A2 X))
                   (:P (ASSUME-FALSE (A1 X) A) B (A3 X)))
              (:P A B X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) A)
                   (NOT (ASSIGNMENT (A1 X) A))
                   (:P A B (A3 X)))
              (:P A B X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) A)
                   (ASSIGNMENT (A1 X) A)
                   (:P A B (A2 X)))
              (:P A B X))).
This induction is justified by the same argument used to admit TAUTP.
Note, however, that the unmeasured variable A is being instantiated.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.

Subgoal *1/5
(IMPLIES (NOT (IF-EXPRP X))
         (IMPLIES (AND (ALISTP A) (NORMP X) (TAUTP X A))
                  (PEVAL X (APP A B)))).

By case analysis we reduce the conjecture to

Subgoal *1/5'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ALISTP A)
              (NORMP X)
              (TAUTP X A))
         (PEVAL X (APP A B))).

But simplification reduces this to T, using the :definitions ASSIGNMENT,
IF-EXPRP, NORMP, PEVAL, QUOTEP and TAUTP, the :executable-counterpart
of EQUAL, the :rewrite rule PROBLEM-136A and the :type-prescription
rule ALISTP.

Subgoal *1/4
(IMPLIES (AND (IF-EXPRP X)
              (NOT (ASSIGNEDP (A1 X) A))
              (NOT (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A)))
              (IMPLIES (AND (ALISTP (ASSUME-TRUE (A1 X) A))
                            (NORMP (A2 X))
                            (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A)))
                       (PEVAL (A2 X)
                              (APP (ASSUME-TRUE (A1 X) A) B))))
         (IMPLIES (AND (ALISTP A) (NORMP X) (TAUTP X A))
                  (PEVAL X (APP A B)))).

By the simple :definitions A1, A2, ASSIGNEDP, ASSUME-TRUE and IF-EXPRP
we reduce the conjecture to

Subgoal *1/4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (QUOTEP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (TAUTP (CADDR X)
                          (CONS (CONS (CADR X) T) A)))
              (IMPLIES (AND (ALISTP (CONS (CONS (CADR X) T) A))
                            (NORMP (CADDR X))
                            (TAUTP (CADDR X)
                                   (CONS (CONS (CADR X) T) A)))
                       (PEVAL (CADDR X)
                              (APP (CONS (CONS (CADR X) T) A) B)))
              (ALISTP A)
              (NORMP X)
              (TAUTP X A))
         (PEVAL X (APP A B))).

This simplifies, using the :definitions A1, ALISTP, ASSIGNEDP, IF-EXPRP,
QUOTEP (if-intro) and TAUTP (if-intro), the :executable-counterpart
of EQUAL, primitive type reasoning, the :forward-chaining rule 
ALISTP-FORWARD-TO-TRUE-LISTP, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule ALISTP, to the following two conjectures.

Subgoal *1/4.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (TAUTP (CADDR X)
                          (CONS (CONS (CADR X) T) A)))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A)))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (TAUTP (CADDR X)
                          (CONS (CONS (CADR X) T) A)))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A)))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3
(IMPLIES (AND (IF-EXPRP X)
              (NOT (ASSIGNEDP (A1 X) A))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (IMPLIES (AND (ALISTP (ASSUME-TRUE (A1 X) A))
                            (NORMP (A2 X))
                            (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A)))
                       (PEVAL (A2 X)
                              (APP (ASSUME-TRUE (A1 X) A) B)))
              (IMPLIES (AND (ALISTP (ASSUME-FALSE (A1 X) A))
                            (NORMP (A3 X))
                            (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A)))
                       (PEVAL (A3 X)
                              (APP (ASSUME-FALSE (A1 X) A) B))))
         (IMPLIES (AND (ALISTP A) (NORMP X) (TAUTP X A))
                  (PEVAL X (APP A B)))).

By the simple :definitions A1, A2, A3, ASSIGNEDP, ASSUME-FALSE, ASSUME-TRUE
and IF-EXPRP we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (QUOTEP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (IMPLIES (AND (ALISTP (CONS (CONS (CADR X) T) A))
                            (NORMP (CADDR X))
                            (TAUTP (CADDR X)
                                   (CONS (CONS (CADR X) T) A)))
                       (PEVAL (CADDR X)
                              (APP (CONS (CONS (CADR X) T) A) B)))
              (IMPLIES (AND (ALISTP (CONS (LIST (CADR X)) A))
                            (NORMP (CADDDR X))
                            (TAUTP (CADDDR X)
                                   (CONS (LIST (CADR X)) A)))
                       (PEVAL (CADDDR X)
                              (APP (CONS (LIST (CADR X)) A) B)))
              (ALISTP A)
              (NORMP X)
              (TAUTP X A))
         (PEVAL X (APP A B))).

This simplifies, using the :definitions A1, A2, A3, ALISTP, APP, ASSIGNEDP,
ASSIGNMENT, IF-EXPRP (if-intro), NORMP (if-intro), PEVAL (if-intro),
QUOTEP (if-intro) and TAUTP (if-intro), the :executable-counterpart
of EQUAL, primitive type reasoning, the :forward-chaining rule 
ALISTP-FORWARD-TO-TRUE-LISTP, the :rewrite rules CAR-CONS, CDR-CONS
and PROBLEM-136A and the :type-prescription rules ALISTP and NORMP,
to the following twelve conjectures.

Subgoal *1/3.12
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/3.12'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (CADDDR X)
                     (CONS (LIST (CADR X)) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

But simplification reduces this to T, using the :equivalence rule 
IFF-IS-AN-EQUIVALENCE, the :executable-counterpart of IFF, the :rewrite
rules PROBLEM-136A and PROBLEM-136B and the :type-prescription rule
ALISTP.

Subgoal *1/3.11
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/3.11'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (CADDDR X)
                     (CONS (LIST (CADR X)) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

But simplification reduces this to T, using the :executable-counterpart
of IFF, the :rewrite rules PROBLEM-136A and PROBLEM-136B and the :type-
prescription rule ALISTP.

Subgoal *1/3.10
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (ALISTP A)
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.9
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (ALISTP A)
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/3.8'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (CADDDR X)
                     (CONS (LIST (CADR X)) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

But simplification reduces this to T, using the :equivalence rule 
IFF-IS-AN-EQUIVALENCE, the :executable-counterparts of EQUAL and IFF,
the :rewrite rules DEFAULT-CAR, PROBLEM-136A and PROBLEM-136B and the
:type-prescription rule ALISTP.

Subgoal *1/3.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/3.7'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (CADDDR X)
                     (CONS (LIST (CADR X)) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

But simplification reduces this to T, using the :executable-counterparts
of EQUAL and IFF, the :rewrite rules DEFAULT-CAR, PROBLEM-136A and
PROBLEM-136B and the :type-prescription rule ALISTP.

Subgoal *1/3.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/3.6'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (CADDDR X)
                     (CONS (LIST (CADR X)) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

But simplification reduces this to T, using the :equivalence rule 
IFF-IS-AN-EQUIVALENCE, the :executable-counterpart of IFF, the :rewrite
rules PROBLEM-136A and PROBLEM-136B and the :type-prescription rule
ALISTP.

Subgoal *1/3.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/3.5'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (PEVAL (CADDDR X)
                     (CONS (LIST (CADR X)) (APP A B)))
              (ALISTP A)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (CADDDR X)
                     (CONS (LIST (CADR X)) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

But simplification reduces this to T, using the :executable-counterpart
of IFF, the :rewrite rules PROBLEM-136A and PROBLEM-136B and the :type-
prescription rule ALISTP.

Subgoal *1/3.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (ALISTP A)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (ALISTP A)
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (ALISTP A)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (CDR (ASSOC-EQUAL (CADR X) B)))
         (PEVAL (CADDR X) (APP A B))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (PEVAL (CADDR X)
                     (CONS (CONS (CADR X) T) (APP A B)))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (ALISTP A)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))
              (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) B))))
         (PEVAL (CADDDR X) (APP A B))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/2
(IMPLIES (AND (IF-EXPRP X)
              (ASSIGNEDP (A1 X) A)
              (NOT (ASSIGNMENT (A1 X) A))
              (IMPLIES (AND (ALISTP A)
                            (NORMP (A3 X))
                            (TAUTP (A3 X) A))
                       (PEVAL (A3 X) (APP A B))))
         (IMPLIES (AND (ALISTP A) (NORMP X) (TAUTP X A))
                  (PEVAL X (APP A B)))).

By the simple :definitions A1, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNEDP (CADR X) A)
              (NOT (ASSIGNMENT (CADR X) A))
              (IMPLIES (AND (ALISTP A)
                            (NORMP (CADDDR X))
                            (TAUTP (CADDDR X) A))
                       (PEVAL (CADDDR X) (APP A B)))
              (ALISTP A)
              (NORMP X)
              (TAUTP X A))
         (PEVAL X (APP A B))).

This simplifies, using the :definitions A1, A2, A3, ASSIGNEDP (if-intro),
ASSIGNMENT (if-intro), IF-EXPRP (if-intro), NORMP, QUOTEP (if-intro)
and TAUTP, the :executable-counterpart of EQUAL and the :type-prescription
rule ALISTP, to the following eight conjectures.

Subgoal *1/2.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (PEVAL (CADDDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A3 X) A))
         (PEVAL X (APP A B))).

By the simple :definition A3 we reduce the conjecture to

Subgoal *1/2.8'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (PEVAL (CADDDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDDR X) A))
         (PEVAL X (APP A B))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
four goals.

Subgoal *1/2.8.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (CONSP (CAR X2)))
              (NOT (CDR (ASSOC-EQUAL (CAR X2) A)))
              (PEVAL (CADDR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADDR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.8.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (CONSP (CAR X2)))
              (NOT (CDR (ASSOC-EQUAL (CAR X2) A)))
              (PEVAL (CADDR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADDR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

But simplification reduces this to T, using the :definitions ASSIGNMENT
and PEVAL, the :executable-counterparts of CAR, CDR, CONSP, EQUAL,
IF-EXPRP, NOT, QUOTEP and SYMBOLP, primitive type reasoning, the :rewrite
rules DEFAULT-CAR, DEFAULT-CDR and PROBLEM-136A and the :type-prescription
rule ALISTP.

Subgoal *1/2.8.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL (CADR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CADR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.8.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL (CADR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CADR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/2.8.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL (CAR X6) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP (CAR X6) A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.8.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL (CAR X6) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP (CAR X6) A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL, QUOTEP and TAUTP, the :executable-
counterparts of CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :forward-chaining rule CONSP-ASSOC-EQUAL,
the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR and PROBLEM-136A
and the :type-prescription rules ALISTP and NORMP.

Subgoal *1/2.8.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 X3 X5 X7 X8)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.8.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 X3 X5 X7 X8)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning, the
:forward-chaining rule CONSP-ASSOC-EQUAL, the :rewrite rules CAR-CONS,
CDR-CONS and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (NOT (TAUTP (CADDDR X) A))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A3 X) A))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (PEVAL (CADDDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A3 X) A))
         (PEVAL X (APP A B))).

By the simple :definition A3 we reduce the conjecture to

Subgoal *1/2.6'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (PEVAL (CADDDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDDR X) A))
         (PEVAL X (APP A B))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of six rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Use CAR-CDR-ELIM to replace
X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6 and restrict
the type of the new variable X4 to be that of the term it replaces.
(6) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X9 X10), (CAR X6)
by X9 and (CDR X6) by X10.  These steps produce the following five
goals.

Subgoal *1/2.6.5
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (CONSP (CAR X2))
              (EQUAL (CAR (CAR X2)) 'QUOTE)
              (NOT (CADR (CAR X2)))
              (PEVAL (CADDR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADDR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/2.6.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (PEVAL (CADR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CADR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.6.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (PEVAL (CADR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CADR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/2.6.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (PEVAL (CAR X6) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP (CAR X6) A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.6.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (PEVAL (CAR X6) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP (CAR X6) A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL, QUOTEP and TAUTP, the :executable-
counterparts of CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR
and PROBLEM-136A and the :type-prescription rules ALISTP and NORMP.

Subgoal *1/2.6.2
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) A)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.6.2'
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) A)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS, CDR-CONS and DEFAULT-CAR.

Subgoal *1/2.6.1
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X9 X10) A)
              (EQUAL X4 'QUOTE)
              (NOT X9)
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.6.1'
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X9 X10) A)
              (EQUAL X4 'QUOTE)
              (NOT X9)
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (TAUTP (CADDDR X) A))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A3 X) A))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (PEVAL (CADDDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A3 X) A))
         (PEVAL X (APP A B))).

By the simple :definition A3 we reduce the conjecture to

Subgoal *1/2.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (PEVAL (CADDDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDDR X) A))
         (PEVAL X (APP A B))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following five goals.

Subgoal *1/2.4.5
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CAR X2) A)))
              (PEVAL (CADDR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADDR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.4.5'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CAR X2) A)))
              (PEVAL (CADDR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADDR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

But simplification reduces this to T, using the :definitions ASSIGNMENT
and PEVAL, the :executable-counterparts of CAR, CDR, EQUAL, IF-EXPRP,
NOT, QUOTEP and SYMBOLP, primitive type reasoning, the :rewrite rules
DEFAULT-CAR, DEFAULT-CDR and PROBLEM-136A and the :type-prescription
rule ALISTP.

Subgoal *1/2.4.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL (CADR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CADR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.4.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL (CADR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CADR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/2.4.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL (CAR X6) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP (CAR X6) A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.4.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL (CAR X6) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP (CAR X6) A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL, QUOTEP and TAUTP, the :executable-
counterparts of CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :forward-chaining rule CONSP-ASSOC-EQUAL,
the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR and PROBLEM-136A
and the :type-prescription rules ALISTP and NORMP.

Subgoal *1/2.4.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 X3 X5 X7 X8)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.4.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 X3 X5 X7 X8)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning, the
:forward-chaining rule CONSP-ASSOC-EQUAL, the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and PROBLEM-136A and the :type-prescription rule
ALISTP.

Subgoal *1/2.4.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) A)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) A)))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.4.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) A)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) A)))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning, the
:forward-chaining rule CONSP-ASSOC-EQUAL, the :rewrite rules CAR-CONS,
CDR-CONS and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (NOT (TAUTP (CADDDR X) A))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A3 X) A))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (PEVAL (CADDDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A3 X) A))
         (PEVAL X (APP A B))).

By the simple :definition A3 we reduce the conjecture to

Subgoal *1/2.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (PEVAL (CADDDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDDR X) A))
         (PEVAL X (APP A B))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of six rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Use CAR-CDR-ELIM to replace
X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6 and restrict
the type of the new variable X4 to be that of the term it replaces.
(6) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X9 X10), (CAR X6)
by X9 and (CDR X6) by X10.  These steps produce the following five
goals.

Subgoal *1/2.2.5
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (CONSP (CAR X2))
              (EQUAL (CAR (CAR X2)) 'QUOTE)
              (NOT (CADR (CAR X2)))
              (PEVAL (CADDR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADDR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/2.2.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (PEVAL (CADR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CADR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.2.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (PEVAL (CADR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CADR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/2.2.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (PEVAL (CAR X6) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP (CAR X6) A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.2.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (PEVAL (CAR X6) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP (CAR X6) A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL, QUOTEP and TAUTP, the :executable-
counterparts of CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR
and PROBLEM-136A and the :type-prescription rules ALISTP and NORMP.

Subgoal *1/2.2.2
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.2.2'
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6))
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS, CDR-CONS and DEFAULT-CAR.

Subgoal *1/2.2.1
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT X9)
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/2.2.1'
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT X9)
              (PEVAL X7 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (TAUTP X7 A))
         (PEVAL (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (TAUTP (CADDDR X) A))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A3 X) A))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/1
(IMPLIES (AND (IF-EXPRP X)
              (ASSIGNEDP (A1 X) A)
              (ASSIGNMENT (A1 X) A)
              (IMPLIES (AND (ALISTP A)
                            (NORMP (A2 X))
                            (TAUTP (A2 X) A))
                       (PEVAL (A2 X) (APP A B))))
         (IMPLIES (AND (ALISTP A) (NORMP X) (TAUTP X A))
                  (PEVAL X (APP A B)))).

By the simple :definitions A1, A2 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNEDP (CADR X) A)
              (ASSIGNMENT (CADR X) A)
              (IMPLIES (AND (ALISTP A)
                            (NORMP (CADDR X))
                            (TAUTP (CADDR X) A))
                       (PEVAL (CADDR X) (APP A B)))
              (ALISTP A)
              (NORMP X)
              (TAUTP X A))
         (PEVAL X (APP A B))).

This simplifies, using the :definitions A1, A2, ASSIGNEDP (if-intro),
ASSIGNMENT (if-intro), IF-EXPRP (if-intro), NORMP, QUOTEP (if-intro)
and TAUTP, the :executable-counterpart of EQUAL and the :type-prescription
rule ALISTP, to the following eight conjectures.

Subgoal *1/1.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) A))
         (PEVAL X (APP A B))).

By the simple :definition A2 we reduce the conjecture to

Subgoal *1/1.8'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDR X) A))
         (PEVAL X (APP A B))).

This simplifies, using primitive type reasoning, the :forward-chaining
rule CONSP-ASSOC-EQUAL and the :type-prescription rule ALISTP, to

Subgoal *1/1.8''
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDR X) A))
         (PEVAL X (APP A B))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following three goals.

Subgoal *1/1.8.3
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (CDR (ASSOC-EQUAL (CAR X2) A))
              (PEVAL (CADR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.8.3'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (CDR (ASSOC-EQUAL (CAR X2) A))
              (PEVAL (CADR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, CONSP, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP
and SYMBOLP, primitive type reasoning, the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR, DEFAULT-CDR and PROBLEM-136A and the :type-
prescription rule ALISTP.

Subgoal *1/1.8.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 A))
              (PEVAL (CAR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CAR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.8.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 A))
              (PEVAL (CAR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CAR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/1.8.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 A))
              (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.8.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 A))
              (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning, the
:forward-chaining rule CONSP-ASSOC-EQUAL, the :rewrite rules CAR-CONS,
CDR-CONS and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/1.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (TAUTP (CADDR X) A))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) A))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) A))
         (PEVAL X (APP A B))).

By the simple :definition A2 we reduce the conjecture to

Subgoal *1/1.6'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDR X) A))
         (PEVAL X (APP A B))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7 and restrict the types of the new
variables X4 and X7 to be those of the terms they replace.  (5) Finally,
use CAR-CDR-ELIM to replace X7 by (CONS X8 X9), (CAR X7) by X8 and
(CDR X7) by X9.  These steps produce the following four goals.

Subgoal *1/1.6.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (CONSP (CAR X2))
              (EQUAL (CAR (CAR X2)) 'QUOTE)
              (CADR (CAR X2))
              (PEVAL (CADR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/1.6.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3)
              (PEVAL (CAR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CAR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.6.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3)
              (PEVAL (CAR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CAR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/1.6.2
(IMPLIES (AND (NOT (CONSP X7))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              X7 (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X7) A)
              (EQUAL X4 'QUOTE)
              (CAR X7)
              (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X7) X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                (APP A B))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/1.6.1
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X8 X9) A)
              (EQUAL X4 'QUOTE)
              X8 (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 (LIST* X4 X8 X9) X5 X6)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.6.1'
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X8 X9) A)
              (EQUAL X4 'QUOTE)
              X8 (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 (LIST* X4 X8 X9) X5 X6)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (TAUTP (CADDR X) A))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) A))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) A))
         (PEVAL X (APP A B))).

By the simple :definition A2 we reduce the conjecture to

Subgoal *1/1.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDR X) A))
         (PEVAL X (APP A B))).

This simplifies, using primitive type reasoning, the :forward-chaining
rule CONSP-ASSOC-EQUAL and the :type-prescription rule ALISTP, to

Subgoal *1/1.4''
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDR X) A))
         (PEVAL X (APP A B))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
four goals.

Subgoal *1/1.4.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CAR X2) A))
              (PEVAL (CADR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.4.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CAR X2) A))
              (PEVAL (CADR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/1.4.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 A))
              (PEVAL (CAR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CAR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.4.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 A))
              (PEVAL (CAR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CAR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/1.4.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 A))
              (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.4.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 A))
              (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 X3 X5 X6) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning, the
:forward-chaining rule CONSP-ASSOC-EQUAL, the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and PROBLEM-136A and the :type-prescription rule
ALISTP.

Subgoal *1/1.4.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) A))
              (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X7) X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.4.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) A))
              (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X7) X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning, the
:forward-chaining rule CONSP-ASSOC-EQUAL, the :rewrite rules CAR-CONS,
CDR-CONS and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (TAUTP (CADDR X) A))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) A))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) A))
         (PEVAL X (APP A B))).

By the simple :definition A2 we reduce the conjecture to

Subgoal *1/1.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (PEVAL (CADDR X) (APP A B))
              (ALISTP A)
              (NORMP X)
              (TAUTP (CADDR X) A))
         (PEVAL X (APP A B))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7 and restrict the types of the new
variables X4 and X7 to be those of the terms they replace.  (5) Finally,
use CAR-CDR-ELIM to replace X7 by (CONS X8 X9), (CAR X7) by X8 and
(CDR X7) by X9.  These steps produce the following four goals.

Subgoal *1/1.2.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (CONSP (CAR X2))
              (EQUAL (CAR (CAR X2)) 'QUOTE)
              (CADR (CAR X2))
              (PEVAL (CADR X2) (APP A B))
              (ALISTP A)
              (NORMP (CONS X1 X2))
              (TAUTP (CADR X2) A))
         (PEVAL (CONS X1 X2) (APP A B))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/1.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3)
              (PEVAL (CAR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CAR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3)
              (PEVAL (CAR X4) (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 X3 X4))
              (TAUTP (CAR X4) A))
         (PEVAL (LIST* X1 X3 X4) (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and TAUTP, the :executable-
counterparts of CAR, CDR, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP and SYMBOLP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR,
DEFAULT-CDR and PROBLEM-136A and the :type-prescription rule ALISTP.

Subgoal *1/1.2.2
(IMPLIES (AND (NOT (CONSP X7))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              X7 (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (CAR X7)
              (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (CONS X4 X7) X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                (APP A B))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/1.2.1
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              X8 (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 (LIST* X4 X8 X9) X5 X6)
                (APP A B))).

By case analysis we reduce the conjecture to

Subgoal *1/1.2.1'
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              X8 (PEVAL X5 (APP A B))
              (ALISTP A)
              (NORMP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (TAUTP X5 A))
         (PEVAL (LIST* X1 (LIST* X4 X8 X9) X5 X6)
                (APP A B))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (TAUTP (CADDR X) A))
              (ALISTP A)
              (NORMP X)
              (TAUTP (A2 X) A))
         (PEVAL X (APP A B))).

But we reduce the conjecture to T, by the simple :definition A2.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-136C ...)
Rules: ((:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION ALISTP)
        (:DEFINITION APP)
        (:DEFINITION ASSIGNEDP)
        (:DEFINITION ASSIGNMENT)
        (:DEFINITION ASSUME-FALSE)
        (:DEFINITION ASSUME-TRUE)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NORMP)
        (:DEFINITION NOT)
        (:DEFINITION PEVAL)
        (:DEFINITION QUOTEP)
        (:DEFINITION TAUTP)
        (:ELIM CAR-CDR-ELIM)
        (:EQUIVALENCE IFF-IS-AN-EQUIVALENCE)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART IF-EXPRP)
        (:EXECUTABLE-COUNTERPART IFF)
        (:EXECUTABLE-COUNTERPART NORMP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART QUOTEP)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:FORWARD-CHAINING ALISTP-FORWARD-TO-TRUE-LISTP)
        (:FORWARD-CHAINING CONSP-ASSOC-EQUAL)
        (:INDUCTION TAUTP)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE PROBLEM-136A)
        (:REWRITE PROBLEM-136B)
        (:TYPE-PRESCRIPTION ALISTP)
        (:TYPE-PRESCRIPTION NORMP))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ASSIGNEDP)
             (:DEFINITION ASSIGNMENT)
             (:DEFINITION IF-EXPRP)
             (:DEFINITION NORMP)
             (:DEFINITION PEVAL)
             (:DEFINITION QUOTEP)
             (:DEFINITION TAUTP))
PROBLEM-136C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-136C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-136C)
PROBLEM-136C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-136C ...) ...)
Rules: NIL
 PROBLEM-136C
ACL2 !>>(THEOREM PROBLEM-136D (NORMP (NORM X))
                 :HINTS (("Goal" :INDUCT (NORM X))))


ACL2 !>>>(DEFTHM PROBLEM-136D
           (NORMP (NORM X))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (NORM X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (NORM X).

This suggestion was produced using the :induction rule NORM.  If we
let (:P X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (IF-EXPRP X)
                   (NOT (IF-EXPRP (A1 X)))
                   (:P (A2 X))
                   (:P (A3 X)))
              (:P X))
     (IMPLIES (AND (IF-EXPRP X)
                   (IF-EXPRP (A1 X))
                   (:P (LIST 'IF
                             (A1 (A1 X))
                             (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                             (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X)))))
              (:P X))
     (IMPLIES (NOT (IF-EXPRP X)) (:P X))).
This induction is justified by the same argument used to admit NORM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (IF-EXPRP X)
              (NOT (IF-EXPRP (A1 X)))
              (NORMP (NORM (A2 X)))
              (NORMP (NORM (A3 X))))
         (NORMP (NORM X))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (IF-EXPRP (CADR X)))
              (NORMP (NORM (CADDR X)))
              (NORMP (NORM (CADDDR X))))
         (NORMP (NORM X))).

This simplifies, using the :definitions A1, A2, A3, IF-EXPRP (if-intro),
NORM and NORMP (if-intro), the :executable-counterpart of EQUAL, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the
following four conjectures.

Subgoal *1/3.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NORMP (NORM (CADDR X)))
              (NORMP (NORM (CADDDR X))))
         (NORMP (NORM (A2 X)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NORMP (NORM (CADDR X)))
              (NORMP (NORM (CADDDR X))))
         (NORMP (NORM (A3 X)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (NORM (CADDR X)))
              (NORMP (NORM (CADDDR X))))
         (NORMP (NORM (A2 X)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (NORM (CADDR X)))
              (NORMP (NORM (CADDDR X))))
         (NORMP (NORM (A3 X)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2
(IMPLIES (AND (IF-EXPRP X)
              (IF-EXPRP (A1 X))
              (NORMP (NORM (LIST 'IF
                                 (A1 (A1 X))
                                 (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                                 (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X))))))
         (NORMP (NORM X))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'IF)
              (NORMP (NORM (LIST 'IF
                                 (CADR (CADR X))
                                 (LIST 'IF
                                       (CADDR (CADR X))
                                       (CADDR X)
                                       (CADDDR X))
                                 (LIST 'IF
                                       (CADDDR (CADR X))
                                       (CADDR X)
                                       (CADDDR X))))))
         (NORMP (NORM X))).

This simplifies, using the :definitions A1, IF-EXPRP and NORM and the
:executable-counterpart of EQUAL, to

Subgoal *1/2''
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'IF)
              (NORMP (NORM (LIST 'IF
                                 (CADR (CADR X))
                                 (LIST 'IF
                                       (CADDR (CADR X))
                                       (CADDR X)
                                       (CADDDR X))
                                 (LIST 'IF
                                       (CADDDR (CADR X))
                                       (CADDR X)
                                       (CADDDR X))))))
         (NORMP (NORM (LIST 'IF
                            (A1 (A1 X))
                            (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                            (LIST 'IF
                                  (A3 (A1 X))
                                  (A2 X)
                                  (A3 X)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3.

Subgoal *1/1
(IMPLIES (NOT (IF-EXPRP X))
         (NORMP (NORM X))).

But simplification reduces this to T, using the :definitions IF-EXPRP,
NORM and NORMP.

That completes the proof of *1.

Q.E.D.

The storage of PROBLEM-136D depends upon the :type-prescription rule
NORMP.

Summary
Form:  ( DEFTHM PROBLEM-136D ...)
Rules: ((:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NORM)
        (:DEFINITION NORMP)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION NORM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION NORMP))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION IF-EXPRP)
             (:DEFINITION NORMP))
PROBLEM-136D


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-136D))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-136D)
PROBLEM-136D

Summary
Form:  ( PROGN (DEFTHM PROBLEM-136D ...) ...)
Rules: NIL
 PROBLEM-136D
ACL2 !>>(THEOREM PROBLEM-136E
                 (EQUAL (PEVAL (NORM X) A) (PEVAL X A))
                 :HINTS (("Goal" :INDUCT (NORM X))))


ACL2 !>>>(DEFTHM PROBLEM-136E
           (EQUAL (PEVAL (NORM X) A) (PEVAL X A))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (NORM X))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (NORM X).

This suggestion was produced using the :induction rule NORM.  If we
let (:P A X) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (IF-EXPRP X)
                   (NOT (IF-EXPRP (A1 X)))
                   (:P A (A2 X))
                   (:P A (A3 X)))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (IF-EXPRP (A1 X))
                   (:P A
                       (LIST 'IF
                             (A1 (A1 X))
                             (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                             (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X)))))
              (:P A X))
     (IMPLIES (NOT (IF-EXPRP X)) (:P A X))).
This induction is justified by the same argument used to admit NORM.
When applied to the goal at hand the above induction scheme produces
three nontautological subgoals.

Subgoal *1/3
(IMPLIES (AND (IF-EXPRP X)
              (NOT (IF-EXPRP (A1 X)))
              (EQUAL (PEVAL (NORM (A2 X)) A)
                     (PEVAL (A2 X) A))
              (EQUAL (PEVAL (NORM (A3 X)) A)
                     (PEVAL (A3 X) A)))
         (EQUAL (PEVAL (NORM X) A) (PEVAL X A))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (IF-EXPRP (CADR X)))
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A)))
         (EQUAL (PEVAL (NORM X) A) (PEVAL X A))).

This simplifies, using the :definitions A1, A2, A3, ASSIGNMENT (if-
intro), IF-EXPRP (if-intro), NORM, PEVAL (if-intro) and QUOTEP (if-
intro), the :executable-counterpart of EQUAL, primitive type reasoning
and the :rewrite rules CAR-CONS and CDR-CONS, to the following eight
conjectures.

Subgoal *1/3.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A))
              (CDR (ASSOC-EQUAL (CADR X) A)))
         (EQUAL (PEVAL (NORM (A2 X)) A)
                (PEVAL (CADDR X) A))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/3.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A))))
         (EQUAL (PEVAL (NORM (A3 X)) A)
                (PEVAL (CADDDR X) A))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/3.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A))
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A)))
         (EQUAL (PEVAL (NORM (A2 X)) A)
                (PEVAL (CADDR X) A))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/3.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A))
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A))))
         (EQUAL (PEVAL (NORM (A3 X)) A)
                (PEVAL (CADDDR X) A))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/3.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A))
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X)))
         (EQUAL (PEVAL (NORM (A2 X)) A)
                (PEVAL (CADDR X) A))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A))
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X))))
         (EQUAL (PEVAL (NORM (A3 X)) A)
                (PEVAL (CADDDR X) A))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A))
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A)))
         (EQUAL (PEVAL (NORM (A2 X)) A)
                (PEVAL (CADDR X) A))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (EQUAL (PEVAL (NORM (CADDR X)) A)
                     (PEVAL (CADDR X) A))
              (EQUAL (PEVAL (NORM (CADDDR X)) A)
                     (PEVAL (CADDDR X) A))
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A))))
         (EQUAL (PEVAL (NORM (A3 X)) A)
                (PEVAL (CADDDR X) A))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2
(IMPLIES
     (AND (IF-EXPRP X)
          (IF-EXPRP (A1 X))
          (EQUAL (PEVAL (NORM (LIST 'IF
                                    (A1 (A1 X))
                                    (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                                    (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X))))
                        A)
                 (PEVAL (LIST 'IF
                              (A1 (A1 X))
                              (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                              (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X)))
                        A)))
     (EQUAL (PEVAL (NORM X) A) (PEVAL X A))).

By the simple :definitions A1, A2, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'IF)
              (EQUAL (PEVAL (NORM (LIST 'IF
                                        (CADR (CADR X))
                                        (LIST 'IF
                                              (CADDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))
                                        (LIST 'IF
                                              (CADDDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))))
                            A)
                     (PEVAL (LIST 'IF
                                  (CADR (CADR X))
                                  (LIST 'IF
                                        (CADDR (CADR X))
                                        (CADDR X)
                                        (CADDDR X))
                                  (LIST 'IF
                                        (CADDDR (CADR X))
                                        (CADDR X)
                                        (CADDDR X)))
                            A)))
         (EQUAL (PEVAL (NORM X) A) (PEVAL X A))).

This simplifies, using the :definitions A1, A2, A3, IF-EXPRP, NORM
and PEVAL (if-intro), the :executable-counterpart of EQUAL, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the
following four conjectures.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'IF)
              (PEVAL (CADR (CADR X)) A)
              (PEVAL (CADDR (CADR X)) A)
              (EQUAL (PEVAL (NORM (LIST 'IF
                                        (CADR (CADR X))
                                        (LIST 'IF
                                              (CADDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))
                                        (LIST 'IF
                                              (CADDDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))))
                            A)
                     (PEVAL (CADDR X) A)))
         (EQUAL (PEVAL (NORM (LIST 'IF
                                   (A1 (A1 X))
                                   (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                                   (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X))))
                       A)
                (PEVAL (CADDR X) A))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'IF)
              (PEVAL (CADR (CADR X)) A)
              (NOT (PEVAL (CADDR (CADR X)) A))
              (EQUAL (PEVAL (NORM (LIST 'IF
                                        (CADR (CADR X))
                                        (LIST 'IF
                                              (CADDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))
                                        (LIST 'IF
                                              (CADDDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))))
                            A)
                     (PEVAL (CADDDR X) A)))
         (EQUAL (PEVAL (NORM (LIST 'IF
                                   (A1 (A1 X))
                                   (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                                   (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X))))
                       A)
                (PEVAL (CADDDR X) A))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'IF)
              (NOT (PEVAL (CADR (CADR X)) A))
              (PEVAL (CADDDR (CADR X)) A)
              (EQUAL (PEVAL (NORM (LIST 'IF
                                        (CADR (CADR X))
                                        (LIST 'IF
                                              (CADDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))
                                        (LIST 'IF
                                              (CADDDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))))
                            A)
                     (PEVAL (CADDR X) A)))
         (EQUAL (PEVAL (NORM (LIST 'IF
                                   (A1 (A1 X))
                                   (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                                   (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X))))
                       A)
                (PEVAL (CADDR X) A))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'IF)
              (NOT (PEVAL (CADR (CADR X)) A))
              (NOT (PEVAL (CADDDR (CADR X)) A))
              (EQUAL (PEVAL (NORM (LIST 'IF
                                        (CADR (CADR X))
                                        (LIST 'IF
                                              (CADDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))
                                        (LIST 'IF
                                              (CADDDR (CADR X))
                                              (CADDR X)
                                              (CADDDR X))))
                            A)
                     (PEVAL (CADDDR X) A)))
         (EQUAL (PEVAL (NORM (LIST 'IF
                                   (A1 (A1 X))
                                   (LIST 'IF (A2 (A1 X)) (A2 X) (A3 X))
                                   (LIST 'IF (A3 (A1 X)) (A2 X) (A3 X))))
                       A)
                (PEVAL (CADDDR X) A))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and A3.

Subgoal *1/1
(IMPLIES (NOT (IF-EXPRP X))
         (EQUAL (PEVAL (NORM X) A) (PEVAL X A))).

But simplification reduces this to T, using the :definitions ASSIGNMENT,
IF-EXPRP, NORM, PEVAL and QUOTEP and primitive type reasoning.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-136E ...)
Rules: ((:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION ASSIGNMENT)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION NORM)
        (:DEFINITION NOT)
        (:DEFINITION PEVAL)
        (:DEFINITION QUOTEP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION NORM)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ASSIGNMENT)
             (:DEFINITION IF-EXPRP)
             (:DEFINITION PEVAL)
             (:DEFINITION QUOTEP))
PROBLEM-136E


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-136E))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-136E)
PROBLEM-136E

Summary
Form:  ( PROGN (DEFTHM PROBLEM-136E ...) ...)
Rules: NIL
 PROBLEM-136E
ACL2 !>>(THEOREM
             PROBLEM-136
             (IMPLIES (TAUTOLOGY-CHECKER X)
                      (PEVAL X A))
             :HINTS (("Goal" :IN-THEORY (ENABLE PROBLEM-136D PROBLEM-136E)
                             :USE (:INSTANCE PROBLEM-136C (A NIL)
                                             (B A)
                                             (X (NORM X))))))


ACL2 !>>>(DEFTHM PROBLEM-136
           (IMPLIES (TAUTOLOGY-CHECKER X)
                    (PEVAL X A))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :IN-THEORY (ENABLE PROBLEM-136D PROBLEM-136E)
                           :USE (:INSTANCE PROBLEM-136C (A NIL)
                                           (B A)
                                           (X (NORM X))))))

[Note:  A hint was supplied for the goal above.  Thanks!]

We augment the goal with the hypothesis provided by the :USE hint.
The hypothesis can be derived from PROBLEM-136C via instantiation.
We are left with the following subgoal.

Goal'
(IMPLIES (IMPLIES (AND (ALISTP NIL)
                       (NORMP (NORM X))
                       (TAUTP (NORM X) NIL))
                  (PEVAL (NORM X) (APP NIL A)))
         (IMPLIES (TAUTOLOGY-CHECKER X)
                  (PEVAL X A))).

By the simple :definition TAUTOLOGY-CHECKER, the :executable-counterpart
of ALISTP and the simple :rewrite rules PROBLEM-136D and PROBLEM-136E
we reduce the conjecture to

Goal''
(IMPLIES (AND (IMPLIES (TAUTP (NORM X) NIL)
                       (PEVAL X (APP NIL A)))
              (TAUTP (NORM X) NIL))
         (PEVAL X A)).

But simplification reduces this to T, using the :definition APP and
the :executable-counterpart of CONSP.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-136 ...)
Rules: ((:DEFINITION APP)
        (:DEFINITION NOT)
        (:DEFINITION TAUTOLOGY-CHECKER)
        (:EXECUTABLE-COUNTERPART ALISTP)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:REWRITE PROBLEM-136D)
        (:REWRITE PROBLEM-136E))
Hint-events: ((:USE PROBLEM-136C))
PROBLEM-136


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-136))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-136)
PROBLEM-136

Summary
Form:  ( PROGN (DEFTHM PROBLEM-136 ...) ...)
Rules: NIL
 PROBLEM-136
ACL2 !>>:NEXT-PROBLEM 
"
; ------------------------------------------------------------
; Problem 137.

; Below we use two ACL2 language features not previously used in this
; material, mv and mv-let.  (mv a b) returns a vector (list) of length
; 2 containing a and b.  (mv-let (x y) <foo> <bar>) evaluates <foo>,
; obtaining a list of length 2, binds x and y to the to elements, and
; then evaluates <bar>.  Thus,
; (mv a b)
; is the same as
; (cons a (cons b nil))
; and
; (mv-let (x y) <foo> <bar>)
; is the same as
; ((lambda (vector)
;   ((lambda (x y)
;     <bar>)
;    (nth 0 vector)
;    (nth 1 vector)))
;  <foo>)
; However, if mv and mv-let are used instead of the expressions
; above, the syntax checker in ACL2 insures that <foo> really does
; produce a vector of length 2.  In addition, mv and mv-let are more
; efficient than the expressions above, because they do not actually
; create the vector.
"
ACL2 !>>(DEFUN FALSIFY (X ALIST)
          (DECLARE (XARGS :MEASURE (CC X)))
          (IF (IF-EXPRP X)
              (IF (ASSIGNEDP (A1 X) ALIST)
                  (IF (ASSIGNMENT (A1 X) ALIST)
                      (FALSIFY (A2 X) ALIST)
                    (FALSIFY (A3 X) ALIST))
                (MV-LET (ANS NEW-ALIST)
                        (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) ALIST))
                  (IF ANS (MV ANS NEW-ALIST)
                    (FALSIFY (A3 X)
                             (ASSUME-FALSE (A1 X) ALIST)))))
            (IF (ASSIGNEDP X ALIST)
                (IF (ASSIGNMENT X ALIST)
                    (MV NIL NIL)
                  (MV T ALIST))
              (MV T (ASSUME-FALSE X ALIST)))))

For the admission of FALSIFY we will use the relation O< (which is
known to be well-founded on the domain recognized by O-P) and the measure
(CC X).  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (CC X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNMENT (A1 X) ALIST))
              (O< (CC (A2 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) ALIST)
                   (NOT (ASSIGNMENT (A1 X) ALIST)))
              (O< (CC (A3 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) ALIST)))
              (O< (CC (A2 X)) (CC X)))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) ALIST))
                   (NOT (MV-NTH 0
                                (FALSIFY (A2 X)
                                         (ASSUME-TRUE (A1 X) ALIST)))))
              (O< (CC (A3 X)) (CC X)))).

By the simple :definitions A1, A2, A3, ASSIGNEDP, ASSUME-TRUE and IF-EXPRP
we reduce the conjecture to the following five conjectures.

Subgoal 5
(O-P (CC X)).

But simplification reduces this to T, using the :compound-recognizer
rules NATP-COMPOUND-RECOGNIZER and O-FINP-CR, the :rewrite rule 
O-P-DEF-O-FINP-1 and the :type-prescription rule CC.

Subgoal 4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNMENT (CADR X) ALIST))
         (O< (CC (CADDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions ASSIGNMENT (if-intro), CC (if-intro), FIX, O< (if-intro)
and QUOTEP (if-intro), the :executable-counterpart of CC, primitive
type reasoning, the :rewrite rule UNICITY-OF-0 and the :type-prescription
rule CC, to the following six conjectures.

Subgoal 4.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 4.6'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X)) (+ 2 (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following two goals.

Subgoal 4.6.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 4.6.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CAR.

Subgoal 4.6.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 4.6.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS and FOLD-CONSTS-IN-+, to

Subgoal 4.6.1''
(IMPLIES (AND (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and CONSP and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 4.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+ and CC, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-
prescription rule CC, to

Subgoal 4.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 3 (CC (CDDR X))
               (CC (CDR (CADR X)))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7 and restrict the types of the new
variables X4 and X7 to be those of the terms they replace.  (5) Finally,
use CAR-CDR-ELIM to replace X7 by (CONS X8 X9), (CAR X7) by X8 and
(CDR X7) by X9.  These steps produce the following three goals.

Subgoal 4.4.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3))
         (< (CC (CAR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 4.4.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3))
         (< (CC (CAR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules DEFAULT-CAR and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 4.4.3''
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3))
         (< 0 (+ 3 (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.4.2
(IMPLIES (AND (NOT (CONSP X7))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              X7 (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (CAR X7))
         (< (CC X5)
            (+ 3 (CC (CONS X5 X6)) (CC X7)))).

But we reduce the conjecture to T, by case analysis.

Subgoal 4.4.1
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              X8)
         (< (CC X5)
            (+ 3 (CC (CONS X5 X6))
               (CC (CONS X8 X9))))).

By case analysis we reduce the conjecture to

Subgoal 4.4.1'
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              X8)
         (< (CC X5)
            (+ 3 (CC (CONS X5 X6))
               (CC (CONS X8 X9))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 4.4.1''
(IMPLIES (AND (CONS X8 X9) X8)
         (< 0 (+ 5 (CC X6) (CC X8) (CC X9)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 4.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 4.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
three goals.

Subgoal 4.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 4.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 4.2.3''
(IMPLIES (AND (NOT (CONSP X4))
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 4.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 4.2.2''
(IMPLIES (AND (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.2.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 4.2.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 4.2.1''
(IMPLIES (AND (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< 0 (+ 4 (CC X4) (CC X6) (CC X7)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 4.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and EQUAL and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNEDP (CADR X) ALIST)
              (NOT (ASSIGNMENT (CADR X) ALIST)))
         (O< (CC (CADDDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions ASSIGNEDP (if-intro), ASSIGNMENT (if-intro), CC (if-intro),
FIX, O< (if-intro) and QUOTEP (if-intro), the :executable-counterparts
of CC and EQUAL, primitive type reasoning, the :rewrite rule UNICITY-OF-0
and the :type-prescription rule CC, to the following eight conjectures.

Subgoal 3.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 3.8'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 2 (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
three goals.

Subgoal 3.8.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CADR X4)) (+ 2 (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 3.8.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CADR X4)) (+ 2 (CC X4)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CAR, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CDR.

Subgoal 3.8.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CAR X6))
            (+ 2 (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 3.8.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CAR X6))
            (+ 2 (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-OF-+,
DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3.8.2''
(IMPLIES (AND (NOT (CONSP X6))
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 3 (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.8.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC X7)
            (+ 2 (CC (LIST* X5 X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 3.8.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC X7)
            (+ 2 (CC (LIST* X5 X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 3.8.1''
(IMPLIES (AND (ASSOC-EQUAL X3 ALIST)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR and CONSP and the :rewrite rules DEFAULT-CAR and
DEFAULT-CDR.

Subgoal 3.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+ and CC, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-
prescription rule CC, to

Subgoal 3.6'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CDDR X))
               (CC (CDR (CADR X)))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of six rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Use CAR-CDR-ELIM to replace
X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6 and restrict
the type of the new variable X4 to be that of the term it replaces.
(6) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X9 X10), (CAR X6)
by X9 and (CDR X6) by X10.  These steps produce the following four
goals.

Subgoal 3.6.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CADR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 3.6.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CADR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CAR, CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules DEFAULT-CDR and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3.6.4''
(IMPLIES (AND (NOT (CONSP X4))
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< 0 (+ 3 (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.6.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CAR X6))
            (+ 3 (CC (CONS X5 X6)) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 3.6.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CAR X6))
            (+ 3 (CC (CONS X5 X6)) (CC (CDR X3))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 3.6.3''
(IMPLIES (AND (NOT (CONSP X6))
              (ASSOC-EQUAL X3 ALIST)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< 0 (+ 4 (CC X5) (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.6.2
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6)))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8)) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 3.6.2'
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6)))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8)) (CC X6)))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, DEFAULT-CAR and
FOLD-CONSTS-IN-+, to

Subgoal 3.6.2''
(IMPLIES (AND (NOT (CONSP X6))
              (ASSOC-EQUAL (CONS 'QUOTE X6) ALIST))
         (< 0 (+ 5 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.6.1
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X9 X10) ALIST)
              (EQUAL X4 'QUOTE)
              (NOT X9))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8))
               (CC (CONS X9 X10))))).

By case analysis we reduce the conjecture to

Subgoal 3.6.1'
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X9 X10) ALIST)
              (EQUAL X4 'QUOTE)
              (NOT X9))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8))
               (CC (CONS X9 X10))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules
CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription rule CC,
to

Subgoal 3.6.1''
(IMPLIES (ASSOC-EQUAL (LIST* 'QUOTE NIL X10)
                      ALIST)
         (< 0 (+ 6 (CC X10) (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 3.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 3.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following four goals.

Subgoal 3.4.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CADR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 3.4.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CADR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CAR, CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CDR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 3.4.4''
(IMPLIES (AND (NOT (CONSP X4))
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.4.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CAR X6))
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 3.4.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC (CAR X6))
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 3.4.3''
(IMPLIES (AND (NOT (CONSP X6))
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 3 (CC X3) (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.4.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC X7)
            (+ 2 (CC X3) (CC (LIST* X5 X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 3.4.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 ALIST)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< (CC X7)
            (+ 2 (CC X3) (CC (LIST* X5 X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 3.4.2''
(IMPLIES (AND (NOT (CONSP X3))
              (ASSOC-EQUAL X3 ALIST)
              (NOT (CDR (ASSOC-EQUAL X3 ALIST))))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.4.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) ALIST))))
         (< (CC X7)
            (+ 2 (CC (CONS X4 X6))
               (CC (LIST* X5 X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 3.4.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) ALIST))))
         (< (CC X7)
            (+ 2 (CC (CONS X4 X6))
               (CC (LIST* X5 X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 3.4.1''
(IMPLIES (AND (ASSOC-EQUAL (CONS X4 X6) ALIST)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) ALIST))))
         (< 0
            (+ 5 (CC X4) (CC X5) (CC X6) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) ALIST)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) ALIST)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR and EQUAL and the :rewrite rules DEFAULT-CAR and
DEFAULT-CDR.

Subgoal 3.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+ and CC, the :rewrite rules COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-
prescription rule CC, to

Subgoal 3.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CONSP (CDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CDDR X))
               (CC (CDR (CADR X)))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of six rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Use CAR-CDR-ELIM to replace
X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6 and restrict
the type of the new variable X4 to be that of the term it replaces.
(6) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X9 X10), (CAR X6)
by X9 and (CDR X6) by X10.  These steps produce the following four
goals.

Subgoal 3.2.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CADR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 3.2.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CADR X4))
            (+ 3 (CC X4) (CC (CDR X3))))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CAR, CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules DEFAULT-CDR and UNICITY-OF-0 and the :type-prescription
rule CC, to

Subgoal 3.2.4''
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< 0 (+ 3 (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.2.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CAR X6))
            (+ 3 (CC (CONS X5 X6)) (CC (CDR X3))))).

By case analysis we reduce the conjecture to

Subgoal 3.2.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< (CC (CAR X6))
            (+ 3 (CC (CONS X5 X6)) (CC (CDR X3))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :rewrite rules CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+,
COMMUTATIVITY-OF-+, DEFAULT-CAR, FOLD-CONSTS-IN-+ and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 3.2.3''
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3)))
         (< 0 (+ 4 (CC X5) (CC (CDR X3))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.2.2
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6)))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8)) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 3.2.2'
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6)))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8)) (CC X6)))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, DEFAULT-CAR and
FOLD-CONSTS-IN-+, to

Subgoal 3.2.2''
(IMPLIES (NOT (CONSP X6))
         (< 0 (+ 5 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.2.1
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT X9))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8))
               (CC (CONS X9 X10))))).

By case analysis we reduce the conjecture to

Subgoal 3.2.1'
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT X9))
         (< (CC X7)
            (+ 3 (CC (LIST* X5 X7 X8))
               (CC (CONS X9 X10))))).

This simplifies, using the :definitions CC, FIX and SYNP, the :executable-
counterparts of BINARY-+, CC, EQUAL, NOT and SYMBOLP, primitive type
reasoning, the :meta rule CANCEL_PLUS-LESSP-CORRECT, the :rewrite rules
CAR-CONS, CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+, 
FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the :type-prescription rule CC,
to

Subgoal 3.2.1''
(< 0 (+ 6 (CC X10) (CC X5) (CC X8))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 3.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But we reduce the conjecture to T, by the :executable-counterpart of
TAU-SYSTEM.

Subgoal 2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (QUOTEP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST)))
         (O< (CC (CADDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro), FIX, O< (if-intro) and QUOTEP (if-intro),
the :executable-counterpart of CC, primitive type reasoning, the :rewrite
rule UNICITY-OF-0 and the :type-prescription rule CC, to the following
four conjectures.

Subgoal 2.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 2.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X)) (+ 2 (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following two goals.

Subgoal 2.4.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 2.4.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4)) (+ 2 (CC X4)))).

But simplification reduces this to T, using the :definition CC, the
:executable-counterparts of <, BINARY-+, CC, EQUAL, NOT and SYMBOLP,
primitive type reasoning and the :rewrite rule DEFAULT-CAR.

Subgoal 2.4.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.4.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5) (+ 2 (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS and FOLD-CONSTS-IN-+, to

Subgoal 2.4.1''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and CONSP and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 1 1 (CC (CADR X)) (CC (CDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 2.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (CONSP (CDR X)))
         (< (CC (CADDR X))
            (+ 2 (CC (CADR X)) (CC (CDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
three goals.

Subgoal 2.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

By case analysis we reduce the conjecture to

Subgoal 2.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC (CAR X4))
            (+ 2 (CC X3) (CC X4)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 2.2.3''
(IMPLIES (AND (NOT (CONSP X4))
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 2 (CC X3)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< (CC X5)
            (+ 2 (CC X3) (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 2.2.2''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST)))
         (< 0 (+ 3 (CC X6)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.2.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

By case analysis we reduce the conjecture to

Subgoal 2.2.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< (CC X5)
            (+ 2 (CC (CONS X4 X7))
               (CC (CONS X5 X6))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 2.2.1''
(IMPLIES (AND (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X7) ALIST)))
         (< 0 (+ 4 (CC X4) (CC X6) (CC X7)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC and EQUAL and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (QUOTEP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (MV-NTH 0
                           (FALSIFY (CADDR X)
                                    (CONS (CONS (CADR X) T) ALIST)))))
         (O< (CC (CADDDR X)) (CC X))).

This simplifies, using the :compound-recognizer rule O-FINP-CR, the
:definitions CC (if-intro), FIX (if-intro), MV-NTH (if-intro), O< (if-
intro) and QUOTEP (if-intro), the :executable-counterparts of CC and
ZP, primitive type reasoning, the :rewrite rule UNICITY-OF-0 and the
:type-prescription rule CC, to the following twelve conjectures.

Subgoal 1.12
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY (CADDR X)
                                   (CONS (CONS (CADR X) T) ALIST))))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR, CONS and CONSP and the :rewrite rules DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.11
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY (CADDR X)
                                   (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 1 (CC (CADDR X))
               (CC (CDDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 1.11'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY (CADDR X)
                                   (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CADDR X)) (CC (CDDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
two goals.

Subgoal 1.11.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC (CAR X6))
            (+ 3 (CC X5) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.11.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC (CAR X6))
            (+ 3 (CC X5) (CC X6)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.11.2''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< 0 (+ 3 (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.11.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC X5) (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.11.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC X5) (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 1.11.1''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.10
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY (CADDR X)
                                   (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< (CC (CADDDR X)) 2)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR and CC and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.9
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) ALIST))))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR, CONS and CONSP and the :rewrite rules DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 1 (CC (CADDR X))
               (CC (CDDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rule FOLD-CONSTS-IN-+, to

Subgoal 1.8'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CADDR X)) (CC (CDDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
two goals.

Subgoal 1.8.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC (CAR X6))
            (+ 3 (CC X5) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.8.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC (CAR X6))
            (+ 3 (CC X5) (CC X6)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.8.2''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< 0 (+ 3 (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.8.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC X5) (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.8.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC X5) (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+, to

Subgoal 1.8.1''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< (CC (CADDDR X)) 2)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR and CC and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal 1.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY (CADDR X)
                                   (CONS (CONS (CADR X) T) ALIST))))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR, CONS and EQUAL and the :rewrite rules DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY (CADDR X)
                                   (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X))
               1 (CC (CADDR X))
               (CC (CDDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 1.5'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY (CADDR X)
                                   (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CADR X))
               (CC (CADDR X))
               (CC (CDDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following three goals.

Subgoal 1.5.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC (CAR X6))
            (+ 3 (CC X3) (CC X5) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.5.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC (CAR X6))
            (+ 3 (CC X3) (CC X5) (CC X6)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.5.3''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< 0 (+ 3 (CC X3) (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.5.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC X3)
               (CC X5)
               (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.5.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC X3)
               (CC X5)
               (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 1.5.2''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CONSP (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.5.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (NOT (CONSP (FALSIFY X5
                                   (CONS (CONS (CONS X4 X6) T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC (CONS X4 X6))
               (CC X5)
               (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.5.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (NOT (CONSP (FALSIFY X5
                                   (CONS (CONS (CONS X4 X6) T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC (CONS X4 X6))
               (CC X5)
               (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 1.5.1''
(IMPLIES (AND (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (NOT (CONSP (FALSIFY X5
                                   (CONS (CONS (CONS X4 X6) T) ALIST)))))
         (< 0
            (+ 5 (CC X4) (CC X5) (CC X6) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY (CADDR X)
                                   (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) 0))).

This simplifies, using the :definitions FIX and SYNP, the :executable-
counterparts of BINARY-+, CAR and CC, the :rewrite rules COMMUTATIVITY-OF-+,
DEFAULT-CAR, DEFAULT-CDR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the
:type-prescription rule CC, to

Subgoal 1.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CONSP (FALSIFY NIL (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< 0 (+ 2 (CC (CADR X))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) ALIST))))
              (NOT (CONSP (CDR X))))
         (< (CC (CADDDR X)) 1)).

But simplification reduces this to T, using the :executable-counterparts
of <, CAR, CC, CDR, CONS and EQUAL and the :rewrite rules DEFAULT-CAR
and DEFAULT-CDR.

Subgoal 1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X))
               1 (CC (CADDR X))
               (CC (CDDDR X))))).

This simplifies, using the :definition SYNP, the :executable-counterpart
of BINARY-+ and the :rewrite rules COMMUTATIVITY-2-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 1.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (CONSP (CDDR X)))
         (< (CC (CADDDR X))
            (+ 3 (CC (CADR X))
               (CC (CADDR X))
               (CC (CDDDR X))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following three goals.

Subgoal 1.2.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC (CAR X6))
            (+ 3 (CC X3) (CC X5) (CC X6)))).

By case analysis we reduce the conjecture to

Subgoal 1.2.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC (CAR X6))
            (+ 3 (CC X3) (CC X5) (CC X6)))).

This simplifies, using the :definitions CC and FIX, the :executable-
counterparts of CC, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :rewrite rules COMMUTATIVITY-OF-+, DEFAULT-CAR and UNICITY-OF-0
and the :type-prescription rule CC, to

Subgoal 1.2.3''
(IMPLIES (AND (NOT (CONSP X6))
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< 0 (+ 3 (CC X3) (CC X5)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC X3)
               (CC X5)
               (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC X3)
               (CC X5)
               (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, DEFAULT-CAR and FOLD-CONSTS-IN-+, to

Subgoal 1.2.2''
(IMPLIES (AND (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 ALIST))
              (NOT (CAR (FALSIFY X5 (CONS (CONS X3 T) ALIST)))))
         (< 0 (+ 4 (CC X5) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.2.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (NOT (CAR (FALSIFY X5
                                 (CONS (CONS (CONS X4 X6) T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC (CONS X4 X6))
               (CC X5)
               (CC (CONS X7 X8))))).

By case analysis we reduce the conjecture to

Subgoal 1.2.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (NOT (CAR (FALSIFY X5
                                 (CONS (CONS (CONS X4 X6) T) ALIST)))))
         (< (CC X7)
            (+ 3 (CC (CONS X4 X6))
               (CC X5)
               (CC (CONS X7 X8))))).

This simplifies, using the :definitions CC and SYNP, the :executable-
counterparts of BINARY-+, EQUAL, NOT and SYMBOLP, primitive type reasoning,
the :meta rule CANCEL_PLUS-LESSP-CORRECT and the :rewrite rules CAR-CONS,
CDR-CONS, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-+ and FOLD-CONSTS-IN-+,
to

Subgoal 1.2.1''
(IMPLIES (AND (NOT (EQUAL X4 'QUOTE))
              (NOT (ASSOC-EQUAL (CONS X4 X6) ALIST))
              (NOT (CAR (FALSIFY X5
                                 (CONS (CONS (CONS X4 X6) T) ALIST)))))
         (< 0
            (+ 5 (CC X4) (CC X5) (CC X6) (CC X8)))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Subgoal 1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< (CC (CADDDR X))
            (+ 1 1 (CC (CADR X)) 0))).

This simplifies, using the :definitions FIX and SYNP, the :executable-
counterparts of BINARY-+, CAR and CC, the :rewrite rules COMMUTATIVITY-OF-+,
DEFAULT-CAR, DEFAULT-CDR, FOLD-CONSTS-IN-+ and UNICITY-OF-0 and the
:type-prescription rule CC, to

Subgoal 1.1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) ALIST))
              (NOT (CAR (FALSIFY NIL (CONS (CONS (CADR X) T) ALIST))))
              (CONSP (CDR X))
              (NOT (CONSP (CDDR X))))
         (< 0 (+ 2 (CC (CADR X))))).

But simplification reduces this to T, using primitive type reasoning
and the :type-prescription rule CC.

Q.E.D.

That completes the proof of the measure theorem for FALSIFY.  Thus,
we admit this function under the principle of definition.  We observe
that the type of FALSIFY is described by the theorem 
(AND (CONSP (FALSIFY X ALIST)) (TRUE-LISTP (FALSIFY X ALIST))).  We
used primitive type reasoning.

(FALSIFY * *) => (MV * *).

Summary
Form:  ( DEFUN FALSIFY ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:COMPOUND-RECOGNIZER O-FINP-CR)
        (:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION ASSIGNEDP)
        (:DEFINITION ASSIGNMENT)
        (:DEFINITION ASSUME-TRUE)
        (:DEFINITION CC)
        (:DEFINITION FIX)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION MV-NTH)
        (:DEFINITION NOT)
        (:DEFINITION O<)
        (:DEFINITION QUOTEP)
        (:DEFINITION SYNP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CC)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:META CANCEL_PLUS-LESSP-CORRECT)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE O-P-DEF-O-FINP-1)
        (:REWRITE UNICITY-OF-0)
        (:TYPE-PRESCRIPTION CC))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ASSIGNEDP)
             (:DEFINITION ASSIGNMENT)
             (:DEFINITION CC)
             (:DEFINITION FIX)
             (:DEFINITION MV-NTH)
             (:DEFINITION O<)
             (:DEFINITION QUOTEP))
 FALSIFY
ACL2 !>>(DEFUN FALSIFYING-ALIST (X)
          (MV-LET (ANS ALIST)
                  (FALSIFY (NORM X) NIL)
            (DECLARE (IGNORE ANS))
            ALIST))

Since FALSIFYING-ALIST is non-recursive, its admission is trivial.
We could deduce no constraints on the type of FALSIFYING-ALIST.

Summary
Form:  ( DEFUN FALSIFYING-ALIST ...)
Rules: NIL
 FALSIFYING-ALIST
ACL2 !>>:----- 
"
; For reasons having to do with the syntactic checking noted above,
; ACL2 accesses the components of the vector with mv-nth rather than
; nth.  Logically, mv-nth is nth.
"
ACL2 !>>(THEOREM PROBLEM-137A
                 (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                          (MV-NTH 0 (FALSIFY X A)))
                 :HINTS (("Goal" :INDUCT (FALSIFY X A))))


ACL2 !>>>(DEFTHM PROBLEM-137A
           (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                    (MV-NTH 0 (FALSIFY X A)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FALSIFY X A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FALSIFY X A).

This suggestion was produced using the :induction rule FALSIFY.  If
we let (:P A X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (IF-EXPRP X))
                   (NOT (ASSIGNEDP X A)))
              (:P A X))
     (IMPLIES (AND (NOT (IF-EXPRP X))
                   (ASSIGNEDP X A)
                   (NOT (ASSIGNMENT X A)))
              (:P A X))
     (IMPLIES (AND (NOT (IF-EXPRP X))
                   (ASSIGNEDP X A)
                   (ASSIGNMENT X A))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) A))
                   (NOT (MV-NTH 0
                                (FALSIFY (A2 X)
                                         (ASSUME-TRUE (A1 X) A))))
                   (:P (ASSUME-TRUE (A1 X) A) (A2 X))
                   (:P (ASSUME-FALSE (A1 X) A) (A3 X)))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) A))
                   (MV-NTH 0
                           (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                   (:P (ASSUME-TRUE (A1 X) A) (A2 X)))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) A)
                   (NOT (ASSIGNMENT (A1 X) A))
                   (:P A (A3 X)))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) A)
                   (ASSIGNMENT (A1 X) A)
                   (:P A (A2 X)))
              (:P A X))).
This induction is justified by the same argument used to admit FALSIFY.
Note, however, that the unmeasured variable A is being instantiated.
When applied to the goal at hand the above induction scheme produces
seven nontautological subgoals.

Subgoal *1/7
(IMPLIES (AND (NOT (IF-EXPRP X))
              (NOT (ASSIGNEDP X A)))
         (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                  (MV-NTH 0 (FALSIFY X A)))).

By the simple :definition ASSIGNEDP we reduce the conjecture to

Subgoal *1/7'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (NOT (QUOTEP X))
              (NOT (ASSOC-EQUAL X A))
              (NORMP X)
              (NOT (TAUTP X A)))
         (MV-NTH 0 (FALSIFY X A))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, ASSUME-FALSE, FALSIFY, IF-EXPRP, MV-NTH, NORMP, QUOTEP
and TAUTP, the :executable-counterparts of CDR and ZP, primitive type
reasoning and the :rewrite rule CAR-CONS.

Subgoal *1/6
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (NOT (ASSIGNMENT X A)))
         (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                  (MV-NTH 0 (FALSIFY X A)))).

By case analysis we reduce the conjecture to

Subgoal *1/6'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (NOT (ASSIGNMENT X A))
              (NORMP X)
              (NOT (TAUTP X A)))
         (MV-NTH 0 (FALSIFY X A))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, FALSIFY, IF-EXPRP, MV-NTH, NORMP, QUOTEP and TAUTP, the
:executable-counterparts of EQUAL and ZP, primitive type reasoning
and the :rewrite rule CAR-CONS.

Subgoal *1/5
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (ASSIGNMENT X A))
         (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                  (MV-NTH 0 (FALSIFY X A)))).

By case analysis we reduce the conjecture to

Subgoal *1/5'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (ASSIGNMENT X A)
              (NORMP X)
              (NOT (TAUTP X A)))
         (MV-NTH 0 (FALSIFY X A))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, IF-EXPRP, NORMP, QUOTEP and TAUTP and the :executable-
counterpart of EQUAL.

Subgoal *1/4
(IMPLIES (AND (IF-EXPRP X)
              (NOT (ASSIGNEDP (A1 X) A))
              (NOT (MV-NTH 0
                           (FALSIFY (A2 X)
                                    (ASSUME-TRUE (A1 X) A))))
              (IMPLIES (AND (NORMP (A2 X))
                            (NOT (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))))
                       (MV-NTH 0
                               (FALSIFY (A2 X)
                                        (ASSUME-TRUE (A1 X) A))))
              (IMPLIES (AND (NORMP (A3 X))
                            (NOT (TAUTP (A3 X) (ASSUME-FALSE (A1 X) A))))
                       (MV-NTH 0
                               (FALSIFY (A3 X)
                                        (ASSUME-FALSE (A1 X) A)))))
         (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                  (MV-NTH 0 (FALSIFY X A)))).

By the simple :definitions A1, A2, A3, ASSIGNEDP, ASSUME-FALSE, ASSUME-TRUE
and IF-EXPRP we reduce the conjecture to

Subgoal *1/4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (QUOTEP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (MV-NTH 0
                           (FALSIFY (CADDR X)
                                    (CONS (CONS (CADR X) T) A))))
              (IMPLIES (AND (NORMP (CADDR X))
                            (NOT (TAUTP (CADDR X)
                                        (CONS (CONS (CADR X) T) A))))
                       (MV-NTH 0
                               (FALSIFY (CADDR X)
                                        (CONS (CONS (CADR X) T) A))))
              (IMPLIES (AND (NORMP (CADDDR X))
                            (NOT (TAUTP (CADDDR X)
                                        (CONS (LIST (CADR X)) A))))
                       (MV-NTH 0
                               (FALSIFY (CADDDR X)
                                        (CONS (LIST (CADR X)) A))))
              (NORMP X)
              (NOT (TAUTP X A)))
         (MV-NTH 0 (FALSIFY X A))).

This simplifies, using the :definitions A1, A2, A3, ASSIGNEDP, ASSUME-FALSE,
ASSUME-TRUE, FALSIFY (if-intro), IF-EXPRP (if-intro), MV-NTH (if-intro),
NORMP (if-intro), NOT (if-intro), QUOTEP (if-intro) and TAUTP, the
:executable-counterparts of EQUAL and ZP, primitive type reasoning
and the :type-prescription rule FALSIFY, to the following six conjectures.

Subgoal *1/4.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (CAR (FALSIFY (A2 X)
                            (ASSUME-TRUE (A1 X) A))))
         (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                    (MV-NTH 1
                            (FALSIFY (A2 X)
                                     (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A)))))
         (CAR (FALSIFY (A3 X)
                       (ASSUME-FALSE (A1 X) A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (CAR (FALSIFY (A2 X)
                            (ASSUME-TRUE (A1 X) A))))
         (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                    (MV-NTH 1
                            (FALSIFY (A2 X)
                                     (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A)))))
         (CAR (FALSIFY (A3 X)
                       (ASSUME-FALSE (A1 X) A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (CAR (FALSIFY (A2 X)
                            (ASSUME-TRUE (A1 X) A))))
         (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                    (MV-NTH 1
                            (FALSIFY (A2 X)
                                     (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (TAUTP (CADDR X)
                     (CONS (CONS (CADR X) T) A))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X))
              (NOT (TAUTP (CADDDR X)
                          (CONS (LIST (CADR X)) A)))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A)))))
         (CAR (FALSIFY (A3 X)
                       (ASSUME-FALSE (A1 X) A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3
(IMPLIES (AND (IF-EXPRP X)
              (NOT (ASSIGNEDP (A1 X) A))
              (MV-NTH 0
                      (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (IMPLIES (AND (NORMP (A2 X))
                            (NOT (TAUTP (A2 X) (ASSUME-TRUE (A1 X) A))))
                       (MV-NTH 0
                               (FALSIFY (A2 X)
                                        (ASSUME-TRUE (A1 X) A)))))
         (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                  (MV-NTH 0 (FALSIFY X A)))).

By the simple :definitions A1, A2, ASSIGNEDP, ASSUME-TRUE and IF-EXPRP
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (QUOTEP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (MV-NTH 0
                      (FALSIFY (CADDR X)
                               (CONS (CONS (CADR X) T) A)))
              (IMPLIES (AND (NORMP (CADDR X))
                            (NOT (TAUTP (CADDR X)
                                        (CONS (CONS (CADR X) T) A))))
                       (MV-NTH 0
                               (FALSIFY (CADDR X)
                                        (CONS (CONS (CADR X) T) A))))
              (NORMP X)
              (NOT (TAUTP X A)))
         (MV-NTH 0 (FALSIFY X A))).

This simplifies, using the :definitions A1, ASSIGNEDP, FALSIFY (if-
intro), IF-EXPRP, MV-NTH (if-intro), NOT (if-intro) and QUOTEP (if-
intro), the :executable-counterparts of EQUAL and ZP, primitive type
reasoning and the :type-prescription rule FALSIFY, to the following
four conjectures.

Subgoal *1/3.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NORMP X)
              (NOT (TAUTP X A))
              (CAR (FALSIFY (A2 X)
                            (ASSUME-TRUE (A1 X) A))))
         (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                    (MV-NTH 1
                            (FALSIFY (A2 X)
                                     (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NORMP X)
              (NOT (TAUTP X A))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A)))))
         (CAR (FALSIFY (A3 X)
                       (ASSUME-FALSE (A1 X) A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NORMP X)
              (NOT (TAUTP X A))
              (CAR (FALSIFY (A2 X)
                            (ASSUME-TRUE (A1 X) A))))
         (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                    (MV-NTH 1
                            (FALSIFY (A2 X)
                                     (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NORMP X)
              (NOT (TAUTP X A))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A)))))
         (CAR (FALSIFY (A3 X)
                       (ASSUME-FALSE (A1 X) A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/2
(IMPLIES (AND (IF-EXPRP X)
              (ASSIGNEDP (A1 X) A)
              (NOT (ASSIGNMENT (A1 X) A))
              (IMPLIES (AND (NORMP (A3 X))
                            (NOT (TAUTP (A3 X) A)))
                       (MV-NTH 0 (FALSIFY (A3 X) A))))
         (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                  (MV-NTH 0 (FALSIFY X A)))).

By the simple :definitions A1, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNEDP (CADR X) A)
              (NOT (ASSIGNMENT (CADR X) A))
              (IMPLIES (AND (NORMP (CADDDR X))
                            (NOT (TAUTP (CADDDR X) A)))
                       (MV-NTH 0 (FALSIFY (CADDDR X) A)))
              (NORMP X)
              (NOT (TAUTP X A)))
         (MV-NTH 0 (FALSIFY X A))).

This simplifies, using the :definitions A1, A2, A3, ASSIGNEDP (if-intro),
ASSIGNMENT (if-intro), FALSIFY, IF-EXPRP (if-intro), MV-NTH, NORMP,
NOT (if-intro), QUOTEP (if-intro) and TAUTP, the :executable-counterparts
of EQUAL and ZP and the :type-prescription rule FALSIFY, to the following
four conjectures.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (CAR (FALSIFY (CADDDR X) A))
              (NORMP X)
              (NOT (TAUTP (CADDDR X) A)))
         (CAR (FALSIFY (A3 X) A))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CAR (FALSIFY (CADDDR X) A))
              (NORMP X)
              (NOT (TAUTP (CADDDR X) A)))
         (CAR (FALSIFY (A3 X) A))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (CAR (FALSIFY (CADDDR X) A))
              (NORMP X)
              (NOT (TAUTP (CADDDR X) A)))
         (CAR (FALSIFY (A3 X) A))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (CAR (FALSIFY (CADDDR X) A))
              (NORMP X)
              (NOT (TAUTP (CADDDR X) A)))
         (CAR (FALSIFY (A3 X) A))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/1
(IMPLIES (AND (IF-EXPRP X)
              (ASSIGNEDP (A1 X) A)
              (ASSIGNMENT (A1 X) A)
              (IMPLIES (AND (NORMP (A2 X))
                            (NOT (TAUTP (A2 X) A)))
                       (MV-NTH 0 (FALSIFY (A2 X) A))))
         (IMPLIES (AND (NORMP X) (NOT (TAUTP X A)))
                  (MV-NTH 0 (FALSIFY X A)))).

By the simple :definitions A1, A2 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNEDP (CADR X) A)
              (ASSIGNMENT (CADR X) A)
              (IMPLIES (AND (NORMP (CADDR X))
                            (NOT (TAUTP (CADDR X) A)))
                       (MV-NTH 0 (FALSIFY (CADDR X) A)))
              (NORMP X)
              (NOT (TAUTP X A)))
         (MV-NTH 0 (FALSIFY X A))).

This simplifies, using the :definitions A1, A2, ASSIGNEDP (if-intro),
ASSIGNMENT (if-intro), FALSIFY, IF-EXPRP (if-intro), MV-NTH, NORMP,
NOT (if-intro), QUOTEP (if-intro) and TAUTP, the :executable-counterparts
of EQUAL and ZP and the :type-prescription rule FALSIFY, to the following
four conjectures.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X) A))
              (NORMP X)
              (NOT (TAUTP (CADDR X) A)))
         (CAR (FALSIFY (A2 X) A))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CAR (FALSIFY (CADDR X) A))
              (NORMP X)
              (NOT (TAUTP (CADDR X) A)))
         (CAR (FALSIFY (A2 X) A))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X) A))
              (NORMP X)
              (NOT (TAUTP (CADDR X) A)))
         (CAR (FALSIFY (A2 X) A))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CAR (FALSIFY (CADDR X) A))
              (NORMP X)
              (NOT (TAUTP (CADDR X) A)))
         (CAR (FALSIFY (A2 X) A))).

But we reduce the conjecture to T, by the simple :definition A2.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-137A ...)
Rules: ((:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION ASSIGNEDP)
        (:DEFINITION ASSIGNMENT)
        (:DEFINITION ASSUME-FALSE)
        (:DEFINITION ASSUME-TRUE)
        (:DEFINITION FALSIFY)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION MV-NTH)
        (:DEFINITION NORMP)
        (:DEFINITION NOT)
        (:DEFINITION QUOTEP)
        (:DEFINITION TAUTP)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FALSIFY)
        (:REWRITE CAR-CONS)
        (:TYPE-PRESCRIPTION FALSIFY))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ASSIGNEDP)
             (:DEFINITION ASSIGNMENT)
             (:DEFINITION FALSIFY)
             (:DEFINITION IF-EXPRP)
             (:DEFINITION MV-NTH)
             (:DEFINITION NORMP)
             (:DEFINITION NOT)
             (:DEFINITION QUOTEP))
PROBLEM-137A


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-137A))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-137A)
PROBLEM-137A

Summary
Form:  ( PROGN (DEFTHM PROBLEM-137A ...) ...)
Rules: NIL
 PROBLEM-137A
ACL2 !>>(THEOREM
             PROBLEM-137B
             (IMPLIES (ASSOC-EQUAL VAR A)
                      (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                             (IF (MV-NTH 0 (FALSIFY X A))
                                 (CDR (ASSOC-EQUAL VAR A))
                               NIL)))
             :HINTS (("Goal" :INDUCT (FALSIFY X A))))


ACL2 !>>>(DEFTHM PROBLEM-137B
           (IMPLIES (ASSOC-EQUAL VAR A)
                    (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                           (IF (MV-NTH 0 (FALSIFY X A))
                               (CDR (ASSOC-EQUAL VAR A))
                             NIL)))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FALSIFY X A))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FALSIFY X A).

This suggestion was produced using the :induction rule FALSIFY.  If
we let (:P A VAR X) denote *1 above then the induction scheme we'll
use is
(AND (IMPLIES (AND (NOT (IF-EXPRP X))
                   (NOT (ASSIGNEDP X A)))
              (:P A VAR X))
     (IMPLIES (AND (NOT (IF-EXPRP X))
                   (ASSIGNEDP X A)
                   (NOT (ASSIGNMENT X A)))
              (:P A VAR X))
     (IMPLIES (AND (NOT (IF-EXPRP X))
                   (ASSIGNEDP X A)
                   (ASSIGNMENT X A))
              (:P A VAR X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) A))
                   (NOT (MV-NTH 0
                                (FALSIFY (A2 X)
                                         (ASSUME-TRUE (A1 X) A))))
                   (:P (ASSUME-TRUE (A1 X) A) VAR (A2 X))
                   (:P (ASSUME-FALSE (A1 X) A) VAR (A3 X)))
              (:P A VAR X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) A))
                   (MV-NTH 0
                           (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                   (:P (ASSUME-TRUE (A1 X) A) VAR (A2 X)))
              (:P A VAR X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) A)
                   (NOT (ASSIGNMENT (A1 X) A))
                   (:P A VAR (A3 X)))
              (:P A VAR X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) A)
                   (ASSIGNMENT (A1 X) A)
                   (:P A VAR (A2 X)))
              (:P A VAR X))).
This induction is justified by the same argument used to admit FALSIFY.
Note, however, that the unmeasured variable A is being instantiated.
When applied to the goal at hand the above induction scheme produces
seven nontautological subgoals.

Subgoal *1/7
(IMPLIES (AND (NOT (IF-EXPRP X))
              (NOT (ASSIGNEDP X A)))
         (IMPLIES (ASSOC-EQUAL VAR A)
                  (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                         (AND (MV-NTH 0 (FALSIFY X A))
                              (CDR (ASSOC-EQUAL VAR A)))))).

By the simple :definition ASSIGNEDP we reduce the conjecture to

Subgoal *1/7'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (NOT (QUOTEP X))
              (NOT (ASSOC-EQUAL X A))
              (ASSOC-EQUAL VAR A))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                (AND (MV-NTH 0 (FALSIFY X A))
                     (CDR (ASSOC-EQUAL VAR A))))).

This simplifies, using the :definitions ASSIGNEDP, ASSOC-EQUAL (if-
intro), ASSUME-FALSE, FALSIFY, IF-EXPRP (if-intro), MV-NTH and QUOTEP
(if-intro), the :executable-counterparts of BINARY-+ and ZP, primitive
type reasoning and the :rewrite rules CAR-CONS and CDR-CONS, to the
following three conjectures.

Subgoal *1/7.3
(IMPLIES (AND (NOT (CONSP X))
              (NOT (ASSOC-EQUAL X A))
              (ASSOC-EQUAL VAR A)
              (EQUAL VAR X))
         (EQUAL (CDR (LIST VAR))
                (CDR (ASSOC-EQUAL VAR A)))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/7.3'
(IMPLIES (AND (NOT (CONSP X))
              (NOT (ASSOC-EQUAL X A))
              (ASSOC-EQUAL VAR A)
              (EQUAL VAR X))
         (EQUAL NIL (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/7.2
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (CONSP X))
              (NOT (ASSOC-EQUAL X A))
              (ASSOC-EQUAL VAR A)
              (EQUAL VAR X))
         (EQUAL (CDR (LIST VAR))
                (CDR (ASSOC-EQUAL VAR A)))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/7.2'
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (CONSP X))
              (NOT (ASSOC-EQUAL X A))
              (ASSOC-EQUAL VAR A)
              (EQUAL VAR X))
         (EQUAL NIL (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/7.1
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (EQUAL (CAR X) 'QUOTE))
              (NOT (ASSOC-EQUAL X A))
              (ASSOC-EQUAL VAR A)
              (EQUAL VAR X))
         (EQUAL (CDR (LIST VAR))
                (CDR (ASSOC-EQUAL VAR A)))).

By the simple :rewrite rule CDR-CONS we reduce the conjecture to

Subgoal *1/7.1'
(IMPLIES (AND (NOT (EQUAL (CAR X) 'IF))
              (NOT (EQUAL (CAR X) 'QUOTE))
              (NOT (ASSOC-EQUAL X A))
              (ASSOC-EQUAL VAR A)
              (EQUAL VAR X))
         (EQUAL NIL (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/6
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (NOT (ASSIGNMENT X A)))
         (IMPLIES (ASSOC-EQUAL VAR A)
                  (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                         (AND (MV-NTH 0 (FALSIFY X A))
                              (CDR (ASSOC-EQUAL VAR A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/6'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (NOT (ASSIGNMENT X A))
              (ASSOC-EQUAL VAR A))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                (AND (MV-NTH 0 (FALSIFY X A))
                     (CDR (ASSOC-EQUAL VAR A))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, FALSIFY, IF-EXPRP, MV-NTH and QUOTEP, the :executable-
counterparts of BINARY-+, EQUAL and ZP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/5
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (ASSIGNMENT X A))
         (IMPLIES (ASSOC-EQUAL VAR A)
                  (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                         (AND (MV-NTH 0 (FALSIFY X A))
                              (CDR (ASSOC-EQUAL VAR A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/5'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (ASSIGNMENT X A)
              (ASSOC-EQUAL VAR A))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                (AND (MV-NTH 0 (FALSIFY X A))
                     (CDR (ASSOC-EQUAL VAR A))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, ASSOC-EQUAL, FALSIFY, IF-EXPRP and QUOTEP and the :executable-
counterparts of CDR, CONSP, EQUAL and MV-NTH.

Subgoal *1/4
(IMPLIES
 (AND
   (IF-EXPRP X)
   (NOT (ASSIGNEDP (A1 X) A))
   (NOT (MV-NTH 0
                (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
   (IMPLIES
        (ASSOC-EQUAL VAR (ASSUME-TRUE (A1 X) A))
        (EQUAL (CDR (ASSOC-EQUAL VAR
                                 (MV-NTH 1
                                         (FALSIFY (A2 X)
                                                  (ASSUME-TRUE (A1 X) A)))))
               (AND (MV-NTH 0
                            (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                    (CDR (ASSOC-EQUAL VAR (ASSUME-TRUE (A1 X) A))))))
   (IMPLIES
        (ASSOC-EQUAL VAR (ASSUME-FALSE (A1 X) A))
        (EQUAL (CDR (ASSOC-EQUAL VAR
                                 (MV-NTH 1
                                         (FALSIFY (A3 X)
                                                  (ASSUME-FALSE (A1 X) A)))))
               (AND (MV-NTH 0
                            (FALSIFY (A3 X)
                                     (ASSUME-FALSE (A1 X) A)))
                    (CDR (ASSOC-EQUAL VAR (ASSUME-FALSE (A1 X) A)))))))
 (IMPLIES (ASSOC-EQUAL VAR A)
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                 (AND (MV-NTH 0 (FALSIFY X A))
                      (CDR (ASSOC-EQUAL VAR A)))))).

By the simple :definitions A1, A2, A3, ASSIGNEDP, ASSUME-FALSE, ASSUME-TRUE
and IF-EXPRP we reduce the conjecture to

Subgoal *1/4'
(IMPLIES
 (AND
  (CONSP X)
  (EQUAL (CAR X) 'IF)
  (NOT (QUOTEP (CADR X)))
  (NOT (ASSOC-EQUAL (CADR X) A))
  (NOT (MV-NTH 0
               (FALSIFY (CADDR X)
                        (CONS (CONS (CADR X) T) A))))
  (IMPLIES
     (ASSOC-EQUAL VAR (CONS (CONS (CADR X) T) A))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (AND (MV-NTH 0
                         (FALSIFY (CADDR X)
                                  (CONS (CONS (CADR X) T) A)))
                 (CDR (ASSOC-EQUAL VAR (CONS (CONS (CADR X) T) A))))))
  (IMPLIES
       (ASSOC-EQUAL VAR (CONS (LIST (CADR X)) A))
       (EQUAL (CDR (ASSOC-EQUAL VAR
                                (MV-NTH 1
                                        (FALSIFY (CADDDR X)
                                                 (CONS (LIST (CADR X)) A)))))
              (AND (MV-NTH 0
                           (FALSIFY (CADDDR X)
                                    (CONS (LIST (CADR X)) A)))
                   (CDR (ASSOC-EQUAL VAR (CONS (LIST (CADR X)) A))))))
  (ASSOC-EQUAL VAR A))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
        (AND (MV-NTH 0 (FALSIFY X A))
             (CDR (ASSOC-EQUAL VAR A))))).

This simplifies, using the :definitions A1, ASSIGNEDP, ASSIGNMENT (if-
intro), ASSOC-EQUAL (if-intro), FALSIFY (if-intro), IF-EXPRP, MV-NTH
(if-intro) and QUOTEP (if-intro), the :executable-counterparts of EQUAL
and ZP, primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule FALSIFY, to the following 48 conjectures.

Subgoal *1/4.48
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                 (MV-NTH 1
                         (FALSIFY (A2 X)
                                  (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.47
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                      (MV-NTH 1
                              (FALSIFY (A2 X)
                                       (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.46
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (CAR (FALSIFY (A3 X)
                    (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.45
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (NOT (CAR (FALSIFY (A3 X)
                         (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.44
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                 (MV-NTH 1
                         (FALSIFY (A2 X)
                                  (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.43
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                      (MV-NTH 1
                              (FALSIFY (A2 X)
                                       (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.42
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (CAR (FALSIFY (A3 X)
                    (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.41
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (NOT (CAR (FALSIFY (A3 X)
                         (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE and the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/4.40
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (CDR (ASSOC-EQUAL VAR A))
      (CAR (FALSIFY (A2 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.40'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (CDR (ASSOC-EQUAL VAR A))
      (CAR (FALSIFY (CADDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.39
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (CDR (ASSOC-EQUAL VAR A))
      (NOT (CAR (FALSIFY (A2 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        NIL)).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.39'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (CDR (ASSOC-EQUAL VAR A))
      (NOT (CAR (FALSIFY (CADDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.38
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (CAR (FALSIFY (A3 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.38'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (CAR (FALSIFY (CADDDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.37
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (NOT (CAR (FALSIFY (A3 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        NIL)).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.37'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (NOT (CAR (FALSIFY (CADDDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.36
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (EQUAL VAR (CADR X)))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                 (MV-NTH 1
                         (FALSIFY (A2 X)
                                  (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.35
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (EQUAL VAR (CADR X)))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                      (MV-NTH 1
                              (FALSIFY (A2 X)
                                       (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.34
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (EQUAL VAR (CADR X)))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (CAR (FALSIFY (A3 X)
                    (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.33
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (EQUAL VAR (CADR X)))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (NOT (CAR (FALSIFY (A3 X)
                         (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.32
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                 (MV-NTH 1
                         (FALSIFY (A2 X)
                                  (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.31
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                      (MV-NTH 1
                              (FALSIFY (A2 X)
                                       (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.30
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (CAR (FALSIFY (A3 X)
                    (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.29
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (CONSP (CADR X)))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (NOT (CAR (FALSIFY (A3 X)
                         (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE and the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/4.28
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                 (MV-NTH 1
                         (FALSIFY (A2 X)
                                  (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.27
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                      (MV-NTH 1
                              (FALSIFY (A2 X)
                                       (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.26
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (CAR (FALSIFY (A3 X)
                    (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.25
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (NOT (CAR (FALSIFY (A3 X)
                         (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.24
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                 (MV-NTH 1
                         (FALSIFY (A2 X)
                                  (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.23
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                      (MV-NTH 1
                              (FALSIFY (A2 X)
                                       (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.22
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (CAR (FALSIFY (A3 X)
                    (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.21
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (NOT (EQUAL VAR (CADR X)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (NOT (CAR (FALSIFY (A3 X)
                         (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE and the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/4.20
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (CONSP VAR))
      (CDR (ASSOC-EQUAL VAR A))
      (CAR (FALSIFY (A2 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.20'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (CONSP VAR))
      (CDR (ASSOC-EQUAL VAR A))
      (CAR (FALSIFY (CADDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.19
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (CONSP VAR))
      (CDR (ASSOC-EQUAL VAR A))
      (NOT (CAR (FALSIFY (A2 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        NIL)).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.19'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (CONSP VAR))
      (CDR (ASSOC-EQUAL VAR A))
      (NOT (CAR (FALSIFY (CADDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.18
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (CONSP VAR))
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (CAR (FALSIFY (A3 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.18'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (CONSP VAR))
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (CAR (FALSIFY (CADDDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.17
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (CONSP VAR))
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (NOT (CAR (FALSIFY (A3 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        NIL)).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.17'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (CONSP VAR))
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (NOT (CAR (FALSIFY (CADDDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.16
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (CONSP VAR)
      (EQUAL (CAR VAR) 'QUOTE)
      (CADR VAR)
      (CAR (FALSIFY (A2 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.16'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (CONSP VAR)
      (EQUAL (CAR VAR) 'QUOTE)
      (CADR VAR)
      (CAR (FALSIFY (CADDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.15
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (CONSP VAR)
      (EQUAL (CAR VAR) 'QUOTE)
      (CADR VAR)
      (NOT (CAR (FALSIFY (A2 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        NIL)).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.15'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (CONSP VAR)
      (EQUAL (CAR VAR) 'QUOTE)
      (CADR VAR)
      (NOT (CAR (FALSIFY (CADDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.14
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (CONSP VAR)
      (EQUAL (CAR VAR) 'QUOTE)
      (NOT (CADR VAR))
      (CAR (FALSIFY (A3 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.14'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (CONSP VAR)
      (EQUAL (CAR VAR) 'QUOTE)
      (NOT (CADR VAR))
      (CAR (FALSIFY (CADDDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.13
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (CONSP VAR)
      (EQUAL (CAR VAR) 'QUOTE)
      (NOT (CADR VAR))
      (NOT (CAR (FALSIFY (A3 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        NIL)).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.13'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (CONSP VAR)
      (EQUAL (CAR VAR) 'QUOTE)
      (NOT (CADR VAR))
      (NOT (CAR (FALSIFY (CADDDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.12
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (EQUAL (CAR VAR) 'QUOTE))
      (CDR (ASSOC-EQUAL VAR A))
      (CAR (FALSIFY (A2 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.12'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (EQUAL (CAR VAR) 'QUOTE))
      (CDR (ASSOC-EQUAL VAR A))
      (CAR (FALSIFY (CADDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.11
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (EQUAL (CAR VAR) 'QUOTE))
      (CDR (ASSOC-EQUAL VAR A))
      (NOT (CAR (FALSIFY (A2 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        NIL)).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.11'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (EQUAL (CAR VAR) 'QUOTE))
      (CDR (ASSOC-EQUAL VAR A))
      (NOT (CAR (FALSIFY (CADDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.10
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (EQUAL (CAR VAR) 'QUOTE))
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (CAR (FALSIFY (A3 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.10'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (EQUAL (CAR VAR) 'QUOTE))
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (CAR (FALSIFY (CADDDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.9
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (LIST VAR)))
      (ASSOC-EQUAL VAR A)
      (NOT (EQUAL (CAR VAR) 'QUOTE))
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (NOT (CAR (FALSIFY (A3 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        NIL)).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/4.9'
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (EQUAL VAR (CADR X))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
      (ASSOC-EQUAL VAR A)
      (NOT (EQUAL (CAR VAR) 'QUOTE))
      (NOT (CDR (ASSOC-EQUAL VAR A)))
      (NOT (CAR (FALSIFY (CADDDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/4.8
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (EQUAL VAR (CADR X)))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                 (MV-NTH 1
                         (FALSIFY (A2 X)
                                  (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.7
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (EQUAL VAR (CADR X)))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                      (MV-NTH 1
                              (FALSIFY (A2 X)
                                       (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.6
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (EQUAL VAR (CADR X)))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (CAR (FALSIFY (A3 X)
                    (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.5
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (EQUAL VAR (CADR X)))
      (CAR (FALSIFY (CADDDR X)
                    (CONS (LIST (CADR X)) A)))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             (CDR (ASSOC-EQUAL VAR A)))
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (NOT (CAR (FALSIFY (A3 X)
                         (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.4
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                 (MV-NTH 1
                         (FALSIFY (A2 X)
                                  (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.3
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
      (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                      (MV-NTH 1
                              (FALSIFY (A2 X)
                                       (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.2
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (CAR (FALSIFY (A3 X)
                    (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.1
(IMPLIES
 (AND (CONSP X)
      (EQUAL (CAR X) 'IF)
      (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
      (NOT (ASSOC-EQUAL (CADR X) A))
      (NOT (CAR (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A))))
      (CONS (CADR X) T)
      (NOT (CDR (ASSOC-EQUAL VAR
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
      (NOT (CAR (FALSIFY (CADDDR X)
                         (CONS (LIST (CADR X)) A))))
      (EQUAL (CDR (ASSOC-EQUAL VAR
                               (MV-NTH 1
                                       (FALSIFY (CADDDR X)
                                                (CONS (LIST (CADR X)) A)))))
             NIL)
      (ASSOC-EQUAL VAR A)
      (NOT (CAR (FALSIFY (A2 X)
                         (ASSUME-TRUE (A1 X) A))))
      (NOT (CAR (FALSIFY (A3 X)
                         (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE and the :executable-counterpart of
TAU-SYSTEM.

Subgoal *1/3
(IMPLIES
 (AND
    (IF-EXPRP X)
    (NOT (ASSIGNEDP (A1 X) A))
    (MV-NTH 0
            (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
    (IMPLIES
         (ASSOC-EQUAL VAR (ASSUME-TRUE (A1 X) A))
         (EQUAL (CDR (ASSOC-EQUAL VAR
                                  (MV-NTH 1
                                          (FALSIFY (A2 X)
                                                   (ASSUME-TRUE (A1 X) A)))))
                (AND (MV-NTH 0
                             (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                     (CDR (ASSOC-EQUAL VAR (ASSUME-TRUE (A1 X) A)))))))
 (IMPLIES (ASSOC-EQUAL VAR A)
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                 (AND (MV-NTH 0 (FALSIFY X A))
                      (CDR (ASSOC-EQUAL VAR A)))))).

By the simple :definitions A1, A2, ASSIGNEDP, ASSUME-TRUE and IF-EXPRP
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES
 (AND
  (CONSP X)
  (EQUAL (CAR X) 'IF)
  (NOT (QUOTEP (CADR X)))
  (NOT (ASSOC-EQUAL (CADR X) A))
  (MV-NTH 0
          (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
  (IMPLIES
     (ASSOC-EQUAL VAR (CONS (CONS (CADR X) T) A))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (AND (MV-NTH 0
                         (FALSIFY (CADDR X)
                                  (CONS (CONS (CADR X) T) A)))
                 (CDR (ASSOC-EQUAL VAR (CONS (CONS (CADR X) T) A))))))
  (ASSOC-EQUAL VAR A))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
        (AND (MV-NTH 0 (FALSIFY X A))
             (CDR (ASSOC-EQUAL VAR A))))).

This simplifies, using the :definitions A1, ASSIGNEDP, ASSIGNMENT (if-
intro), ASSOC-EQUAL (if-intro), FALSIFY (if-intro), IF-EXPRP, MV-NTH
(if-intro) and QUOTEP (if-intro), the :executable-counterparts of EQUAL
and ZP, primitive type reasoning, the :rewrite rules CAR-CONS and CDR-CONS
and the :type-prescription rule FALSIFY, to the following 24 conjectures.

Subgoal *1/3.24
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (NOT (EQUAL VAR (CADR X)))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (ASSOC-EQUAL VAR A)))
     (ASSOC-EQUAL VAR A)
     (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
     (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                (MV-NTH 1
                        (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/3.23
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (NOT (EQUAL VAR (CADR X)))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (ASSOC-EQUAL VAR A)))
     (ASSOC-EQUAL VAR A)
     (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
     (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/3.22
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (NOT (EQUAL VAR (CADR X)))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (ASSOC-EQUAL VAR A)))
     (ASSOC-EQUAL VAR A)
     (NOT (CAR (FALSIFY (A2 X)
                        (ASSUME-TRUE (A1 X) A))))
     (CAR (FALSIFY (A3 X)
                   (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.21
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (NOT (EQUAL VAR (CADR X)))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (ASSOC-EQUAL VAR A)))
     (ASSOC-EQUAL VAR A)
     (NOT (CAR (FALSIFY (A2 X)
                        (ASSUME-TRUE (A1 X) A))))
     (NOT (CAR (FALSIFY (A3 X)
                        (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.20
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (CDR (ASSOC-EQUAL VAR A))
     (CAR (FALSIFY (A2 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.20'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (CDR (ASSOC-EQUAL VAR A))
     (CAR (FALSIFY (CADDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.19
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (CDR (ASSOC-EQUAL VAR A))
     (NOT (CAR (FALSIFY (A2 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        NIL)).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.19'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (CDR (ASSOC-EQUAL VAR A))
     (NOT (CAR (FALSIFY (CADDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.18
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (CAR (FALSIFY (A3 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.18'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (CAR (FALSIFY (CADDDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.17
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (NOT (CAR (FALSIFY (A3 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        NIL)).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.17'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (CONSP (CADR X)))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (NOT (CAR (FALSIFY (CADDDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.16
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (NOT (EQUAL VAR (CADR X)))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (ASSOC-EQUAL VAR A)))
     (ASSOC-EQUAL VAR A)
     (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
     (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                (MV-NTH 1
                        (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/3.15
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (NOT (EQUAL VAR (CADR X)))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (ASSOC-EQUAL VAR A)))
     (ASSOC-EQUAL VAR A)
     (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
     (NOT (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A2 X)
                                           (ASSUME-TRUE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/3.14
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (NOT (EQUAL VAR (CADR X)))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (ASSOC-EQUAL VAR A)))
     (ASSOC-EQUAL VAR A)
     (NOT (CAR (FALSIFY (A2 X)
                        (ASSUME-TRUE (A1 X) A))))
     (CAR (FALSIFY (A3 X)
                   (ASSUME-FALSE (A1 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.13
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (NOT (EQUAL VAR (CADR X)))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (ASSOC-EQUAL VAR A)))
     (ASSOC-EQUAL VAR A)
     (NOT (CAR (FALSIFY (A2 X)
                        (ASSUME-TRUE (A1 X) A))))
     (NOT (CAR (FALSIFY (A3 X)
                        (ASSUME-FALSE (A1 X) A)))))
 (EQUAL (CDR (ASSOC-EQUAL VAR
                          (MV-NTH 1
                                  (FALSIFY (A3 X)
                                           (ASSUME-FALSE (A1 X) A)))))
        NIL)).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.12
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (CONSP VAR))
     (CDR (ASSOC-EQUAL VAR A))
     (CAR (FALSIFY (A2 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.12'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (CONSP VAR))
     (CDR (ASSOC-EQUAL VAR A))
     (CAR (FALSIFY (CADDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.11
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (CONSP VAR))
     (CDR (ASSOC-EQUAL VAR A))
     (NOT (CAR (FALSIFY (A2 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        NIL)).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.11'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (CONSP VAR))
     (CDR (ASSOC-EQUAL VAR A))
     (NOT (CAR (FALSIFY (CADDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.10
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (CONSP VAR))
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (CAR (FALSIFY (A3 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.10'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (CONSP VAR))
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (CAR (FALSIFY (CADDDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.9
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (CONSP VAR))
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (NOT (CAR (FALSIFY (A3 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        NIL)).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.9'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (CONSP VAR))
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (NOT (CAR (FALSIFY (CADDDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.8
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (CONSP VAR)
     (EQUAL (CAR VAR) 'QUOTE)
     (CADR VAR)
     (CAR (FALSIFY (A2 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.8'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (CONSP VAR)
     (EQUAL (CAR VAR) 'QUOTE)
     (CADR VAR)
     (CAR (FALSIFY (CADDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.7
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (CONSP VAR)
     (EQUAL (CAR VAR) 'QUOTE)
     (CADR VAR)
     (NOT (CAR (FALSIFY (A2 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        NIL)).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.7'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (CONSP VAR)
     (EQUAL (CAR VAR) 'QUOTE)
     (CADR VAR)
     (NOT (CAR (FALSIFY (CADDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.6
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (CONSP VAR)
     (EQUAL (CAR VAR) 'QUOTE)
     (NOT (CADR VAR))
     (CAR (FALSIFY (A3 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.6'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (CONSP VAR)
     (EQUAL (CAR VAR) 'QUOTE)
     (NOT (CADR VAR))
     (CAR (FALSIFY (CADDDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.5
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (CONSP VAR)
     (EQUAL (CAR VAR) 'QUOTE)
     (NOT (CADR VAR))
     (NOT (CAR (FALSIFY (A3 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        NIL)).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.5'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (CONSP VAR)
     (EQUAL (CAR VAR) 'QUOTE)
     (NOT (CADR VAR))
     (NOT (CAR (FALSIFY (CADDDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.4
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (EQUAL (CAR VAR) 'QUOTE))
     (CDR (ASSOC-EQUAL VAR A))
     (CAR (FALSIFY (A2 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.4'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (EQUAL (CAR VAR) 'QUOTE))
     (CDR (ASSOC-EQUAL VAR A))
     (CAR (FALSIFY (CADDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.3
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (EQUAL (CAR VAR) 'QUOTE))
     (CDR (ASSOC-EQUAL VAR A))
     (NOT (CAR (FALSIFY (A2 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
        NIL)).

By the simple :definition A2 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.3'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (EQUAL (CAR VAR) 'QUOTE))
     (CDR (ASSOC-EQUAL VAR A))
     (NOT (CAR (FALSIFY (CADDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.2
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (EQUAL (CAR VAR) 'QUOTE))
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (CAR (FALSIFY (A3 X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.2'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (EQUAL (CAR VAR) 'QUOTE))
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (CAR (FALSIFY (CADDDR X) A)))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        (CDR (ASSOC-EQUAL VAR A)))).

But simplification reduces this to T, using trivial observations.

Subgoal *1/3.1
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            (CDR (CONS VAR T)))
     (ASSOC-EQUAL VAR A)
     (NOT (EQUAL (CAR VAR) 'QUOTE))
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (NOT (CAR (FALSIFY (A3 X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
        NIL)).

By the simple :definition A3 and the simple :rewrite rule CDR-CONS
we reduce the conjecture to

Subgoal *1/3.1'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
     (NOT (ASSOC-EQUAL (CADR X) A))
     (CAR (FALSIFY (CADDR X)
                   (CONS (CONS (CADR X) T) A)))
     (EQUAL VAR (CADR X))
     (EQUAL (CDR (ASSOC-EQUAL VAR
                              (MV-NTH 1
                                      (FALSIFY (CADDR X)
                                               (CONS (CONS (CADR X) T) A)))))
            T)
     (ASSOC-EQUAL VAR A)
     (NOT (EQUAL (CAR VAR) 'QUOTE))
     (NOT (CDR (ASSOC-EQUAL VAR A)))
     (NOT (CAR (FALSIFY (CADDDR X) A))))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
        NIL)).

But simplification reduces this to T, using trivial observations.

Subgoal *1/2
(IMPLIES
   (AND (IF-EXPRP X)
        (ASSIGNEDP (A1 X) A)
        (NOT (ASSIGNMENT (A1 X) A))
        (IMPLIES (ASSOC-EQUAL VAR A)
                 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
                        (AND (MV-NTH 0 (FALSIFY (A3 X) A))
                             (CDR (ASSOC-EQUAL VAR A))))))
   (IMPLIES (ASSOC-EQUAL VAR A)
            (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                   (AND (MV-NTH 0 (FALSIFY X A))
                        (CDR (ASSOC-EQUAL VAR A)))))).

By the simple :definitions A1, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/2'
(IMPLIES
 (AND
    (CONSP X)
    (EQUAL (CAR X) 'IF)
    (ASSIGNEDP (CADR X) A)
    (NOT (ASSIGNMENT (CADR X) A))
    (IMPLIES (ASSOC-EQUAL VAR A)
             (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                    (AND (MV-NTH 0 (FALSIFY (CADDDR X) A))
                         (CDR (ASSOC-EQUAL VAR A)))))
    (ASSOC-EQUAL VAR A))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
        (AND (MV-NTH 0 (FALSIFY X A))
             (CDR (ASSOC-EQUAL VAR A))))).

This simplifies, using the :definitions A1, ASSIGNEDP (if-intro), ASSIGNMENT
(if-intro), FALSIFY, IF-EXPRP, MV-NTH and QUOTEP (if-intro), the :executable-
counterparts of EQUAL and ZP and the :type-prescription rule FALSIFY,
to the following 16 conjectures.

Subgoal *1/2.16
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (NOT (CONSP (CADR X)))
          (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
          (CAR (FALSIFY (CADDDR X) A))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 (CDR (ASSOC-EQUAL VAR A)))
          (ASSOC-EQUAL VAR A)
          (CAR (FALSIFY (A3 X) A)))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.15
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (NOT (CONSP (CADR X)))
          (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
          (CAR (FALSIFY (CADDDR X) A))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 (CDR (ASSOC-EQUAL VAR A)))
          (ASSOC-EQUAL VAR A)
          (NOT (CAR (FALSIFY (A3 X) A))))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            NIL)).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.14
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (NOT (CONSP (CADR X)))
          (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
          (NOT (CAR (FALSIFY (CADDDR X) A)))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 NIL)
          (ASSOC-EQUAL VAR A)
          (CAR (FALSIFY (A3 X) A)))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.13
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (NOT (CONSP (CADR X)))
          (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
          (NOT (CAR (FALSIFY (CADDDR X) A)))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 NIL)
          (ASSOC-EQUAL VAR A)
          (NOT (CAR (FALSIFY (A3 X) A))))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            NIL)).

But we reduce the conjecture to T, by the simple :definition A3 and
the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/2.12
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (CONSP (CADR X))
          (EQUAL (CAR (CADR X)) 'QUOTE)
          (NOT (CADR (CADR X)))
          (CAR (FALSIFY (CADDDR X) A))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 (CDR (ASSOC-EQUAL VAR A)))
          (ASSOC-EQUAL VAR A)
          (CAR (FALSIFY (A3 X) A)))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.11
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (CONSP (CADR X))
          (EQUAL (CAR (CADR X)) 'QUOTE)
          (NOT (CADR (CADR X)))
          (CAR (FALSIFY (CADDDR X) A))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 (CDR (ASSOC-EQUAL VAR A)))
          (ASSOC-EQUAL VAR A)
          (NOT (CAR (FALSIFY (A3 X) A))))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            NIL)).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.10
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (CONSP (CADR X))
          (EQUAL (CAR (CADR X)) 'QUOTE)
          (NOT (CADR (CADR X)))
          (NOT (CAR (FALSIFY (CADDDR X) A)))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 NIL)
          (ASSOC-EQUAL VAR A)
          (CAR (FALSIFY (A3 X) A)))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.9
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (CONSP (CADR X))
          (EQUAL (CAR (CADR X)) 'QUOTE)
          (NOT (CADR (CADR X)))
          (NOT (CAR (FALSIFY (CADDDR X) A)))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 NIL)
          (ASSOC-EQUAL VAR A)
          (NOT (CAR (FALSIFY (A3 X) A))))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            NIL)).

But we reduce the conjecture to T, by the simple :definition A3 and
the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/2.8
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
          (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
          (CAR (FALSIFY (CADDDR X) A))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 (CDR (ASSOC-EQUAL VAR A)))
          (ASSOC-EQUAL VAR A)
          (CAR (FALSIFY (A3 X) A)))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.7
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
          (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
          (CAR (FALSIFY (CADDDR X) A))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 (CDR (ASSOC-EQUAL VAR A)))
          (ASSOC-EQUAL VAR A)
          (NOT (CAR (FALSIFY (A3 X) A))))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            NIL)).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.6
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
          (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
          (NOT (CAR (FALSIFY (CADDDR X) A)))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 NIL)
          (ASSOC-EQUAL VAR A)
          (CAR (FALSIFY (A3 X) A)))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.5
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (ASSOC-EQUAL (CADR X) A)
          (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
          (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
          (NOT (CAR (FALSIFY (CADDDR X) A)))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 NIL)
          (ASSOC-EQUAL VAR A)
          (NOT (CAR (FALSIFY (A3 X) A))))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            NIL)).

But we reduce the conjecture to T, by the simple :definition A3 and
the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/2.4
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (CONSP (CADR X))
          (EQUAL (CAR (CADR X)) 'QUOTE)
          (NOT (CADR (CADR X)))
          (CAR (FALSIFY (CADDDR X) A))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 (CDR (ASSOC-EQUAL VAR A)))
          (ASSOC-EQUAL VAR A)
          (CAR (FALSIFY (A3 X) A)))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.3
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (CONSP (CADR X))
          (EQUAL (CAR (CADR X)) 'QUOTE)
          (NOT (CADR (CADR X)))
          (CAR (FALSIFY (CADDDR X) A))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 (CDR (ASSOC-EQUAL VAR A)))
          (ASSOC-EQUAL VAR A)
          (NOT (CAR (FALSIFY (A3 X) A))))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            NIL)).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.2
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (CONSP (CADR X))
          (EQUAL (CAR (CADR X)) 'QUOTE)
          (NOT (CADR (CADR X)))
          (NOT (CAR (FALSIFY (CADDDR X) A)))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 NIL)
          (ASSOC-EQUAL VAR A)
          (CAR (FALSIFY (A3 X) A)))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.1
(IMPLIES
     (AND (CONSP X)
          (EQUAL (CAR X) 'IF)
          (CONSP (CADR X))
          (EQUAL (CAR (CADR X)) 'QUOTE)
          (NOT (CADR (CADR X)))
          (NOT (CAR (FALSIFY (CADDDR X) A)))
          (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDDR X) A))))
                 NIL)
          (ASSOC-EQUAL VAR A)
          (NOT (CAR (FALSIFY (A3 X) A))))
     (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A3 X) A))))
            NIL)).

But we reduce the conjecture to T, by the simple :definition A3 and
the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/1
(IMPLIES
   (AND (IF-EXPRP X)
        (ASSIGNEDP (A1 X) A)
        (ASSIGNMENT (A1 X) A)
        (IMPLIES (ASSOC-EQUAL VAR A)
                 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                        (AND (MV-NTH 0 (FALSIFY (A2 X) A))
                             (CDR (ASSOC-EQUAL VAR A))))))
   (IMPLIES (ASSOC-EQUAL VAR A)
            (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
                   (AND (MV-NTH 0 (FALSIFY X A))
                        (CDR (ASSOC-EQUAL VAR A)))))).

By the simple :definitions A1, A2 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/1'
(IMPLIES
 (AND
     (CONSP X)
     (EQUAL (CAR X) 'IF)
     (ASSIGNEDP (CADR X) A)
     (ASSIGNMENT (CADR X) A)
     (IMPLIES (ASSOC-EQUAL VAR A)
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (AND (MV-NTH 0 (FALSIFY (CADDR X) A))
                          (CDR (ASSOC-EQUAL VAR A)))))
     (ASSOC-EQUAL VAR A))
 (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY X A))))
        (AND (MV-NTH 0 (FALSIFY X A))
             (CDR (ASSOC-EQUAL VAR A))))).

This simplifies, using the :definitions A1, ASSIGNEDP (if-intro), ASSIGNMENT
(if-intro), FALSIFY, IF-EXPRP, MV-NTH and QUOTEP (if-intro), the :executable-
counterparts of EQUAL and ZP and the :type-prescription rule FALSIFY,
to the following 16 conjectures.

Subgoal *1/1.16
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X) A))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (CDR (ASSOC-EQUAL VAR A)))
              (ASSOC-EQUAL VAR A)
              (CAR (FALSIFY (A2 X) A)))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.15
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X) A))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (CDR (ASSOC-EQUAL VAR A)))
              (ASSOC-EQUAL VAR A)
              (NOT (CAR (FALSIFY (A2 X) A))))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                NIL)).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.14
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     NIL)
              (ASSOC-EQUAL VAR A)
              (CAR (FALSIFY (A2 X) A)))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.13
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     NIL)
              (ASSOC-EQUAL VAR A)
              (NOT (CAR (FALSIFY (A2 X) A))))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                NIL)).

But we reduce the conjecture to T, by the simple :definition A2 and
the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/1.12
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CAR (FALSIFY (CADDR X) A))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (CDR (ASSOC-EQUAL VAR A)))
              (ASSOC-EQUAL VAR A)
              (CAR (FALSIFY (A2 X) A)))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.11
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CAR (FALSIFY (CADDR X) A))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (CDR (ASSOC-EQUAL VAR A)))
              (ASSOC-EQUAL VAR A)
              (NOT (CAR (FALSIFY (A2 X) A))))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                NIL)).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.10
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     NIL)
              (ASSOC-EQUAL VAR A)
              (CAR (FALSIFY (A2 X) A)))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.9
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     NIL)
              (ASSOC-EQUAL VAR A)
              (NOT (CAR (FALSIFY (A2 X) A))))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                NIL)).

But we reduce the conjecture to T, by the simple :definition A2 and
the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/1.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X) A))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (CDR (ASSOC-EQUAL VAR A)))
              (ASSOC-EQUAL VAR A)
              (CAR (FALSIFY (A2 X) A)))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X) A))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (CDR (ASSOC-EQUAL VAR A)))
              (ASSOC-EQUAL VAR A)
              (NOT (CAR (FALSIFY (A2 X) A))))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                NIL)).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     NIL)
              (ASSOC-EQUAL VAR A)
              (CAR (FALSIFY (A2 X) A)))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     NIL)
              (ASSOC-EQUAL VAR A)
              (NOT (CAR (FALSIFY (A2 X) A))))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                NIL)).

But we reduce the conjecture to T, by the simple :definition A2 and
the :executable-counterpart of TAU-SYSTEM.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CAR (FALSIFY (CADDR X) A))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (CDR (ASSOC-EQUAL VAR A)))
              (ASSOC-EQUAL VAR A)
              (CAR (FALSIFY (A2 X) A)))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (CAR (FALSIFY (CADDR X) A))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     (CDR (ASSOC-EQUAL VAR A)))
              (ASSOC-EQUAL VAR A)
              (NOT (CAR (FALSIFY (A2 X) A))))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                NIL)).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     NIL)
              (ASSOC-EQUAL VAR A)
              (CAR (FALSIFY (A2 X) A)))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                (CDR (ASSOC-EQUAL VAR A)))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (CADDR X) A))))
                     NIL)
              (ASSOC-EQUAL VAR A)
              (NOT (CAR (FALSIFY (A2 X) A))))
         (EQUAL (CDR (ASSOC-EQUAL VAR (MV-NTH 1 (FALSIFY (A2 X) A))))
                NIL)).

But we reduce the conjecture to T, by the simple :definition A2 and
the :executable-counterpart of TAU-SYSTEM.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-137B ...)
Rules: ((:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION ASSIGNEDP)
        (:DEFINITION ASSIGNMENT)
        (:DEFINITION ASSOC-EQUAL)
        (:DEFINITION ASSUME-FALSE)
        (:DEFINITION ASSUME-TRUE)
        (:DEFINITION FALSIFY)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION MV-NTH)
        (:DEFINITION NOT)
        (:DEFINITION QUOTEP)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART MV-NTH)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FALSIFY)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:TYPE-PRESCRIPTION FALSIFY))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ASSIGNEDP)
             (:DEFINITION ASSIGNMENT)
             (:DEFINITION ASSOC-EQUAL)
             (:DEFINITION FALSIFY)
             (:DEFINITION IF-EXPRP)
             (:DEFINITION MV-NTH)
             (:DEFINITION QUOTEP))
PROBLEM-137B


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-137B))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-137B)
PROBLEM-137B

Summary
Form:  ( PROGN (DEFTHM PROBLEM-137B ...) ...)
Rules: NIL
 PROBLEM-137B
ACL2 !>>(THEOREM PROBLEM-137C
                 (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
                          (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))
                 :HINTS (("Goal" :INDUCT (FALSIFY X A)
                                 :IN-THEORY (ENABLE PROBLEM-137B))))


ACL2 !>>>(DEFTHM PROBLEM-137C
           (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
                    (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))
           :HINTS (("Goal" :DO-NOT-INDUCT T
                           :DO-NOT '(GENERALIZE)
                           :INDUCT (FALSIFY X A)
                           :IN-THEORY (ENABLE PROBLEM-137B))))

[Note:  A hint was supplied for the goal above.  Thanks!]

Name the formula above *1.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (FALSIFY X A).

This suggestion was produced using the :induction rule FALSIFY.  If
we let (:P A X) denote *1 above then the induction scheme we'll use
is
(AND (IMPLIES (AND (NOT (IF-EXPRP X))
                   (NOT (ASSIGNEDP X A)))
              (:P A X))
     (IMPLIES (AND (NOT (IF-EXPRP X))
                   (ASSIGNEDP X A)
                   (NOT (ASSIGNMENT X A)))
              (:P A X))
     (IMPLIES (AND (NOT (IF-EXPRP X))
                   (ASSIGNEDP X A)
                   (ASSIGNMENT X A))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) A))
                   (NOT (MV-NTH 0
                                (FALSIFY (A2 X)
                                         (ASSUME-TRUE (A1 X) A))))
                   (:P (ASSUME-TRUE (A1 X) A) (A2 X))
                   (:P (ASSUME-FALSE (A1 X) A) (A3 X)))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (NOT (ASSIGNEDP (A1 X) A))
                   (MV-NTH 0
                           (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                   (:P (ASSUME-TRUE (A1 X) A) (A2 X)))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) A)
                   (NOT (ASSIGNMENT (A1 X) A))
                   (:P A (A3 X)))
              (:P A X))
     (IMPLIES (AND (IF-EXPRP X)
                   (ASSIGNEDP (A1 X) A)
                   (ASSIGNMENT (A1 X) A)
                   (:P A (A2 X)))
              (:P A X))).
This induction is justified by the same argument used to admit FALSIFY.
Note, however, that the unmeasured variable A is being instantiated.
When applied to the goal at hand the above induction scheme produces
seven nontautological subgoals.

Subgoal *1/7
(IMPLIES (AND (NOT (IF-EXPRP X))
              (NOT (ASSIGNEDP X A)))
         (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
                  (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))).

By the simple :definition ASSIGNEDP we reduce the conjecture to

Subgoal *1/7'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (NOT (QUOTEP X))
              (NOT (ASSOC-EQUAL X A))
              (MV-NTH 0 (FALSIFY X A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP, MV-NTH, NORMP,
PEVAL and QUOTEP, the :executable-counterparts of BINARY-+ and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/6
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (NOT (ASSIGNMENT X A)))
         (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
                  (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/6'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (NOT (ASSIGNMENT X A))
              (MV-NTH 0 (FALSIFY X A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, FALSIFY, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP, the
:executable-counterparts of BINARY-+, EQUAL and ZP, primitive type
reasoning and the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/5
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (ASSIGNMENT X A))
         (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
                  (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/5'
(IMPLIES (AND (NOT (IF-EXPRP X))
              (ASSIGNEDP X A)
              (ASSIGNMENT X A)
              (MV-NTH 0 (FALSIFY X A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, FALSIFY, IF-EXPRP and QUOTEP and the :executable-counterparts
of EQUAL and MV-NTH.

Subgoal *1/4
(IMPLIES
     (AND (IF-EXPRP X)
          (NOT (ASSIGNEDP (A1 X) A))
          (NOT (MV-NTH 0
                       (FALSIFY (A2 X)
                                (ASSUME-TRUE (A1 X) A))))
          (IMPLIES (AND (MV-NTH 0
                                (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                        (NORMP (A2 X)))
                   (NOT (PEVAL (A2 X)
                               (MV-NTH 1
                                       (FALSIFY (A2 X)
                                                (ASSUME-TRUE (A1 X) A))))))
          (IMPLIES (AND (MV-NTH 0
                                (FALSIFY (A3 X)
                                         (ASSUME-FALSE (A1 X) A)))
                        (NORMP (A3 X)))
                   (NOT (PEVAL (A3 X)
                               (MV-NTH 1
                                       (FALSIFY (A3 X)
                                                (ASSUME-FALSE (A1 X) A)))))))
     (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
              (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))).

By the simple :definitions A1, A2, A3, ASSIGNEDP, ASSUME-FALSE, ASSUME-TRUE
and IF-EXPRP we reduce the conjecture to

Subgoal *1/4'
(IMPLIES
   (AND (CONSP X)
        (EQUAL (CAR X) 'IF)
        (NOT (QUOTEP (CADR X)))
        (NOT (ASSOC-EQUAL (CADR X) A))
        (NOT (MV-NTH 0
                     (FALSIFY (CADDR X)
                              (CONS (CONS (CADR X) T) A))))
        (IMPLIES (AND (MV-NTH 0
                              (FALSIFY (CADDR X)
                                       (CONS (CONS (CADR X) T) A)))
                      (NORMP (CADDR X)))
                 (NOT (PEVAL (CADDR X)
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
        (IMPLIES (AND (MV-NTH 0
                              (FALSIFY (CADDDR X)
                                       (CONS (LIST (CADR X)) A)))
                      (NORMP (CADDDR X)))
                 (NOT (PEVAL (CADDDR X)
                             (MV-NTH 1
                                     (FALSIFY (CADDDR X)
                                              (CONS (LIST (CADR X)) A))))))
        (MV-NTH 0 (FALSIFY X A))
        (NORMP X))
   (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A))))).

This simplifies, using the :definitions A1, A2, A3, ASSIGNEDP, FALSIFY
(if-intro), IF-EXPRP (if-intro), MV-NTH (if-intro), NORMP (if-intro),
NOT (if-intro) and QUOTEP (if-intro), the :executable-counterparts
of BINARY-+, EQUAL and ZP, primitive type reasoning, the :rewrite rule
CDR-CONS and the :type-prescription rule FALSIFY, to the following
twelve conjectures.

Subgoal *1/4.12
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (CAR (FALSIFY (CADDDR X)
                                 (CONS (LIST (CADR X)) A))))
              (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                         (MV-NTH 1
                                 (FALSIFY (A2 X)
                                          (ASSUME-TRUE (A1 X) A)))))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.11
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (CAR (FALSIFY (CADDDR X)
                                 (CONS (LIST (CADR X)) A))))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))
              (CAR (FALSIFY (A3 X)
                            (ASSUME-FALSE (A1 X) A)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A3 X)
                                      (ASSUME-FALSE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.10
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                         (MV-NTH 1
                                 (FALSIFY (A2 X)
                                          (ASSUME-TRUE (A1 X) A)))))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.9
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))
              (CAR (FALSIFY (A3 X)
                            (ASSUME-FALSE (A1 X) A)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A3 X)
                                      (ASSUME-FALSE (A1 X) A)))))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/4.9'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (CADDDR X)
                                      (CONS (LIST (CADR X)) A)))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, ASSOC-EQUAL, IF-EXPRP, MV-NTH, PEVAL and QUOTEP, the
:executable-counterparts of EQUAL and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-137B and the :type-
prescription rule FALSIFY.

Subgoal *1/4.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (CAR (FALSIFY (CADDDR X)
                                 (CONS (LIST (CADR X)) A))))
              (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                         (MV-NTH 1
                                 (FALSIFY (A2 X)
                                          (ASSUME-TRUE (A1 X) A)))))
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (CAR (FALSIFY (CADDDR X)
                                 (CONS (LIST (CADR X)) A))))
              (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                         (MV-NTH 1
                                 (FALSIFY (A2 X)
                                          (ASSUME-TRUE (A1 X) A)))))
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (CAR (FALSIFY (CADDDR X)
                                 (CONS (LIST (CADR X)) A))))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))
              (CAR (FALSIFY (A3 X)
                            (ASSUME-FALSE (A1 X) A)))
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A3 X)
                                      (ASSUME-FALSE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (CAR (FALSIFY (CADDDR X)
                                 (CONS (LIST (CADR X)) A))))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))
              (CAR (FALSIFY (A3 X)
                            (ASSUME-FALSE (A1 X) A)))
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A3 X)
                                      (ASSUME-FALSE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/4.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                         (MV-NTH 1
                                 (FALSIFY (A2 X)
                                          (ASSUME-TRUE (A1 X) A)))))
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                         (MV-NTH 1
                                 (FALSIFY (A2 X)
                                          (ASSUME-TRUE (A1 X) A)))))
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2
and ASSUME-TRUE and the simple :rewrite rule CAR-CONS.

Subgoal *1/4.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))
              (CAR (FALSIFY (A3 X)
                            (ASSUME-FALSE (A1 X) A)))
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A3 X)
                                      (ASSUME-FALSE (A1 X) A)))))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/4.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NOT (CONSP (CADR X)))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (CADDDR X)
                                      (CONS (LIST (CADR X)) A)))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, ASSOC-EQUAL, IF-EXPRP, MV-NTH, PEVAL and QUOTEP, the
:executable-counterparts of EQUAL and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR and PROBLEM-137B
and the :type-prescription rule FALSIFY.

Subgoal *1/4.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))
              (CAR (FALSIFY (A3 X)
                            (ASSUME-FALSE (A1 X) A)))
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A3 X)
                                      (ASSUME-FALSE (A1 X) A)))))).

By the simple :definitions A1, A2, A3, ASSUME-FALSE and ASSUME-TRUE
we reduce the conjecture to

Subgoal *1/4.1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X)
                                 (CONS (CONS (CADR X) T) A))))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDDR X)
                                           (CONS (LIST (CADR X)) A)))))
              (CAR (FALSIFY (CADDDR X)
                            (CONS (LIST (CADR X)) A)))
              (NOT (EQUAL (CAR (CADR X)) 'IF))
              (NORMP (CADDR X))
              (NORMP (CADDDR X)))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (CADDDR X)
                                      (CONS (LIST (CADR X)) A)))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, ASSOC-EQUAL, IF-EXPRP, MV-NTH, PEVAL and QUOTEP, the
:executable-counterparts of EQUAL and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-137B and the :type-
prescription rule FALSIFY.

Subgoal *1/3
(IMPLIES
     (AND (IF-EXPRP X)
          (NOT (ASSIGNEDP (A1 X) A))
          (MV-NTH 0
                  (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
          (IMPLIES (AND (MV-NTH 0
                                (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                        (NORMP (A2 X)))
                   (NOT (PEVAL (A2 X)
                               (MV-NTH 1
                                       (FALSIFY (A2 X)
                                                (ASSUME-TRUE (A1 X) A)))))))
     (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
              (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))).

By the simple :definitions A1, A2, ASSIGNEDP, ASSUME-TRUE and IF-EXPRP
we reduce the conjecture to

Subgoal *1/3'
(IMPLIES
   (AND (CONSP X)
        (EQUAL (CAR X) 'IF)
        (NOT (QUOTEP (CADR X)))
        (NOT (ASSOC-EQUAL (CADR X) A))
        (MV-NTH 0
                (FALSIFY (CADDR X)
                         (CONS (CONS (CADR X) T) A)))
        (IMPLIES (AND (MV-NTH 0
                              (FALSIFY (CADDR X)
                                       (CONS (CONS (CADR X) T) A)))
                      (NORMP (CADDR X)))
                 (NOT (PEVAL (CADDR X)
                             (MV-NTH 1
                                     (FALSIFY (CADDR X)
                                              (CONS (CONS (CADR X) T) A))))))
        (MV-NTH 0 (FALSIFY X A))
        (NORMP X))
   (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A))))).

This simplifies, using the :definitions A1, A2, ASSIGNEDP, FALSIFY
(if-intro), IF-EXPRP (if-intro), MV-NTH (if-intro), NORMP, NOT (if-
intro) and QUOTEP (if-intro), the :executable-counterparts of BINARY-+,
EQUAL and ZP, primitive type reasoning, the :rewrite rule CDR-CONS
and the :type-prescription rule FALSIFY, to the following four conjectures.

Subgoal *1/3.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDR X)
                                           (CONS (CONS (CADR X) T) A)))))
              (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                         (MV-NTH 1
                                 (FALSIFY (A2 X)
                                          (ASSUME-TRUE (A1 X) A)))))
              (NORMP X))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))).

By the simple :definitions A1, A2 and ASSUME-TRUE and the simple :rewrite
rule CAR-CONS we reduce the conjecture to

Subgoal *1/3.4'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDR X)
                                           (CONS (CONS (CADR X) T) A)))))
              (NORMP X))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (CADDR X)
                                      (CONS (CONS (CADR X) T) A)))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following three goals.

Subgoal *1/3.4.3
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (NOT (ASSOC-EQUAL (CAR X2) A))
              (CAR (FALSIFY (CADR X2)
                            (CONS (CONS (CAR X2) T) A)))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1
                                  (FALSIFY (CADR X2)
                                           (CONS (CONS (CAR X2) T) A)))))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1
                             (FALSIFY (CADR X2)
                                      (CONS (CONS (CAR X2) T) A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/3.4.3'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (CONSP (CAR X2)))
              (NOT (ASSOC-EQUAL (CAR X2) A))
              (CAR (FALSIFY (CADR X2)
                            (CONS (CONS (CAR X2) T) A)))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1
                                  (FALSIFY (CADR X2)
                                           (CONS (CONS (CAR X2) T) A)))))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1
                             (FALSIFY (CADR X2)
                                      (CONS (CONS (CAR X2) T) A)))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, ASSOC-EQUAL and FALSIFY, the :executable-counterparts of
CAR, CDR, CONS, CONSP, EQUAL, IF-EXPRP, NOT, QUOTEP and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/3.4.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 A))
              (CAR (FALSIFY (CAR X4) (CONS (CONS X3 T) A)))
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1
                                  (FALSIFY (CAR X4)
                                           (CONS (CONS X3 T) A)))))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1
                             (FALSIFY (CAR X4)
                                      (CONS (CONS X3 T) A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/3.4.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 A))
              (CAR (FALSIFY (CAR X4) (CONS (CONS X3 T) A)))
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1
                                  (FALSIFY (CAR X4)
                                           (CONS (CONS X3 T) A)))))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1
                             (FALSIFY (CAR X4)
                                      (CONS (CONS X3 T) A)))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/3.4.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 A))
              (CAR (FALSIFY X5 (CONS (CONS X3 T) A)))
              (NOT (PEVAL X5
                          (MV-NTH 1 (FALSIFY X5 (CONS (CONS X3 T) A)))))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY X5 (CONS (CONS X3 T) A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/3.4.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (CONSP X3))
              (NOT (ASSOC-EQUAL X3 A))
              (CAR (FALSIFY X5 (CONS (CONS X3 T) A)))
              (NOT (PEVAL X5
                          (MV-NTH 1 (FALSIFY X5 (CONS (CONS X3 T) A)))))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY X5 (CONS (CONS X3 T) A)))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, ASSOC-EQUAL, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP,
the :executable-counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-137B
and the :type-prescription rule FALSIFY.

Subgoal *1/3.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (CONSP (CADR X)))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDR X)
                                           (CONS (CONS (CADR X) T) A)))))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))
              (CAR (FALSIFY (A3 X)
                            (ASSUME-FALSE (A1 X) A)))
              (NORMP X))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A3 X)
                                      (ASSUME-FALSE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/3.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDR X)
                                           (CONS (CONS (CADR X) T) A)))))
              (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
              (CAR (LIST (CAR (FALSIFY (A2 X) (ASSUME-TRUE (A1 X) A)))
                         (MV-NTH 1
                                 (FALSIFY (A2 X)
                                          (ASSUME-TRUE (A1 X) A)))))
              (NORMP X))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A2 X)
                                      (ASSUME-TRUE (A1 X) A)))))).

By the simple :definitions A1, A2 and ASSUME-TRUE and the simple :rewrite
rule CAR-CONS we reduce the conjecture to

Subgoal *1/3.2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDR X)
                                           (CONS (CONS (CADR X) T) A)))))
              (NORMP X))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (CADDR X)
                                      (CONS (CONS (CADR X) T) A)))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
four goals.

Subgoal *1/3.2.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CAR X2) A))
              (CAR (FALSIFY (CADR X2)
                            (CONS (CONS (CAR X2) T) A)))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1
                                  (FALSIFY (CADR X2)
                                           (CONS (CONS (CAR X2) T) A)))))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1
                             (FALSIFY (CADR X2)
                                      (CONS (CONS (CAR X2) T) A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/3.2.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CAR X2) A))
              (CAR (FALSIFY (CADR X2)
                            (CONS (CONS (CAR X2) T) A)))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1
                                  (FALSIFY (CADR X2)
                                           (CONS (CONS (CAR X2) T) A)))))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1
                             (FALSIFY (CADR X2)
                                      (CONS (CONS (CAR X2) T) A)))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT, ASSOC-EQUAL and FALSIFY, the :executable-counterparts of
CAR, CDR, CONS, EQUAL, IF-EXPRP, NOT, QUOTEP and SYMBOLP, primitive
type reasoning and the :rewrite rules CAR-CONS, DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/3.2.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 A))
              (CAR (FALSIFY (CAR X4) (CONS (CONS X3 T) A)))
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1
                                  (FALSIFY (CAR X4)
                                           (CONS (CONS X3 T) A)))))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1
                             (FALSIFY (CAR X4)
                                      (CONS (CONS X3 T) A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/3.2.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 A))
              (CAR (FALSIFY (CAR X4) (CONS (CONS X3 T) A)))
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1
                                  (FALSIFY (CAR X4)
                                           (CONS (CONS X3 T) A)))))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1
                             (FALSIFY (CAR X4)
                                      (CONS (CONS X3 T) A)))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/3.2.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 A))
              (CAR (FALSIFY X5 (CONS (CONS X3 T) A)))
              (NOT (PEVAL X5
                          (MV-NTH 1 (FALSIFY X5 (CONS (CONS X3 T) A)))))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY X5 (CONS (CONS X3 T) A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/3.2.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (ASSOC-EQUAL X3 A))
              (CAR (FALSIFY X5 (CONS (CONS X3 T) A)))
              (NOT (PEVAL X5
                          (MV-NTH 1 (FALSIFY X5 (CONS (CONS X3 T) A)))))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY X5 (CONS (CONS X3 T) A)))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, ASSOC-EQUAL, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP,
the :executable-counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR
and PROBLEM-137B and the :type-prescription rule FALSIFY.

Subgoal *1/3.2.1
(IMPLIES
     (AND (CONSP (CONS X4 X7))
          (CONSP (CONS X5 X6))
          (CONSP (LIST* (CONS X4 X7) X5 X6))
          (SYMBOLP X1)
          (NOT (EQUAL X1 T))
          (NOT (EQUAL X1 NIL))
          (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
          (EQUAL X1 'IF)
          (NOT (EQUAL X4 'QUOTE))
          (NOT (ASSOC-EQUAL (CONS X4 X7) A))
          (CAR (FALSIFY X5 (CONS (CONS (CONS X4 X7) T) A)))
          (NOT (PEVAL X5
                      (MV-NTH 1
                              (FALSIFY X5 (CONS (CONS (CONS X4 X7) T) A)))))
          (NORMP (LIST* X1 (CONS X4 X7) X5 X6)))
     (NOT (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                 (MV-NTH 1
                         (FALSIFY X5 (CONS (CONS (CONS X4 X7) T) A)))))).

By case analysis we reduce the conjecture to

Subgoal *1/3.2.1'
(IMPLIES
     (AND (CONSP (CONS X4 X7))
          (CONSP (CONS X5 X6))
          (CONSP (LIST* (CONS X4 X7) X5 X6))
          (SYMBOLP X1)
          (NOT (EQUAL X1 T))
          X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
          (EQUAL X1 'IF)
          (NOT (EQUAL X4 'QUOTE))
          (NOT (ASSOC-EQUAL (CONS X4 X7) A))
          (CAR (FALSIFY X5 (CONS (CONS (CONS X4 X7) T) A)))
          (NOT (PEVAL X5
                      (MV-NTH 1
                              (FALSIFY X5 (CONS (CONS (CONS X4 X7) T) A)))))
          (NORMP (LIST* X1 (CONS X4 X7) X5 X6)))
     (NOT (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                 (MV-NTH 1
                         (FALSIFY X5 (CONS (CONS (CONS X4 X7) T) A)))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, ASSOC-EQUAL, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP,
the :executable-counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive
type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-137B
and the :type-prescription rule FALSIFY.

Subgoal *1/3.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (ASSOC-EQUAL (CADR X) A))
              (CAR (FALSIFY (CADDR X)
                            (CONS (CONS (CADR X) T) A)))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1
                                  (FALSIFY (CADDR X)
                                           (CONS (CONS (CADR X) T) A)))))
              (NOT (CAR (FALSIFY (A2 X)
                                 (ASSUME-TRUE (A1 X) A))))
              (CAR (FALSIFY (A3 X)
                            (ASSUME-FALSE (A1 X) A)))
              (NORMP X))
         (NOT (PEVAL X
                     (MV-NTH 1
                             (FALSIFY (A3 X)
                                      (ASSUME-FALSE (A1 X) A)))))).

But we reduce the conjecture to T, by the simple :definitions A1, A2,
A3, ASSUME-FALSE and ASSUME-TRUE.

Subgoal *1/2
(IMPLIES (AND (IF-EXPRP X)
              (ASSIGNEDP (A1 X) A)
              (NOT (ASSIGNMENT (A1 X) A))
              (IMPLIES (AND (MV-NTH 0 (FALSIFY (A3 X) A))
                            (NORMP (A3 X)))
                       (NOT (PEVAL (A3 X)
                                   (MV-NTH 1 (FALSIFY (A3 X) A))))))
         (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
                  (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))).

By the simple :definitions A1, A3 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/2'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNEDP (CADR X) A)
              (NOT (ASSIGNMENT (CADR X) A))
              (IMPLIES (AND (MV-NTH 0 (FALSIFY (CADDDR X) A))
                            (NORMP (CADDDR X)))
                       (NOT (PEVAL (CADDDR X)
                                   (MV-NTH 1 (FALSIFY (CADDDR X) A)))))
              (MV-NTH 0 (FALSIFY X A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A))))).

This simplifies, using the :definitions A1, A2, A3, ASSIGNEDP (if-intro),
ASSIGNMENT (if-intro), FALSIFY, IF-EXPRP (if-intro), MV-NTH, NORMP,
NOT (if-intro) and QUOTEP (if-intro), the :executable-counterparts
of EQUAL and ZP and the :type-prescription rule FALSIFY, to the following
eight conjectures.

Subgoal *1/2.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (NOT (CAR (FALSIFY (CADDDR X) A)))
              (CAR (FALSIFY (A3 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A3 X) A))))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1 (FALSIFY (CADDDR X) A))))
              (CAR (FALSIFY (A3 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A3 X) A))))).

By the simple :definition A3 we reduce the conjecture to

Subgoal *1/2.7'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1 (FALSIFY (CADDDR X) A))))
              (CAR (FALSIFY (CADDDR X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (CADDDR X) A))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  These steps produce the following
four goals.

Subgoal *1/2.7.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (CONSP (CAR X2)))
              (NOT (CDR (ASSOC-EQUAL (CAR X2) A)))
              (NOT (PEVAL (CADDR X2)
                          (MV-NTH 1 (FALSIFY (CADDR X2) A))))
              (CAR (FALSIFY (CADDR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADDR X2) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.7.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (CONSP (CAR X2)))
              (NOT (CDR (ASSOC-EQUAL (CAR X2) A)))
              (NOT (PEVAL (CADDR X2)
                          (MV-NTH 1 (FALSIFY (CADDR X2) A))))
              (CAR (FALSIFY (CADDR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADDR X2) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, FALSIFY, IF-EXPRP, MV-NTH, NORMP and PEVAL,
the :executable-counterparts of BINARY-+, CAR, CDR, CONSP, EQUAL, IF-EXPRP,
NORMP, NOT, QUOTEP, SYMBOLP and ZP, primitive type reasoning and the
:rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/2.7.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL (CADR X4)
                          (MV-NTH 1 (FALSIFY (CADR X4) A))))
              (CAR (FALSIFY (CADR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CADR X4) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.7.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL (CADR X4)
                          (MV-NTH 1 (FALSIFY (CADR X4) A))))
              (CAR (FALSIFY (CADR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CADR X4) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/2.7.2
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL (CAR X6)
                          (MV-NTH 1 (FALSIFY (CAR X6) A))))
              (CAR (FALSIFY (CAR X6) A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY (CAR X6) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.7.2'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL (CAR X6)
                          (MV-NTH 1 (FALSIFY (CAR X6) A))))
              (CAR (FALSIFY (CAR X6) A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY (CAR X6) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and
DEFAULT-CAR and the :type-prescription rule NORMP.

Subgoal *1/2.7.1
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 X3 X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 X3 X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.7.1'
(IMPLIES (AND (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 X3 X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 X3 X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-137B and the :type-
prescription rule FALSIFY.

Subgoal *1/2.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (CAR (FALSIFY (CADDDR X) A)))
              (CAR (FALSIFY (A3 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A3 X) A))))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1 (FALSIFY (CADDDR X) A))))
              (CAR (FALSIFY (A3 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A3 X) A))))).

By the simple :definition A3 we reduce the conjecture to

Subgoal *1/2.5'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1 (FALSIFY (CADDDR X) A))))
              (CAR (FALSIFY (CADDDR X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (CADDDR X) A))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of six rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Use CAR-CDR-ELIM to replace
X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6 and restrict
the type of the new variable X4 to be that of the term it replaces.
(6) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X9 X10), (CAR X6)
by X9 and (CDR X6) by X10.  These steps produce the following five
goals.

Subgoal *1/2.5.5
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (CONSP (CAR X2))
              (EQUAL (CAR (CAR X2)) 'QUOTE)
              (NOT (CADR (CAR X2)))
              (NOT (PEVAL (CADDR X2)
                          (MV-NTH 1 (FALSIFY (CADDR X2) A))))
              (CAR (FALSIFY (CADDR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADDR X2) A))))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/2.5.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (NOT (PEVAL (CADR X4)
                          (MV-NTH 1 (FALSIFY (CADR X4) A))))
              (CAR (FALSIFY (CADR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CADR X4) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.5.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (NOT (PEVAL (CADR X4)
                          (MV-NTH 1 (FALSIFY (CADR X4) A))))
              (CAR (FALSIFY (CADR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CADR X4) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/2.5.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (NOT (PEVAL (CAR X6)
                          (MV-NTH 1 (FALSIFY (CAR X6) A))))
              (CAR (FALSIFY (CAR X6) A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY (CAR X6) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.5.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (NOT (PEVAL (CAR X6)
                          (MV-NTH 1 (FALSIFY (CAR X6) A))))
              (CAR (FALSIFY (CAR X6) A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY (CAR X6) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and
DEFAULT-CAR and the :type-prescription rule NORMP.

Subgoal *1/2.5.2
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) A)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.5.2'
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) A)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS, CDR-CONS and DEFAULT-CAR.

Subgoal *1/2.5.1
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X9 X10) A)
              (EQUAL X4 'QUOTE)
              (NOT X9)
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.5.1'
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X9 X10) A)
              (EQUAL X4 'QUOTE)
              (NOT X9)
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/2.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (NOT (CAR (FALSIFY (CADDDR X) A)))
              (CAR (FALSIFY (A3 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A3 X) A))))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1 (FALSIFY (CADDDR X) A))))
              (CAR (FALSIFY (A3 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A3 X) A))))).

By the simple :definition A3 we reduce the conjecture to

Subgoal *1/2.3'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CADR X) A)))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1 (FALSIFY (CADDDR X) A))))
              (CAR (FALSIFY (CADDDR X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (CADDDR X) A))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Finally, use CAR-CDR-ELIM to
replace X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6.  These
steps produce the following five goals.

Subgoal *1/2.3.5
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CAR X2) A)))
              (NOT (PEVAL (CADDR X2)
                          (MV-NTH 1 (FALSIFY (CADDR X2) A))))
              (CAR (FALSIFY (CADDR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADDR X2) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.3.5'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CAR X2) A)))
              (NOT (PEVAL (CADDR X2)
                          (MV-NTH 1 (FALSIFY (CADDR X2) A))))
              (CAR (FALSIFY (CADDR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADDR X2) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, FALSIFY, IF-EXPRP, MV-NTH, NORMP and PEVAL,
the :executable-counterparts of BINARY-+, CAR, CDR, EQUAL, IF-EXPRP,
NORMP, NOT, QUOTEP, SYMBOLP and ZP, primitive type reasoning and the
:rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/2.3.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL (CADR X4)
                          (MV-NTH 1 (FALSIFY (CADR X4) A))))
              (CAR (FALSIFY (CADR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CADR X4) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.3.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL (CADR X4)
                          (MV-NTH 1 (FALSIFY (CADR X4) A))))
              (CAR (FALSIFY (CADR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CADR X4) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/2.3.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL (CAR X6)
                          (MV-NTH 1 (FALSIFY (CAR X6) A))))
              (CAR (FALSIFY (CAR X6) A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY (CAR X6) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.3.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL (CAR X6)
                          (MV-NTH 1 (FALSIFY (CAR X6) A))))
              (CAR (FALSIFY (CAR X6) A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY (CAR X6) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and
DEFAULT-CAR and the :type-prescription rule NORMP.

Subgoal *1/2.3.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 X3 X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 X3 X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.3.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* X3 X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL X3 A)))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 X3 X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 X3 X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR and PROBLEM-137B
and the :type-prescription rule FALSIFY.

Subgoal *1/2.3.1
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) A)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) A)))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.3.1'
(IMPLIES (AND (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X6) A)
              (NOT (EQUAL X4 'QUOTE))
              (NOT (CDR (ASSOC-EQUAL (CONS X4 X6) A)))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-137B and the :type-
prescription rule FALSIFY.

Subgoal *1/2.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (CAR (FALSIFY (CADDDR X) A)))
              (CAR (FALSIFY (A3 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A3 X) A))))).

But we reduce the conjecture to T, by the simple :definition A3.

Subgoal *1/2.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1 (FALSIFY (CADDDR X) A))))
              (CAR (FALSIFY (A3 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A3 X) A))))).

By the simple :definition A3 we reduce the conjecture to

Subgoal *1/2.1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (NOT (CADR (CADR X)))
              (NOT (PEVAL (CADDDR X)
                          (MV-NTH 1 (FALSIFY (CADDDR X) A))))
              (CAR (FALSIFY (CADDDR X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (CADDDR X) A))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of six rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X6 by (CONS X7 X8),
(CAR X6) by X7 and (CDR X6) by X8.  (5) Use CAR-CDR-ELIM to replace
X3 by (CONS X4 X6), (CAR X3) by X4 and (CDR X3) by X6 and restrict
the type of the new variable X4 to be that of the term it replaces.
(6) Finally, use CAR-CDR-ELIM to replace X6 by (CONS X9 X10), (CAR X6)
by X9 and (CDR X6) by X10.  These steps produce the following five
goals.

Subgoal *1/2.1.5
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (CONSP (CAR X2))
              (EQUAL (CAR (CAR X2)) 'QUOTE)
              (NOT (CADR (CAR X2)))
              (NOT (PEVAL (CADDR X2)
                          (MV-NTH 1 (FALSIFY (CADDR X2) A))))
              (CAR (FALSIFY (CADDR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADDR X2) A))))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/2.1.4
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (NOT (PEVAL (CADR X4)
                          (MV-NTH 1 (FALSIFY (CADR X4) A))))
              (CAR (FALSIFY (CADR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CADR X4) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.1.4'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (NOT (PEVAL (CADR X4)
                          (MV-NTH 1 (FALSIFY (CADR X4) A))))
              (CAR (FALSIFY (CADR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CADR X4) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/2.1.3
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (NOT (PEVAL (CAR X6)
                          (MV-NTH 1 (FALSIFY (CAR X6) A))))
              (CAR (FALSIFY (CAR X6) A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY (CAR X6) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.1.3'
(IMPLIES (AND (NOT (CONSP X6))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (NOT (CADR X3))
              (NOT (PEVAL (CAR X6)
                          (MV-NTH 1 (FALSIFY (CAR X6) A))))
              (CAR (FALSIFY (CAR X6) A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY (CAR X6) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning, the :rewrite rules CAR-CONS, CDR-CONS and
DEFAULT-CAR and the :type-prescription rule NORMP.

Subgoal *1/2.1.2
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.1.2'
(IMPLIES (AND (NOT (CONSP X6))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (CONS X4 X6))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (CONS X4 X6) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (CONS X4 X6) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT (CAR X6))
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (CONS X4 X6) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X6) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS, CDR-CONS and DEFAULT-CAR.

Subgoal *1/2.1.1
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT X9)
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/2.1.1'
(IMPLIES (AND (CONSP (CONS X9 X10))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONSP (LIST* X4 X9 X10))
              (CONSP (CONS X7 X8))
              (CONSP (LIST* X5 X7 X8))
              (CONSP (LIST* (LIST* X4 X9 X10) X5 X7 X8))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (NOT X9)
              (NOT (PEVAL X7 (MV-NTH 1 (FALSIFY X7 A))))
              (CAR (FALSIFY X7 A))
              (NORMP (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)))
         (NOT (PEVAL (LIST* X1 (LIST* X4 X9 X10) X5 X7 X8)
                     (MV-NTH 1 (FALSIFY X7 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1
(IMPLIES (AND (IF-EXPRP X)
              (ASSIGNEDP (A1 X) A)
              (ASSIGNMENT (A1 X) A)
              (IMPLIES (AND (MV-NTH 0 (FALSIFY (A2 X) A))
                            (NORMP (A2 X)))
                       (NOT (PEVAL (A2 X)
                                   (MV-NTH 1 (FALSIFY (A2 X) A))))))
         (IMPLIES (AND (MV-NTH 0 (FALSIFY X A)) (NORMP X))
                  (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A)))))).

By the simple :definitions A1, A2 and IF-EXPRP we reduce the conjecture
to

Subgoal *1/1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSIGNEDP (CADR X) A)
              (ASSIGNMENT (CADR X) A)
              (IMPLIES (AND (MV-NTH 0 (FALSIFY (CADDR X) A))
                            (NORMP (CADDR X)))
                       (NOT (PEVAL (CADDR X)
                                   (MV-NTH 1 (FALSIFY (CADDR X) A)))))
              (MV-NTH 0 (FALSIFY X A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY X A))))).

This simplifies, using the :definitions A1, A2, ASSIGNEDP (if-intro),
ASSIGNMENT (if-intro), FALSIFY, IF-EXPRP (if-intro), MV-NTH, NORMP,
NOT (if-intro) and QUOTEP (if-intro), the :executable-counterparts
of EQUAL and ZP and the :type-prescription rule FALSIFY, to the following
eight conjectures.

Subgoal *1/1.8
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (CAR (FALSIFY (A2 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A2 X) A))))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.7
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1 (FALSIFY (CADDR X) A))))
              (CAR (FALSIFY (A2 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A2 X) A))))).

By the simple :definition A2 we reduce the conjecture to

Subgoal *1/1.7'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (CONSP (CADR X)))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1 (FALSIFY (CADDR X) A))))
              (CAR (FALSIFY (CADDR X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (CADDR X) A))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of three rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Finally, use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by
X5 and (CDR X4) by X6.  These steps produce the following three goals.

Subgoal *1/1.7.3
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (CONSP (CAR X2)))
              (CDR (ASSOC-EQUAL (CAR X2) A))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1 (FALSIFY (CADR X2) A))))
              (CAR (FALSIFY (CADR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADR X2) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.7.3'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (CONSP (CAR X2)))
              (CDR (ASSOC-EQUAL (CAR X2) A))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1 (FALSIFY (CADR X2) A))))
              (CAR (FALSIFY (CADR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADR X2) A))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT and FALSIFY, the :executable-counterparts of CAR, CONSP,
EQUAL, IF-EXPRP, MV-NTH, NOT, PEVAL, QUOTEP and SYMBOLP, primitive
type reasoning and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/1.7.2
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 A))
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1 (FALSIFY (CAR X4) A))))
              (CAR (FALSIFY (CAR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CAR X4) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.7.2'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 A))
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1 (FALSIFY (CAR X4) A))))
              (CAR (FALSIFY (CAR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CAR X4) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/1.7.1
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 A))
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.7.1'
(IMPLIES (AND (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (CONSP X3))
              (CDR (ASSOC-EQUAL X3 A))
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-137B and the :type-
prescription rule FALSIFY.

Subgoal *1/1.6
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (CAR (FALSIFY (A2 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A2 X) A))))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.5
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1 (FALSIFY (CADDR X) A))))
              (CAR (FALSIFY (A2 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A2 X) A))))).

By the simple :definition A2 we reduce the conjecture to

Subgoal *1/1.5'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1 (FALSIFY (CADDR X) A))))
              (CAR (FALSIFY (CADDR X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (CADDR X) A))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7 and restrict the types of the new
variables X4 and X7 to be those of the terms they replace.  (5) Finally,
use CAR-CDR-ELIM to replace X7 by (CONS X8 X9), (CAR X7) by X8 and
(CDR X7) by X9.  These steps produce the following four goals.

Subgoal *1/1.5.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (CONSP (CAR X2))
              (EQUAL (CAR (CAR X2)) 'QUOTE)
              (CADR (CAR X2))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1 (FALSIFY (CADR X2) A))))
              (CAR (FALSIFY (CADR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADR X2) A))))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/1.5.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3)
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1 (FALSIFY (CAR X4) A))))
              (CAR (FALSIFY (CAR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CAR X4) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.5.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3)
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1 (FALSIFY (CAR X4) A))))
              (CAR (FALSIFY (CAR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CAR X4) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/1.5.2
(IMPLIES (AND (NOT (CONSP X7))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              X7 (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X7) A)
              (EQUAL X4 'QUOTE)
              (CAR X7)
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 (CONS X4 X7) X5 X6)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/1.5.1
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X8 X9) A)
              (EQUAL X4 'QUOTE)
              X8
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 (LIST* X4 X8 X9) X5 X6)))
         (NOT (PEVAL (LIST* X1 (LIST* X4 X8 X9) X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.5.1'
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (LIST* X4 X8 X9) A)
              (EQUAL X4 'QUOTE)
              X8
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 (LIST* X4 X8 X9) X5 X6)))
         (NOT (PEVAL (LIST* X1 (LIST* X4 X8 X9) X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

Subgoal *1/1.4
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (CAR (FALSIFY (A2 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A2 X) A))))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.3
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1 (FALSIFY (CADDR X) A))))
              (CAR (FALSIFY (A2 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A2 X) A))))).

By the simple :definition A2 we reduce the conjecture to

Subgoal *1/1.3'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (ASSOC-EQUAL (CADR X) A)
              (NOT (EQUAL (CAR (CADR X)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CADR X) A))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1 (FALSIFY (CADDR X) A))))
              (CAR (FALSIFY (CADDR X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (CADDR X) A))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of four rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Finally, use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7.  These steps produce the following
four goals.

Subgoal *1/1.3.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CAR X2) A))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1 (FALSIFY (CADR X2) A))))
              (CAR (FALSIFY (CADR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADR X2) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.3.4'
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CAR X2) A)
              (NOT (EQUAL (CAR (CAR X2)) 'QUOTE))
              (CDR (ASSOC-EQUAL (CAR X2) A))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1 (FALSIFY (CADR X2) A))))
              (CAR (FALSIFY (CADR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADR X2) A))))).

But simplification reduces this to T, using the :definitions ASSIGNEDP,
ASSIGNMENT and FALSIFY, the :executable-counterparts of CAR, EQUAL,
IF-EXPRP, MV-NTH, NOT, PEVAL, QUOTEP and SYMBOLP, primitive type reasoning
and the :rewrite rules DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/1.3.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 A))
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1 (FALSIFY (CAR X4) A))))
              (CAR (FALSIFY (CAR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CAR X4) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.3.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 A))
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1 (FALSIFY (CAR X4) A))))
              (CAR (FALSIFY (CAR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CAR X4) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/1.3.2
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 A))
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.3.2'
(IMPLIES (AND (NOT (CONSP X3))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* X3 X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL X3 A)
              (NOT (EQUAL (CAR X3) 'QUOTE))
              (CDR (ASSOC-EQUAL X3 A))
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 X3 X5 X6)))
         (NOT (PEVAL (LIST* X1 X3 X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS, DEFAULT-CAR and PROBLEM-137B
and the :type-prescription rule FALSIFY.

Subgoal *1/1.3.1
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X7) A)
              (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) A))
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 (CONS X4 X7) X5 X6)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.3.1'
(IMPLIES (AND (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (ASSOC-EQUAL (CONS X4 X7) A)
              (NOT (EQUAL X4 'QUOTE))
              (CDR (ASSOC-EQUAL (CONS X4 X7) A))
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 (CONS X4 X7) X5 X6)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, MV-NTH, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT, SYMBOLP and ZP, primitive type reasoning,
the :rewrite rules CAR-CONS, CDR-CONS and PROBLEM-137B and the :type-
prescription rule FALSIFY.

Subgoal *1/1.2
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (CAR (FALSIFY (CADDR X) A)))
              (CAR (FALSIFY (A2 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A2 X) A))))).

But we reduce the conjecture to T, by the simple :definition A2.

Subgoal *1/1.1
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1 (FALSIFY (CADDR X) A))))
              (CAR (FALSIFY (A2 X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (A2 X) A))))).

By the simple :definition A2 we reduce the conjecture to

Subgoal *1/1.1'
(IMPLIES (AND (CONSP X)
              (EQUAL (CAR X) 'IF)
              (CONSP (CADR X))
              (EQUAL (CAR (CADR X)) 'QUOTE)
              (CADR (CADR X))
              (NOT (PEVAL (CADDR X)
                          (MV-NTH 1 (FALSIFY (CADDR X) A))))
              (CAR (FALSIFY (CADDR X) A))
              (NORMP X))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (CADDR X) A))))).

The destructor terms (CAR X) and (CDR X) can be eliminated.  Furthermore,
those terms are at the root of a chain of five rounds of destructor
elimination.  (1) Use CAR-CDR-ELIM to replace X by (CONS X1 X2), (CAR X)
by X1 and (CDR X) by X2 and restrict the type of the new variable X1
to be that of the term it replaces.  (2) Use CAR-CDR-ELIM, again, to
replace X2 by (CONS X3 X4), (CAR X2) by X3 and (CDR X2) by X4.  (3)
Use CAR-CDR-ELIM to replace X4 by (CONS X5 X6), (CAR X4) by X5 and
(CDR X4) by X6.  (4) Use CAR-CDR-ELIM to replace X3 by (CONS X4 X7),
(CAR X3) by X4 and (CDR X3) by X7 and restrict the types of the new
variables X4 and X7 to be those of the terms they replace.  (5) Finally,
use CAR-CDR-ELIM to replace X7 by (CONS X8 X9), (CAR X7) by X8 and
(CDR X7) by X9.  These steps produce the following four goals.

Subgoal *1/1.1.4
(IMPLIES (AND (NOT (CONSP X2))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (CONS X1 X2))
              (EQUAL X1 'IF)
              (CONSP (CAR X2))
              (EQUAL (CAR (CAR X2)) 'QUOTE)
              (CADR (CAR X2))
              (NOT (PEVAL (CADR X2)
                          (MV-NTH 1 (FALSIFY (CADR X2) A))))
              (CAR (FALSIFY (CADR X2) A))
              (NORMP (CONS X1 X2)))
         (NOT (PEVAL (CONS X1 X2)
                     (MV-NTH 1 (FALSIFY (CADR X2) A))))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/1.1.3
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3)
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1 (FALSIFY (CAR X4) A))))
              (CAR (FALSIFY (CAR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CAR X4) A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.1.3'
(IMPLIES (AND (NOT (CONSP X4))
              (CONSP (CONS X3 X4))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1 (CONSP (LIST* X1 X3 X4))
              (EQUAL X1 'IF)
              (CONSP X3)
              (EQUAL (CAR X3) 'QUOTE)
              (CADR X3)
              (NOT (PEVAL (CAR X4)
                          (MV-NTH 1 (FALSIFY (CAR X4) A))))
              (CAR (FALSIFY (CAR X4) A))
              (NORMP (LIST* X1 X3 X4)))
         (NOT (PEVAL (LIST* X1 X3 X4)
                     (MV-NTH 1 (FALSIFY (CAR X4) A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNEDP, ASSIGNMENT, ASSOC-EQUAL, ASSUME-FALSE, FALSIFY, IF-EXPRP,
MV-NTH, NORMP and PEVAL, the :executable-counterparts of BINARY-+,
CAR, CDR, CONS, EQUAL, IF-EXPRP, NORMP, NOT, QUOTEP, SYMBOLP and ZP,
primitive type reasoning and the :rewrite rules CAR-CONS, CDR-CONS,
DEFAULT-CAR and DEFAULT-CDR.

Subgoal *1/1.1.2
(IMPLIES (AND (NOT (CONSP X7))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              X7 (CONSP (CONS X4 X7))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (CONS X4 X7) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (CONS X4 X7) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              (CAR X7)
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 (CONS X4 X7) X5 X6)))
         (NOT (PEVAL (LIST* X1 (CONS X4 X7) X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

But we reduce the conjecture to T, by case analysis.

Subgoal *1/1.1.1
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              (NOT (EQUAL X4 NIL))
              (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              (NOT (EQUAL X1 NIL))
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              X8
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 (LIST* X4 X8 X9) X5 X6)))
         (NOT (PEVAL (LIST* X1 (LIST* X4 X8 X9) X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

By case analysis we reduce the conjecture to

Subgoal *1/1.1.1'
(IMPLIES (AND (CONSP (CONS X8 X9))
              (SYMBOLP X4)
              (NOT (EQUAL X4 T))
              X4 (CONS X8 X9)
              (CONSP (LIST* X4 X8 X9))
              (CONSP (CONS X5 X6))
              (CONSP (LIST* (LIST* X4 X8 X9) X5 X6))
              (SYMBOLP X1)
              (NOT (EQUAL X1 T))
              X1
              (CONSP (LIST* X1 (LIST* X4 X8 X9) X5 X6))
              (EQUAL X1 'IF)
              (EQUAL X4 'QUOTE)
              X8
              (NOT (PEVAL X5 (MV-NTH 1 (FALSIFY X5 A))))
              (CAR (FALSIFY X5 A))
              (NORMP (LIST* X1 (LIST* X4 X8 X9) X5 X6)))
         (NOT (PEVAL (LIST* X1 (LIST* X4 X8 X9) X5 X6)
                     (MV-NTH 1 (FALSIFY X5 A))))).

But simplification reduces this to T, using the :definitions A1, A2,
A3, ASSIGNMENT, IF-EXPRP, NORMP, PEVAL and QUOTEP, the :executable-
counterparts of EQUAL, NOT and SYMBOLP, primitive type reasoning and
the :rewrite rules CAR-CONS and CDR-CONS.

That completes the proof of *1.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-137C ...)
Rules: ((:DEFINITION A1)
        (:DEFINITION A2)
        (:DEFINITION A3)
        (:DEFINITION ASSIGNEDP)
        (:DEFINITION ASSIGNMENT)
        (:DEFINITION ASSOC-EQUAL)
        (:DEFINITION ASSUME-FALSE)
        (:DEFINITION ASSUME-TRUE)
        (:DEFINITION FALSIFY)
        (:DEFINITION IF-EXPRP)
        (:DEFINITION MV-NTH)
        (:DEFINITION NORMP)
        (:DEFINITION NOT)
        (:DEFINITION PEVAL)
        (:DEFINITION QUOTEP)
        (:ELIM CAR-CDR-ELIM)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART CAR)
        (:EXECUTABLE-COUNTERPART CDR)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART CONSP)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART IF-EXPRP)
        (:EXECUTABLE-COUNTERPART MV-NTH)
        (:EXECUTABLE-COUNTERPART NORMP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART PEVAL)
        (:EXECUTABLE-COUNTERPART QUOTEP)
        (:EXECUTABLE-COUNTERPART SYMBOLP)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION FALSIFY)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE DEFAULT-CAR)
        (:REWRITE DEFAULT-CDR)
        (:REWRITE PROBLEM-137B)
        (:TYPE-PRESCRIPTION FALSIFY)
        (:TYPE-PRESCRIPTION NORMP))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ASSIGNEDP)
             (:DEFINITION ASSIGNMENT)
             (:DEFINITION FALSIFY)
             (:DEFINITION IF-EXPRP)
             (:DEFINITION MV-NTH)
             (:DEFINITION NORMP)
             (:DEFINITION NOT)
             (:DEFINITION QUOTEP))
PROBLEM-137C


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-137C))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-137C)
PROBLEM-137C

Summary
Form:  ( PROGN (DEFTHM PROBLEM-137C ...) ...)
Rules: NIL
 PROBLEM-137C
ACL2 !>>(THEOREM
          PROBLEM-137
          (IMPLIES (NOT (TAUTOLOGY-CHECKER X))
                   (NOT (PEVAL X (FALSIFYING-ALIST X))))
          :HINTS
          (("Goal" :IN-THEORY (ENABLE PROBLEM-136D PROBLEM-136E PROBLEM-137A)
                   :USE (:INSTANCE PROBLEM-137C (A NIL)
                                   (X (NORM X))))))


ACL2 !>>>(DEFTHM PROBLEM-137
          (IMPLIES (NOT (TAUTOLOGY-CHECKER X))
                   (NOT (PEVAL X (FALSIFYING-ALIST X))))
          :HINTS
          (("Goal" :DO-NOT-INDUCT T
                   :DO-NOT '(GENERALIZE)
                   :IN-THEORY (ENABLE PROBLEM-136D PROBLEM-136E PROBLEM-137A)
                   :USE (:INSTANCE PROBLEM-137C (A NIL)
                                   (X (NORM X))))))

ACL2 Warning [Non-rec] in ( DEFTHM PROBLEM-137 ...):  A :REWRITE rule
generated from PROBLEM-137 will be triggered only by terms containing
the function symbol FALSIFYING-ALIST, which has a non-recursive definition.
Unless this definition is disabled, this rule is unlikely ever to be
used.


[Note:  A hint was supplied for the goal above.  Thanks!]

We augment the goal with the hypothesis provided by the :USE hint.
The hypothesis can be derived from PROBLEM-137C via instantiation.
We are left with the following subgoal.

Goal'
(IMPLIES (IMPLIES (AND (MV-NTH 0 (FALSIFY (NORM X) NIL))
                       (NORMP (NORM X)))
                  (NOT (PEVAL (NORM X)
                              (MV-NTH 1 (FALSIFY (NORM X) NIL)))))
         (IMPLIES (NOT (TAUTOLOGY-CHECKER X))
                  (NOT (PEVAL X (FALSIFYING-ALIST X))))).

By the simple :definitions FALSIFYING-ALIST and TAUTOLOGY-CHECKER and
the simple :rewrite rules PROBLEM-136D and PROBLEM-136E we reduce the
conjecture to

Goal''
(IMPLIES (AND (IMPLIES (AND (MV-NTH 0 (FALSIFY (NORM X) NIL))
                            T)
                       (NOT (PEVAL X (MV-NTH 1 (FALSIFY (NORM X) NIL)))))
              (NOT (TAUTP (NORM X) NIL)))
         (NOT (PEVAL X (MV-NTH 1 (FALSIFY (NORM X) NIL))))).

But simplification reduces this to T, using the :congruence rule 
IFF-IMPLIES-EQUAL-NOT, the :executable-counterpart of NOT and the :rewrite
rules PROBLEM-136D and PROBLEM-137A.

Q.E.D.

Summary
Form:  ( DEFTHM PROBLEM-137 ...)
Rules: ((:CONGRUENCE IFF-IMPLIES-EQUAL-NOT)
        (:DEFINITION FALSIFYING-ALIST)
        (:DEFINITION NOT)
        (:DEFINITION TAUTOLOGY-CHECKER)
        (:EXECUTABLE-COUNTERPART NOT)
        (:REWRITE PROBLEM-136D)
        (:REWRITE PROBLEM-136E)
        (:REWRITE PROBLEM-137A))
Hint-events: ((:USE PROBLEM-137C))
Warnings:  Non-rec
PROBLEM-137


ACL2 !>>>(IN-THEORY (DISABLE PROBLEM-137))

Summary
Form:  ( IN-THEORY (DISABLE ...))
Rules: NIL
:CURRENT-THEORY-UPDATED


ACL2 !>>>(VALUE-TRIPLE 'PROBLEM-137)
PROBLEM-137

Summary
Form:  ( PROGN (DEFTHM PROBLEM-137 ...) ...)
Rules: NIL
Warnings:  Non-rec
 PROBLEM-137
ACL2 !>>Bye.
