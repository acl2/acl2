(boot-strap nqthm)

;;; requires 17 minutes to prove-file on a 300MHZ Pentium II.

;;; Should look carefully at including extra lemmas for situations in which
;;; automatic disabling is used.  Many of the present lemmas assume normal
;;; forms which are only present when "canonical" lemmas are not disabled.

;;; This file contains a modular arithmetic library for nqthm-1992.  Lemmas
;;; within this file fall into two classes:  those commented "canonical,"
;;; which rewrite expressions to canonical form; and those uncommented, which
;;; simplify expressions already in canonical form.  A nesting order for
;;; function calls is established, and rewrite rules are provided which
;;; rewrite out of order expressions into the established nesting order.
;;; Because opening a function definition in effect behaves as a rewrite rule,
;;; the nesting order is constrained by existing function definitions.
;;; For example,

;;;      (plus x y) = (if (zerop x)
;;;                       (fix y)
;;;                       (add1 (plus (sub1 x) y)))

;;; places add1 outside of plus, and sub1 inside of plus.  Thus the nesting
;;; order must place add1, plus and sub1 in that order.  Among all orders
;;; satisfying these constraints, we choose the following:

;;; add1 plus times remainder quotient difference sub1

;;; Since nqthm applies lemmas in reverse chronological order, we place the
;;; more costly rules early in this file.

;;; The following lemma is costly, because as a linear rule it is applied
;;; before (remainder a b) is simplified.  Thus (remainder a b) is simplified
;;; twice for remainder-lessp-linear, and then again each time it occurs
;;; within the target formula.

(prove-lemma remainder-lessp-linear (rewrite)
  (and (implies (and (numberp b)
                     (not (equal b 0)))
                (lessp (remainder a b) b))
       (not (lessp a (remainder a b)))))

;;; canonical

(prove-lemma times-add1 (rewrite)
  (and (equal (times a (add1 b))
              (plus a (times a b)))
       (equal (times (add1 a) b)
              (plus b (times a b)))))

(prove-lemma times-zerop (rewrite)
  (implies (not (numberp b))
           (equal (times a b) 0)))

(prove-lemma times-0 (rewrite)
  (and (equal (times a 0) 0)
       (equal (times 0 a) 0)))

;;; We begin by removing times, remainder and quotient from within difference.

(prove-lemma quotient-remainder (elim)
  (implies (and (numberp a)
; do not eliminate destructors when b is 0
                (numberp b)
                (not (equal b 0)))
           (equal (plus (remainder a b)
                        (times b (quotient a b)))
                  a)))

(prove-lemma quotient-remainder-generalize (generalize)
  (implies (and (numberp b)
                (not (equal b 0)))
           (lessp (remainder a b) b)))

;;; We omit the commutative version because it will not occur after
;;; plus-commutes-meta is proven.

(prove-lemma quotient-remainder-rewrite (rewrite)
  (equal (plus (remainder a b)
               (times b (quotient a b)))
         (if (numberp a) a 0)))


(defn diff-times-ind (a b c)
  (if (lessp c a)
      0
    (if (zerop b)
        0
      (diff-times-ind a (sub1 b) (difference c a)))))

;;; canonical

;;; The following rule introduces (quotient c a) and (remainder c a) in cases
;;; where destructor elimination may not apply.  For this reason its
;;; application is discouraged by making the rule conditional on c < a*b.

(prove-lemma difference-times-arg1 (rewrite)
  (implies (lessp c (times a b))
           (equal (difference (times a b) c)
                  (plus (difference a (remainder c a))
                        (times a (difference
                                  (sub1 b)
                                  (quotient c a))))))
  ((induct (diff-times-ind a b c))))

(defn diff-times-1 (a)
  (if (and (equal (car a) 'difference)
           (equal (caadr a) 'times)
           (litatom (caddr a)))
      `(if (lessp ,(caddr a) ,(cadr a))
           (plus (difference ,(cadadr a) (remainder ,(caddr a) ,(cadadr a)))
                 (times ,(cadadr a)
                        (difference (sub1 ,(caddadr a))
                                    (quotient ,(caddr a) ,(cadadr a)))))
         (zero))
    a))

(prove-lemma difference-not-lessp (rewrite)
  (implies (not (lessp a b))
           (equal (difference b a) 0)))

;;; The following meta rule rewrites a*b - c only in cases where c is a litatom.
;;; This assures that (quotient c a) and (remainder c a) will eventually be
;;; candidates for destructor elimination.

;;; canonical

(prove-lemma difference-times-arg1-meta ((meta difference))
  (equal (eval$ t a y)
         (eval$ t (diff-times-1 a) y)))

;;; canonical

(prove-lemma difference-times-arg1-simpler (rewrite)
  (implies (and (lessp c (plus a b))
                (numberp a)
                (not (equal a 0))
                (numberp b)
                (not (equal b 0))
                (numberp c)
                (not (equal c 0)))
           (equal (difference (times a b) c)
                  (if (lessp (sub1 a) (sub1 c))
                      (plus (difference (sub1 b)
                                        (difference (sub1 c)
                                                    (sub1 a)))
                            (times (sub1 a) (sub1 b)))
                    (plus (sub1 b)
                          (difference (sub1 a) (sub1 c))
                          (times (sub1 a) (sub1 b)))))))

;;; canonical

(prove-lemma difference-times-arg1-simplest (rewrite)
  (implies (and (not (lessp b c))
                (numberp a)  ; to avoid forced expansion
                (not (equal a 0))) ; of times
           (and
            (equal (difference (times a b) c)
                   (plus (difference b c) (times b (sub1 a))))
            (equal (difference (times b a) c)
                   (plus (difference b c) (times b (sub1 a)))))))

;;; canonical

(prove-lemma times-commutes (rewrite)
  (equal (times a b)
         (times b a)))

;;; The following two lemmas will be disabled after they are replaced by
;;; the permutative meta rules for plus and difference.

(prove-lemma plus-commutes (rewrite)
  (equal (plus a b)
         (plus b a)))

(prove-lemma plus-commutes-nest (rewrite)
  (equal (plus a (plus b c))
         (plus b (plus a c))))

(prove-lemma difference-times-arg1-kb (rewrite)
  (implies (and (equal (remainder c b) 0)
                (lessp c (times a b)))
           (and
            (equal (plus (difference a (remainder c a))
                         (times a (difference (sub1 b)
                                              (quotient c a))))
                   (plus b
                         (times b (difference (sub1 a)
                                              (quotient c b)))))
            (equal (plus (difference a (remainder c a))
                         (difference (sub1 b) (quotient c a))
                         (times (sub1 a)
                                (difference (sub1 b)
                                            (quotient c a))))
                   (plus b
                         (times b (difference (sub1 a)
                                              (quotient c b)))))
            (equal (plus (difference (sub1 b) (quotient c a))
                         (difference a (remainder c a))
                         (times (sub1 a)
                                (difference (sub1 b)
                                            (quotient c a))))
                   (plus b
                         (times b (difference (sub1 a)
                                              (quotient c b)))))))
  ((use (difference-times-arg1 (a a) (b b) (c c))
        (difference-times-arg1 (a b) (b a) (c c)))
   (disable difference-times-arg1)))

;;; canonical

;;; We make this conditional because rewriting the right hand side is costly.

(prove-lemma difference-times-arg2 (rewrite)
  (implies (not (lessp c (times b a)))
           (equal (difference c (times b a))
                  (plus (remainder c b)
                        (times b (difference (quotient c b) a)))))
  ((induct (diff-times-ind b a c))))

;;; canonical

(prove-lemma difference-times-arg2-preferred (rewrite)
  (implies (and (equal (remainder c a) 0)
                (not (lessp c (times b a))))
           (equal (difference c (times b a))
                  (times a (difference (quotient c a) b))))
  ((use (difference-times-arg2 (a a) (b b) (c c))
        (difference-times-arg2 (a b) (b a) (c c)))
   (disable difference-times-arg2)))

;;; canonical (preferred)

(prove-lemma difference-times-arg1-arg2 (rewrite)
  (and
   (equal (difference (times c a) (times c b))
          (times c (difference a b)))
   (equal (difference (times a c) (times c b))
          (times c (difference a b)))
   (equal (difference (times c a) (times b c))
          (times c (difference a b)))
   (equal (difference (times a c) (times b c))
          (times c (difference a b))))
  ((induct (difference a b))
   (disable difference-times-arg1-simplest
            difference-times-arg2
            difference-times-arg2-preferred
            difference-times-arg1-simpler
            plus-commutes
            plus-commutes-nest
            difference-times-arg1)))

;;; canonical

(prove-lemma sub1-difference (rewrite)
  (equal (sub1 (difference a b))
         (difference (sub1 a) b)))

;;; In the following lemma, we choose (lessp a b) rather than (not (lessp b a))
;;; so that the hypothesis of the rewrite rule is more likely to reduce to
;;; true or false.  Consider the case where (difference a b) is introduced by
;;; expanding (remainder a b) or (quotient a b).  In both cases the occurrence
;;; of (difference a b) is governed by the predicate (lessp a b).  So we adopt
;;; the policy of favoring (lessp a b) over (lessp b a) whenever b occurs as a
;;; subtrahend.  This same policy when applied to terms introduced on the right
;;; hand side of unconditional rewrite rules encourages function expansion,
;;; since it introduces terms which are likely to be already present
;;; in the term structure of the conjecture being proven.

(prove-lemma difference-lessp (rewrite)
  (implies (lessp a b)
           (equal (difference a b) 0)))

;;; canonical

(prove-lemma sub1-remainder (rewrite)
  (equal (sub1 (remainder a b))
         (if (equal (remainder a b) 0)
             0
           (remainder (sub1 a) b))))

;;; canonical

(prove-lemma difference-remainder-arg1 (rewrite)
  (equal (difference (remainder a c) b)
         (if (lessp (remainder a c) b)
             0
           (remainder (difference a b) c)))
  ((induct (difference a b))))

;;; canonical

(prove-lemma difference-remainder-arg2 (rewrite)
  (implies (not (lessp b a))
           (equal (difference b (remainder a c))
                  (plus (difference b a)
                        (times c (quotient a c))))))

(defn lessp-quotient-ind (a b c)
  (if (zerop c)
      0
    (if (lessp b c)
        0
      (if (lessp a c)
          0
        (lessp-quotient-ind (difference a c) (difference b c) c)))))

;;; lessp-quotient will eventually mask this rule.

(prove-lemma lessp-quotient-arg1-linear (rewrite)
  (and (implies (not (lessp b a))
                (not (lessp (quotient b c)
                            (quotient a c))))
       (implies (lessp a b)
                (not (lessp (quotient b c)
                            (quotient a c)))))
  ((induct (lessp-quotient-ind a b c))))

;;; aka "min(a,b)"

(prove-lemma difference-difference-cancellation (rewrite)
  (equal (difference b (difference b a))
         (if (and (numberp a)
                  (numberp b))
             (if (lessp a b)
                 a
               b)
           0)))

;;; difference-elim is useful in situations where quotient-remainder
;;; will not apply because the first argument of quotient and remainder is a
;;; difference.

(prove-lemma difference-elim (elim)
  (implies (lessp b a)
           (equal (plus b (difference a b)) a)))

(prove-lemma difference-generalize (generalize)
  (and (numberp (difference a b))
       (not (lessp a (difference a b)))))

;;; Assuming (plus a b) is normalized, a is lexicographically smaller than
;;; b.  In order to minimize the likelihood of introducing costly inversions
;;; on the right hand side of this rule, we choose to place a within lessp
;;; and difference, when given a choice between a and b.  We use (lessp a c)
;;; rather than (not (lessp c a)) because (difference (plus a b) 0) will not
;;; otherwise immediately simplify.

;;; canonical

(prove-lemma difference-plus-arg1 (rewrite)
  (equal (difference (plus a b) c) ; a is lex smaller than b
         (if (lessp a c)
             (difference b (difference c a)) ; move smaller in
           (plus (difference a c) b))))      ; b could be plus nest

#|
;;; This version of difference-plus-arg1 avoids the case split on (lessp a c)
;;; but in practice did not perform as well as the more aggressive version.

;;; canonical

(prove-lemma difference-plus-arg1 (rewrite)
  (equal (difference (plus a b) c)
         (plus (difference b c)
               (difference a (difference c b)))))

|#
;;; We avoid the more natural equivalence (equal (difference a b) 0) iff
;;; (not (lessp b a)) in order to encourage the opening of functions such as
;;; (quotient a b) and (remainder a b).  Another way to rationalize this, is
;;; that if (difference a b) is already present, then (not (lessp a b)) is
;;; also likely to be present.  Thus (lessp a b) will be eliminated, and
;;; we will have new equality facts about a.

(prove-lemma difference-0 (rewrite)
  (equal (equal (difference a b) 0)
         (or (not (numberp a))
             (equal a 0)
             (equal a b)
             (lessp a b))))

(prove-lemma difference-difference-arg1-commutes (rewrite)
  (equal (difference (difference a b) c)
         (difference (difference a c) b)))

;;; This lemma is dangerous since it rewrites a potentially numerically
;;; smaller argument to a larger one.
;;; quotient-difference-arg1 can force expansion of quotient.  For example,
;;; consider (quotient a (add1 b)).

(prove-lemma quotient-difference-arg1 (rewrite)
  (implies (lessp c b)
           (equal (quotient (difference a c) b)
                  (if (lessp (remainder a b) c)
                      (quotient (difference a b) b)
                    (quotient a b))))
  ((induct (remainder a b))))

(prove-lemma difference-difference-difference-cancellation (rewrite)
  (and (equal (difference (difference b a) (difference c a))
              (if (lessp b a)
                  0
                (if (lessp c a)
                    (difference b a)
                  (difference b c))))
       (equal (difference (difference a b) (difference a c))
              (if (lessp a b)
                  0
                (if (lessp a c)
                    (difference a b)
                  (difference c b))))))

;;; Consider replacing (lessp (remainder b a) (remainder c a) by
;;; (lessp (plus b (times a (quotient c a)))
;;;        (plus c (times a (quotient b a))))

;;; canonical (qbca avoids repeated rewriting)

(prove-lemma difference-quotient-arg1-arg2 (rewrite)
  (implies (equal qbca (quotient (difference b c) a))
           (equal (difference (quotient b a) (quotient c a))
                  (if (lessp b c)
                      0
                    (if (lessp (remainder b a) (remainder c a))
                        (add1 qbca)
                      qbca))))
  ((induct (lessp-quotient-ind b c a))))

;;; The goal of this library is to reduce the "entropy" of symbolic
;;; expressions, that is the number of ways that a canonical object in the
;;; logic may be expressed.  The expressions b + (a - c) and a + (b - c)
;;; are equal, provided a >= c and b >= c.  This suggests a conditional
;;; permutative rule.  However, such a rule would convert the normalized
;;; expression (plus (times x y) (difference a (difference b c))) to
;;; (plus a (difference (times x y) (difference b c))).  This problem
;;; arises because nqthm's term order does not obey our function
;;; nesting conventions.  So we create our own term order, and represent
;;; permutative rules on difference and plus by meta rules.  This approach
;;; does not work when the permutative rule compares two "non-tame" function
;;; applications (e.g. EVAL$), since nqthm replaces non-tame functions by
;;; variable symbols before applying the meta rule.  For this reason we retain
;;; (disabled) versions of several permutative rewrite rules, notably
;;; plus-commutes and plus-commutes-nest.

;;; Compare two exploded litatoms.
;;; lit-ord returns true iff a is strictly less than b.

(defn lit-ord (a b)
  (if (listp a)
      (if (listp b)
          (or (lessp (car a) (car b))
              (and (equal (car a) (car b))
                   (lit-ord (cdr a) (cdr b))))
        f)
    (if (listp b)
        t
      (lessp a b))))

;;; There is a problem with permutative meta rules when applied to non-tame
;;; terms.  nqthm replaces the non-tame term with a tame one by substituting
;;; new variables for the non-tame subterms.  It does this before applying
;;; the body of the meta rule.  This makes any syntactic checks based upon
;;; the specific structure of a subterm ineffective.  We provide an
;;; implementation specific solution by treating all variables beginning
;;; with vvv- as placeholders for non-tame terms.  We place vvv- at the
;;; upper end of the term order, and return f whenever the result depends
;;; on comparing two variables beginning with vvv-.

;;; Test whether an exploded litatom is a placeholder for a non-tame term.

(defn wild (a)
  (and (equal (car a) 86)
       (equal (cadr a) 86)
       (equal (caddr a) 86)
       (equal (cadddr a) 45)))

;;; Count the number of cons's within a.

(defn size (a)
  (if (listp a)
      (add1 (plus (size (car a)) (size (cdr a))))
    0))

(defn fcn-idx (a)
  (cond ((equal a 'plus) 6)
        ((equal a 'times) 5)
        ((equal a 'difference) 1)
        ((equal a 'add1) 7)
        ((equal a 'sub1) 0)
        ((equal a 'remainder) 3)
        ((equal a 'quotient) 2)
        ((equal a 'exp) 4)
        (t f)))

;;; (sub-expr a b f) returns true iff a is a subexpression of b.
;;; If b is a proper list, then (sub-expr 'nil b f) is always true.

(defn sub-expr (a b arg?)
  (if (listp b)
      (if arg?
          (or (sub-expr a (car b) f)
              (sub-expr a (cdr b) t))
        (or (equal a b)
            (sub-expr a (cdr b) t)))
    (equal a b))) ; don't bother checking arg? at this point

;;; Compare two terms

;;; (lex a b f) returns true iff a is difference from b, and either
;;; 1. a is a subexpression of b, or
;;; 2. b is not a subexpression of a, and
;;;    a is strictly less than b in the order
;;;       0 1 2 ...
;;;       a b c ... z aa ab ...
;;;       sub1 difference quotient remainder exp times plus add1
;;;       {all other functions}
;;;       {non-tame terms}
;;;    or a and b begin with the same function symbol and
;;;       either the size of a is less than that of b, or
;;;       the sizes are equal and the first argument ai in a which differs
;;;       from the corresponding argument bi in b satisfies (lex ai bi f).

;;; lex has the trichotomy property if a and b are not both wild and of type
;;; listp, litatom or numberp.  That is to say, the only things which are
;;; not comparable are two wild terms, or terms not of type listp, litatom
;;; or numberp.  However, lex is not transitive.

;;; The flag sz is included to prevent (if true) recalculation of the sizes
;;; of a and b.

(defn lex (a b sz)
  (if (equal a b)
      f
    (if (sub-expr a b f)
        t
      (if (sub-expr b a f)
          f
        (if (listp a)
            (if (listp b)
                (or (lex (car a) (car b) sz)
                    (and (equal (car a) (car b))
                         (if sz
                             (lex (cdr a) (cdr b) sz)
                           (let ((sa (size a))
                                 (sb (size b)))
                             (or (lessp sa sb)
                                 (and (equal sa sb)
                                      (lex (cdr a) (cdr b) t)))))))
              (and (litatom b)
                   (wild (unpack b))))
          (if (listp b)
              (not (and (litatom a)
                        (wild (unpack a))))
            (if (litatom a)
                (if (wild (unpack a))
                    f
                  (if (litatom b)
                      (if (wild (unpack b))
                          t
                        (let ((c (fcn-idx a))
                              (d (fcn-idx b)))
                          (if d
                              (if c
                                  (lessp c d)
                                f)
                            (if c
                                t
                              (lit-ord (unpack a) (unpack b))))))
                    f))
              (if (numberp a)
                  (if (litatom b)
                      t
                    (if (numberp b)
                        (lessp a b)
                      f))
                (or (litatom b)
                    (numberp b))))))))))

;;; The following sequence of rewrites demonstrate the need for a secondary
;;; sort within lex which uses the size of the term.  Without this, as is
;;; shown, the sequence cycles.
;;;
;;; Wherever a difference occurs introduce the constraint necessary for the
;;; result to remain non-negative.  Then all constraints are satisfied using
;;; A = 2, B = 3, C = 1, D = 0.  The lexicographic constraints are
;;; satisfied by choosing A, B, C, D to be new function symbols above ADD1,
;;; where B is smaller than D.
;;;
;;; (A + C) - (B + D) -> {difference-plus-arg2}
;;; ((A + C) - B) - D -> {difference-plus-arg1}
;;; (C - (B - A)) - D -> {difference-difference-arg2-commutes-meta}
;;; (A - (B - C)) - D -> {difference-difference-arg1-commutes-meta}
;;; (A - D) - (B - C) -> {difference-difference-arg2-commutes-meta}
;;; C - (B - (A - D)) -> {difference-difference-arg2-commutes-meta}
;;; C - (D + (B - A)) -> {difference-plus-arg2}
;;; (C - D) - (B - A) -> {difference-difference-arg2-commutes}
;;; A - (B - (C - D)) -> {difference-difference-arg2-commutes}
;;; A - (D + (B - C)) -> {difference-plus-arg2}
;;; (A - D) - (B - C) -> which cycles

;;; The following tree illustrates the relationship among the permutative
;;; meta rules for difference and plus.
;;;
;;;
;;;                         (a + b) - c
;;;                            /    \
;;;                    a < c  /      \ a >= c
;;;                          /        \
;;;                         /          \
;;;                  b - (c - a)   b + (a - c) or (a - c) + b
;;;                       /\           / \
;;;               c >= a /  \ c<a a<c /   \ a >= c
;;;                     /    \       /     \
;;;                    /\     b     b      /\
;;;                   /  \                /  \
;;;           c >= b /    \ c < b  b < c /    \ b >= c
;;;                 /      \            /      \
;;;                /        \          /        \
;;;               /          \        /          \
;;;       a - (c - b)  a + (b - c)  a - (c - b)  a + (b - c)
;;;
;;;                         c - (b + a)
;;;                              |
;;;                              |
;;;                         (c - a) - b
;;;                              |
;;;                              |
;;;                         (c - b) - a
;;;

;;; b + (a - c) -> (b - c) + a if b is lexicographically less than a.
;;; (a - c) + b -> (b - c) + a if b is lexicographically less than a.

;;; The right hand side is oriented assuming plus-commutes-meta has
;;; already been applied to the left hand side.  Thus we are assured
;;; that (b - c) << a when (a - c) << b << a

(defn plus-diff (a)
  (if (equal (car a) 'plus)
      (if (and (equal (caaddr a) 'difference)
               (lex (cadr a) (cadr (caddr a)) f)) ; b << a
          `(if (lessp ,(cadaddr a) ,(caddr (caddr a))) ; a < c
               (if (numberp ,(cadr a)) ,(cadr a) (zero))
             (if (lessp ,(cadr a) ,(caddr (caddr a))) ; b < c
                 (difference ,(cadaddr a)             ; a - (c - b)
                             (difference ,(caddr (caddr a)) ,(cadr a)))
               (plus (difference ,(cadr a) ,(caddr (caddr a))) ,(cadaddr a))))
        (if (and (equal (caadr a) 'difference)
                 (lex (caddr a) (cadadr a) f))   ; b << a
            `(if (lessp ,(cadadr a) ,(caddr (cadr a))) ; a < c
                 (if (numberp ,(caddr a)) ,(caddr a) (zero))
               (if (lessp ,(caddr a) ,(caddr (cadr a))) ; b < c
                   (difference ,(cadadr a)              ; a - (c - b)
                               (difference ,(caddr (cadr a)) ,(caddr a)))
                 (plus (difference ,(caddr a) ,(caddr (cadr a))) ,(cadadr a))))
          a))
    a))

;;; When a rule is potentially costly, rather than combining several rewrites
;;; under a common name we provide separate rules so that the inexpensive rule
;;; is still available after the costly one is disabled.  We do not provide
;;; a rule for (not (numberp a)) in plus-zerop, because this will be treated
;;; by function expansion.  Furthermore, when plus is expanded there will be
;;; no recursive call of plus where the first argument is not numberp.

(prove-lemma plus-zerop (rewrite)
  (implies (not (numberp b))
           (equal (plus a b) (if (numberp a) a 0))))

;;; We include the case (plus 0 a) because it may arise from the expansion
;;; of (plus 1 a).  Recursive functions do not expand fully, unless all
;;; arguments are explicit values.

(prove-lemma plus-0 (rewrite)
  (and (equal (plus a 0) (if (numberp a) a 0))
       (equal (plus 0 a) (if (numberp a) a 0))))

;;; This rule is costly on deep plus nests which are equated to 0.

(prove-lemma plus-is-0 (rewrite)
  (equal (equal (plus a b) 0)
         (and (or (not (numberp a))
                  (equal a 0))
              (or (not (numberp b))
                  (equal b 0)))))

;;; canonical

(prove-lemma plus-difference-commutes-meta ((meta plus))
  (equal (eval$ t a y)
         (eval$ t (plus-diff a) y))
  ((disable lex)))

;;; We order the terms within a normalized plus nest from lexicographically
;;; large to small as we procede from the outer to the inner levels.  This
;;; moves the smallest addend next to difference, and increases the likelihood
;;; of having a favorable term to move within difference using
;;; plus-difference-commutes-meta.  In a similar fashion, we order the terms
;;; within a difference nest to maximize the likelihood of having a favorable
;;; term to exchange at its outer level.

(defn plus-com (a)
  (if (and (equal (car a) 'plus)
           (not (equal (caaddr a) 'plus))
           (lex (caddr a) (cadr a) f))
      `(plus ,(caddr a) ,(cadr a))
    a))

;;; canonical

(prove-lemma plus-commutes-meta ((meta plus))
  (equal (eval$ t a y)
         (eval$ t (plus-com a) y))
  ((disable lex)))

(disable plus-commutes)

;;; a + (b + c) -> b + (a + c) if a is lexicographically less than b.

(defn plus-plus-com (a)
  (if (and (equal (car a) 'plus)
           (equal (caaddr a) 'plus)
           (lex (cadr (caddr a)) (cadr a) f))
      `(plus ,(cadr (caddr a)) (plus ,(cadr a) ,(caddr (caddr a))))
    a))

;;; canonical

(prove-lemma plus-commutes-nest-meta ((meta plus))
  (equal (eval$ t a y)
         (eval$ t (plus-plus-com a) y))
  ((disable lex)))

(disable plus-commutes-nest)

;;; We now correct inversions involving add1, plus, times and sub1.

;;; canonical

(prove-lemma plus-add1 (rewrite)
  (and (equal (plus a (add1 b))
              (add1 (plus a b)))
       (equal (plus (add1 a) b)
              (add1 (plus a b)))))

;;; (sub1 (add1 x)) is already present as an axiom

;;; canonical

(prove-lemma times-plus (rewrite)
  (and (equal (times (plus a b) c)
              (plus (times a c) (times b c)))
       (equal (times c (plus a b))
              (plus (times c a) (times c b)))))

;;; This rule in effect forces an expansion of plus, regardless of the value
;;; of a.  This will not lead to infinite expansion, provided sub1 is not
;;; driven down to plus infinitely often from the enclosing expression.

;;; We do not include normalization lemmas for sub1 inside of plus, since
;;; they would conflict with plus-difference-commutes-meta.  Furthermore,
;;; there is a natural normalization which occurs when plus is expanded.
;;; As plus-commutes-meta moves litatoms to the left, expansion of plus will
;;; tend to distribute sub1's uniformly over all litatoms occuring with the
;;; plus nest.

;;; canonical (needed to avoid "expand" hints)

(prove-lemma sub1-plus (rewrite)
  (equal (sub1 (plus a b))
         (if (or (not (numberp a))
                 (equal a 0))
             (sub1 b)
           (plus (sub1 a) b)))) ; b may be a plus nest

;;; canonical

(prove-lemma sub1-times (rewrite)
  (equal (sub1 (times a b))
         (if (or (not (numberp a))
                 (equal a 0))
             0
           (plus (sub1 b) (times b (sub1 a))))))

;;; canonical

(prove-lemma plus-associates-right (rewrite)
  (equal (plus (plus a b) c)
         (plus a (plus b c))))

(prove-lemma no-divisors-of-zero (rewrite)
  (equal (equal (times a b) 0)
         (or (not (numberp b))
             (equal b 0)
             (not (numberp a))
             (equal a 0))))

;;; canonical

(prove-lemma times-commutes-nest (rewrite)
  (equal (times a (times b c))
         (times b (times a c))))

;;; canonical

(prove-lemma times-associates-right (rewrite)
  (equal (times (times a b) c)
         (times a (times b c))))

(prove-lemma lessp-times-linear (rewrite)
  (and (implies (and (not (lessp b a))
                     (numberp c)
                     (not (equal c 0)))
                (and (not (lessp (times c b) a))
                     (not (lessp (times b c) a))))
       (implies (and (lessp a b)
                     (numberp c)
                     (not (equal c 0)))
                (and (lessp a (times b c))
                     (lessp a (times c b))))))

(prove-lemma lessp-times-both-linear (rewrite)
  (and (implies (and (lessp a b)
                     (not (lessp d c))
                     (numberp d)
                     (not (equal d 0)))
                (and (lessp (times a c) (times b d))
                     (lessp (times c a) (times b d))
                     (lessp (times a c) (times d b))
                     (lessp (times c a) (times d b))))
       (implies (and (lessp a b)
                     (lessp c d))
                (and (lessp (times a c) (times b d))
                     (lessp (times c a) (times b d)))))
  ((induct (lessp a b))))

(prove-lemma lessp-times-single-linear (rewrite)
  (and (implies (and (lessp a b)
                     (not (equal c 0))
                     (numberp c))
                (and (lessp (times a c) (times b c))
                     (lessp (times c a) (times b c))
                     (lessp (times a c) (times c b))
                     (lessp (times c a) (times c b))))
       (implies (not (lessp b a))
                (and (not (lessp (times b c) (times a c)))
                     (not (lessp (times c b) (times a c)))
                     (not (lessp (times b c) (times c a)))
                     (not (lessp (times c b) (times c a)))))
       (implies (lessp a b)
                (and (not (lessp (times b c) (times a c)))
                     (not (lessp (times c b) (times a c)))
                     (not (lessp (times b c) (times c a)))
                     (not (lessp (times c b) (times c a))))))
  ((induct (lessp a b))
   (disable sub1-times
            sub1-plus
            plus-is-0)))

;;; We include this cancellation lemma to reduce the opportunities for the
;;; above linear rules.  It also compensates for a deficiency of linear
;;; (Presburger) arithmetic which does not use properties of times.  So we
;;; remove times from inside lessp whenever possible.  Additionally, we
;;; favor (and (numberp c) (not (equal c 0))) to (lessp 0 c), because
;;; linear arithmetic is not consistently employed (e.g. when relieving
;;; the hypotheses of rewrite rules.

(prove-lemma lessp-times-cancellation (rewrite)
  (and
   (equal (lessp (times a c) (times b c))
          (and (numberp c) (not (equal c 0)) (lessp a b)))
   (equal (lessp (times c a) (times b c))
          (and (numberp c) (not (equal c 0)) (lessp a b)))
   (equal (lessp (times a c) (times c b))
          (and (numberp c) (not (equal c 0)) (lessp a b)))
   (equal (lessp (times c a) (times c b))
          (and (numberp c) (not (equal c 0)) (lessp a b)))
   (equal (lessp (times c b) c)
          (and (numberp c)
               (not (equal c 0))
               (or (not (numberp b))
                   (equal b 0))))
   (equal (lessp (times b c) c)
          (and (numberp c)
               (not (equal c 0))
               (or (not (numberp b))
                   (equal b 0))))
   (equal (lessp c (times c b))
          (and (numberp c)
               (not (equal c 0))
               (not (equal (sub1 b) 0))))
   (equal (lessp c (times b c))
          (and (numberp c)
               (not (equal c 0))
               (not (equal (sub1 b) 0)))))
  ((disable lessp-times-single-linear
            sub1-times
            sub1-plus
            lessp-times-linear)))

(prove-lemma lessp-facts (rewrite)
  (and (equal (lessp a a) f)
       (equal (lessp a 0) f)
       (equal (lessp 0 a)
              (and (numberp a) (not (equal a 0))))
       (equal (lessp (sub1 a) a)
              (and (numberp a) (not (equal a 0))))
       (equal (lessp a (sub1 a)) f)
       (equal (lessp (sub1 (sub1 a)) a)
              (and (numberp a) (not (equal a 0))))
       (equal (lessp a (sub1 (sub1 a))) f)))

;;; We include the following lemma because nqthm does not normalize
;;; if-expressions when relieving the hypotheses of rewrite rules.
;;; Consequently expressions such as (not (lessp b a)), which expands to
;;; (if (lessp b a) F T), will not benefit from linear arithmetic.

(prove-lemma dichotomy (rewrite)
  (and
   (implies (and (lessp x a)      ; use free variable x to avoid
                 (equal x b))     ; rewriting (lessp b a), but
            (equal (lessp a b) f)) ; not (equal x b) unfortunately.
   (implies (and (lessp b x)       ; (lessp x a) must precede
                 (equal x a))      ; (equal x b) to avoid rewriting
            (equal (lessp a b) f))
   (implies (and (not (lessp x a))
                 (equal x b)
                 (numberp b)
                 (not (equal b 0))
                 (not (equal a x)))
            (equal (lessp a b) t))
   (implies (and (not (lessp b x))
                 (equal x a)
                 (numberp b)
                 (not (equal b 0))
                 (not (equal b x)))
            (equal (lessp a b) t))))

;;; Extend the nesting order to add1, plus, times, difference, sub1

;;; canonical

;;; We choose to push add1 to the inside rather than to the outside in order
;;; to move more rapidly to a normal form.

(prove-lemma difference-add1 (rewrite)
  (and (equal (difference (add1 a) b)
              (if (or (not (numberp b))
                      (equal b 0))
                  (add1 a)
                (difference a (sub1 b))))
       (equal (difference a (add1 b))
              (difference (sub1 a) b))))

;;; canonical

(prove-lemma add1-difference (rewrite)
  (equal (add1 (difference a b))
         (if (or (not (numberp b))
                 (equal b 0))
             (add1 a)
           (if (lessp a b)
               1
             (difference a (sub1 b))))))

;;; canonical

(prove-lemma difference-plus-arg2 (rewrite)
  (equal (difference a (plus b c))
         (difference (difference a c) b)))

;;; (a - b) - c -> (a - c) - b if c is lexicographically less than b.

(defn diff-diff-1 (a)
  (if (and (equal (car a) 'difference)
           (equal (caadr a) 'difference)
           (lex (caddr a) (caddadr a) f))
      `(difference (difference ,(cadadr a) ,(caddr a)) ,(caddadr a))
    a))

;;; canonical

(prove-lemma difference-difference-arg1-commutes-meta ((meta difference))
  (equal (eval$ t a y)
         (eval$ t (diff-diff-1 a) y))
  ((disable lex)))

(disable difference-difference-arg1-commutes)

;;; b - (c - a) -> a - (c - b) if b is lexicographically less than a.

(defn diff-diff-2 (a)
  (if (and (equal (car a) 'difference)
           (equal (caaddr a) 'difference)
           (lex (cadr a) (caddaddr a) f))
      `(if (lessp ,(cadaddr a) ,(caddaddr a)) ; c < a
           (if (numberp ,(cadr a)) ,(cadr a) (zero))
         (if (lessp ,(cadaddr a) ,(cadr a)) ; c < b
             (plus ,(caddaddr a)
                   (difference ,(cadr a) ,(cadaddr a)))
           (difference ,(caddaddr a)
                       (difference ,(cadaddr a) ,(cadr a)))))
    a))

;;; canonical

(prove-lemma difference-difference-arg2-commutes-meta ((meta difference))
  (equal (eval$ t a y)
         (eval$ t (diff-diff-2 a) y))
  ((disable lex)))

;;; We may omit the meta rule to permute a and d within d + (b - (c - a)),
;;; assuming that normalization has progressed to the point where nesting
;;; order inversions are largely absent.  In this case lex will be transitive,
;;; since subexpression inclusion implies normal lex ordering without
;;; subexpression inclusion checks.  So plus-difference-commutes-meta and
;;; difference-difference-arg2-commutes-meta will assure that a << b << d.
;;; From transitivity, a << d.

(prove-lemma difference-facts (rewrite)
  (and (equal (difference a a) 0)
       (equal (difference a (sub1 a))
              (if (or (not (numberp a))
                      (equal a 0))
                  0
                1))
       (equal (difference a (sub1 (sub1 a)))
              (if (or (not (numberp a))
                      (equal a 0))
                  0
                (if (equal a 1)
                    1
                  2)))
       (equal (difference (sub1 b) (difference b a))
              (if (lessp a b)
                  (sub1 a)
                (sub1 b)))
       (equal (difference b (difference (sub1 b) a))
              (if (numberp b)
                  (if (lessp a b)
                      (add1 a)
                    b)
                0))))

(prove-lemma remainder-lessp-rewrite (rewrite)
  (and (equal (lessp (remainder a b) b)
              (and (numberp b)
                   (not (equal b 0))))
       (equal (lessp (remainder a b) a)
              (and (numberp b)
                   (not (equal b 0))
                   (not (lessp a b))))
       (equal (lessp a (remainder a b)) f)
       (equal (lessp b (remainder a b))
              (and (or (not (numberp b)) (equal b 0))
                   (numberp a)
                   (not (equal a 0)))))
  ((disable lessp-times-single-linear)))

(prove-lemma quotient-lessp-linear (rewrite)
  (and (not (lessp a (times b (quotient a b))))
       (not (lessp a (plus (quotient a b)
                           (times (sub1 b) (quotient a b)))))))

;;; Create meta rule for eliminating a factor from both sides of an equality.

;;; Assume that products are in normal form, i.e. no leftmost argument to
;;; times begins with times and the arguments to times proceeding from left
;;; to right are lexicographically sorted.

(prove-lemma count-decreases (rewrite)
  (implies (not (equal (car a) 0))
           (and (lessp (count (cadr a)) (count a))
                (lessp (count (caddr a)) (count a)))))

;;; Assume that a and b are in normal form, i.e. no leftmost argument to
;;; times begins with times and the arguments to times proceeding from left
;;; to right are lexicographically sorted.

;;; (factor? a b) returns true if the factors of b are a sub bag of the
;;; factors of a.  factor? may not recognize some cases where b divides
;;; a syntactically if a and b are not in normal form.

(defn factor? (a b)
  (if (equal (car a) 'times)
      (if (equal (car b) 'times)
          (if (equal (cadr a) (cadr b))
              (factor? (caddr a) (caddr b))
            (factor? (caddr a) b))
        (if (equal (cadr a) b)
            t
          (factor? (caddr a) b)))
    (equal a b)))

;;; (tail? a b) returns true if b is a tail of the times nest in a.

(defn tail? (a b)
  (if (equal a b)
      t
    (if (equal (car a) 'times)
        (tail? (caddr a) b)
      f)))

(prove-lemma tail?-is-transitive (rewrite)
  (implies (and (tail? a b)
                (tail? b c))
           (tail? a c)))

(prove-lemma tail?-implies-factor? (rewrite)
  (implies (tail? a b)
           (factor? a b))
  ((induct (factor? a b))))

(prove-lemma factor?-tail?-helper-1 nil
  (implies (and (factor? a (cons 'times (cons b x)))
                (not (listp x)))
           (factor? a 0)))

(prove-lemma factor?-tail?-helper-2 (rewrite)
  (implies (and (factor? a b)
                (equal (car b) 'times))
           (factor? a (caddr b)))
  ((use (factor?-tail?-helper-1 (a a) (x (cddr b))))
   (disable tail?
            tail?-implies-factor?)))

(prove-lemma factor?-tail? (rewrite)
  (implies (and (factor? a b)
                (tail? c a))
           (factor? c b))
  ((induct (factor? c b))))

(prove-lemma factor?-is-transitive (rewrite)
  (and (implies (and (factor? a b)
                     (factor? b c))
                (factor? a c))
       (implies (and (factor? b c)
                     (factor? a b))
                (factor? a c))))

;;; If a and b are in normal form (using times-commutes and times-associates),
;;; then gcd? returns the largest common subsequence of factors in a and b.
;;; If no such subsequence exists, then gcd? returns false.  In all cases,
;;; if gcd? is non false then it returns a common subsequence of a and b.
;;; The subsequence is only guaranteed to be maximal when a and b are in
;;; normal form.  We do not prove that the subsequence is maximal, since it
;;; does not affect the soundness of the derived meta rule.  This procedure
;;; is a bit complex.  It makes use of the property that a and b are
;;; lexicographically sorted to infer from (factor? b (cadr a)) and
;;; (cadr a) /= (cadr b) that (cadr b) is not a factor of a.

(defn gcd? (a b)
  (if (equal (car a) 'times)
      (if (equal (caadr a) 'times)
          f
        (if (equal (car b) 'times)
            (if (equal (cadr a) (cadr b))
                (if (gcd? (caddr a) (caddr b))
                    `(times ,(cadr a) ,(gcd? (caddr a) (caddr b)))
                  (cadr a))
              (if (factor? b (cadr a))
                  (gcd? a (caddr b))
                (gcd? (caddr a) b)))
          (if (factor? a b)
              b
            f)))
    (if (factor? b a)
        a
      f))
  ((lessp (plus (count a) (count b)))))

(prove-lemma factor?-gcd? (rewrite)
  (implies (gcd? a b)
           (and (factor? a (gcd? a b))
                (factor? b (gcd? a b)))))

(disable tail?-is-transitive)
(disable tail?-implies-factor?)
(disable factor?-tail?-helper-2)
(disable factor?-tail?)

;;; `(fix ,(remove-factors a b)) before use.

(defn remove-factors (a b)
  (if (equal (car a) 'times)
      (if (equal (car b) 'times)
          (if (equal (cadr a) (cadr b))
              (remove-factors (caddr a) (caddr b))
            `(times ,(cadr a) ,(remove-factors (caddr a) b)))
        (if (equal (cadr a) b)
            (caddr a)
          `(times ,(cadr a) ,(remove-factors (caddr a) b))))
    (if (equal a b)
        '(add1 (zero))
      a)))

(prove-lemma factor?-divides (rewrite)
  (implies (factor? a b)
           (equal (times (eval$ t b y)
                         (eval$ t (remove-factors a b) y))
                  (if (numberp (eval$ t a y))
                      (eval$ t a y)
                    0)))
  ((induct (remove-factors a b))
   (disable sub1-times
            plus-commutes-meta)))

;;; Find the largest factor occurring in all summands of a.

(defn gcd?-sum (a)
  (if (equal (car a) 'plus)
      (gcd? (cadr a) (gcd?-sum (caddr a)))
    a))

;;; Remove the factor b from the sum a.

(defn remove-sum (a b)
  (if (equal (car a) 'plus)
      `(plus ,(remove-factors (cadr a) b)
             ,(remove-sum (caddr a) b))
    (remove-factors a b)))

(prove-lemma gcd?-sum-divides nil
  (implies (and (gcd?-sum a) ; factor of every summand of a
                (factor? (gcd?-sum a) b))
           (equal (times (eval$ t b y)
                         (eval$ t (remove-sum a b) y))
                  (if (numberp (eval$ t a y))
                      (eval$ t a y)
                    0)))
  ((induct (remove-sum a b))))

;;; Remove factor from both sides of an equality

(defn t-cancel (a)
  (if (and (equal (car a) 'equal)
           (not (equal (cadr a) (caddr a)))) ; => lhs or rhs is numberp
      (let ((b (gcd? (gcd?-sum (cadr a)) (gcd?-sum (caddr a)))))
        (if (and b (not (equal b '(add1 (zero)))) (not (equal b ''1)))
            `(if (and (numberp ,b)
                      (not (equal ,b (zero))))
                 (equal (fix ,(remove-sum (cadr a) b))
                        (fix ,(remove-sum (caddr a) b)))
               (and (numberp ,(cadr a))
                    (numberp ,(caddr a))))
          a))
    a))

(defn t-c-ind (a b)
  (if (equal (car a) 'plus)
      (if (equal (car b) 'plus)
          (t-c-ind (caddr a) (caddr b))
        (t-c-ind (caddr a) b))
    (if (equal (car b) 'plus)
        (t-c-ind a (caddr b))
      nil))
  ((lessp (plus (count a) (count b)))))

(prove-lemma t-cancel-numberp-helper nil
  (implies (and (not (equal a b))
                (gcd? (cons a c) (cons b d)))
           (or (equal a 'times)
               (equal b 'times))))

(prove-lemma t-cancel-numberp nil
  (implies (and (not (equal a b))
                (gcd? (gcd?-sum a) (gcd?-sum b)))
           (or (numberp (eval$ t a y))
               (numberp (eval$ t b y))))
  ((induct (t-c-ind a b))
   (use (t-cancel-numberp-helper (a (car a)) (b (car b))
                                 (c (cdr a)) (d (cdr b))))
   (disable eval$
            no-divisors-of-zero
            plus-add1
            times-associates-right
            quotient-remainder-rewrite
            times-plus)))

(prove-lemma equal-plus-cancel (rewrite)
  (and (equal (equal a (plus a b))
              (and (numberp a)
                   (or (not (numberp b))
                       (equal b 0))))
       (equal (equal a (plus b a))
              (and (numberp a)
                   (or (not (numberp b))
                       (equal b 0))))
       (equal (equal (plus a b) a)
              (and (numberp a)
                   (or (not (numberp b))
                       (equal b 0))))
       (equal (equal (plus b a) a)
              (and (numberp a)
                   (or (not (numberp b))
                       (equal b 0))))))

(prove-lemma equal-times-cancel (rewrite)
  (and (equal (equal (times a c) (times b c))
              (or (not (numberp c))
                  (equal c 0)
                  (equal (fix a) (fix b))))
       (equal (equal (times c a) (times b c))
              (or (not (numberp c))
                  (equal c 0)
                  (equal (fix a) (fix b))))
       (equal (equal (times a c) (times c b))
              (or (not (numberp c))
                  (equal c 0)
                  (equal (fix a) (fix b))))
       (equal (equal (times c a) (times c b))
              (or (not (numberp c))
                  (equal c 0)
                  (equal (fix a) (fix b))))
       (equal (equal c (times c b))
              (and (numberp c)
                   (or (equal c 0)
                       (equal b 1))))
       (equal (equal c (times b c))
              (and (numberp c)
                   (or (equal c 0)
                       (equal b 1))))
       (equal (equal (times c b) c)
              (and (numberp c)
                   (or (equal c 0)
                       (equal b 1))))
       (equal (equal (times b c) c)
              (and (numberp c)
                   (or (equal c 0)
                       (equal b 1)))))
  ((induct (difference a b))
   (expand (times b c))
   (disable sub1-times)))

(prove-lemma gcd?-sum-of-non-number-1 (rewrite)
  (implies (and (not (numberp (eval$ t a y)))
                (gcd? (gcd?-sum a) b))
           (equal (gcd?-sum a) a))
  ((induct (gcd?-sum a))))

(prove-lemma gcd?-sum-of-non-number-2 (rewrite)
  (implies (and (not (numberp (eval$ t a y)))
                (gcd? b (gcd?-sum a)))
           (equal (gcd?-sum a) a))
  ((induct (gcd?-sum a))))

(prove-lemma gcd?-of-non-number-1 (rewrite)
  (implies (and (not (numberp (eval$ t a y)))
                (gcd? (gcd?-sum a) b))
           (equal (gcd? a b) a))
  ((induct (gcd? a b))))

(prove-lemma gcd?-of-non-number-2 (rewrite)
  (implies (and (not (numberp (eval$ t a y)))
                (gcd? b (gcd?-sum a)))
           (equal (gcd? b a) a))
  ((induct (gcd? a b))))

(prove-lemma fix-eval$ (rewrite)
  (implies (equal (car a) 'fix)
           (equal (eval$ t a y)
                  (fix (eval$ t (cadr a) y)))))

(prove-lemma times-eval$ (rewrite)
  (implies (equal (car a) 'times)
           (equal (eval$ t a y)
                  (times (eval$ t (cadr a) y)
                         (eval$ t (caddr a) y)))))

(prove-lemma equal-eval$ (rewrite)
  (implies (equal (car a) 'equal)
           (equal (eval$ t a y)
                  (equal (eval$ t (cadr a) y)
                         (eval$ t (caddr a) y)))))

(prove-lemma if-eval$ (rewrite)
  (implies (equal (car a) 'if)
           (equal (eval$ t a y)
                  (if (eval$ t (cadr a) y)
                      (eval$ t (caddr a) y)
                    (eval$ t (cadddr a) y)))))

(prove-lemma equal-times-cancel-helper (rewrite)
  (implies (and (equal (times a b) c)
                (equal (times a d) c)
                (numberp a)
                (not (equal a 0))
                (numberp b)
                (numberp d))
           (equal (equal b d) t)))

(prove-lemma equal-times-cancel-meta ((meta equal))
  (equal (eval$ t a y)
         (eval$ t (t-cancel a) y))
  ((use (gcd?-sum-divides (a (cadr a))
                          (b (gcd? (gcd?-sum (cadr a)) (gcd?-sum (caddr a)))))
        (gcd?-sum-divides (a (caddr a))
                          (b (gcd? (gcd?-sum (cadr a)) (gcd?-sum (caddr a)))))
        (t-cancel-numberp (a (cadr a)) (b (caddr a))))
   (disable gcd?-sum
            plus-commutes-meta
            remove-sum)))


(disable equal-times-cancel-helper)

(defn t-cancel-lessp (a)
  (if (and (equal (car a) 'lessp)
           (not (equal (cadr a) (caddr a)))) ; => lhs or rhs is numberp
      (let ((b (gcd? (gcd?-sum (cadr a)) (gcd?-sum (caddr a)))))
        (if (and b (not (equal b '(add1 (zero)))) (not (equal b ''1)))
            `(if (and (numberp ,b)
                      (not (equal ,b (zero))))
                 (lessp ,(remove-sum (cadr a) b)
                        ,(remove-sum (caddr a) b))
               (false))
          a))
    a))

(prove-lemma lessp-times-cancel-meta-helper-1 (rewrite)
  (implies (and (not (equal a b))
                (gcd? (gcd?-sum a) (gcd?-sum b))
                (not (numberp (eval$ t a y))))
           (factor? (gcd?-sum b) a))
  ((use (factor?-gcd? (a (gcd?-sum a)) (b (gcd?-sum b))))))

(prove-lemma lessp-times-cancel-meta-helper-2 (rewrite)
  (implies (and (equal a (times c d))
                (equal b (times c e))
                (not (zerop c)))
           (equal (lessp a b)
                  (lessp d e))))

(prove-lemma lessp-times-cancel-meta ((meta lessp))
  (equal (eval$ t a y)
         (eval$ t (t-cancel-lessp a) y))
  ((use (gcd?-sum-divides (a (cadr a))
                          (b (gcd? (gcd?-sum (cadr a)) (gcd?-sum (caddr a)))))
        (gcd?-sum-divides (a (caddr a))
                          (b (gcd? (gcd?-sum (cadr a)) (gcd?-sum (caddr a)))))
        (t-cancel-numberp (a (cadr a)) (b (caddr a))))
   (disable plus-commutes-meta)))

(disable lessp-times-cancel-meta-helper-1)
(disable lessp-times-cancel-meta-helper-2)
(disable factor?-is-transitive)
(disable factor?-gcd?)
(disable factor?-divides)
(disable gcd?-sum-divides)
(disable gcd?-sum-of-non-number-1)
(disable gcd?-sum-of-non-number-2)
(disable gcd?-of-non-number-1)
(disable gcd?-of-non-number-2)

(prove-lemma difference-cancellation (rewrite)
  (and (equal (equal (difference a c)
                     (difference b c))
              (or (and (lessp a c) (lessp b c))
                  (and (lessp a c) (equal b c))
                  (and (lessp b c) (equal a c))
                  (equal (fix a) (fix b))))
       (equal (equal (difference c a)
                     (difference c b))
              (or (and (lessp c a) (lessp c b))
                  (and (lessp c a) (equal (fix b) (fix c)))
                  (and (lessp c b) (equal (fix a) (fix c)))
                  (equal (fix a) (fix b))))))

;;; Provide meta-rules for add1/plus/times cancellation within equal and lessp.

;;; Find the first occurrence of difference within the times-normalized list a.

(defn find-difference-times (a)
  (if (equal (car a) 'times)
      (if (equal (caadr a) 'difference)
          (cadr a)
        (find-difference-times (caddr a)))
    (if (equal (car a) 'difference)
        a
      f)))

;;; Find the first occurrence of difference within the plus-times-normalized a.

(defn find-difference-plus (a)
  (if (equal (car a) 'plus)
      (if (find-difference-times (cadr a))
          (find-difference-times (cadr a))
        (find-difference-plus (caddr a)))
    (find-difference-times a)))

;;; Find the first occurrence of difference within the add1/plus/times nest a.

(defn find-difference (a)
  (if (equal (car a) 'add1)
      (find-difference (cadr a))
    (find-difference-plus a)))

;;; Compute positive or negative addend associated with a difference term
;;; within a times nest.

(defn get-addend-times (a c)
  (if (equal (car a) 'times)
      (if (equal (caadr a) 'difference)
          (if c
              `(times ,(cadadr a) ,(caddr a))
            `(times ,(caddadr a) ,(caddr a)))
        `(times ,(cadr a) ,(get-addend-times (caddr a) c)))
    (if (equal (car a) 'difference)
        (if c (cadr a) (caddr a))
      f)))

;;; Compute positive or negative addend associated with a difference term
;;; within a plus/times nest.

(defn get-addend-plus (a c)
  (if (equal (car a) 'plus)
      (if (find-difference-times (cadr a))
          (get-addend-times (cadr a) c)
        (get-addend-plus (caddr a) c))
    (get-addend-times a c)))

;;; Compute positive or negative addend associated with a difference term
;;; within an add1/plus/times nest.

(defn get-addend (a c)
  (if (equal (car a) 'add1)
      (get-addend (cadr a) c)
    (get-addend-plus a c)))

;;; Delete the first difference term from a plus/times nest.

(defn remove-difference-plus (a)
  (if (equal (car a) 'plus)
      (if (find-difference-times (cadr a))
          (caddr a)
        `(plus ,(cadr a) ,(remove-difference-plus (caddr a))))
    '(zero)))

;;; Delete the first difference term from an add1/plus/times nest.

(defn remove-difference (a)
  (if (equal (car a) 'add1)
      `(add1 ,(remove-difference (cadr a)))
    (remove-difference-plus a)))

;;; Transpose negative portion of first difference across equal.

(defn equal-transpose (a)
  (if (equal (car a) 'equal)
      (if (find-difference (cadr a))
          (let ((b (find-difference (cadr a))))
            `(if (not (lessp ,(cadr b) ,(caddr b)))
                 (and (numberp ,(caddr a))
                      (equal (plus ,(get-addend (cadr a) t)
                                   ,(remove-difference (cadr a)))
                             (plus ,(get-addend (cadr a) f) ,(caddr a))))
               (equal (fix ,(remove-difference (cadr a)))
                      ,(caddr a))))
        (if (find-difference (caddr a))
            (let ((b (find-difference (caddr a))))
              `(if (not (lessp ,(cadr b) ,(caddr b)))
                   (and (numberp ,(cadr a))
                        (equal (plus ,(get-addend (caddr a) f) ,(cadr a))
                               (plus ,(get-addend (caddr a) t)
                                     ,(remove-difference (caddr a)))))
                 (equal ,(cadr a)
                        (fix ,(remove-difference (caddr a))))))
          a))
    a))

(prove-lemma remove-difference-times-subtracts (rewrite)
  (implies (find-difference-times a)
           (equal (eval$ t a y)
                  (difference (eval$ t (get-addend-times a t) y)
                              (eval$ t (get-addend-times a f) y))))
  ((induct (find-difference-times a))
   (disable plus-difference-commutes-meta)))

(prove-lemma remove-difference-plus-subtracts (rewrite)
  (implies (find-difference-plus a)
           (equal (eval$ t a y)
                  (plus (difference
                         (eval$ t (get-addend-plus a t) y)
                         (eval$ t (get-addend-plus a f) y))
                        (eval$ t (remove-difference-plus a) y))))
  ((induct (find-difference-plus a))
   (disable plus-commutes-meta
            plus-commutes-nest-meta
            plus-difference-commutes-meta)))


(prove-lemma remove-difference-subtracts (rewrite)
  (implies (find-difference a)
           (equal (eval$ t a y)
                  (plus (difference
                         (eval$ t (get-addend a t) y)
                         (eval$ t (get-addend a f) y))
                        (eval$ t (remove-difference a) y))))
  ((induct (find-difference a))))

(prove-lemma lessp-find-difference-times-1 (rewrite)
  (implies (lessp (eval$ t (cadr (find-difference-times a)) y)
                  (eval$ t (caddr (find-difference-times a)) y))
           (not (lessp (eval$ t (get-addend-times a f) y)
                       (eval$ t (get-addend-times a t) y))))
  ((induct (find-difference-times a))))

(prove-lemma lessp-find-difference-plus-1 (rewrite)
  (implies (lessp (eval$ t (cadr (find-difference-plus a)) y)
                  (eval$ t (caddr (find-difference-plus a)) y))
           (not (lessp (eval$ t (get-addend-plus a f) y)
                       (eval$ t (get-addend-plus a t) y))))
  ((induct (find-difference-plus a))))

(prove-lemma lessp-find-difference-1 (rewrite)
  (implies (lessp (eval$ t (cadr (find-difference a)) y)
                  (eval$ t (caddr (find-difference a)) y))
           (not (lessp (eval$ t (get-addend a f) y)
                       (eval$ t (get-addend a t) y))))
  ((induct (find-difference a))))

(prove-lemma lessp-find-difference-times-2 (rewrite)
  (implies (lessp (eval$ t (get-addend-times a t) y)
                  (eval$ t (get-addend-times a f) y))
           (lessp (eval$ t (cadr (find-difference-times a)) y)
                  (eval$ t (caddr (find-difference-times a)) y)))
  ((induct (find-difference-times a))))

(prove-lemma lessp-find-difference-plus-2 (rewrite)
  (implies (lessp (eval$ t (get-addend-plus a t) y)
                  (eval$ t (get-addend-plus a f) y))
           (lessp (eval$ t (cadr (find-difference-plus a)) y)
                  (eval$ t (caddr (find-difference-plus a)) y)))
  ((induct (find-difference-plus a))))

(prove-lemma lessp-find-difference-2 (rewrite)
  (implies (lessp (eval$ t (get-addend a t) y)
                  (eval$ t (get-addend a f) y))
           (lessp (eval$ t (cadr (find-difference a)) y)
                  (eval$ t (caddr (find-difference a)) y)))
  ((induct (find-difference a))))

;;; canonical (trades difference for plus across equal)

(prove-lemma equal-transpose-meta ((meta equal))
  (equal (eval$ t a y)
         (eval$ t (equal-transpose a) y))
  ((disable find-difference-times
            find-difference-plus
            remove-difference-plus-subtracts
            plus-difference-commutes-meta
            remove-difference-times-subtracts
            get-addend
            if-eval$
            fix-eval$
            times-eval$)))

(defn lessp-transpose (a)
  (if (equal (car a) 'lessp)
      (if (find-difference (cadr a))
          (let ((b (find-difference (cadr a))))
            `(if (not (lessp ,(cadr b) ,(caddr b)))
                 (lessp (plus ,(get-addend (cadr a) t)
                              ,(remove-difference (cadr a)))
                        (plus ,(get-addend (cadr a) f) ,(caddr a)))
               (lessp ,(remove-difference (cadr a))
                      ,(caddr a))))
        (if (find-difference (caddr a))
            (let ((b (find-difference (caddr a))))
              `(if (not (lessp ,(cadr b) ,(caddr b)))
                   (lessp (plus ,(get-addend (caddr a) f) ,(cadr a))
                          (plus ,(get-addend (caddr a) t)
                                ,(remove-difference (caddr a))))
                 (lessp ,(cadr a)
                        ,(remove-difference (caddr a)))))
          a))
    a))

(prove-lemma lessp-plus-difference (rewrite)
  (and (equal (lessp (plus c (difference a b)) d)
              (if (not (lessp a b))
                  (lessp (plus c a) (plus d b))
                (lessp c d)))
       (equal (lessp c (plus d (difference a b)))
              (if (not (lessp a b))
                  (lessp (plus c b) (plus d a))
                (lessp c d))))
  ((induct (difference a b))
   (disable plus-difference-commutes-meta ; necessary to prevent
            sub1-plus)))                  ; bind stack overflow

(prove-lemma numberp-get-addend-times (rewrite)
  (implies (and (find-difference-times a)
                (not (numberp (eval$ t (get-addend-times a c) y))))
           (and (equal (get-addend-times a t)
                       (cadr (find-difference-times a)))
                (equal (get-addend-times a f)
                       (caddr (find-difference-times a)))))
  ((induct (find-difference-times a))))

(prove-lemma numberp-get-addend-plus (rewrite)
  (implies (and (find-difference-plus a)
                (not (numberp (eval$ t (get-addend-plus a c) y))))
           (and (equal (get-addend-plus a t)
                       (cadr (find-difference-plus a)))
                (equal (get-addend-plus a f)
                       (caddr (find-difference-plus a)))))
  ((induct (find-difference-plus a))))

(prove-lemma numberp-get-addend (rewrite)
  (implies (and (find-difference a)
                (not (numberp (eval$ t (get-addend a c) y))))
           (and (equal (get-addend a t)
                       (cadr (find-difference a)))
                (equal (get-addend a f)
                       (caddr (find-difference a)))))
  ((induct (find-difference a))))

(prove-lemma equal-get-addend-times (rewrite)
  (implies (and (equal (eval$ t (get-addend-times a t) y)
                       (eval$ t (get-addend-times a f) y))
                (numberp (eval$ t (get-addend-times a f) y))
                (lessp (eval$ t (cadr (find-difference-times a)) y)
                       (eval$ t (caddr (find-difference-times a)) y)
                       ))
           (and (equal (eval$ t (get-addend-times a f) y) 0)
                (equal (eval$ t (get-addend-times a t) y) 0)))
  ((induct (find-difference-times a))
   (disable find-difference-plus
            remove-difference-plus-subtracts
            lessp-find-difference-times-2
            numberp-get-addend-times
            remove-difference-times-subtracts
            lessp-find-difference-times-1
            lessp-times-cancel-meta
            find-difference
            remove-difference-subtracts)))

(prove-lemma equal-get-addend-plus (rewrite)
  (implies (and (equal (eval$ t (get-addend-plus a t) y)
                       (eval$ t (get-addend-plus a f) y))
                (numberp (eval$ t (get-addend-plus a f) y))
                (lessp (eval$ t (cadr (find-difference-plus a)) y)
                       (eval$ t (caddr (find-difference-plus a)) y)
                       ))
           (and (equal (eval$ t (get-addend-plus a f) y) 0)
                (equal (eval$ t (get-addend-plus a t) y) 0)))
  ((induct (find-difference-plus a))
   (disable find-difference-times
            get-addend-times
            lessp-find-difference-plus-1
            lessp-find-difference-plus-2
            remove-difference-plus-subtracts
            numberp-get-addend-plus
            lessp-find-difference-times-1
            lessp-find-difference-times-2
            numberp-get-addend-times
            remove-difference-times-subtracts)))

(prove-lemma equal-get-addend (rewrite)
  (implies (and (equal (eval$ t (get-addend a t) y)
                       (eval$ t (get-addend a f) y))
                (numberp (eval$ t (get-addend a f) y))
                (lessp (eval$ t (cadr (find-difference a)) y)
                       (eval$ t (caddr (find-difference a)) y)
                       ))
           (and (equal (eval$ t (get-addend a f) y) 0)
                (equal (eval$ t (get-addend a t) y) 0)))
  ((induct (find-difference a))
   (disable find-difference-times
            get-addend-plus
            find-difference-plus
            lessp-find-difference-1
            lessp-find-difference-2
            numberp-get-addend-plus
            remove-difference-plus-subtracts
            lessp-find-difference-plus-1
            lessp-find-difference-plus-2)))

;;; canonical (trades difference for plus across lessp)

(prove-lemma lessp-transpose-meta ((meta lessp))
  (equal (eval$ t a y)
         (eval$ t (lessp-transpose a) y))
  ((enable plus-commutes)
   (disable plus-commutes-meta
            plus-difference-commutes-meta
            find-difference-times
            find-difference-plus
            remove-difference-plus-subtracts
            difference-lessp
            equal-transpose-meta
            get-addend
            remove-difference-times-subtracts
            dichotomy
            sub1-difference
            if-eval$
            times-eval$
            equal-eval$
            fix-eval$)))

(disable equal-get-addend)
(disable equal-get-addend-plus)
(disable equal-get-addend-times)
(disable numberp-get-addend)
(disable numberp-get-addend-plus)
(disable numberp-get-addend-times)
(disable lessp-plus-difference)
(disable lessp-find-difference-2)
(disable lessp-find-difference-plus-2)
(disable lessp-find-difference-times-2)
(disable lessp-find-difference-1)
(disable lessp-find-difference-plus-1)
(disable lessp-find-difference-times-1)
(disable remove-difference-subtracts)
(disable remove-difference-plus-subtracts)
(disable remove-difference-times-subtracts)

;;; remove the term x from the add1/plus nest a

(defn plus-remove (a x)
  (if x
      (if (equal a x)
          '(zero)
        (if (listp a)
            (if (equal (car a) 'add1)
                (if (plus-remove (cadr a) x)
                    `(add1 ,(plus-remove (cadr a) x))
                  f)
              (if (equal (car a) 'plus)
                  (if (equal (cadr a) x)
                      (if (caddr a)
                          (caddr a)
                        '(zero))
                    (if (plus-remove (caddr a) x)
                        `(plus ,(cadr a) ,(plus-remove (caddr a) x))
                      f))
                f))
          f))
    f))

(prove-lemma plus-eval$ (rewrite)
  (implies (and (listp a)
                (equal (car a) 'plus))
           (equal (eval$ t a y)
                  (plus (eval$ t (cadr a) y)
                        (eval$ t (caddr a) y)))))

(prove-lemma plus-remove-ge (rewrite)
  (implies (plus-remove a x)
           (not (lessp (eval$ t a y) (eval$ t x y))))
  ((induct (plus-remove a x))))

(prove-lemma plus-remove-subtracts (rewrite)
  (implies (plus-remove a x)
           (equal (fix (eval$ t (plus-remove a x) y))
                  (difference (eval$ t a y)
                              (eval$ t x y))))
  ((induct (plus-remove a x))
   (disable fix-eval$
            times-eval$
            equal-eval$
            lessp-transpose-meta
            if-eval$)))

;;; find a term which occurs within both add1/plus nests a and b

(defn overlap? (a b)
  (if (plus-remove a b)
      b
    (if (listp b)
        (if (equal (car b) 'add1)
            (overlap? a (cadr b))
          (if (equal (car b) 'plus)
              (if (plus-remove a (cadr b))
                  (cadr b)
                (overlap? a (caddr b)))
            f))
      f)))

(prove-lemma overlap?-add1-is-symmetric (rewrite)
  (implies (and (equal (car b) 'add1)
                (overlap? (cadr b) a))
           (overlap? b a)))

(prove-lemma overlap?-plus-is-symmetric (rewrite)
  (implies (and (equal (car b) 'plus)
                (overlap? (caddr b) a))
           (overlap? b a)))

(prove-lemma overlap?-is-symmetric (rewrite)
  (implies (overlap? a b)
           (overlap? b a)))

(disable overlap?-add1-is-symmetric)

(disable overlap?-plus-is-symmetric)

(prove-lemma overlap?-implies-plus-remove (rewrite)
  (implies (overlap? a b)
           (and (plus-remove a (overlap? a b))
                (plus-remove b (overlap? a b)))))

;;; remove a cancelling pair of terms from add1/plus nests within equal

(defn p-cancel-equal (a)
  (if (and (equal (car a) 'equal)
           (overlap? (cadr a) (caddr a))
           (not (equal (cadr a) (caddr a))))
      (if (plus-remove (cadr a) (caddr a))
          `(and (numberp ,(caddr a))
                (equal (zero) (fix ,(plus-remove (cadr a) (caddr a)))))
        (if (plus-remove (caddr a) (cadr a))
            `(and (numberp ,(cadr a))
                  (equal (zero) (fix ,(plus-remove (caddr a) (cadr a)))))
          `(equal (fix ,(plus-remove (cadr a)
                                     (overlap? (cadr a) (caddr a))))
                  (fix ,(plus-remove (caddr a)
                                     (overlap? (cadr a) (caddr a)))))))
    a))

(prove-lemma eval$-overlap?-le (rewrite)
  (and (not (lessp (eval$ t a x)
                   (eval$ t (overlap? a b) x)))
       (not (lessp (eval$ t b x)
                   (eval$ t (overlap? a b) x))))
  ((induct (overlap? a b))))

(prove-lemma plus-remove-implies-numberp (rewrite)
  (implies (and (plus-remove a b)
                (not (equal a b)))
           (numberp (eval$ t a y))))

(prove-lemma overlap?-implies-numberp-1 (rewrite)
  (implies (and (overlap? a b)
                (not (plus-remove a b)))
           (numberp (eval$ t b y)))
  ((expand (overlap? a b))))

(prove-lemma overlap?-implies-numberp-2 (rewrite)
  (implies (and (overlap? b a)
                (not (plus-remove a b)))
           (numberp (eval$ t b y)))
  ((use (overlap?-is-symmetric (a a) (b b)))
   (disable overlap?-is-symmetric)))

(prove-lemma equal-plus-cancel-helper (rewrite)
  (IMPLIES (AND (NOT (EQUAL V Z))
                (PLUS-REMOVE Z V)
                (EQUAL (EVAL$ T V Y) (EVAL$ T Z Y)))
           (NUMBERP (EVAL$ T V Y)))
  ((use (plus-remove-implies-numberp (a z) (b v)))))

;;; Placed here because the following meta rule is preferred

(prove-lemma equal-add1 (rewrite)
  (and (equal (equal a (add1 b))
              (if (numberp b)
                  (and (numberp a)
                       (not (equal a 0))
                       (equal b (sub1 a)))
                (equal a 1)))
       (equal (equal (add1 b) a)
              (if (numberp b)
                  (and (numberp a)
                       (not (equal a 0))
                       (equal b (sub1 a)))
                (equal a 1)))))

;;; canonical (preferred)

(prove-lemma equal-plus-cancel-meta ((meta equal))
  (equal (eval$ t a y)
         (eval$ t (p-cancel-equal a) y))
  ((enable plus-commutes
           plus-commutes-nest-meta)
   (disable plus-commutes-meta
            plus-commutes-nest-meta
            difference-lessp
            equal-transpose-meta)))

(disable equal-plus-cancel-helper)

;;; remove a cancelling pair of terms from add1/plus nests within lessp

(defn p-cancel-lessp (a)
  (if (and (equal (car a) 'lessp)
           (overlap? (cadr a) (caddr a)))
      (if (plus-remove (cadr a) (caddr a))
          '(false)
        `(lessp ,(plus-remove (cadr a)
                              (overlap? (cadr a) (caddr a)))
                ,(plus-remove (caddr a)
                              (overlap? (cadr a) (caddr a)))))
    a))

(prove-lemma lessp-eval$ (rewrite)
  (implies (equal (car a) 'lessp)
           (equal (eval$ t a y)
                  (lessp (eval$ t (cadr a) y)
                         (eval$ t (caddr a) y)))))

(prove-lemma difference-is-monotonic (rewrite)
  (and (equal (lessp (difference a b)
                     (difference c b))
              (and (lessp a c)
                   (lessp b c)))
       (equal (lessp (difference c a)
                     (difference c b))
              (and (lessp b a)
                   (lessp b c)))))

(prove-lemma lessp-plus-cancel-helper (rewrite)
  (implies (overlap? a b)
           (equal (lessp (eval$ t (plus-remove a (overlap? a b)) y)
                         (eval$ t (plus-remove b (overlap? a b)) y))
                  (lessp (eval$ t a y)
                         (eval$ t b y))))
  ((use (difference-is-monotonic
         (a (eval$ t a y))
         (b (eval$ t (overlap? a b) y))
         (c (eval$ t b y)))
        (plus-remove-subtracts (a a) (x (overlap? a b)) (y y))
        (plus-remove-subtracts (a b) (x (overlap? a b)) (y y)))
   (disable difference-is-monotonic
            plus-remove-subtracts
            lessp-transpose-meta
            equal-transpose-meta
            difference-lessp
            equal-eval$
            fix-eval$
            lessp-eval$
            times-eval$
            if-eval$
            overlap?-is-symmetric
            overlap?-implies-numberp-1
            overlap?-implies-numberp-2)))

(prove-lemma lessp-plus-cancel-meta ((meta lessp))
  (equal (eval$ t a y)
         (eval$ t (p-cancel-lessp a) y)))

(disable plus-remove-ge)
(disable plus-remove-subtracts)
(disable overlap?-implies-plus-remove)
(disable eval$-overlap?-le)
(disable lessp-plus-cancel-helper)
(disable overlap?-is-symmetric)
(disable plus-remove-implies-numberp)
(disable overlap?-implies-numberp-1)
(disable overlap?-implies-numberp-2)

(prove-lemma lessp-odometer-helper nil
  (implies (and (not (lessp z x))
                (not (lessp z y)))
           (equal (lessp (plus x (times a z))
                         (plus y (times b z)))
                  (and (numberp z)
                       (not (equal z 0))
                       (not (lessp b a))
                       (or (lessp x y)
                           (and (lessp a b)
                                (or (lessp x z)
                                    (and (numberp y)
                                         (not (equal y 0)))))
                           (lessp a (sub1 b))))))
  ((induct (difference b a)) ; for speed
   (disable lessp-times-single-linear
            sub1-plus
            sub1-times
            equal-plus-cancel-meta
            no-divisors-of-zero
            plus-associates-right
            plus-commutes-meta)))

(prove-lemma lessp-odometer-simple (rewrite)
  (implies (and (lessp a b)
                (equal (remainder c b) 0)
                (equal (remainder d b) 0))
           (and (equal (lessp (plus a c) d)
                       (lessp c d))
                (equal (lessp (plus c a) d)
                       (lessp c d))
                (equal (lessp d (plus a c))
                       (if (or (not (numberp a)) (equal a 0))
                           (lessp d c)
                         (not (lessp c d))))
                (equal (lessp d (plus c a))
                       (if (or (not (numberp a)) (equal a 0))
                           (lessp d c)
                         (not (lessp c d))))))
  ((use (lessp-odometer-helper (z b) (x a) (a (quotient c b))
                               (b (quotient d b)) (y 0))
        (lessp-odometer-helper (z b) (x 0) (a (quotient d b))
                               (b (quotient c b)) (y a)))
   (disable sub1-times
            times-plus
            times-associates-right
            times-commutes-nest
            sub1-plus
            lessp-times-both-linear
            difference-plus-arg1
            equal-plus-cancel-meta
            lessp-times-single-linear
            quotient-lessp-linear
            difference-lessp
            lessp-times-linear
            no-divisors-of-zero
            remainder-lessp-linear
            difference-not-lessp)))


(prove-lemma lessp-odometer (rewrite)
  (let ((rhs (and (numberp z)
                  (not (equal z 0))
                  (not (lessp b a))
                  (or (lessp x y)
                      (and (lessp a b)
                           (or (lessp x z)
                               (and (numberp y)
                                    (not (equal y 0)))))
                      (lessp a (sub1 b))))))
    (implies (and (not (lessp z x))
                  (not (lessp z y)))
             (and (equal (lessp (plus x (times a z))
                                (plus y (times b z)))
                         rhs)
                  (equal (lessp (plus x (times z a))
                                (plus y (times b z)))
                         rhs)
                  (equal (lessp (plus x (times a z))
                                (plus y (times z b)))
                         rhs)
                  (equal (lessp (plus x (times z a))
                                (plus y (times z b)))
                         rhs)
                  (equal (lessp (plus (times a z) x)
                                (plus y (times b z)))
                         rhs)
                  (equal (lessp (plus (times z a) x)
                                (plus y (times b z)))
                         rhs)
                  (equal (lessp (plus (times a z) x)
                                (plus y (times z b)))
                         rhs)
                  (equal (lessp (plus (times z a) x)
                                (plus y (times z b)))
                         rhs)
                  (equal (lessp (plus x (times a z))
                                (plus (times b z) y))
                         rhs)
                  (equal (lessp (plus x (times z a))
                                (plus (times b z) y))
                         rhs)
                  (equal (lessp (plus x (times a z))
                                (plus (times z b) y))
                         rhs)
                  (equal (lessp (plus x (times z a))
                                (plus (times z b) y))
                         rhs)
                  (equal (lessp (plus (times a z) x)
                                (plus (times b z) y))
                         rhs)
                  (equal (lessp (plus (times z a) x)
                                (plus (times b z) y))
                         rhs)
                  (equal (lessp (plus (times a z) x)
                                (plus (times z b) y))
                         rhs)
                  (equal (lessp (plus (times z a) x)
                                (plus (times z b) y))
                         rhs))))
  ((use (lessp-odometer-helper (a a) (b b) (x x) (y y) (z z)))
   (disable times
            lessp
            dichotomy
            lessp-times-linear
            lessp-times-single-linear
            lessp-odometer-simple
            difference-times-arg1-simplest)))

(prove-lemma lessp-half-odometer-left (rewrite)
  (let ((rhs (and (numberp z)
                  (not (equal z 0))
                  (not (lessp b a))
                  (or (and (numberp y)
                           (not (equal y 0)))
                      (lessp a b)))))
    (implies (not (lessp z y))
             (and
              (equal (lessp (times a z) (plus y (times b z))) rhs)
              (equal (lessp (times z a) (plus y (times b z))) rhs)
              (equal (lessp (times a z) (plus y (times z b))) rhs)
              (equal (lessp (times z a) (plus y (times z b))) rhs)
              (equal (lessp (times a z) (plus (times b z) y)) rhs)
              (equal (lessp (times z a) (plus (times b z) y)) rhs)
              (equal (lessp (times a z) (plus (times z b) y)) rhs)
              (equal (lessp (times z a) (plus (times z b) y)) rhs)
              )))
  ((use (lessp-odometer (a a) (b b) (x 0) (y y) (z z)))
   (disable lessp-odometer
            sub1-times
            sub1-plus
            no-divisors-of-zero
            plus-is-0)))

(prove-lemma lessp-half-odometer-right (rewrite)
  (let ((rhs (and (numberp z)
                  (not (equal z 0))
                  (lessp a b)
                  (or (not (equal z x))
                      (lessp a (sub1 b))))))
    (implies (not (lessp z x))
             (and
              (equal (lessp (plus x (times a z)) (times b z)) rhs)
              (equal (lessp (plus x (times z a)) (times b z)) rhs)
              (equal (lessp (plus x (times a z)) (times z b)) rhs)
              (equal (lessp (plus x (times z a)) (times z b)) rhs)
              (equal (lessp (plus (times a z) x) (times b z)) rhs)
              (equal (lessp (plus (times z a) x) (times b z)) rhs)
              (equal (lessp (plus (times a z) x) (times z b)) rhs)
              (equal (lessp (plus (times z a) x) (times z b)) rhs)
              ))))

(prove-lemma lessp-quarter-odometer-left (rewrite)
  (let ((rhs1 (if (or (not (numberp c))
                      (equal c 0))
                  (lessp b a)
                (if (or (equal (sub1 c) 0)
                        (not (numberp b))
                        (equal b 0))
                    (and (numberp a)
                         (not (equal a 0)))
                  t)))
        (rhs2 (if (or (not (numberp c))
                      (equal c 0)
                      (not (numberp d))
                      (equal d 0))
                  (lessp b a)
                (if (or (not (numberp b))
                        (equal b 0)
                        (and (equal (sub1 c) 0)
                             (equal (sub1 d) 0)))
                    (and (numberp a)
                         (not (equal a 0)))
                  t))))
    (and
     (equal (lessp b (plus a (times b c))) rhs1)
     (equal (lessp b (plus (times b c) a)) rhs1)
     (equal (lessp b (plus a (times c b))) rhs1)
     (equal (lessp b (plus (times c b) a)) rhs1)
     (equal (lessp b (plus a (times c (times d b)))) rhs2)
     (equal (lessp b (plus a (times c (times b d)))) rhs2)
     (equal (lessp b (plus (times c (times d b)) a)) rhs2)
     (equal (lessp b (plus (times c (times b d)) a)) rhs2)))
  ((induct (difference a b))
   (disable plus-commutes-meta
            plus-commutes-nest-meta
            lessp-times-single-linear
            sub1-times)))


(prove-lemma lessp-quarter-odometer-right (rewrite)
  (let ((rhs1 (and (lessp a b)
                   (or (not (numberp c))
                       (equal c 0))))
        (rhs2 (and (lessp a b)
                   (or (not (numberp c))
                       (equal c 0)
                       (not (numberp d))
                       (equal d 0)))))
    (and (equal (lessp (plus a (times b c)) b) rhs1)
         (equal (lessp (plus (times b c) a) b) rhs1)
         (equal (lessp (plus a (times c b)) b) rhs1)
         (equal (lessp (plus (times c b) a) b) rhs1)
         (equal (lessp (plus a (times c (times d b))) b) rhs2)
         (equal (lessp (plus (times c (times d b)) a) b) rhs2)
         (equal (lessp (plus a (times c (times b d))) b) rhs2)
         (equal (lessp (plus (times c (times b d)) a) b) rhs2)))
  ((induct (difference a b))
   (disable difference-times-arg1-simplest
            lessp-times-single-linear
            difference-times-arg1
            sub1-times
            plus-commutes-meta
            plus-commutes-nest-meta
            lessp-odometer-simple
            difference-times-arg1-simpler)))

;;; This appears costly, but the free variable b may make it efficient.

(prove-lemma equal-odometer-simple (rewrite)
  (let ((rhs (and (or (not (numberp a)) (equal a 0))
                  (numberp d)
                  (or (equal c d)
                      (and (equal d 0)
                           (not (numberp c)))))))
    (implies (and (lessp a b)
                  (equal (remainder c b) 0)
                  (equal (remainder d b) 0))
             (and (equal (equal (plus a c) d) rhs)
                  (equal (equal (plus c a) d) rhs)
                  (equal (equal d (plus a c)) rhs)
                  (equal (equal d (plus c a)) rhs))))
  ((induct (lessp-quotient-ind c d b))
   (disable difference-lessp
            equal-transpose-meta
            lessp-transpose-meta
            difference-0
            sub1-difference
            plus-commutes-meta)))

(prove-lemma equal-odometer (rewrite)
  (implies (and (lessp a z)
                (lessp b z))
           (and (equal (equal (plus a (times z x))
                              (plus b (times z y)))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times z x) a)
                              (plus b (times z y)))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus a (times z x))
                              (plus (times z y) b))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times z x) a)
                              (plus (times z y) b))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus a (times x z))
                              (plus b (times z y)))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times x z) a)
                              (plus b (times z y)))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus a (times x z))
                              (plus (times z y) b))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times x z) a)
                              (plus (times z y) b))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus a (times z x))
                              (plus b (times y z)))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times z x) a)
                              (plus b (times y z)))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus a (times z x))
                              (plus (times y z) b))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times z x) a)
                              (plus (times y z) b))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus a (times x z))
                              (plus b (times y z)))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times x z) a)
                              (plus b (times y z)))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus a (times x z))
                              (plus (times y z) b))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times x z) a)
                              (plus (times y z) b))
                       (and (equal (fix a) (fix b))
                            (equal (fix x) (fix y))))))
  ((induct (difference x y))
   (disable equal-odometer-simple
            lessp-times-both-linear
            times-plus
            sub1-times
            no-divisors-of-zero
            times-zerop
            plus-is-0
            equal-plus-cancel-meta
            lessp-times-single-linear)))

(prove-lemma equal-half-odometer (rewrite)
  (implies (lessp b z)
           (and (equal (equal (times z x)
                              (plus b (times z y)))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (times z x)
                              (plus (times z y) b))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (times x z)
                              (plus b (times z y)))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (times x z)
                              (plus (times z y) b))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (times z x)
                              (plus b (times y z)))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (times z x)
                              (plus (times y z) b))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (times x z)
                              (plus b (times y z)))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (times x z)
                              (plus (times y z) b))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))

                (equal (equal (plus b (times z y))
                              (times z x))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times z y) b)
                              (times z x))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (plus b (times z y))
                              (times x z))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times z y) b)
                              (times x z))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (plus b (times y z))
                              (times z x))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times y z) b)
                              (times z x))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (plus b (times y z))
                              (times x z))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))
                (equal (equal (plus (times y z) b)
                              (times x z))
                       (and (or (not (numberp b))
                                (equal b 0))
                            (equal (fix x) (fix y))))))
  ((use (equal-odometer (a 0) (b b) (x x) (y y) (z z)))
   (disable equal-odometer
            equal-odometer-simple
            difference-times-arg1-simplest
            lessp-times-cancel-meta
            sub1-times)))

(prove-lemma equal-quarter-odometer (rewrite)
  (let ((rhs1 (and (numberp b)
                   (if (or (not (numberp c))
                           (equal c 0))
                       (if (numberp a)
                           (equal a b)
                         (equal b 0))
                     (if (equal (sub1 c) 0)
                         (or (not (numberp a))
                             (equal a 0))
                       (and (equal b 0)
                            (or (not (numberp a))
                                (equal a 0)))))))
        (rhs2 (and (numberp b)
                   (if (or (not (numberp c))
                           (equal c 0)
                           (not (numberp d))
                           (equal d 0))
                       (if (numberp a)
                           (equal a b)
                         (equal b 0))
                     (if (and (equal (sub1 c) 0)
                              (equal (sub1 d) 0))
                         (or (not (numberp a))
                             (equal a 0))
                       (and (equal b 0)
                            (or (not (numberp a))
                                (equal a 0))))))))
    (and
     (equal (equal b (plus a (times b c))) rhs1)
     (equal (equal b (plus (times b c) a)) rhs1)
     (equal (equal b (plus a (times c b))) rhs1)
     (equal (equal b (plus (times c b) a)) rhs1)
     (equal (equal (plus a (times b c)) b) rhs1)
     (equal (equal (plus (times b c) a) b) rhs1)
     (equal (equal (plus a (times c b)) b) rhs1)
     (equal (equal (plus (times c b) a) b) rhs1)

     (equal (equal b (plus a (times c (times d b)))) rhs2)
     (equal (equal b (plus a (times c (times b d)))) rhs2)
     (equal (equal b (plus (times c (times d b)) a)) rhs2)
     (equal (equal b (plus (times c (times b d)) a)) rhs2)
     (equal (equal (plus a (times c (times d b))) b) rhs2)
     (equal (equal (plus a (times c (times b d))) b) rhs2)
     (equal (equal (plus (times c (times d b)) a) b) rhs2)
     (equal (equal (plus (times c (times b d)) a) b) rhs2)))
  ((disable sub1-times
            sub1-plus
            times-associates-right
            lessp-facts
            plus-commutes-meta
            plus-commutes-nest-meta
            times-plus)))

;;; Provide a meta rule to cancel complementary terms within a plus nest.

(prove-lemma difference-eval$ (rewrite)
  (implies (and (listp a)
                (equal (car a) 'difference))
           (equal (eval$ t a y)
                  (difference (eval$ t (cadr a) y)
                              (eval$ t (caddr a) y)))))

;;; parses a summand, returning a list of (a . b)'s, where "a" is a subtrahend
;;; and "b" is either nil or a multiplier of the subtrahend.  We assume that
;;; x is a summand in normal form.  We treat only the simplest and most
;;; commonly occurring cases, i.e. we ignore times nests and do not expand
;;; products of differences.  The latter simplification is justified by
;;; reducing the complexity of rewrites, and the former has the weak
;;; justification of possibly improving the run time performance of meta-plus
;;; and certainly reducing the programming complexity of this meta rule.

(defn parse-term-neg (x)
  (if (equal (car x) 'difference)
      (list (list (caddr x))) ; ? - a
    (if (equal (car x) 'times)
        (if (equal (caadr x) 'difference)
            (if (equal (caaddr x) 'difference)
                (list (cons (caddadr x) (caddr x)) ; (? - a) * b
                      (cons (caddaddr x) (cadr x))) ; b * (? - a)
              (list (cons (caddadr x) (caddr x))))  ; (? - a) * b
          (if (equal (caaddr x) 'difference)
              (list (cons (caddaddr x) (cadr x))) ; b * (? - a)
            nil))
      nil)))

;;; Extract a list of all (subtrahend)'s and (subtrahend . multiplier)'s
;;; from the plus nest x.  We assume that x is in normal form.

(defn collect-neg (x)
  (if (listp x)
      (if (equal (car x) 'plus)
          (append (parse-term-neg (cadr x))
                  (collect-neg (caddr x)))
        (parse-term-neg x))
    nil))

;;; Find a pair (a . b) from y such that a * b (or just "a" if b is nil)
;;; occurs as a summand or minuend (after distributing times over difference)
;;; in x.  flg is used to prevent full exploration of plus nests in the first
;;; argument of plus (which should not happen if x is normalized).
;;; We do not treat the commutative version of (a . b) because the resulting
;;; rewrite would introduce an inversion of the nesting order.

(defn find-comp (flg x y)
  (if (member (list x) y)
      (list x) ; a
    (if (listp x)
        (if (and (equal (car x) 'difference)
                 (member (list (cadr x)) y))
            (list (cadr x)) ; a - ?
          (if (equal (car x) 'times)
              (if (member (cons (cadr x) (caddr x)) y)
                  (cons (cadr x) (caddr x)) ; a * b
                (if (member (cons (caddr x) (cadr x)) y)
                    (cons (caddr x) (cadr x)) ; b * a
                  (if (and (equal (caadr x) 'difference)
                           (member (cons (cadadr x) (caddr x)) y))
                      (cons (cadadr x) (caddr x)) ; (a - ?) * b
                    (if (and (equal (caaddr x) 'difference)
                             (member (cons (cadaddr x) (cadr x)) y))
                        (cons (cadaddr x) (cadr x)) ; b * (a - ?)
                      f))))
            (if (and flg
                     (equal (car x) 'plus))
                (if (find-comp f (cadr x) y)
                    (find-comp f (cadr x) y)
                  (find-comp t (caddr x) y))
              f)))
      f)))

;;; recognizer predicate for complementary positive term
;;; (We do not use is-pos? within find-comp for efficiency reasons.)
;;; x is a summand, y is an (a . b) pair

(defn is-pos? (x y)
  (and (listp y)
       (if (equal (cdr y) nil)
           (or (equal x (car y))
               (equal x `(difference ,(car y) ,(caddr x))))
         (or (equal x `(times ,(car y) ,(cdr y)))
             (equal x `(times ,(cdr y) ,(car y)))
             (equal x `(times (difference ,(car y) ,(caddadr x)) ,(cdr y)))
             (equal x `(times ,(cdr y)
                              (difference ,(car y) ,(caddaddr x))))))))

;;; Identify first complementary positive term.
;;; x is a plus nest, y is an (a . b) pair

(defn first-pos (x y)
  (if (is-pos? x y)
      x
    (if (and (listp x)
             (equal (car x) 'plus))
        (if (is-pos? (cadr x) y)
            (cadr x)
          (first-pos (caddr x) y))
      f)))

;;; delete the first positive occurrence of y from the plus nest x

(defn delete-pos (x y)
  (if (is-pos? x y)
      '(zero)
    (if (and (listp x) (equal (car x) 'plus))
        (if (is-pos? (cadr x) y)
            (caddr x)
          (if (is-pos? (caddr x) y)
              (cadr x)
            (list 'plus (cadr x) (delete-pos (caddr x) y))))
      x)))

(prove-lemma delete-pos-subtracts (rewrite)
  (equal (plus (eval$ t (first-pos x y) a)
               (eval$ t (delete-pos x y) a))
         (fix (eval$ t x a)))
  ((induct (first-pos x y))
   (disable is-pos?)))

;;; recognizer predicate for negative complementary term
;;; x is a summand, y is an (a . b) pair

(defn is-neg? (x y)
  (and (listp y)
       (if (equal (cdr y) nil)
           (equal x `(difference ,(cadr x) ,(car y)))
         (or (equal x `(times (difference ,(cadadr x) ,(car y)) ,(cdr y)))
             (equal x `(times ,(cdr y) (difference ,(cadaddr x) ,(car y))))))))

;;; Identify the first negative occurrence of y in the plus nest x.  We assume
;;; that x is the result of applying delete-pos.

(defn first-neg (x y)
  (if (is-neg? x y)
      x
    (if (and (listp x) (equal (car x) 'plus))
        (if (is-neg? (cadr x) y)
            (cadr x)
          (first-neg (caddr x) y))
      '(zero))))
; We do not return f here because delete-pos may have eliminated the negative
; occurrence as well.

;;; Delete the first negative occurrence of y from the plus nest x.

(defn delete-neg (x y)
  (if (is-neg? x y)
      '(zero)
    (if (and (listp x) (equal (car x) 'plus))
        (if (is-neg? (cadr x) y)
            (caddr x)
          (if (is-neg? (caddr x) y)
              (cadr x)
            (list 'plus (cadr x) (delete-neg (caddr x) y))))
      x))) ; y should be such that this does not happen

(prove-lemma delete-neg-subtracts (rewrite)
  (and (equal (plus (eval$ t (first-neg x y) a)
                    (eval$ t (delete-neg x y) a))
              (fix (eval$ t x a)))
       (equal (plus (eval$ t (delete-neg x y) a)
                    (eval$ t (first-neg x y) a))
              (fix (eval$ t x a))))
  ((induct (first-neg x y))
   (disable is-neg?)))

;;; Compose a new reduced term equivalent to x + y.
;;; We use the orientation (lessp ,(cadr y) ,(caddr y)) to encourage function
;;; expansion.  We assume that y is generated from first-neg.

(defn compose (x y)               ; x + y
  (if (equal (car y) 'difference) ; x + (? - ?)
      (if (equal x (caddr y))     ; x + (? - x)
          `(if (lessp ,(cadr y) ,(caddr y))
               (fix ,x)
             (fix ,(cadr y)))
        (if (and (equal (car x) 'difference) ; (? - ?) + (? - ?)
                 (equal (cadr x) (caddr y))) ; (a - ?) + (? - a)
            `(if (lessp ,(cadr y) ,(caddr y))
                 ,x
               (if (lessp ,(cadr x) ,(caddr x))
                   ,y
                 (difference ,(cadr y) ,(caddr x))))
          `(plus ,x ,y))) ; should not happen
    (if (and (equal (car y) 'times) (equal (car x) 'times))
        (if (equal (caadr y) 'difference) ; (? * ?) + ((? - ?) * ?)
            (if (or (equal x `(times ,(caddadr y) ,(caddr y))) ; (a * b) +
                    (equal x `(times ,(caddr y) ,(caddadr y)))) ; ((? - a) * b)
                `(if (lessp ,(cadadr y) ,(caddadr y))
                     ,x
                   (times ,(cadadr y) ,(caddr y)))
              (if (and (equal (caadr x) 'difference) ; ((b - ?) * a) +
                       (equal (caddr x) (caddr y))   ; ((? - b) * a)
                       (equal (cadadr x) (caddadr y)))
                  `(if (lessp ,(cadadr y) ,(caddadr y))
                       ,x
                     (if (lessp ,(cadadr x) ,(caddadr x))
                         ,y
                       (times (difference ,(cadadr y) ,(caddadr x))
                              ,(caddr y))))
                (if (and (equal (caaddr x) 'difference) ; (a * (b - ?)) +
                         (equal (cadr x) (caddr y)) ; ((? - b) * a)
                         (equal (cadaddr x) (caddadr y)))
                    `(if (lessp ,(cadadr y) ,(caddadr y))
                         ,x
                       (if (lessp ,(cadaddr x) ,(caddaddr x))
                           ,y
                         (times (difference ,(cadadr y) ,(caddaddr x))
                                ,(caddr y))))
                  `(plus ,x ,y))))     ; should not happen
          (if (equal (caaddr y) 'difference) ; (? * ?) + (? * (? - ?))
              (if (or (equal x `(times ,(caddaddr y) ,(cadr y))) ; (a * b) +
                      (equal x `(times ,(cadr y) ,(caddaddr y)))) ; b * (? - a)
                  `(if (lessp ,(cadaddr y) ,(caddaddr y))
                       ,x
                     (times ,(cadr y) ,(cadaddr y)))
                (if (and (equal (caadr x) 'difference) ; ((b - ?) * a) +
                         (equal (caddr x) (cadr y))    ; (a * (? - b))
                         (equal (caddaddr y) (cadadr x)))
                    `(if (lessp ,(cadaddr y) ,(caddaddr y))
                         ,x
                       (if (lessp ,(cadadr x) ,(caddadr x))
                           ,y
                         (times ,(cadr y)
                                (difference ,(cadaddr y) ,(caddadr x)))))
                  (if (and (equal (caaddr x) 'difference) ; (a * (b - ?)) +
                           (equal (cadr x) (cadr y)) ; (a * (? - b))
                           (equal (cadaddr x) (caddaddr y)))
                      `(if (lessp ,(cadaddr y) ,(caddaddr y))
                           ,x
                         (if (lessp ,(cadaddr x) ,(caddaddr x))
                             ,y
                           (times ,(cadr y)
                                  (difference ,(cadaddr y) ,(caddaddr x)))))
                    `(plus ,x ,y)))) ; should not happen
            `(plus ,x ,y)))          ; should not happen
      (if (equal y '(zero)) ; only arises if difference-lessp is disabled
          (if (and (equal (car x) 'difference)
                   (equal (cadr x) (caddr x)))
              '(zero)
            `(fix ,x))
        `(plus ,x ,y))))) ; should not happen

(prove-lemma compose-helper (rewrite)
  (and (equal (plus (times d b) (times d (difference a b)))
              (if (lessp a b)
                  (times d b)
                (times d a)))
       (equal (plus (times b d) (times d (difference a b)))
              (if (lessp a b)
                  (times d b)
                (times d a)))))

(prove-lemma compose-is-correct (rewrite)
  (equal (eval$ t (compose x y) a)
         (plus (eval$ t x a) (eval$ t y a)))
  ((enable plus-commutes
           plus-commutes-nest)
   (disable eval$
            plus-commutes-meta
            plus-commutes-nest-meta
            plus-difference-commutes-meta
            lessp-eval$
            if-eval$
            equal-eval$
            fix-eval$
            equal-half-odometer
            difference-lessp
            equal-transpose-meta
            lessp-transpose-meta
            dichotomy
            difference-eval$
            plus-eval$
            sub1-times
            sub1-difference
            lessp-times-single-linear
            difference-not-lessp)))

;;; Remove complementary pair from plus nest.

(defn diff-cancel (a)
  (let ((y (find-comp t a (collect-neg a))))
    (if y
        (let ((x (delete-pos a y)))
          `(plus
            ,(compose (first-pos a y) (first-neg x y))
            ,(delete-neg x y)))
      a)))

(prove-lemma meta-plus-helper-1 (rewrite)
  (equal (plus (eval$ t (first-pos a y) b)
               (eval$ t (delete-neg (delete-pos a y) y) b)
               (eval$ t (first-neg (delete-pos a y) y) b))
         (fix (eval$ t a b)))
  ((induct (first-pos a y))
   (disable is-pos?
            plus-commutes-meta
            plus-commutes-nest-meta
            lessp-eval$
            if-eval$
            times-eval$
            equal-eval$
            fix-eval$)))

(prove-lemma meta-plus-helper-2 (rewrite)
  (implies (find-comp t a (collect-neg a))
           (numberp (eval$ t a b)))
  ((induct (collect-neg a))))

(disable delete-neg-subtracts)

(prove-lemma meta-plus ((meta plus))
  (equal (eval$ t a b)
         (eval$ t (diff-cancel a) b))
  ((enable plus-commutes
           plus-commutes-nest)
   (disable plus-commutes-meta
            plus-commutes-nest-meta
            compose)))

(disable delete-pos-subtracts)
(disable compose-helper)
(disable compose-is-correct)
(disable meta-plus-helper-1)
(disable meta-plus-helper-2)

(prove-lemma quotient-is-unique-temp nil
  (implies (lessp c b)
           (equal (quotient (plus c (times a b)) b)
                  (if (numberp a) a 0)))
  ((induct (times a b))))

;;; Add quotient and remainder to nesting order as follows
;;; add1, plus, times, remainder, quotient, difference, sub1

;;; J does not like the idea of introducing 1 less than the modulus/dividend
;;; in proofs where the modulus is constant.  My only come back was that this
;;; allows more possibilities for induction (say inducting on the modulus).
;;; J then proved the only example of this within the present file
;;; (lessp-quotient-arg2-linear) without inducting on the modulus.

(prove-lemma quotient-add1-arg2-helper-1 nil
  (implies (and (not (lessp (sub1 q) r))
                (lessp r b)
                (equal a (plus r (times b q)))
                (not (lessp a (plus (sub1 q) (times b (sub1 q))))))
           (equal (quotient a (add1 b))
                  (sub1 q)))
  ((use (quotient-is-unique-temp
         (a (sub1 q))
         (b (add1 b))
         (c (difference (plus b r) (sub1 q)))))
   (disable lessp-transpose-meta
            difference-plus-arg1
            difference-plus-arg2
            difference-lessp
            dichotomy
            equal-transpose-meta
            lessp-times-single-linear
            equal-odometer-simple
            lessp-quotient-arg1-linear
            sub1-times
            lessp-times-both-linear
            difference-add1
            times-plus
            no-divisors-of-zero
            difference-times-arg1-simplest
            lessp-times-cancel-meta
            lessp-times-linear
            plus-associates-right
            difference-not-lessp
            difference-times-arg1-meta
            remainder-lessp-linear)))

(prove-lemma quotient-add1-arg2-helper-2 nil
  (implies (and (numberp q)
                (lessp (sub1 q) r)
                (lessp r b)
                (equal a (plus r (times b q)))
                (not (lessp a (plus (sub1 q) (times b (sub1 q))))))
           (equal (quotient a (add1 b))
                  q))
  ((use (quotient-is-unique-temp (a q)
                                 (b (add1 b))
                                 (c (difference r q))))
   (disable lessp-transpose-meta
            lessp-odometer-simple
            equal-odometer-simple
            difference-times-arg1-simplest
            lessp-quotient-arg1-linear
            difference-times-arg1
            sub1-times
            sub1-plus
            difference-times-arg1-simpler
            no-divisors-of-zero
            plus-is-0
            difference-plus-arg1
            difference-not-lessp)))

(prove-lemma remainder-as-quotient nil
  (equal (remainder a b)
         (difference a (times b (quotient a b))))
  ((use (quotient-remainder-rewrite (a a) (b b)))
   (disable quotient-remainder-rewrite
            quotient-remainder
            quotient
            remainder
            difference-times-arg2)))

;;; quotient-add1-arg2 was derived using the following calculations:
;;;
;;; Let a = q*b + r = p*(b + 1) + s, where r < b and s < b + 1, and p = q - k.
;;;
;;; p = q - k <=> q*b + r = (q - k)*(b + 1) + s
;;;           <=> r + k*(b + 1) = s + q
;;;           <=> r + (k - 1)*(b + 1) < q <= r + k*(b + 1) for k > 0, and
;;;               q <= r for k = 0
;;;
;;; The last equivalence allows us to define k in terms of q and r.  We treat
;;; only the case k = 0 and k = 1 in the lemma quotient-add1-arg2.  In either
;;; case we have
;;;
;;; q <= r + b + 1, or equivalently
;;;
;;; (b + 1)*(q - 1) <= a, or equivalently
;;;
;;; a <= (b + 1)*(r + b)
;;;
;;; Since we know that the right hand side of quotient-add1-arg2 will involve
;;; q - 1, we choose (b + 1)*(q - 1) <= a as the hypothesis rather than the
;;; expression involving r.  This avoids having to simplify (remainder a b)
;;; in the hypothesis and (quotient (difference a b) b) in the conclusion.
;;; Instead, using the temporary variable qdab, we simplify
;;; (quotient (difference a b) b) only once.

;;; canonical

(prove-lemma quotient-add1-arg2 (rewrite)
  (implies (and (equal qdab (quotient (difference a b) b))
                (not (lessp a (plus qdab (times b qdab)))))
           (equal (quotient a (add1 b))
                  (if (lessp (plus b qdab (times b qdab)) a)
                      (if (or (not (numberp b))
                              (equal b 0))
                          a
                        (add1 qdab))
                    qdab)))
  ((use (quotient-add1-arg2-helper-1 (a a)
                                     (b b)
                                     (r (difference (difference a b)
                                                    (times b qdab)))
                                     (q (add1 qdab)))
        (quotient-add1-arg2-helper-2 (a a)
                                     (b b)
                                     (r (difference (difference a b)
                                                    (times b qdab)))
                                     (q (add1 qdab)))
        (remainder-as-quotient (a a) (b b)))
   (disable lessp-transpose-meta
            equal-transpose-meta
            difference-lessp
            lessp-quotient-arg1-linear
            dichotomy
            lessp-times-single-linear
            lessp-odometer-simple
            equal-odometer-simple
            sub1-difference
            times-plus
            lessp-times-both-linear
            times-commutes-nest
            difference-plus-arg1
            difference-not-lessp
            difference-times-arg2-preferred)))

;;; remainder-add1-arg2 uses the same calculations as quotient-add1-arg2.
;;; In particular k is defined by
;;;
;;; r + k*(b + 1) = s + q
;;;
;;; r < q <=> k > 0
;;;

;;; canonical

(prove-lemma remainder-add1-arg2 (rewrite)
  (implies (and (equal qdab (quotient (difference a b) b))
                (not (lessp a (plus qdab (times b qdab)))))
           (equal (remainder a (add1 b))
                  (if (lessp (plus b qdab (times b qdab)) a)
                      (if (or (not (numberp b))
                              (equal b 0))
                          0
                        (remainder
                         (difference (sub1 a) qdab) b))
                    (if (lessp a b)
                        (if (numberp a) a 0)
                      (difference b (difference qdab
                                                (remainder a b)))))))
  ((use (remainder-as-quotient (a a) (b (add1 b)))
        (remainder-as-quotient (a a) (b b))
        (difference-remainder-arg1 (a a) (b (quotient a b)) (c b)))
   (disable difference-remainder-arg1
            difference-times-arg2 ; needed
            lessp-transpose-meta
            equal-transpose-meta
            difference-lessp
            lessp-times-single-linear
            dichotomy
            difference-difference-arg1-commutes-meta
            lessp-quotient-arg1-linear
            times-plus
            difference-times-arg2-preferred
            sub1-difference
            sub1-plus
            difference-not-lessp
            remainder-lessp-linear
            lessp-times-both-linear
            sub1-times)))

;;; We include the following lemma to cover alternative formulations of the
;;; hypothesis of remainder-add1-arg2

(prove-lemma remainder-add1-arg2-trigger (rewrite)
  (implies (not (lessp (plus b (remainder a b))
                       (quotient (difference a b) b)))
           (equal (lessp
                   a
                   (plus
                    (quotient (difference a b) b)
                    (times b (quotient (difference a b) b))))

                  f))
  ((disable lessp-transpose-meta
            difference-lessp
            lessp-times-single-linear
            times-plus
            sub1-times)))

;;; canonical

(prove-lemma quotient-add1-arg2-trigger (rewrite)
  (implies (lessp a (plus b b (times b b)))
           (equal
            (lessp a (plus (quotient (difference a b) b)
                           (times b (quotient (difference a b) b))))
            f))
  ((induct (quotient a b))
   (disable lessp-transpose-meta
            equal-transpose-meta
            lessp-times-single-linear
            times-associates-right
            sub1-times
            difference-lessp
            lessp-times-both-linear
            equal-odometer-simple
            times-commutes-nest
            dichotomy
            difference-plus-arg2
            lessp-odometer-simple
            sub1-difference
            equal-plus-cancel-meta
            difference-difference-arg1-commutes-meta
            difference-not-lessp)))

(prove-lemma quotient-add1-arg1-helper nil
  (equal (quotient (add1 a) b)
         (if (or (not (numberp b)) (equal b 0))
             0
           (if (equal (remainder a b) (sub1 b))
               (add1 (quotient a b))
             (quotient a b))))
  ((disable lessp-transpose-meta
            lessp-times-single-linear
            quotient-add1-arg2
            difference-plus-arg1
            equal-transpose-meta
            sub1-difference
            difference-times-arg2
            difference-plus-arg2
            sub1-times
            dichotomy
            difference-times-arg2-preferred
            equal-quarter-odometer
            no-divisors-of-zero
            sub1-plus
            equal-times-cancel-meta
            quotient-difference-arg1)))

;;; canonical (qab avoids repeated rewriting)

(prove-lemma quotient-add1-arg1 (rewrite)
  (implies (equal qab (quotient a b))
           (equal (quotient (add1 a) b)
                  (if (or (not (numberp b)) (equal b 0))
                      0
                    (if (equal (remainder a b) (sub1 b))
                        (add1 qab)
                      qab))))
  ((use (quotient-add1-arg1-helper (a a) (b b)))))

;;; canonical (preferred)

(prove-lemma remainder-add1-arg2-simple (rewrite)
  (and (equal (remainder (plus a (times b a)) (add1 b)) 0)
       (equal (remainder (plus a (times a b)) (add1 b)) 0))
  ((use (times-add1 (a a) (b b))) ; for speed
   (disable times-add1
            remainder-add1-arg2
            plus-associates-right
            plus-commutes
            difference-lessp
            lessp-times-single-linear
            sub1-times
            lessp-times-cancel-meta
            difference-times-arg1-simplest
            difference-times-arg1
            difference-plus-arg2
            difference-times-arg2
            lessp-transpose-meta
            equal-transpose-meta)))

(prove-lemma remainder-plus-arg1-helper (rewrite)
  (equal (remainder (plus c d (times b a)) b)
         (remainder (plus c d) b))
  ((induct (times a b))
   (disable dichotomy
            times-plus
            sub1-times
            difference-times-arg1-simplest
            lessp-times-single-linear
            lessp-transpose-meta
            difference-lessp
            plus-is-0
            sub1-plus
            difference-times-arg1
            equal-transpose-meta
            sub1-difference)))

(prove-lemma remainder-plus-arg1-helper-1 nil
  (equal (remainder (plus a b) c)
         (if (lessp (plus (remainder a c)
                          (remainder b c))
                    c)
             (plus (remainder a c) (remainder b c))
           (if (or (not (numberp c))
                   (equal c 0))
               (plus a b)
             (difference (remainder a c)
                         (difference c
                                     (remainder b c))))))
  ((induct (remainder a c))
   (expand (remainder (plus a b) c))
   (disable lessp-transpose-meta
            equal-transpose-meta
            quotient-add1-arg2
            remainder-add1-arg2
            dichotomy
            sub1-times
            lessp-times-single-linear
            lessp-odometer-simple
            difference-times-arg1-simplest
            sub1-plus
            difference-is-monotonic
            lessp-times-cancel-meta
            remainder-lessp-linear
            difference-not-lessp
            difference-0)))

;;; canonical (rac and rbc avoid repeated rewriting)

(prove-lemma remainder-plus-arg1 (rewrite)
  (implies (and (equal rac (remainder a c))
                (equal rbc (remainder b c)))
           (equal (remainder (plus a b) c)
                  (if (lessp (plus rac rbc) c)
                      (plus rac rbc)
                    (if (or (not (numberp c))
                            (equal c 0))
                        (plus a b)
                      (difference rac (difference c rbc))))))
  ((use (remainder-plus-arg1-helper-1 (a a) (b b) (c c)))))

(disable remainder-plus-arg1-helper)

(prove-lemma quotient-plus-arg1-helper nil
  (implies (and (lessp r c)
                (lessp s c))
           (equal (quotient (plus (plus r (times a c))
                                  (plus s (times b c)))
                            c)
                  (if (lessp (plus r s) c)
                      (plus a b)
                    (add1 (plus a b)))))
  ((induct (plus a b))
   (do-not-generalize t)
   (disable lessp-transpose-meta
            dichotomy
            lessp-times-single-linear
            times-plus
            sub1-times
            equal-transpose-meta
            equal-odometer-simple
            difference-times-arg1-simplest
            lessp-odometer-simple
            sub1-difference
            sub1-plus
            no-divisors-of-zero
            difference-0
            difference-not-lessp)))

;;; canonical

(prove-lemma quotient-plus-arg1 (rewrite)
  (implies (equal ans (plus (quotient a c) (quotient b c)))
           (equal (quotient (plus a b) c)
                  (if (or (not (numberp c))
                          (equal c 0))
                      0
                    (if (lessp (plus a b) (plus c (times c ans)))
                        ans
                      (add1 ans)))))
  ((use (quotient-plus-arg1-helper (r (remainder a c))
                                   (s (remainder b c))
                                   (a (quotient a c))
                                   (b (quotient b c))))
   (disable dichotomy
            sub1-times
            difference-times-arg1-simplest
            difference-times-arg1
            difference-times-arg1-simpler
            lessp-transpose-meta
            equal-transpose-meta
            difference-plus-arg2
            lessp-times-single-linear
            remainder-plus-arg1
            lessp-odometer-simple
            remainder
            no-divisors-of-zero
            difference-lessp
            difference-0
            sub1-difference
            quotient-lessp-linear
            lessp-times-linear
            sub1-plus
            lessp-times-cancel-meta
            plus-is-0
            difference-not-lessp)))

(prove-lemma quotient-is-unique (rewrite)
  (implies (lessp c a)
           (and (equal (quotient (plus c (times b a)) a) (fix b))
                (equal (quotient (plus c (times a b)) a) (fix b))
                (equal (quotient (plus (times b a) c) a) (fix b))
                (equal (quotient (plus (times a b) c) a) (fix b))))
  ((induct (times b a))))

;;; canonical

;;; Even though this lemma is true unconditionally, we include the
;;; hypotheses to (in most cases) prevent looping.  This will not work
;;; in the presence of inconsistent hypotheses.

(prove-lemma quotient-times-arg1 (rewrite)
  (and
   (implies (and (numberp c)
                 (not (equal c 0))
                 (not (lessp b c)))
            (equal (quotient (times a b) c)
                   (plus (quotient (times a (remainder b c)) c)
                         (times a (quotient b c)))))
   (implies (and (numberp c)
                 (not (equal c 0))
                 (not (lessp b c)))
            (equal (quotient (times b a) c)
                   (plus (quotient (times a (remainder b c)) c)
                         (times a (quotient b c))))))
  ((induct (times a b))
   (disable dichotomy
            difference-times-arg1-simplest
            difference-times-arg1-simpler
            sub1-times
            difference-times-arg1
            difference-lessp
            lessp-times-single-linear
            difference-plus-arg2
            lessp-odometer-simple
            difference-times-arg2
            lessp-transpose-meta
            no-divisors-of-zero
            equal-odometer-simple
            equal-transpose-meta
            lessp-times-cancel-meta
            equal-times-cancel-meta
            lessp-times-linear
            lessp-times-both-linear
            equal-add1
            remainder-plus-arg1
            sub1-difference
            sub1-plus
            difference-times-arg1-meta
            difference-not-lessp
            sub1-remainder
            remainder-lessp-linear)))

(prove-lemma remainder-times-remainder-arg1 (rewrite)
  (and (equal (remainder (times a (remainder b c)) c)
              (remainder (times a b) c))
       (equal (remainder (times (remainder b c) a) c)
              (remainder (times a b) c)))
  ((induct (times a b)) ; for speed
   (disable difference-lessp
            dichotomy
            difference-times-arg1
            difference-difference-arg1-commutes-meta
            difference-times-arg1-simpler
            sub1-times
            no-divisors-of-zero
            equal-transpose-meta
            sub1-plus
            difference-times-arg1-simplest
            plus-is-0
            difference-not-lessp
            difference-times-arg1-meta)))

;;; canonical

(prove-lemma remainder-times-arg1 (rewrite)
  (implies (and (equal rhs (times (remainder b a) (remainder c a)))
                (or (not (numberp a))
                    (equal a 0)
                    (lessp rhs a)))
           (equal (remainder (times b c) a) rhs))
  ((use (remainder-times-remainder-arg1 (a (remainder b a))
                                        (b c)
                                        (c a))
        (remainder-times-remainder-arg1 (a c)
                                        (b b)
                                        (c a)))
   (disable remainder-times-remainder-arg1
            difference-times-arg1
            dichotomy
            difference-times-arg1-simpler
            sub1-times
            no-divisors-of-zero
            difference-times-arg1-meta
            lessp-quotient-arg1-linear
            remainder-lessp-linear
            difference-not-lessp
            difference-lessp)))

(prove-lemma remainder-times-arg1-simple (rewrite)
  (and (equal (remainder (times a b) b) 0)
       (equal (remainder (times b a) b) 0)))

(prove-lemma lessp-quotient-arg2-linear-helper nil
  (implies (not (zerop a))
           (not (lessp (quotient b a)
                       (quotient b (add1 a)))))
  ((use (quotient-remainder-rewrite (a b) (b (add1 a))))
   (disable lessp-transpose-meta
            quotient-lessp-linear
            remainder-add1-arg2
            sub1-plus
            equal-transpose-meta
            sub1-difference
            plus-is-0
            sub1-times
            difference-add1
            no-divisors-of-zero
            plus-associates-right
            difference-not-lessp
            remainder-lessp-linear)))

(prove-lemma lessp-quotient-arg2-linear (rewrite)
  (and (implies (and (not (lessp b a))
                     (numberp a)
                     (not (equal a 0)))
                (not (lessp (quotient c a)
                            (quotient c b))))
       (implies (and (lessp a b)
                     (numberp a)
                     (not (equal a 0)))
                (not (lessp (quotient c a)
                            (quotient c b)))))
  ((induct (plus b a))
   (use (lessp-quotient-arg2-linear-helper
         (a (sub1 b))
         (b c)))))

;;; canonical

(prove-lemma sub1-quotient (rewrite)
  (equal (sub1 (quotient a b))
         (quotient (difference a b) b)))

(prove-lemma equal-remainder-difference-arg1 (rewrite)
  (implies (not (equal b c)) ; to prevent most common looping
           (equal (equal (remainder (difference a b) c) 0)
                  (or (lessp a b)
                      (equal (remainder a c)
                             (remainder b c)))))
  ((disable difference-plus-arg2
            dichotomy
            remainder-times-arg1
            lessp-odometer-simple
            sub1-remainder
            lessp-times-single-linear
            times-plus
            times-commutes
            sub1-plus
            difference-is-monotonic
            difference-plus-arg1
            equal-quarter-odometer
            plus-is-0
            difference-times-arg1-simplest
            difference-times-arg1-simpler
            sub1-times
            remainder-lessp-linear
            difference-not-lessp
            equal-odometer-simple
            difference-lessp)))

(prove-lemma remainder-difference-arg1 (rewrite)
  (implies (equal (remainder a c) b)
           (equal (remainder (difference a b) c) 0)))

(prove-lemma remainder-plus-arg1-kb (rewrite)
  (implies (and (equal rac (remainder a c))
                (equal rbc (remainder b c)))
           (equal (remainder (add1 (plus a b)) c)
                  (if (lessp (plus rac rbc) (sub1 c))
                      (add1 (plus rac rbc))
                    (if (or (not (numberp c))
                            (equal c 0))
                        (add1 (plus a b))
                      (difference rac (difference (sub1 c) rbc))))))
  ((use (remainder-plus-arg1-helper-1 (a (add1 a)) (b b) (c c))
        (sub1-remainder (a (add1 a)) (b c)))
   (expand (remainder (add1 a) (add1 x)))
   (disable remainder-plus-arg1
            sub1-remainder
            quotient-remainder
            remainder-add1-arg2
            difference-remainder-arg1
            difference-remainder-arg2
            difference-plus-arg1
            dichotomy
            sub1-plus
            plus-is-0
            difference-plus-arg2
            equal-odometer-simple
            lessp-odometer-simple
            remainder-lessp-linear
            difference-not-lessp
            difference-lessp)))

(prove-lemma remainder-times-minus-one (rewrite)
  (and (equal (remainder (times a b) (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  0
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (times b a) (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  0
                (difference b (remainder (sub1 a) (add1 b))))))
  ((use (remainder-add1-arg2-simple (a a) (b b)))
   (enable remainder-lessp-linear)
   (disable remainder-add1-arg2-simple
            remainder-add1-arg2
            remainder
            remainder-times-arg1
            times
            difference-remainder-arg2
            sub1-remainder
            remainder-plus-arg1
            difference-lessp
            difference-add1
            sub1-times
            sub1-plus
            dichotomy
            remainder-difference-arg1
            lessp-times-single-linear
            times-plus
            equal-plus-cancel-meta
            no-divisors-of-zero
            difference-difference-arg2-commutes-meta
            difference-remainder-arg1)))

(prove-lemma remainder-times-minus-one-normal (rewrite)
  (and (equal (remainder (times a (sub1 b)) b)
              (if (or (not (numberp a))
                      (equal a 0))
                  0
                (difference (sub1 b) (remainder (sub1 a) b))))
       (equal (remainder (times (sub1 b) a) b)
              (if (or (not (numberp a))
                      (equal a 0))
                  0
                (difference (sub1 b) (remainder (sub1 a) b)))))
  ((use (remainder-times-minus-one (a a) (b (sub1 b))))
   (disable remainder-times-minus-one
            times
            remainder-times-arg1
            remainder-lessp-linear
            difference-not-lessp
            difference-times-arg1-meta)))

;;; Lengthy self-proof (requires remainder-if and plus-if)

(prove-lemma remainder-times-minus-one-kb (rewrite)
  (and (equal (remainder (plus b (times b (sub1 a))) (add1 b))
              (difference b (remainder (sub1 a) (add1 b))))
       (equal (remainder (plus b (times (sub1 a) b)) (add1 b))
              (difference b (remainder (sub1 a) (add1 b))))
       (equal (remainder (plus a (times a (sub1 b))) (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  0
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (plus a (times (sub1 b) a)) (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  0
                (difference b (remainder (sub1 a) (add1 b)))))
; the next 5 are included because they were observed during the  self-proof
       (equal (remainder (plus a (sub1 b) (times (sub1 a) (sub1 b)))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (sub1 b)
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (plus (sub1 b) a (times (sub1 a) (sub1 b)))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (sub1 b)
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (plus a (sub1 b) (times (sub1 b) (sub1 a)))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (sub1 b)
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (plus (sub1 b) a (times (sub1 b) (sub1 a)))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (sub1 b)
                (difference b (remainder (sub1 a) (add1 b)))))

       (equal (remainder (plus b (sub1 a) (times (sub1 a) (sub1 b)))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (if (numberp b) b 0)
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (plus (sub1 a) b (times (sub1 a) (sub1 b)))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (if (numberp b) b 0)
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (plus b (sub1 a) (times (sub1 b) (sub1 a)))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (if (numberp b) b 0)
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (plus (sub1 a) b (times (sub1 b) (sub1 a)))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (if (numberp b) b 0)
                (difference b (remainder (sub1 a) (add1 b)))))

       (equal (remainder (add1 (plus   (sub1 a)
                                       (sub1 b)
                                       (times (sub1 a) (sub1 b))))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (if (numberp b) b 0)
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (add1 (plus (sub1 b)
                                     (sub1 a)
                                     (times (sub1 a) (sub1 b))))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (if (numberp b) b 0)
                (difference b (remainder (sub1 a) (add1 b)))))
       (equal (remainder (add1 (plus   (sub1 a)
                                       (sub1 b)
                                       (times (sub1 b) (sub1 a))))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (if (numberp b) b 0)
                (difference b (remainder (sub1 a) (add1 b)))))

       (equal (remainder (add1 (plus   (sub1 b)
                                       (sub1 a)
                                       (times (sub1 b) (sub1 a))))
                         (add1 b))
              (if (or (not (numberp a))
                      (equal a 0))
                  (if (numberp b) b 0)
                (difference b (remainder (sub1 a) (add1 b))))))
  ((use (remainder-times-minus-one (a a) (b b)))
   (disable remainder-times-minus-one ; remember to disable just
            remainder-add1-arg2       ; about everything when
            difference-lessp          ; proving kb rules
            lessp-transpose-meta
            equal-transpose-meta
            remainder-plus-arg1
            dichotomy
            difference-remainder-arg2
            remainder-plus-arg1-kb
            difference-remainder-arg1
            difference-plus-arg1
            difference-times-arg1
            lessp-times-single-linear
            sub1-remainder
            difference-add1
            remainder-difference-arg1
            sub1-plus
            equal-add1
            plus-is-0
            difference-not-lessp
            remainder-lessp-linear
            remainder-times-arg1)))

(prove-lemma remainder-times-minus-one-normal-kb (rewrite)
  (and (equal (remainder (plus (sub1 b)
                               (times (sub1 b) (sub1 a)))
                         b)
              (difference (sub1 b) (remainder (sub1 a) b)))
       (equal (remainder (plus (sub1 b)
                               (times (sub1 a) (sub1 b)))
                         b)
              (difference (sub1 b) (remainder (sub1 a) b)))
       (equal (remainder (plus a (times a (sub1 (sub1 b))))
                         b)
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (numberp a) a 0)
                (if (or (equal (sub1 b) 0)
                        (not (numberp a))
                        (equal a 0))
                    0
                  (difference (sub1 b) (remainder (sub1 a) b)))))
       (equal (remainder (plus a (times (sub1 (sub1 b)) a))
                         b)
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (numberp a) a 0)
                (if (or (equal (sub1 b) 0)
                        (not (numberp a))
                        (equal a 0))
                    0
                  (difference (sub1 b) (remainder (sub1 a) b)))))

       (equal (remainder (plus (sub1 b)
                               (sub1 b)
                               (times (sub1 b) (sub1 (sub1 a))))
                         b)
              (if (equal (sub1 a) 0)
                  (sub1 (sub1 b))
                (difference (sub1 b) (remainder (sub1 a) b))))
       (equal (remainder (plus (sub1 b)
                               (sub1 b)
                               (times (sub1 (sub1 a)) (sub1 b)))
                         b)
              (if (equal (sub1 a) 0)
                  (sub1 (sub1 b))
                (difference (sub1 b) (remainder (sub1 a) b)))))
  ((use (remainder-times-minus-one-normal (a a) (b b)))
   (expand (times a (sub1 b))
           (times (sub1 a) (sub1 (sub1 b)))
           (times (sub1 a) (sub1 b))
           (times (sub1 b) (sub1 (sub1 a))))
   (disable remainder-times-minus-one-normal
            remainder-plus-arg1
            equal-transpose-meta
            lessp-transpose-meta
            dichotomy
            sub1-remainder
            sub1-quotient
            difference-lessp
            lessp-times-single-linear
            quotient-add1-arg2
            difference-remainder-arg1
            difference-remainder-arg2
            quotient-remainder
            remainder-plus-arg1-kb
            difference-times-arg1-simpler
            difference-times-arg1-simplest
            difference-times-arg1
            remainder-difference-arg1
            remainder-times-arg1
            sub1-plus
            difference-0
            sub1-times
            plus-is-0
            sub1-difference
            lessp-times-both-linear
            no-divisors-of-zero
            lessp-times-linear
            lessp-times-cancel-meta
            difference-times-arg2
            difference-plus-arg2
            lessp-quarter-odometer-left
            remainder-lessp-linear
            quotient-difference-arg1)))

;;; canonical

(prove-lemma remainder-add1-arg1 (rewrite)
  (equal (remainder (add1 a) b)
         (if (or (lessp a (sub1 b))
                 (not (numberp b))
                 (equal b 0))
             (add1 a)
           (remainder (difference a (sub1 b)) b))))

(prove-lemma remainder-plus-modulus-kb (rewrite)
  (and
   (equal (remainder (add1 (add1 (plus (sub1 b) c))) (add1 b))
          (remainder c (add1 b)))
   (equal (remainder (add1 (add1 (plus c (sub1 b)))) (add1 b))
          (remainder c (add1 b))))
  ((disable remainder-add1-arg1
            remainder-add1-arg2
            remainder-lessp-linear)))

(prove-lemma remainder-plus-arg1-simple (rewrite)
  (implies (and (not (lessp (plus a b) c))
                (not (lessp c a)))
           (and
            (equal (remainder (plus a b) c)
                   (remainder (difference b (difference c a)) c))
            (equal (remainder (plus b a) c)
                   (remainder (difference b (difference c a)) c))))
  ((expand (remainder (plus a b) c))
   (disable remainder-plus-arg1
            lessp-transpose-meta
            difference-lessp
            dichotomy
            remainder-lessp-linear
            remainder-difference-arg1
            difference-not-lessp)))

;;; canonical (preferred)

(prove-lemma modulus-sub1-cancellation (rewrite)
  (and (equal (equal (remainder (times a b) (add1 b)) 0)
              (equal (remainder a (add1 b)) 0))
       (equal (equal (remainder (times b a) (add1 b)) 0)
              (equal (remainder a (add1 b)) 0)))
  ((disable
    difference-difference-arg1-commutes-meta
    lessp-quotient-arg2-linear
    sub1-remainder
    quotient-lessp-linear
    sub1-quotient
    remainder-plus-arg1-simple
    lessp-transpose-meta
    equal-transpose-meta
    quotient
    dichotomy
    difference-lessp
    remainder-add1-arg2
    difference-times-arg1-simplest
    lessp-times-single-linear
    difference-times-arg1
    difference-remainder-arg2
    lessp-times-both-linear
    sub1-times
    times-plus
    lessp-times-linear
    remainder-lessp-linear
    difference-not-lessp)))

(prove-lemma quotient-times-arg1-kb (rewrite)
  (and
   (implies
    (and (numberp c)
         (not (equal c 0))
         (not (lessp b c)))
    (equal (quotient (plus b (times a b)) c)
           (if (lessp (plus (remainder b c)
                            (remainder (times a b) c))
                      c)
               (plus (quotient b c)
                     (quotient (times a (remainder b c)) c)
                     (times a (quotient b c)))
             (add1 (plus (quotient b c)
                         (quotient (times a (remainder b c)) c)
                         (times a (quotient b c)))))))
   (implies
    (and (numberp c)
         (not (equal c 0))
         (not (lessp b c)))
    (equal (quotient (plus b (times b a)) c)
           (if (lessp (plus (remainder b c)
                            (remainder (times a b) c))
                      c)
               (plus (quotient b c)
                     (quotient (times a (remainder b c)) c)
                     (times a (quotient b c)))
             (add1 (plus (quotient b c)
                         (quotient (times a (remainder b c)) c)
                         (times a (quotient b c))))))))
  ((use (quotient-times-arg1 (a (add1 a)) (b b) (c c))
        (quotient-remainder-rewrite (a b) (b c))
        (quotient-remainder-rewrite (a (times a b)) (b c)))
   (disable ; must not disable  quotient-times-arg1
    remainder-times-arg1
    quotient-remainder-rewrite
    quotient-remainder
    lessp
    times
    plus
    difference-times-arg1-simplest
    lessp-quotient-arg2-linear
    quotient-lessp-linear
    quotient
    lessp-times-single-linear
    dichotomy
    lessp-odometer-simple
    difference-times-arg1
    difference-times-arg1-simpler
    remainder-difference-arg1
    difference-lessp
    equal-times-cancel-meta
    equal-half-odometer
    sub1-times
    lessp-times-linear
    remainder-lessp-linear
    difference-not-lessp
    difference-times-arg1-meta)))

(prove-lemma quotient-times-minus-one-helper (rewrite)
  (implies (not (lessp b (sub1 a)))
           (and (equal (quotient (times a b) (add1 b))
                       (sub1 a))
                (equal (quotient (times b a) (add1 b))
                       (sub1 a))))
  ((use (quotient-is-unique (a (add1 b))
                            (b (sub1 a))
                            (c (difference b (sub1 a)))))
   (disable quotient-is-unique
            quotient-plus-arg1
            quotient-add1-arg2
            difference-plus-arg1
            lessp-times-single-linear
            remainder-difference-arg1
            difference-times-arg2-preferred
            remainder-add1-arg1
            difference-lessp)))

;;; This lemma is needed because quotient-times-arg1 was weakened to prevent
;;; looping.

(prove-lemma quotient-times-arg1-simple (rewrite)
  (implies (equal (remainder a c) 0)
           (and (equal (quotient (times a b) c)
                       (times b (quotient a c)))
                (equal (quotient (times b a) c)
                       (times b (quotient a c)))))
  ((disable lessp-transpose-meta
            equal-transpose-meta
            dichotomy
            sub1-times
            sub1-difference
            difference-0
            difference-lessp
            sub1-quotient
            difference-times-arg1
            no-divisors-of-zero
            difference-times-arg1-simpler
            lessp-quotient-arg1-linear
            difference-times-arg1-simplest
            sub1-plus
            lessp-times-cancel-meta
            plus-is-0
            difference-times-arg1-meta
            difference-not-lessp
            remainder-lessp-linear
            difference-times-arg1-kb
            sub1-remainder)))

;;; times-1 is needed to expand (times 2 a) in those cases where (add1 0)
;;; is not present within the term structure of the formula being proven.
;;; It also prevents bind-stack overflows due to equal-times-cancel-meta.

(prove-lemma times-1 (rewrite)
  (and (equal (times 1 a) (if (numberp a) a 0))
       (equal (times a 1) (if (numberp a) a 0))))

;;; canonical (preferred)

(prove-lemma quotient-times-minus-one (rewrite)
  (and (equal (quotient (times a b) (add1 b))
              (if (equal (remainder a (add1 b)) 0)
                  (times b (quotient a (add1 b)))
                (plus (remainder (sub1 a) (add1 b))
                      (times b (quotient a (add1 b))))))
       (equal (quotient (times b a) (add1 b))
              (if (equal (remainder a (add1 b)) 0)
                  (times b (quotient a (add1 b)))
                (plus (remainder (sub1 a) (add1 b))
                      (times b (quotient a (add1 b)))))))
  ((use (quotient-remainder-rewrite (a a) (b (add1 b))))
   (expand (times x (sub1 b))
           (times b (sub1 x)))
   (disable quotient-remainder-rewrite
            quotient-add1-arg2
            remainder-add1-arg2
            times
            times-add1
            equal-add1
            sub1-quotient
            lessp-transpose-meta
            remainder-plus-arg1-simple
            quotient-lessp-linear
            lessp-times-single-linear
            difference-times-arg1
            difference-times-arg1-simpler
            remainder-lessp-linear
            difference-not-lessp)))

(disable quotient-times-minus-one-helper)

;;; This lemma is included for cases in which sub1-elim has not produced
;;; a term suitable for quotient-times-minus-one.

(prove-lemma quotient-times-minus-one-normal (rewrite)
  (and (equal (quotient (times a (sub1 b)) b)
              (if (equal (remainder a b) 0)
                  (times (sub1 b) (quotient a b))
                (if (or (not (numberp b))
                        (equal b 0))
                    0
                  (plus (remainder (sub1 a) b)
                        (times (sub1 b) (quotient a b))))))
       (equal (quotient (times (sub1 b) a) b)
              (if (equal (remainder a b) 0)
                  (times (sub1 b) (quotient a b))
                (if (or (not (numberp b))
                        (equal b 0))
                    0
                  (plus (remainder (sub1 a) b)
                        (times (sub1 b) (quotient a b)))))))
  ((use (quotient-times-minus-one (a a) (b (sub1 b))))
   (disable quotient-times-minus-one
            quotient-plus-arg1
            sub1-quotient
            difference-lessp
            difference-plus-arg1
            difference-times-arg1
            difference-not-lessp)))

;;; Needed to speed up quotient-times-minus-one-kb

(prove-lemma quotient-1-2 (rewrite)
  (and (equal (quotient a 1) (if (numberp a) a 0))
       (equal (quotient (add1 (add1 a)) 2)
              (add1 (quotient a 2)))
       (equal (quotient (plus a a) 2) (if (numberp a) a 0))
       (equal (quotient (plus a (plus a b)) 2)
              (plus a (quotient b 2))))
  ((induct (plus a b)) ; for speed
   (disable quotient-plus-arg1
            quotient-add1-arg1
            dichotomy
            lessp-transpose-meta
            difference-lessp
            remainder-plus-arg1
            difference-plus-arg1
            difference-add1
            equal-transpose-meta
            difference-0
            sub1-quotient
            plus-commutes-meta
            difference-difference-arg1-commutes-meta
            sub1-difference
            sub1-plus
            quotient-difference-arg1
            equal-odometer-simple
            remainder-add1-arg2
            remainder-plus-arg1-simple
            plus-associates-right
            modulus-sub1-cancellation
            difference-not-lessp)))

;;; Needs plus-if in order to prevent quotient-plus-arg1 from firing first.

(prove-lemma quotient-times-minus-one-kb (rewrite)
  (and (equal (quotient (plus b (times b (sub1 a))) (add1 b))
              (if (equal (remainder a (add1 b)) 0)
                  (times b (quotient a (add1 b)))
                (plus (remainder (sub1 a) (add1 b))
                      (times b (quotient a (add1 b))))))
       (equal (quotient (plus b (times (sub1 a) b)) (add1 b))
              (if (equal (remainder a (add1 b)) 0)
                  (times b (quotient a (add1 b)))
                (plus (remainder (sub1 a) (add1 b))
                      (times b (quotient a (add1 b))))))
       (equal (quotient (plus a (times a (sub1 b))) (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (numberp a) a 0)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (plus a (times (sub1 b) a)) (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (numberp a) a 0)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (plus a (sub1 b) (times (sub1 a) (sub1 b)))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (numberp a) a 0)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (plus a (sub1 b) (times (sub1 b) (sub1 a)))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (numberp a) a 0)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (plus (sub1 b) a (times (sub1 a) (sub1 b)))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (numberp a) a 0)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (plus (sub1 b) a (times (sub1 b) (sub1 a)))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (numberp a) a 0)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))

       (equal (quotient (plus b (sub1 a) (times (sub1 b) (sub1 a)))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (sub1 a)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (plus b (sub1 a) (times (sub1 a) (sub1 b)))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (sub1 a)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (plus (sub1 a) b (times (sub1 b) (sub1 a)))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (sub1 a)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (plus (sub1 a) b (times (sub1 a) (sub1 b)))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (sub1 a)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))

       (equal (quotient (add1 (plus (sub1 a)
                                    (sub1 b)
                                    (times (sub1 a) (sub1 b))))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (or (not (numberp a))
                          (equal a 0))
                      1
                    a)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (add1 (plus (sub1 b)
                                    (sub1 a)
                                    (times (sub1 b) (sub1 a))))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (or (not (numberp a))
                          (equal a 0))
                      1
                    a)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (add1 (plus (sub1 b)
                                    (sub1 a)
                                    (times (sub1 a) (sub1 b))))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (or (not (numberp a))
                          (equal a 0))
                      1
                    a)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b)))))))
       (equal (quotient (add1 (plus (sub1 a)
                                    (sub1 b)
                                    (times (sub1 b) (sub1 a))))
                        (add1 b))
              (if (or (not (numberp b))
                      (equal b 0))
                  (if (or (not (numberp a))
                          (equal a 0))
                      1
                    a)
                (if (equal (remainder a (add1 b)) 0)
                    (times b (quotient a (add1 b)))
                  (plus (remainder (sub1 a) (add1 b))
                        (times b (quotient a (add1 b))))))))
  ((use (quotient-times-minus-one (a a) (b b))
        (times-add1 (a a) (b (sub1 b))))
   (disable quotient-times-minus-one
            times-add1
            lessp-transpose-meta
            equal-transpose-meta
            quotient-add1-arg1
            quotient-add1-arg2
            difference-0
            difference-lessp
            dichotomy
            lessp-times-single-linear
            remainder-add1-arg2
            difference-plus-arg1
            difference-add1
            difference-times-arg1
            sub1-quotient
            lessp-times-both-linear
            sub1-difference
            sub1-times
            quotient-difference-arg1
            difference-times-arg1-simpler
            lessp-times-linear
            sub1-remainder
            plus-associates-right
            plus-commutes
            equal-odometer-simple
            no-divisors-of-zero
            difference-times-arg1-simplest
            sub1-plus
            plus-is-0
            difference-not-lessp
            remainder-difference-arg1
            remainder-lessp-linear)))

(prove-lemma quotient-times-minus-one-normal-kb (rewrite)
  (and
   (equal (quotient (plus (sub1 b) (times (sub1 b) (sub1 a))) b)
          (if (equal (sub1 b) 0)
              0
            (if (equal (remainder a b) 0)
                (times (sub1 b) (quotient a b))
              (plus (remainder (sub1 a) b)
                    (times (sub1 b) (quotient a b))))))
   (equal (quotient (plus (sub1 b) (times (sub1 a) (sub1 b))) b)
          (if (equal (sub1 b) 0)
              0
            (if (equal (remainder a b) 0)
                (times (sub1 b) (quotient a b))
              (plus (remainder (sub1 a) b)
                    (times (sub1 b) (quotient a b))))))
   (equal (quotient (plus a (times a (sub1 (sub1 b)))) b)
          (if (equal (sub1 b) 0)
              (quotient a b)
            (if (equal (remainder a b) 0)
                (times (sub1 b) (quotient a b))
              (plus (remainder (sub1 a) b)
                    (times (sub1 b) (quotient a b))))))
   (equal (quotient (plus a (times (sub1 (sub1 b)) a)) b)
          (if (equal (sub1 b) 0)
              (quotient a b)
            (if (equal (remainder a b) 0)
                (times (sub1 b) (quotient a b))
              (plus (remainder (sub1 a) b)
                    (times (sub1 b) (quotient a b))))))
   (equal (quotient (plus (sub1 b)
                          (sub1 b)
                          (times (sub1 (sub1 a)) (sub1 b)))
                    b)
          (if (equal (sub1 b) 0)
              0
            (if (equal (sub1 a) 0)
                1
              (if (equal (remainder a b) 0)
                  (times (sub1 b) (quotient a b))
                (plus (remainder (sub1 a) b)
                      (times (sub1 b) (quotient a b)))))))
   (equal (quotient (plus (sub1 b)
                          (sub1 b)
                          (times (sub1 b) (sub1 (sub1 a))))
                    b)
          (if (equal (sub1 b) 0)
              0
            (if (equal (sub1 a) 0)
                1
              (if (equal (remainder a b) 0)
                  (times (sub1 b) (quotient a b))
                (plus (remainder (sub1 a) b)
                      (times (sub1 b) (quotient a b))))))))
  ((use (quotient-times-minus-one-normal (a a) (b b)))
   (expand (times a (sub1 b))
           (times a (sub1 (sub1 b)))
           (times (sub1 a) (sub1 b))
           (times (sub1 b) (sub1 (sub1 a)))
           (times (sub1 a) (sub1 (sub1 b)))
           (quotient (plus x x) (add1 x))
           (quotient (add1 (add1 (plus v z z (times v z))))
                     (add1 (add1 z))))
   (disable quotient-times-minus-one-normal
            remainder
            quotient-remainder
            lessp-plus-cancel-meta
            lessp-transpose-meta
            equal-transpose-meta
            lessp-times-single-linear
            quotient-add1-arg2
            quotient-add1-arg1
            quotient-plus-arg1
            dichotomy
            remainder-plus-arg1-simple
            equal-odometer-simple
            remainder-plus-arg1
            quotient-difference-arg1
            remainder-add1-arg2
            difference-lessp
            times-plus
            sub1-quotient
            difference-0
            lessp-quotient-arg2-linear
            sub1-difference
            difference-times-arg1
            difference-times-arg1-simpler
            lessp-quotient-arg1-linear
            difference-not-lessp)))

;;; canonical

(prove-lemma quotient-plus-arg2 (rewrite)
  (and (implies (and (numberp a)
                     (not (equal a 0))
                     (not (lessp (remainder c a)
                                 (times b (quotient c a)))))
                (equal (quotient c (plus a b))
                       (quotient c a)))
       (implies (and (numberp a)
                     (not (equal a 0))
                     (not (lessp (remainder c a)
                                 (times b (quotient c a)))))
                (equal (quotient c (plus b a))
                       (quotient c a)))
       (implies (and (numberp a)
                     (not (equal a 0))
                     (lessp (remainder c a)
                            (times b (quotient c a)))
                     (not (lessp
                           (plus a (remainder c a))
                           (times b (quotient (difference c a) a)))))
                (equal (quotient c (plus a b))
                       (quotient (difference c a) a)))
       (implies (and (numberp a)
                     (not (equal a 0))
                     (lessp (remainder c a)
                            (times b (quotient c a)))
                     (not (lessp
                           (plus a (remainder c a))
                           (times b (quotient (difference c a) a)))))
                (equal (quotient c (plus b a))
                       (quotient (difference c a) a))))
  ((use (quotient-is-unique (a (plus a b))
                            (b (quotient c a))
                            (c (difference
                                (remainder c a)
                                (times b (quotient c a)))))
        (quotient-is-unique
         (a (plus a b))
         (b (quotient (difference c a) a))
         (c (difference
             (plus a (remainder c a))
             (times b (quotient (difference c a) a))))))
   (disable quotient-is-unique
            lessp-transpose-meta
            difference-lessp
            equal-transpose-meta
            quotient-plus-arg1
            dichotomy
            difference-plus-arg1
            lessp-quotient-arg2-linear
            remainder-difference-arg1
            sub1-quotient
            difference-0
            difference-times-arg2-preferred
            difference-times-arg2
            equal-odometer-simple
            lessp-odometer-simple
            lessp-half-odometer-left
            lessp-quotient-arg1-linear
            lessp-times-single-linear
            lessp-plus-cancel-meta
            sub1-difference
            sub1-plus
            sub1-remainder
            sub1-times
            no-divisors-of-zero
            lessp-times-cancel-meta
            quotient-difference-arg1
            times
            difference-not-lessp
            difference-plus-arg2)))

;;; canonical

;;; We omit permutative cases involving non tame terms.

(prove-lemma quotient-plus-arg2-simple (rewrite)
  (and (equal (quotient (plus (times a c) (times b c)) (plus a b))
              (if (equal (plus a b) 0) 0 (fix c)))
       (equal (quotient (plus (times a c) (times c b)) (plus a b))
              (if (equal (plus a b) 0) 0 (fix c)))
       (equal (quotient (plus (times a c) (times c b)) (plus b a))
              (if (equal (plus a b) 0) 0 (fix c)))

       (equal (quotient (plus (times c a) (times c b)) (plus a b))
              (if (equal (plus a b) 0) 0 (fix c)))
       (equal (quotient (plus (times c a) (times b c)) (plus a b))
              (if (equal (plus a b) 0) 0 (fix c)))
       (equal (quotient (plus (times c a) (times b c)) (plus b a))
              (if (equal (plus a b) 0) 0 (fix c))))
  ((use (quotient-times-arg1-simple (a (plus a b))
                                    (b c)
                                    (c (plus a b))))
   (disable quotient-times-arg1-simple
            quotient-plus-arg1
            quotient-plus-arg2
            difference-plus-arg2
            equal-odometer-simple
            difference-lessp
            dichotomy
            lessp-transpose-meta
            difference-times-arg2-preferred
            remainder-plus-arg1
            difference-remainder-arg1
            equal-transpose-meta
            sub1-remainder
            remainder-difference-arg1
            sub1-plus
            sub1-times
            difference-times-arg2
            difference-times-arg1
            lessp-times-single-linear
            no-divisors-of-zero
            difference-times-arg1-simplest
            lessp-odometer-simple
            difference-times-arg1-meta
            remainder-lessp-linear
            difference-times-arg1-simpler
            sub1-difference
            difference-0
            difference-not-lessp
            lessp-times-cancel-meta)))

;;; I could find no good canonical rule for remainder-plus-arg2

(prove-lemma remainder-plus-arg2 (rewrite)
  (and
   (equal (remainder (plus (times a c) (times b c)) (plus a b)) 0)
   (equal (remainder (plus (times a c) (times c b)) (plus a b)) 0)
   (equal (remainder (plus (times a c) (times c b)) (plus b a)) 0)

   (equal (remainder (plus (times c a) (times c b)) (plus a b)) 0)
   (equal (remainder (plus (times c a) (times b c)) (plus a b)) 0)
   (equal (remainder (plus (times c a) (times b c)) (plus b a)) 0))
  ((use (remainder-times-arg1-simple (a c) (b (plus a b))))
   (disable remainder-times-arg1-simple
            remainder-plus-arg1
            difference-plus-arg2
            difference-plus-arg1
            lessp-transpose-meta
            difference-lessp
            sub1-plus
            sub1-times
            remainder-plus-arg1-simple
            difference-times-arg1-simplest
            difference-times-arg1
            no-divisors-of-zero
            plus-is-0)))

;;; canonical

(prove-lemma quotient-times-arg2 (rewrite)
  (equal (quotient a (times zb zc))
         (quotient (quotient a zb) zc))
  ((expand (quotient z (times zb zc)))
   (disable lessp-transpose-meta
            equal-transpose-meta
            sub1-quotient
            sub1-times
            difference-times-arg2
            remainder-plus-arg1-simple
            lessp-times-both-linear
            lessp-odometer
            lessp-quarter-odometer-right
            lessp-half-odometer-left
            lessp-quarter-odometer-left
            difference-times-arg2-preferred)))

;;; canonical

(prove-lemma remainder-times-arg2 (rewrite)
  (equal (remainder a (times zb zc))
         (plus (remainder a zb)
               (times zb (remainder (quotient a zb) zc))))
  ((use (quotient-remainder (a a) (b (times zb zc)))
        (quotient-remainder (a (quotient a zb)) (b zc)))
   (disable quotient-remainder-rewrite
            sub1-quotient
            difference-times-arg2
            difference-times-arg1
            remainder-times-arg1
            remainder-plus-arg1
            difference-plus-arg1
            sub1-times

            remainder-plus-arg1-simple
            equal-plus-cancel-meta
            equal-odometer-simple
            sub1-remainder
            difference-lessp
            quotient-lessp-linear
            remainder-difference-arg1
            sub1-plus
            plus-is-0
            lessp-times-single-linear
            plus-associates-right
            lessp-times-both-linear
            plus-commutes-nest
            difference-times-arg2-preferred
            lessp-times-linear
            difference-not-lessp
            remainder-lessp-linear)))
;;; canonical

(prove-lemma difference-associates (rewrite)
  (implies (not (lessp c d))
           (equal (difference (difference a (difference b c)) d)
                  (if (lessp b c)
                      (difference a d)
                    (difference
                     a
                     (difference b (difference c d))))))
  ((disable equal-transpose-meta
            lessp-transpose-meta)))

;;; canonical

(prove-lemma quotient-plus-times-minus-one (rewrite)
  (implies (and (not (lessp c a))
                (not (lessp b (difference c a))))
           (and (equal (quotient (plus (times b a) c) (add1 b))
                       (if (numberp a) a 0))
                (equal (quotient (plus (times a b) c) (add1 b))
                       (if (numberp a) a 0))
                (equal (quotient (plus c (times b a)) (add1 b))
                       (if (numberp a) a 0))
                (equal (quotient (plus c (times a b)) (add1 b))
                       (if (numberp a) a 0))))
  ((use (quotient-is-unique (a (add1 b))
                            (b a)
                            (c (difference c a))))
   (disable quotient-is-unique
            difference-plus-arg1
            difference-times-arg2
            no-divisors-of-zero
            sub1-plus
            difference-add1
            plus-zerop
            sub1-times
            difference-lessp
            quotient-plus-arg1
            quotient-add1-arg2
            quotient-remainder
            lessp-times-single-linear
            equal-transpose-meta
            dichotomy
            plus-is-0
            lessp-times-linear
            lessp-half-odometer-right
            sub1-difference
            equal-plus-cancel-meta
            lessp-times-cancel-meta
            equal-add1)))

;;; canonical

(prove-lemma add1-remainder-sub1-arg1 (rewrite)
  (equal (add1 (remainder (sub1 a) b))
         (if (or (not (numberp a))
                 (equal a 0))
             1
           (if (equal (remainder a b) 0)
               b
             (remainder a b))))
  ((disable quotient-remainder)))

;;; The inversion correcting lemmas are now complete.  We include here some
;;; generally useful simplifications.

(prove-lemma remainder-minus-one-as-0 (rewrite)
  (and (implies (and (equal b (remainder x (add1 b))) ; avoid
                     (equal x (sub1 a)))              ; rewriting
                (equal (remainder a (add1 b)) 0))
       (implies (and (equal (remainder x (add1 b)) b)
                     (equal x (sub1 a)))
                (equal (remainder a (add1 b)) 0)))
  ((disable remainder-add1-arg2
            sub1-quotient)))

(prove-lemma quotient-remainder-rewrite-kb (rewrite)
  (and (equal (plus b
                    (remainder a b)
                    (times b (quotient (difference a b) b)))
              (if (lessp a b)
                  (plus a b)
                (if (numberp a) a 0)))
       (equal (plus (quotient a b)
                    (remainder a b)
                    (times (sub1 b) (quotient a b)))
              (if (numberp a) a 0))
       (equal (plus (sub1 b)
                    (quotient a b)
                    (remainder a b)
                    (times (sub1 b) (quotient (difference a b) b)))
              (if (lessp a b)
                  (plus a (sub1 b))
                (if (numberp a) a 0))))
  ((use (quotient-remainder (a a) (b b)))
   (disable difference-lessp
            sub1-quotient
            lessp-transpose-meta
            lessp-quotient-arg2-linear
            lessp-times-single-linear
            equal-transpose-meta
            dichotomy
            remainder-difference-arg1
            quotient-lessp-linear
            sub1-remainder
            sub1-plus
            quotient-difference-arg1
            plus-is-0
            difference-not-lessp)))

(prove-lemma remainder-sub1-cancellation (rewrite)
  (equal (equal (remainder (sub1 a) c)
                (remainder (sub1 b) c))
         (if (or (not (numberp a))
                 (equal a 0))
             (equal (remainder (sub1 b) c) 0)
           (if (or (not (numberp b))
                   (equal b 0))
               (equal (remainder (sub1 a) c) 0)
             (equal (remainder a c)
                    (remainder b c)))))
  ((use (sub1-remainder (a a) (b c))
        (sub1-remainder (a b) (b c)))
   (disable sub1-remainder
            quotient-remainder
            remainder-add1-arg2
            difference-lessp
            remainder-minus-one-as-0
            lessp-transpose-meta
            difference-difference-arg1-commutes-meta
            equal-transpose-meta
            difference-0
            sub1-difference
            remainder-lessp-linear
            difference-not-lessp)))

;;; Trade quotient for times in lessp.

(prove-lemma lessp-quotient (rewrite)
  (and (equal (lessp b (quotient c a))
              (and (numberp a)
                   (not (equal a 0))
                   (not (lessp c (plus a (times a b))))))
       (equal (lessp (quotient c b) a)
              (or (lessp c (times a b))
                  (and (or (not (numberp b))
                           (equal b 0))
                       (numberp a)
                       (not (equal a 0))))))
  ((disable sub1-quotient
            difference-lessp
            lessp-transpose-meta
            quotient-lessp-linear
            equal-transpose-meta
            sub1-difference
            sub1-plus
            equal-times-cancel-meta
            quotient-times-arg1-simple
            lessp-times-linear
            difference-not-lessp)))

;;; The following two lemmas are required because nqthm does not open
;;;  recursive definitions more than once.

(prove-lemma remainder-of-modulus (rewrite)
  (equal (remainder a a) 0))

(prove-lemma quotient-is-1 (rewrite)
  (equal (quotient a a)
         (if (or (not (numberp a))
                 (equal a 0))
             0
           1)))

(prove-lemma equal-quotient-0 (rewrite)
  (equal (equal (quotient a b) 0)
         (or (not (numberp b))
             (equal b 0)
             (lessp a b))))

(prove-lemma plus-1 (rewrite)
  (and (equal (plus 1 a) (add1 a))
       (equal (plus a 1) (add1 a))))

(prove-lemma sub1-decreases (rewrite)
  (and
   (equal (equal (sub1 a) a)
          (equal a 0))
   (equal (equal (sub1 (sub1 a)) a)
          (equal a 0))))

(prove-lemma lessp-2 (rewrite)
  (equal (lessp a 2)
         (equal (sub1 a) 0)))

(prove-lemma lessp-remainder-by-2 (rewrite)
  (equal (lessp (times (remainder a 2) (remainder b 2)) 2) t)
  ((disable sub1-remainder
            sub1-times)))

(prove-lemma remainder-1-2 (rewrite)
  (and (equal (remainder a 1) 0)
       (equal (remainder (plus a a) 2) 0)
       (equal (remainder (plus a (plus a b)) 2)
              (remainder b 2))
       (equal (remainder (times a (sub1 a)) 2) 0)
       (equal (remainder (times a a) 2)
              (remainder a 2))
       (equal (remainder (times a (times a b)) 2)
              (remainder (times a b) 2)))
  ((expand (remainder x 2)
           (lessp x 2)
           (remainder b 2)
           (times b (times x x)))
   (disable remainder
            times
            plus
            lessp
            remainder-add1-arg2
            lessp-transpose-meta
            sub1-difference
            remainder-difference-arg1
            difference-lessp
            sub1-decreases
            equal-transpose-meta
            remainder-plus-arg1-simple
            difference-remainder-arg2
            sub1-times
            dichotomy
            lessp-facts
            times-zerop)))

(prove-lemma equal-difference-difference-cancellation (rewrite)
  (equal (equal a (difference b (difference c a)))
         (if (lessp c a)
             (equal a (if (numberp b) b 0))
           (if (lessp (plus a b) c)
               (equal a 0)
             (and (numberp a)
                  (equal (if (numberp b) b 0)
                         (if (numberp c) c 0)))))))

;;; Since the proof is not immediate, we include this Knuth-Bendix version
;;; of lessp-times.  In most cases, we expect times expansion, sub1 elimination
;;; and lessp-plus-cancel-meta to render this unnecessary.

(prove-lemma lessp-times-kb (rewrite)
  (and (equal (lessp (plus b (times b (sub1 a))) a)
              (and (not (zerop a))
                   (zerop b)))
       (equal (lessp (plus b (times (sub1 a) b)) a)
              (and (not (zerop a))
                   (zerop b)))
       (equal (lessp a (plus b (times b (sub1 a))))
              (or (and (zerop a)
                       (not (zerop b)))
                  (and (not (zerop a))
                       (not (zerop b))
                       (not (equal (sub1 b) 0)))))
       (equal (lessp a (plus b (times (sub1 a) b)))
              (or (and (zerop a)
                       (not (zerop b)))
                  (and (not (zerop a))
                       (not (zerop b))
                       (not (equal (sub1 b) 0)))))))

;;; This lemma is provided for situations where (times b c) is not naturally
;;; expanded.

(prove-lemma equal-plus-times-cancellation (rewrite)
  (let ((rhs (and (numberp c)
                  (or (and (numberp b)
                           (not (equal b 0))
                           (or (not (numberp a))
                               (equal a 0))
                           (or (equal c 0)
                               (equal (sub1 b) 0)))
                      (and (or (not (numberp b))
                               (equal b 0))
                           (equal (fix a) c))))))
    (and (equal (equal (plus a (times b c)) c) rhs)
         (equal (equal (plus (times b c) a) c) rhs)
         (equal (equal (plus a (times c b)) c) rhs)
         (equal (equal (plus (times c b) a) c) rhs))))

(prove-lemma remainder-remainder (rewrite)
  (implies (equal (remainder a b) 0)
           (and (equal (remainder (remainder c a) b)
                       (remainder c b))
                (equal (remainder (remainder c b) a)
                       (remainder c b))))
  ((disable remainder-lessp-linear
            remainder-plus-arg1-simple
            difference-not-lessp
            lessp-times-single-linear)))

(prove-lemma remainder-plus-remainder-arg1 (rewrite)
  (and (implies (equal (remainder b d) 0)
                (equal (remainder (plus a (remainder c b)) d)
                       (remainder (plus a c) d)))
       (implies (equal (remainder b d) 0)
                (equal (remainder (plus (remainder c b) a) d)
                       (remainder (plus c a) d))))
  ((disable remainder-lessp-linear
            dichotomy
            difference-not-lessp
            difference-lessp
            sub1-remainder
            sub1-plus
            remainder-difference-arg1
            difference-remainder-arg2
            sub1-difference
            remainder-plus-arg1-simple)))

(prove-lemma remainder-times-arg1-arg2 (rewrite)
  (and
   (equal (remainder (times a c) (times b c))
          (times c (remainder a b)))
   (equal (remainder (times c a) (times b c))
          (times c (remainder a b)))
   (equal (remainder (times a c) (times c b))
          (times c (remainder a b)))
   (equal (remainder (times c a) (times c b))
          (times c (remainder a b))))
  ((disable sub1-remainder
            lessp-transpose-meta
            difference-lessp
            difference-remainder-arg1
            sub1-plus
            sub1-times
            sub1-quotient
            remainder-difference-arg1
            equal-transpose-meta
            dichotomy
            difference-difference-arg1-commutes-meta
            difference-times-arg1
            lessp-times-single-linear
            difference-times-arg1-simpler
            equal-quotient-0
            quotient-lessp-linear
            equal-odometer-simple
            lessp-times-linear
            lessp-odometer-simple
            times-add1
            difference-times-arg1-meta
            difference-not-lessp
            remainder-lessp-linear
            sub1-difference
            quotient-plus-arg2
            plus-commutes-nest-meta
            quotient-times-arg1
            quotient-times-arg2
            no-divisors-of-zero
            difference-times-arg1-simplest
            remainder-times-arg1
            remainder-plus-arg1-simple)))

(prove-lemma quotient-times-arg2-commutes (rewrite)
  (and (equal (quotient (quotient (times a c) b) c)
              (if (or (not (numberp c))
                      (equal c 0))
                  0
                (quotient a b)))
       (equal (quotient (quotient (times c a) b) c)
              (if (or (not (numberp c))
                      (equal c 0))
                  0
                (quotient a b))))
  ((use (quotient-times-arg2 (a (times a c)) (zb c) (zc b))
        (quotient-times-arg2 (a (times a c)) (zb b) (zc c)))
   (disable quotient-times-arg2
            lessp-transpose-meta
            sub1-remainder
            sub1-quotient
            difference-lessp
            plus-is-0
            dichotomy
            remainder-times-arg2
            lessp-quotient-arg1-linear
            lessp-quotient
            equal-quotient-0
            lessp-quotient-arg2-linear
            difference-times-arg1-arg2
            quotient-plus-arg1
            difference-times-arg1
            sub1-times
            difference-not-lessp
            difference-times-arg1-meta
            remainder-lessp-linear)))

(prove-lemma quotient-times-arg1-arg2 (rewrite)
  (and
   (equal (quotient (times a c) (times b c))
          (if (or (not (numberp c)) (equal c 0))
              0
            (quotient a b)))
   (equal (quotient (times c a) (times b c))
          (if (or (not (numberp c)) (equal c 0))
              0
            (quotient a b)))
   (equal (quotient (times a c) (times c b))
          (if (or (not (numberp c)) (equal c 0))
              0
            (quotient a b)))
   (equal (quotient (times c a) (times c b))
          (if (or (not (numberp c)) (equal c 0))
              0
            (quotient a b))))
  ((disable times
            lessp-times-single-linear
            lessp-transpose-meta
            lessp-odometer-simple
            quotient-plus-arg1
            quotient-lessp-linear
            remainder-plus-arg1-simple
            equal-times-cancel-meta
            difference-lessp
            lessp-quotient
            difference-plus-arg1
            difference-times-arg2
            dichotomy
            equal-transpose-meta
            quotient-remainder
            difference-times-arg1-meta
            difference-not-lessp
            remainder-lessp-linear)))

(prove-lemma lessp-quotient-arg1-kb-linear (rewrite)
  (and (implies (and (not (lessp b a))
                     (numberp c)
                     (not (equal c 0)))
                (lessp a (plus c (times c (quotient b c)))))
       (implies (and (lessp a b) ; because of free variables
                     (numberp c)
                     (not (equal c 0)))
                (lessp a (plus c (times c (quotient b c))))))
  ((disable equal-odometer-simple)))

(prove-lemma lessp-quotient-arg2-kb-linear (rewrite)
  (and (implies (and (not (lessp b a))
                     (numberp a)
                     (not (equal a 0)))
                (lessp c (plus a (times b (quotient c a)))))
       (implies (and (not (lessp b a))
                     (numberp a)
                     (not (equal a 0)))
                (lessp c (plus a (times (quotient c a) b)))))
  ((disable lessp-times-linear
            sub1-quotient
            lessp-times-single-linear
            lessp-transpose-meta
            difference-not-lessp
            lessp-odometer-simple)))

(prove-lemma plus-difference-difference-cancellation (rewrite)
  (and (implies (and (not (lessp b a))
                     (not (lessp (plus c a) b)))
                (equal (plus b d (difference c (difference b a)))
                       (plus a c d)))
       (implies (and (not (lessp b a))
                     (not (lessp (plus c a) b)))
                (equal (plus b (difference c (difference b a)) d)
                       (plus a c d)))
       (implies (and (not (lessp b a))
                     (not (lessp (plus c a) b)))
                (equal (plus b (difference c (difference b a)))
                       (plus a c)))))

(prove-lemma quotient-times-arg2-kb (rewrite)
  (equal (quotient (quotient a b) c)
         (quotient (quotient a c) b))
  ((use (quotient-times-arg2 (a a) (zb b) (zc c))
        (quotient-times-arg2 (a a) (zb c) (zc b)))
   (disable quotient-times-arg2
            quotient
            times)))

(prove-lemma times-quotient-remainder (rewrite)
  (and
   (equal (plus (times a (remainder c b))
                (times a b (quotient c b)))
          (times c a))
   (equal (plus (times a (remainder c b))
                (times b a (quotient c b)))
          (times c a))
   (equal (plus (times (remainder c b) a)
                (times b (quotient c b) a))
          (times c a))

   (equal (plus (times a d (remainder c b))
                (times a d b (quotient c b)))
          (times c a d))
   (equal (plus (times a d (remainder c b))
                (times a b d (quotient c b)))
          (times c a d))
   (equal (plus (times a d (remainder c b))
                (times b a d (quotient c b)))
          (times c a d))
   (equal (plus (times a (remainder c b) d)
                (times a b (quotient c b) d))
          (times c a d))
   (equal (plus (times a (remainder c b) d)
                (times b a (quotient c b) d))
          (times c a d))

   (equal (plus (times a (remainder c b))
                (times a b (quotient c b))
                d)
          (plus (times c a) d))
   (equal (plus (times a (remainder c b))
                (times b a (quotient c b))
                d)
          (plus (times c a) d))
   (equal (plus (times (remainder c b) a)
                (times b (quotient c b) a)
                d)
          (plus (times c a) d))

   (equal (plus (times a d (remainder c b))
                (times a d b (quotient c b))
                e)
          (plus (times c a d) e))
   (equal (plus (times a d (remainder c b))
                (times a b d (quotient c b))
                e)
          (plus (times c a d) e))
   (equal (plus (times a d (remainder c b))
                (times b a d (quotient c b))
                e)
          (plus (times c a d) e))
   (equal (plus (times a b (quotient c b) d)
                (times a (remainder c b) d)
                e)
          (plus (times c a d) e))
   (equal (plus (times a (remainder c b) d)
                (times b a (quotient c b) d)
                e)
          (plus (times c a d) e)))
  ((disable sub1-times
            plus-commutes-meta
            equal-half-odometer
            lessp-times-cancel-meta
            sub1-quotient
            lessp-transpose-meta
            difference-not-lessp
            sub1-remainder
            difference-lessp
            equal-quotient-0
            remainder-difference-arg1
            remainder-lessp-linear
            equal-odometer
            lessp-quarter-odometer-right)))

(prove-lemma quotient-sub1-arg1 (rewrite)
  (equal (quotient (sub1 a) b)
         (if (or (not (numberp b))
                 (equal b 0))
             0
           (if (equal (sub1 b) 0)
               (sub1 a)
             (if (equal (remainder a b) 0)
                 (quotient (difference a b) b)
               (quotient a b)))))
  ((disable remainder-lessp-linear
            dichotomy
            plus-commutes-nest-meta
            plus-commutes-meta
            lessp-transpose-meta
            equal-transpose-meta
            difference-not-lessp
            lessp-times-single-linear)))


;;; lessp-cross-dot-linear and not-lessp-dot-cross-linear are expensive,
;;; when applied using the key (times a b).  If a is a complex expression,
;;; it gets duplicated when rewriting (times a a) within the right hand side.

;;; The following two lemmas are not needed for proofs in this event file.
;;; They will be enabled at the end of this proof file.

(prove-lemma lessp-cross-dot-linear (rewrite)
  (implies (or (lessp a b)
               (lessp b a)
               (and (not (equal a b))
                    (or (and (numberp a) (not (equal a 0)))
                        (and (numberp b) (not (equal b 0))))))
           (lessp (plus (times a b) (times a b))
                  (plus (times a a) (times b b))))
  ((induct (lessp a b))))

(disable lessp-cross-dot-linear)

(prove-lemma not-lessp-dot-cross-linear (rewrite)
  (not (lessp (plus (times a a) (times b b))
              (plus (times a b) (times a b))))
  ((induct (lessp a b))))

(disable not-lessp-dot-cross-linear)

;;; These rewrite rules should be placed at the end of the event file to
;;; assure that they are applied first.  They are here because we have
;;; economized on various Knuth-Bendix rules, by assuming if-normalization
;;; occurs.  In fact, if-normalization only occurs after rewriting has
;;; finished.  These rules are expensive and are rarely needed.  For this
;;; reason we include them in a deftheory so that they may be easily
;;; disabled.

;;; times-if is needed to speed up difference-times-arg1-arg2.  In particular
;;; it avoids using difference-times-arg1 needlessly, by simplifying
;;; (times b (quotient a a)) to (if (equal a 0) 0 (if (numberp a) b 0)).

(prove-lemma times-if (rewrite)
  (implies (equal aa a) ; to avoid repeated rewriting
           (and (equal (times a (if b c d))
                       (if b (times aa c) (times aa d)))
                (equal (times (if b c d) a)
                       (if b (times c aa) (times d aa))))))


(prove-lemma plus-if (rewrite)
  (implies (equal dd d)
           (and (equal (plus (if a b c) d)
                       (if a (plus b dd) (plus c dd)))
                (equal (plus d (if a b c))
                       (if a (plus dd b) (plus dd c))))))

(prove-lemma difference-if (rewrite)
  (implies
   (equal dd d)
   (and (equal (difference (if a b c) d)
               (if a (difference b dd) (difference c dd)))
        (equal (difference d (if a b c))
               (if a (difference dd b) (difference dd c))))))

(prove-lemma lessp-if (rewrite)
  (implies (equal dd d)
           (and (equal (lessp (if a b c) d)
                       (if a (lessp b dd) (lessp c dd)))
                (equal (lessp d (if a b c))
                       (if a (lessp dd b) (lessp dd c))))))

(prove-lemma equal-if (rewrite)
  (implies (equal dd d)
           (equal (equal (if a b c) d)
                  (if a (equal b dd) (equal c dd)))))

(prove-lemma add1-if (rewrite)
  (equal (add1 (if a b c))
         (if a (add1 b) (add1 c))))

(prove-lemma sub1-if (rewrite)
  (equal (sub1 (if a b c))
         (if a (sub1 b) (sub1 c))))

(prove-lemma remainder-if (rewrite)
  (implies (equal dd d)
           (and
            (equal (remainder (if a b c) d)
                   (if a (remainder b dd) (remainder c dd)))
            (equal (remainder dd (if a b c))
                   (if a (remainder dd b) (remainder dd c))))))

(prove-lemma quotient-if (rewrite)
  (implies (equal dd d)
           (and
            (equal (quotient (if a b c) d)
                   (if a (quotient b dd) (quotient c dd)))
            (equal (quotient dd (if a b c))
                   (if a (quotient dd b) (quotient dd c))))))

(deftheory if-normalization
  (times-if
   plus-if
   difference-if
   lessp-if
   equal-if
   add1-if
   sub1-if
   remainder-if
   quotient-if))

(make-lib "modularithmetic-98")
