;; THIS FILE IS AUTOGENERATED
;; See scripts/gen_z3_api.py for more information
(in-package :z3-c)

(defmacro defcfun? (name &rest args)
  "A version of defcfun that first checks whether the foreign function
exists, and warns if it does not."
  `(if (not (cffi:foreign-symbol-pointer ,name))
       (warn "Couldn't find function with name ~S, skipping..." ,name)
     (defcfun ,name ,@args)))

(defcfun "Z3_global_param_set" :void
  "Set a global (or module) parameter. This setting is shared by all Z3 contexts."
  (param-id :string)
  (param-value :string))

(defcfun "Z3_global_param_reset_all" :void
  "Restore the value of all global (and module) parameters. This command will not affect already created objects (such as tactics and solvers)."
  )

(defcfun "Z3_global_param_get" :bool
  "Get a global (or module) parameter."
  (param-id :string)
  (param-value :pointer))

(defcfun "Z3_mk_config" z3-c-types::Z3_config
  "Create a configuration object for the Z3 context object."
  )

(defcfun "Z3_del_config" :void
  "Delete the given configuration object."
  (c z3-c-types::Z3_config))

(defcfun "Z3_set_param_value" :void
  "Set a configuration parameter."
  (c z3-c-types::Z3_config)
  (param-id :string)
  (param-value :string))

(defcfun "Z3_mk_context" z3-c-types::Z3_context
  "Create a context using the given configuration."
  (c z3-c-types::Z3_config))

(defcfun "Z3_mk_context_rc" z3-c-types::Z3_context
  "Create a context using the given configuration. This function is similar to `Z3_mk_context`. However, in the context returned by this function, the user is responsible for managing `Z3_ast` reference counters. Managing reference counters is a burden and error-prone, but allows the user to use the memory more efficiently. The user must invoke `Z3_inc_ref` for any `Z3_ast` returned by Z3, and `Z3_dec_ref` whenever the `Z3_ast` is not needed anymore. This idiom is similar to the one used in BDD (binary decision diagrams) packages such as CUDD."
  (c z3-c-types::Z3_config))

(defcfun "Z3_del_context" :void
  "Delete the given logical context."
  (c z3-c-types::Z3_context))

(defcfun "Z3_inc_ref" :void
  "Increment the reference counter of the given AST. The context `c` should have been created using `Z3_mk_context_rc`. This function is a NOOP if `c` was created using `Z3_mk_context`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_dec_ref" :void
  "Decrement the reference counter of the given AST. The context `c` should have been created using `Z3_mk_context_rc`. This function is a NOOP if `c` was created using `Z3_mk_context`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_update_param_value" :void
  "Set a value of a context parameter."
  (c z3-c-types::Z3_context)
  (param-id :string)
  (param-value :string))

(defcfun "Z3_interrupt" :void
  "Interrupt the execution of a Z3 procedure. This procedure can be used to interrupt: solvers, simplifiers and tactics."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_params" z3-c-types::Z3_params
  "Create a Z3 (empty) parameter set. Starting at Z3 4.0, parameter sets are used to configure many components such as: simplifiers, tactics, solvers, etc."
  (c z3-c-types::Z3_context))

(defcfun "Z3_params_inc_ref" :void
  "Increment the reference counter of the given parameter set."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_params))

(defcfun "Z3_params_dec_ref" :void
  "Decrement the reference counter of the given parameter set."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_params))

(defcfun "Z3_params_set_bool" :void
  "Add a Boolean parameter `k` with value `v` to the parameter set `p`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_params)
  (k z3-c-types::Z3_symbol)
  (v :bool))

(defcfun "Z3_params_set_uint" :void
  "Add a unsigned parameter `k` with value `v` to the parameter set `p`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_params)
  (k z3-c-types::Z3_symbol)
  (v :uint))

(defcfun "Z3_params_set_double" :void
  "Add a double parameter `k` with value `v` to the parameter set `p`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_params)
  (k z3-c-types::Z3_symbol)
  (v :double))

(defcfun "Z3_params_set_symbol" :void
  "Add a symbol parameter `k` with value `v` to the parameter set `p`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_params)
  (k z3-c-types::Z3_symbol)
  (v z3-c-types::Z3_symbol))

(defcfun "Z3_params_to_string" :string
  "Convert a parameter set into a string. This function is mainly used for printing the contents of a parameter set."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_params))

(defcfun "Z3_params_validate" :void
  "Validate the parameter set `p` against the parameter description set `d`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_params)
  (d z3-c-types::Z3_param_descrs))

(defcfun "Z3_param_descrs_inc_ref" :void
  "Increment the reference counter of the given parameter description set."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_param_descrs))

(defcfun "Z3_param_descrs_dec_ref" :void
  "Decrement the reference counter of the given parameter description set."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_param_descrs))

(defcfun "Z3_param_descrs_get_kind" z3-c-types::Z3_param_kind
  "Return the kind associated with the given parameter name `n`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_param_descrs)
  (n z3-c-types::Z3_symbol))

(defcfun "Z3_param_descrs_size" :uint
  "Return the number of parameters in the given parameter description set."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_param_descrs))

(defcfun "Z3_param_descrs_get_name" z3-c-types::Z3_symbol
  "Return the name of the parameter at given index `i`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_param_descrs)
  (i :uint))

(defcfun "Z3_param_descrs_get_documentation" :string
  "Retrieve documentation string corresponding to parameter name `s`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_param_descrs)
  (s z3-c-types::Z3_symbol))

(defcfun "Z3_param_descrs_to_string" :string
  "Convert a parameter description set into a string. This function is mainly used for printing the contents of a parameter description set."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_param_descrs))

(defcfun "Z3_mk_int_symbol" z3-c-types::Z3_symbol
  "Create a Z3 symbol using an integer."
  (c z3-c-types::Z3_context)
  (i :int))

(defcfun "Z3_mk_string_symbol" z3-c-types::Z3_symbol
  "Create a Z3 symbol using a C string."
  (c z3-c-types::Z3_context)
  (s :string))

(defcfun "Z3_mk_uninterpreted_sort" z3-c-types::Z3_sort
  "Create a free (uninterpreted) type using the given name (symbol)."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_symbol))

(defcfun "Z3_mk_bool_sort" z3-c-types::Z3_sort
  "Create the Boolean type."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_int_sort" z3-c-types::Z3_sort
  "Create the integer type."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_real_sort" z3-c-types::Z3_sort
  "Create the real type."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_bv_sort" z3-c-types::Z3_sort
  "Create a bit-vector type of the given size."
  (c z3-c-types::Z3_context)
  (sz :uint))

(defcfun "Z3_mk_finite_domain_sort" z3-c-types::Z3_sort
  "Create a named finite domain sort."
  (c z3-c-types::Z3_context)
  (name z3-c-types::Z3_symbol)
  (size :uint64))

(defcfun "Z3_mk_array_sort" z3-c-types::Z3_sort
  "Create an array type."
  (c z3-c-types::Z3_context)
  (domain z3-c-types::Z3_sort)
  (range z3-c-types::Z3_sort))

(defcfun "Z3_mk_array_sort_n" z3-c-types::Z3_sort
  "Create an array type with N arguments"
  (c z3-c-types::Z3_context)
  (n :uint)
  (domain :pointer)
  (range z3-c-types::Z3_sort))

(defcfun "Z3_mk_tuple_sort" z3-c-types::Z3_sort
  "Create a tuple type."
  (c z3-c-types::Z3_context)
  (mk-tuple-name z3-c-types::Z3_symbol)
  (num-fields :uint)
  (field-names :pointer)
  (field-sorts :pointer)
  (mk-tuple-decl :pointer)
  (proj-decl :pointer))

(defcfun "Z3_mk_enumeration_sort" z3-c-types::Z3_sort
  "Create a enumeration sort."
  (c z3-c-types::Z3_context)
  (name z3-c-types::Z3_symbol)
  (n :uint)
  (enum-names :pointer)
  (enum-consts :pointer)
  (enum-testers :pointer))

(defcfun "Z3_mk_list_sort" z3-c-types::Z3_sort
  "Create a list sort"
  (c z3-c-types::Z3_context)
  (name z3-c-types::Z3_symbol)
  (elem-sort z3-c-types::Z3_sort)
  (nil-decl :pointer)
  (is-nil-decl :pointer)
  (cons-decl :pointer)
  (is-cons-decl :pointer)
  (head-decl :pointer)
  (tail-decl :pointer))

(defcfun "Z3_mk_constructor" z3-c-types::Z3_constructor
  "Create a constructor."
  (c z3-c-types::Z3_context)
  (name z3-c-types::Z3_symbol)
  (recognizer z3-c-types::Z3_symbol)
  (num-fields :uint)
  (field-names :pointer)
  (sorts :pointer)
  (sort-refs :pointer))

(defcfun "Z3_del_constructor" :void
  "Reclaim memory allocated to constructor."
  (c z3-c-types::Z3_context)
  (constr z3-c-types::Z3_constructor))

(defcfun "Z3_mk_datatype" z3-c-types::Z3_sort
  "Create datatype, such as lists, trees, records, enumerations or unions of records. The datatype may be recursive. Return the datatype sort."
  (c z3-c-types::Z3_context)
  (name z3-c-types::Z3_symbol)
  (num-constructors :uint)
  (constructors :pointer))

(defcfun "Z3_mk_constructor_list" z3-c-types::Z3_constructor_list
  "Create list of constructors."
  (c z3-c-types::Z3_context)
  (num-constructors :uint)
  (constructors :pointer))

(defcfun "Z3_del_constructor_list" :void
  "Reclaim memory allocated for constructor list."
  (c z3-c-types::Z3_context)
  (clist z3-c-types::Z3_constructor_list))

(defcfun "Z3_mk_datatypes" :void
  "Create mutually recursive datatypes."
  (c z3-c-types::Z3_context)
  (num-sorts :uint)
  (sort-names :pointer)
  (sorts :pointer)
  (constructor-lists :pointer))

(defcfun "Z3_query_constructor" :void
  "Query constructor for declared functions."
  (c z3-c-types::Z3_context)
  (constr z3-c-types::Z3_constructor)
  (num-fields :uint)
  (constructor :pointer)
  (tester :pointer)
  (accessors :pointer))

(defcfun "Z3_mk_func_decl" z3-c-types::Z3_func_decl
  "Declare a constant or function."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_symbol)
  (domain-size :uint)
  (domain :pointer)
  (range z3-c-types::Z3_sort))

(defcfun "Z3_mk_app" z3-c-types::Z3_ast
  "Create a constant or function application."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_const" z3-c-types::Z3_ast
  "Declare and create a constant."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_symbol)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_fresh_func_decl" z3-c-types::Z3_func_decl
  "Declare a fresh constant or function."
  (c z3-c-types::Z3_context)
  (prefix :string)
  (domain-size :uint)
  (domain :pointer)
  (range z3-c-types::Z3_sort))

(defcfun "Z3_mk_fresh_const" z3-c-types::Z3_ast
  "Declare and create a fresh constant."
  (c z3-c-types::Z3_context)
  (prefix :string)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_rec_func_decl" z3-c-types::Z3_func_decl
  "Declare a recursive function"
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_symbol)
  (domain-size :uint)
  (domain :pointer)
  (range z3-c-types::Z3_sort))

(defcfun "Z3_add_rec_def" :void
  "Define the body of a recursive function."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_decl)
  (n :uint)
  (args :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_true" z3-c-types::Z3_ast
  "Create an AST node representing `true`."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_false" z3-c-types::Z3_ast
  "Create an AST node representing `false`."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_eq" z3-c-types::Z3_ast
  "Create an AST node representing `l = r`."
  (c z3-c-types::Z3_context)
  (l z3-c-types::Z3_ast)
  (r z3-c-types::Z3_ast))

(defcfun "Z3_mk_distinct" z3-c-types::Z3_ast
  "Create an AST node representing `distinct(args[0], ..., args[num_args-1])`."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_not" z3-c-types::Z3_ast
  "Create an AST node representing `not(a)`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_mk_ite" z3-c-types::Z3_ast
  "Create an AST node representing an if-then-else: `ite(t1, t2, t3)`."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast)
  (t3 z3-c-types::Z3_ast))

(defcfun "Z3_mk_iff" z3-c-types::Z3_ast
  "Create an AST node representing `t1 iff t2`."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_implies" z3-c-types::Z3_ast
  "Create an AST node representing `t1 implies t2`."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_xor" z3-c-types::Z3_ast
  "Create an AST node representing `t1 xor t2`."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_and" z3-c-types::Z3_ast
  "Create an AST node representing `args[0] and ... and args[num_args-1]`."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_or" z3-c-types::Z3_ast
  "Create an AST node representing `args[0] or ... or args[num_args-1]`."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_add" z3-c-types::Z3_ast
  "Create an AST node representing `args[0] + ... + args[num_args-1]`."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_mul" z3-c-types::Z3_ast
  "Create an AST node representing `args[0] * ... * args[num_args-1]`."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_sub" z3-c-types::Z3_ast
  "Create an AST node representing `args[0] - ... - args[num_args - 1]`."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_unary_minus" z3-c-types::Z3_ast
  "Create an AST node representing `- arg`."
  (c z3-c-types::Z3_context)
  (arg z3-c-types::Z3_ast))

(defcfun "Z3_mk_div" z3-c-types::Z3_ast
  "Create an AST node representing `arg1 div arg2`."
  (c z3-c-types::Z3_context)
  (arg1 z3-c-types::Z3_ast)
  (arg2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_mod" z3-c-types::Z3_ast
  "Create an AST node representing `arg1 mod arg2`."
  (c z3-c-types::Z3_context)
  (arg1 z3-c-types::Z3_ast)
  (arg2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_rem" z3-c-types::Z3_ast
  "Create an AST node representing `arg1 rem arg2`."
  (c z3-c-types::Z3_context)
  (arg1 z3-c-types::Z3_ast)
  (arg2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_power" z3-c-types::Z3_ast
  "Create an AST node representing `arg1 ^ arg2`."
  (c z3-c-types::Z3_context)
  (arg1 z3-c-types::Z3_ast)
  (arg2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_lt" z3-c-types::Z3_ast
  "Create less than."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_le" z3-c-types::Z3_ast
  "Create less than or equal to."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_gt" z3-c-types::Z3_ast
  "Create greater than."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_ge" z3-c-types::Z3_ast
  "Create greater than or equal to."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_divides" z3-c-types::Z3_ast
  "Create division predicate."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_int2real" z3-c-types::Z3_ast
  "Coerce an integer to a real."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_real2int" z3-c-types::Z3_ast
  "Coerce a real to an integer."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_is_int" z3-c-types::Z3_ast
  "Check if a real number is an integer."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvnot" z3-c-types::Z3_ast
  "Bitwise negation."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvredand" z3-c-types::Z3_ast
  "Take conjunction of bits in vector, return vector of length 1."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvredor" z3-c-types::Z3_ast
  "Take disjunction of bits in vector, return vector of length 1."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvand" z3-c-types::Z3_ast
  "Bitwise and."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvor" z3-c-types::Z3_ast
  "Bitwise or."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvxor" z3-c-types::Z3_ast
  "Bitwise exclusive-or."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvnand" z3-c-types::Z3_ast
  "Bitwise nand."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvnor" z3-c-types::Z3_ast
  "Bitwise nor."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvxnor" z3-c-types::Z3_ast
  "Bitwise xnor."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvneg" z3-c-types::Z3_ast
  "Standard two's complement unary minus."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvadd" z3-c-types::Z3_ast
  "Standard two's complement addition."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsub" z3-c-types::Z3_ast
  "Standard two's complement subtraction."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvmul" z3-c-types::Z3_ast
  "Standard two's complement multiplication."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvudiv" z3-c-types::Z3_ast
  "Unsigned division."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsdiv" z3-c-types::Z3_ast
  "Two's complement signed division."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvurem" z3-c-types::Z3_ast
  "Unsigned remainder."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsrem" z3-c-types::Z3_ast
  "Two's complement signed remainder (sign follows dividend)."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsmod" z3-c-types::Z3_ast
  "Two's complement signed remainder (sign follows divisor)."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvult" z3-c-types::Z3_ast
  "Unsigned less than."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvslt" z3-c-types::Z3_ast
  "Two's complement signed less than."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvule" z3-c-types::Z3_ast
  "Unsigned less than or equal to."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsle" z3-c-types::Z3_ast
  "Two's complement signed less than or equal to."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvuge" z3-c-types::Z3_ast
  "Unsigned greater than or equal to."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsge" z3-c-types::Z3_ast
  "Two's complement signed greater than or equal to."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvugt" z3-c-types::Z3_ast
  "Unsigned greater than."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsgt" z3-c-types::Z3_ast
  "Two's complement signed greater than."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_concat" z3-c-types::Z3_ast
  "Concatenate the given bit-vectors."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_extract" z3-c-types::Z3_ast
  "Extract the bits `high` down to `low` from a bit-vector of size `m` to yield a new bit-vector of size `n,` where `n = high - low + 1`."
  (c z3-c-types::Z3_context)
  (high :uint)
  (low :uint)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_sign_ext" z3-c-types::Z3_ast
  "Sign-extend of the given bit-vector to the (signed) equivalent bit-vector of size `m+i`, where `m` is the size of the given bit-vector."
  (c z3-c-types::Z3_context)
  (i :uint)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_zero_ext" z3-c-types::Z3_ast
  "Extend the given bit-vector with zeros to the (unsigned) equivalent bit-vector of size `m+i`, where `m` is the size of the given bit-vector."
  (c z3-c-types::Z3_context)
  (i :uint)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_repeat" z3-c-types::Z3_ast
  "Repeat the given bit-vector up length `i`."
  (c z3-c-types::Z3_context)
  (i :uint)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvshl" z3-c-types::Z3_ast
  "Shift left."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvlshr" z3-c-types::Z3_ast
  "Logical shift right."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvashr" z3-c-types::Z3_ast
  "Arithmetic shift right."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_rotate_left" z3-c-types::Z3_ast
  "Rotate bits of `t1` to the left `i` times."
  (c z3-c-types::Z3_context)
  (i :uint)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_rotate_right" z3-c-types::Z3_ast
  "Rotate bits of `t1` to the right `i` times."
  (c z3-c-types::Z3_context)
  (i :uint)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_ext_rotate_left" z3-c-types::Z3_ast
  "Rotate bits of `t1` to the left `t2` times."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_ext_rotate_right" z3-c-types::Z3_ast
  "Rotate bits of `t1` to the right `t2` times."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_int2bv" z3-c-types::Z3_ast
  "Create an `n` bit bit-vector from the integer argument `t1`."
  (c z3-c-types::Z3_context)
  (n :uint)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bv2int" z3-c-types::Z3_ast
  "Create an integer from the bit-vector argument `t1`. If `is_signed` is false, then the bit-vector `t1` is treated as unsigned. So the result is non-negative and in the range `[0..2^N-1]`, where N are the number of bits in `t1`. If `is_signed` is true, `t1` is treated as a signed bit-vector."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (is-signed :bool))

(defcfun "Z3_mk_bvadd_no_overflow" z3-c-types::Z3_ast
  "Create a predicate that checks that the bit-wise addition of `t1` and `t2` does not overflow."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast)
  (is-signed :bool))

(defcfun "Z3_mk_bvadd_no_underflow" z3-c-types::Z3_ast
  "Create a predicate that checks that the bit-wise signed addition of `t1` and `t2` does not underflow."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsub_no_overflow" z3-c-types::Z3_ast
  "Create a predicate that checks that the bit-wise signed subtraction of `t1` and `t2` does not overflow."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvsub_no_underflow" z3-c-types::Z3_ast
  "Create a predicate that checks that the bit-wise subtraction of `t1` and `t2` does not underflow."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast)
  (is-signed :bool))

(defcfun "Z3_mk_bvsdiv_no_overflow" z3-c-types::Z3_ast
  "Create a predicate that checks that the bit-wise signed division of `t1` and `t2` does not overflow."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvneg_no_overflow" z3-c-types::Z3_ast
  "Check that bit-wise negation does not overflow when `t1` is interpreted as a signed bit-vector."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast))

(defcfun "Z3_mk_bvmul_no_overflow" z3-c-types::Z3_ast
  "Create a predicate that checks that the bit-wise multiplication of `t1` and `t2` does not overflow."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast)
  (is-signed :bool))

(defcfun "Z3_mk_bvmul_no_underflow" z3-c-types::Z3_ast
  "Create a predicate that checks that the bit-wise signed multiplication of `t1` and `t2` does not underflow."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_select" z3-c-types::Z3_ast
  "Array read. The argument `a` is the array and `i` is the index of the array that gets read."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (i z3-c-types::Z3_ast))

(defcfun "Z3_mk_select_n" z3-c-types::Z3_ast
  "n-ary Array read. The argument `a` is the array and `idxs` are the indices of the array that gets read."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (n :uint)
  (idxs :pointer))

(defcfun "Z3_mk_store" z3-c-types::Z3_ast
  "Array update."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (i z3-c-types::Z3_ast)
  (v z3-c-types::Z3_ast))

(defcfun "Z3_mk_store_n" z3-c-types::Z3_ast
  "n-ary Array update."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (n :uint)
  (idxs :pointer)
  (v z3-c-types::Z3_ast))

(defcfun "Z3_mk_const_array" z3-c-types::Z3_ast
  "Create the constant array."
  (c z3-c-types::Z3_context)
  (domain z3-c-types::Z3_sort)
  (v z3-c-types::Z3_ast))

(defcfun "Z3_mk_map" z3-c-types::Z3_ast
  "Map f on the argument arrays."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_decl)
  (n :uint)
  (args :pointer))

(defcfun "Z3_mk_array_default" z3-c-types::Z3_ast
  "Access the array default value. Produces the default range value, for arrays that can be represented as finite maps with a default range value."
  (c z3-c-types::Z3_context)
  (array z3-c-types::Z3_ast))

(defcfun "Z3_mk_as_array" z3-c-types::Z3_ast
  "Create array with the same interpretation as a function. The array satisfies the property (f x) = (select (_ as-array f) x) for every argument x."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_decl))

(defcfun "Z3_mk_set_has_size" z3-c-types::Z3_ast
  "Create predicate that holds if Boolean array `set` has `k` elements set to true."
  (c z3-c-types::Z3_context)
  (set z3-c-types::Z3_ast)
  (k z3-c-types::Z3_ast))

(defcfun "Z3_mk_set_sort" z3-c-types::Z3_sort
  "Create Set type."
  (c z3-c-types::Z3_context)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_empty_set" z3-c-types::Z3_ast
  "Create the empty set."
  (c z3-c-types::Z3_context)
  (domain z3-c-types::Z3_sort))

(defcfun "Z3_mk_full_set" z3-c-types::Z3_ast
  "Create the full set."
  (c z3-c-types::Z3_context)
  (domain z3-c-types::Z3_sort))

(defcfun "Z3_mk_set_add" z3-c-types::Z3_ast
  "Add an element to a set."
  (c z3-c-types::Z3_context)
  (set z3-c-types::Z3_ast)
  (elem z3-c-types::Z3_ast))

(defcfun "Z3_mk_set_del" z3-c-types::Z3_ast
  "Remove an element to a set."
  (c z3-c-types::Z3_context)
  (set z3-c-types::Z3_ast)
  (elem z3-c-types::Z3_ast))

(defcfun "Z3_mk_set_union" z3-c-types::Z3_ast
  "Take the union of a list of sets."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_set_intersect" z3-c-types::Z3_ast
  "Take the intersection of a list of sets."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_mk_set_difference" z3-c-types::Z3_ast
  "Take the set difference between two sets."
  (c z3-c-types::Z3_context)
  (arg1 z3-c-types::Z3_ast)
  (arg2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_set_complement" z3-c-types::Z3_ast
  "Take the complement of a set."
  (c z3-c-types::Z3_context)
  (arg z3-c-types::Z3_ast))

(defcfun "Z3_mk_set_member" z3-c-types::Z3_ast
  "Check for set membership."
  (c z3-c-types::Z3_context)
  (elem z3-c-types::Z3_ast)
  (set z3-c-types::Z3_ast))

(defcfun "Z3_mk_set_subset" z3-c-types::Z3_ast
  "Check for subsetness of sets."
  (c z3-c-types::Z3_context)
  (arg1 z3-c-types::Z3_ast)
  (arg2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_array_ext" z3-c-types::Z3_ast
  "Create array extensionality index given two arrays with the same sort. The meaning is given by the axiom: (=> (= (select A (array-ext A B)) (select B (array-ext A B))) (= A B))"
  (c z3-c-types::Z3_context)
  (arg1 z3-c-types::Z3_ast)
  (arg2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_numeral" z3-c-types::Z3_ast
  "Create a numeral of a given sort."
  (c z3-c-types::Z3_context)
  (numeral :string)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_real" z3-c-types::Z3_ast
  "Create a real from a fraction."
  (c z3-c-types::Z3_context)
  (num :int)
  (den :int))

(defcfun "Z3_mk_int" z3-c-types::Z3_ast
  "Create a numeral of an int, bit-vector, or finite-domain sort."
  (c z3-c-types::Z3_context)
  (v :int)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_unsigned_int" z3-c-types::Z3_ast
  "Create a numeral of a int, bit-vector, or finite-domain sort."
  (c z3-c-types::Z3_context)
  (v :uint)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_int64" z3-c-types::Z3_ast
  "Create a numeral of a int, bit-vector, or finite-domain sort."
  (c z3-c-types::Z3_context)
  (v :int64)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_unsigned_int64" z3-c-types::Z3_ast
  "Create a numeral of a int, bit-vector, or finite-domain sort."
  (c z3-c-types::Z3_context)
  (v :uint64)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_bv_numeral" z3-c-types::Z3_ast
  "create a bit-vector numeral from a vector of Booleans."
  (c z3-c-types::Z3_context)
  (sz :uint)
  (bits :pointer))

(defcfun "Z3_mk_seq_sort" z3-c-types::Z3_sort
  "Create a sequence sort out of the sort for the elements."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_is_seq_sort" :bool
  "Check if `s` is a sequence sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_get_seq_sort_basis" z3-c-types::Z3_sort
  "Retrieve basis sort for sequence sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_re_sort" z3-c-types::Z3_sort
  "Create a regular expression sort out of a sequence sort."
  (c z3-c-types::Z3_context)
  (seq z3-c-types::Z3_sort))

(defcfun "Z3_is_re_sort" :bool
  "Check if `s` is a regular expression sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_get_re_sort_basis" z3-c-types::Z3_sort
  "Retrieve basis sort for regex sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_string_sort" z3-c-types::Z3_sort
  "Create a sort for unicode strings."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_char_sort" z3-c-types::Z3_sort
  "Create a sort for unicode characters."
  (c z3-c-types::Z3_context))

(defcfun "Z3_is_string_sort" :bool
  "Check if `s` is a string sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_is_char_sort" :bool
  "Check if `s` is a character sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_string" z3-c-types::Z3_ast
  "Create a string constant out of the string that is passed in The string may contain escape encoding for non-printable characters or characters outside of the basic printable ASCII range. For example, the escape encoding \\u{0} represents the character 0 and the encoding \\u{100} represents the character 256."
  (c z3-c-types::Z3_context)
  (s :string))

(defcfun "Z3_mk_lstring" z3-c-types::Z3_ast
  "Create a string constant out of the string that is passed in It takes the length of the string as well to take into account 0 characters. The string is treated as if it is unescaped so a sequence of characters \\u{0} is treated as 5 characters and not the character 0."
  (c z3-c-types::Z3_context)
  (len :uint)
  (s :string))

(defcfun "Z3_mk_u32string" z3-c-types::Z3_ast
  "Create a string constant out of the string that is passed in It takes the length of the string as well to take into account 0 characters. The string is unescaped."
  (c z3-c-types::Z3_context)
  (len :uint)
  (chars :pointer))

(defcfun "Z3_is_string" :bool
  "Determine if `s` is a string constant."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_get_string" :string
  "Retrieve the string constant stored in `s`. Characters outside the basic printiable ASCII range are escaped."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_get_lstring" :pointer
  "Retrieve the string constant stored in `s`. The string can contain escape sequences. Characters in the range 1 to 255 are literal. Characters in the range 0, and 256 above are escaped."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast)
  (length :pointer))

(defcfun "Z3_get_string_length" :uint
  "Retrieve the length of the unescaped string constant stored in `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_get_string_contents" :void
  "Retrieve the unescaped string constant stored in `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast)
  (length :uint)
  (contents :pointer))

(defcfun "Z3_mk_seq_empty" z3-c-types::Z3_ast
  "Create an empty sequence of the sequence sort `seq`."
  (c z3-c-types::Z3_context)
  (seq z3-c-types::Z3_sort))

(defcfun "Z3_mk_seq_unit" z3-c-types::Z3_ast
  "Create a unit sequence of `a`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_concat" z3-c-types::Z3_ast
  "Concatenate sequences."
  (c z3-c-types::Z3_context)
  (n :uint)
  (args :pointer))

(defcfun "Z3_mk_seq_prefix" z3-c-types::Z3_ast
  "Check if `prefix` is a prefix of `s`."
  (c z3-c-types::Z3_context)
  (prefix z3-c-types::Z3_ast)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_suffix" z3-c-types::Z3_ast
  "Check if `suffix` is a suffix of `s`."
  (c z3-c-types::Z3_context)
  (suffix z3-c-types::Z3_ast)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_contains" z3-c-types::Z3_ast
  "Check if `container` contains `containee`."
  (c z3-c-types::Z3_context)
  (container z3-c-types::Z3_ast)
  (containee z3-c-types::Z3_ast))

(defcfun "Z3_mk_str_lt" z3-c-types::Z3_ast
  "Check if `s1` is lexicographically strictly less than `s2`."
  (c z3-c-types::Z3_context)
  (prefix z3-c-types::Z3_ast)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_str_le" z3-c-types::Z3_ast
  "Check if `s1` is equal or lexicographically strictly less than `s2`."
  (c z3-c-types::Z3_context)
  (prefix z3-c-types::Z3_ast)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_extract" z3-c-types::Z3_ast
  "Extract subsequence starting at `offset` of `length`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast)
  (offset z3-c-types::Z3_ast)
  (length z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_replace" z3-c-types::Z3_ast
  "Replace the first occurrence of `src` with `dst` in `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast)
  (src z3-c-types::Z3_ast)
  (dst z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_at" z3-c-types::Z3_ast
  "Retrieve from `s` the unit sequence positioned at position `index`. The sequence is empty if the index is out of bounds."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast)
  (index z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_nth" z3-c-types::Z3_ast
  "Retrieve from `s` the element positioned at position `index`. The function is under-specified if the index is out of bounds."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast)
  (index z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_length" z3-c-types::Z3_ast
  "Return the length of the sequence `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_index" z3-c-types::Z3_ast
  "Return index of first occurrence of `substr` in `s` starting from offset `offset`. If `s` does not contain `substr,` then the value is -1, if `offset` is the length of `s,` then the value is -1 as well. The value is -1 if `offset` is negative or larger than the length of `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast)
  (substr z3-c-types::Z3_ast)
  (offset z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_last_index" z3-c-types::Z3_ast
  ""
  (c z3-c-types::Z3_context)
  (x z3-c-types::Z3_ast)
  (substr z3-c-types::Z3_ast))

(defcfun "Z3_mk_str_to_int" z3-c-types::Z3_ast
  "Convert string to integer."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_int_to_str" z3-c-types::Z3_ast
  "Integer to string conversion."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_string_to_code" z3-c-types::Z3_ast
  "String to code conversion."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_mk_string_from_code" z3-c-types::Z3_ast
  "Code to string conversion."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_mk_ubv_to_str" z3-c-types::Z3_ast
  "Unsigned bit-vector to string conversion."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_sbv_to_str" z3-c-types::Z3_ast
  "Signed bit-vector to string conversion."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_to_re" z3-c-types::Z3_ast
  "Create a regular expression that accepts the sequence `seq`."
  (c z3-c-types::Z3_context)
  (seq z3-c-types::Z3_ast))

(defcfun "Z3_mk_seq_in_re" z3-c-types::Z3_ast
  "Check if `seq` is in the language generated by the regular expression `re`."
  (c z3-c-types::Z3_context)
  (seq z3-c-types::Z3_ast)
  (re z3-c-types::Z3_ast))

(defcfun "Z3_mk_re_plus" z3-c-types::Z3_ast
  "Create the regular language `re+`."
  (c z3-c-types::Z3_context)
  (re z3-c-types::Z3_ast))

(defcfun "Z3_mk_re_star" z3-c-types::Z3_ast
  "Create the regular language `re*`."
  (c z3-c-types::Z3_context)
  (re z3-c-types::Z3_ast))

(defcfun "Z3_mk_re_option" z3-c-types::Z3_ast
  "Create the regular language `[re]`."
  (c z3-c-types::Z3_context)
  (re z3-c-types::Z3_ast))

(defcfun "Z3_mk_re_union" z3-c-types::Z3_ast
  "Create the union of the regular languages."
  (c z3-c-types::Z3_context)
  (n :uint)
  (args :pointer))

(defcfun "Z3_mk_re_concat" z3-c-types::Z3_ast
  "Create the concatenation of the regular languages."
  (c z3-c-types::Z3_context)
  (n :uint)
  (args :pointer))

(defcfun "Z3_mk_re_range" z3-c-types::Z3_ast
  "Create the range regular expression over two sequences of length 1."
  (c z3-c-types::Z3_context)
  (lo z3-c-types::Z3_ast)
  (hi z3-c-types::Z3_ast))

(defcfun "Z3_mk_re_allchar" z3-c-types::Z3_ast
  "Create a regular expression that accepts all singleton sequences of the regular expression sort"
  (c z3-c-types::Z3_context)
  (regex-sort z3-c-types::Z3_sort))

(defcfun "Z3_mk_re_loop" z3-c-types::Z3_ast
  "Create a regular expression loop. The supplied regular expression `r` is repeated between `lo` and `hi` times. The `lo` should be below `hi` with one exception: when supplying the value `hi` as 0, the meaning is to repeat the argument `r` at least `lo` number of times, and with an unbounded upper bound."
  (c z3-c-types::Z3_context)
  (r z3-c-types::Z3_ast)
  (lo :uint)
  (hi :uint))

(defcfun "Z3_mk_re_power" z3-c-types::Z3_ast
  "Create a power regular expression."
  (c z3-c-types::Z3_context)
  (x z3-c-types::Z3_ast)
  (n :uint))

(defcfun "Z3_mk_re_intersect" z3-c-types::Z3_ast
  "Create the intersection of the regular languages."
  (c z3-c-types::Z3_context)
  (n :uint)
  (args :pointer))

(defcfun "Z3_mk_re_complement" z3-c-types::Z3_ast
  "Create the complement of the regular language `re`."
  (c z3-c-types::Z3_context)
  (re z3-c-types::Z3_ast))

(defcfun "Z3_mk_re_diff" z3-c-types::Z3_ast
  "Create the difference of regular expressions."
  (c z3-c-types::Z3_context)
  (re1 z3-c-types::Z3_ast)
  (re2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_re_empty" z3-c-types::Z3_ast
  "Create an empty regular expression of sort `re`."
  (c z3-c-types::Z3_context)
  (re z3-c-types::Z3_sort))

(defcfun "Z3_mk_re_full" z3-c-types::Z3_ast
  "Create an universal regular expression of sort `re`."
  (c z3-c-types::Z3_context)
  (re z3-c-types::Z3_sort))

(defcfun "Z3_mk_char" z3-c-types::Z3_ast
  ""
  (c z3-c-types::Z3_context)
  (ch :uint))

(defcfun "Z3_mk_char_le" z3-c-types::Z3_ast
  "Create less than or equal to between two characters."
  (c z3-c-types::Z3_context)
  (ch1 z3-c-types::Z3_ast)
  (ch2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_char_to_int" z3-c-types::Z3_ast
  "Create an integer (code point) from character."
  (c z3-c-types::Z3_context)
  (ch z3-c-types::Z3_ast))

(defcfun "Z3_mk_char_to_bv" z3-c-types::Z3_ast
  "Create a bit-vector (code point) from character."
  (c z3-c-types::Z3_context)
  (ch z3-c-types::Z3_ast))

(defcfun "Z3_mk_char_from_bv" z3-c-types::Z3_ast
  "Create a character from a bit-vector (code point)."
  (c z3-c-types::Z3_context)
  (bv z3-c-types::Z3_ast))

(defcfun "Z3_mk_char_is_digit" z3-c-types::Z3_ast
  "Create a check if the character is a digit."
  (c z3-c-types::Z3_context)
  (ch z3-c-types::Z3_ast))

(defcfun "Z3_mk_linear_order" z3-c-types::Z3_func_decl
  "create a linear ordering relation over signature `a`. The relation is identified by the index `id`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_sort)
  (id :uint))

(defcfun "Z3_mk_partial_order" z3-c-types::Z3_func_decl
  "create a partial ordering relation over signature `a` and index `id`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_sort)
  (id :uint))

(defcfun "Z3_mk_piecewise_linear_order" z3-c-types::Z3_func_decl
  "create a piecewise linear ordering relation over signature `a` and index `id`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_sort)
  (id :uint))

(defcfun "Z3_mk_tree_order" z3-c-types::Z3_func_decl
  "create a tree ordering relation over signature `a` identified using index `id`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_sort)
  (id :uint))

(defcfun "Z3_mk_transitive_closure" z3-c-types::Z3_func_decl
  "create transitive closure of binary relation."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_decl))

(defcfun "Z3_mk_pattern" z3-c-types::Z3_pattern
  "Create a pattern for quantifier instantiation."
  (c z3-c-types::Z3_context)
  (num-patterns :uint)
  (terms :pointer))

(defcfun "Z3_mk_bound" z3-c-types::Z3_ast
  "Create a bound variable."
  (c z3-c-types::Z3_context)
  (index :uint)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_forall" z3-c-types::Z3_ast
  "Create a forall formula. It takes an expression `body` that contains bound variables of the same sorts as the sorts listed in the array `sorts`. The bound variables are de-Bruijn indices created using `Z3_mk_bound`. The array `decl_names` contains the names that the quantified formula uses for the bound variables. Z3 applies the convention that the last element in the `decl_names` and `sorts` array refers to the variable with index 0, the second to last element of `decl_names` and `sorts` refers to the variable with index 1, etc."
  (c z3-c-types::Z3_context)
  (weight :uint)
  (num-patterns :uint)
  (patterns :pointer)
  (num-decls :uint)
  (sorts :pointer)
  (decl-names :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_exists" z3-c-types::Z3_ast
  "Create an exists formula. Similar to `Z3_mk_forall`."
  (c z3-c-types::Z3_context)
  (weight :uint)
  (num-patterns :uint)
  (patterns :pointer)
  (num-decls :uint)
  (sorts :pointer)
  (decl-names :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_quantifier" z3-c-types::Z3_ast
  "Create a quantifier - universal or existential, with pattern hints. See the documentation for `Z3_mk_forall` for an explanation of the parameters."
  (c z3-c-types::Z3_context)
  (is-forall :bool)
  (weight :uint)
  (num-patterns :uint)
  (patterns :pointer)
  (num-decls :uint)
  (sorts :pointer)
  (decl-names :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_quantifier_ex" z3-c-types::Z3_ast
  "Create a quantifier - universal or existential, with pattern hints, no patterns, and attributes"
  (c z3-c-types::Z3_context)
  (is-forall :bool)
  (weight :uint)
  (quantifier-id z3-c-types::Z3_symbol)
  (skolem-id z3-c-types::Z3_symbol)
  (num-patterns :uint)
  (patterns :pointer)
  (num-no-patterns :uint)
  (no-patterns :pointer)
  (num-decls :uint)
  (sorts :pointer)
  (decl-names :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_forall_const" z3-c-types::Z3_ast
  "Create a universal quantifier using a list of constants that will form the set of bound variables."
  (c z3-c-types::Z3_context)
  (weight :uint)
  (num-bound :uint)
  (bound :pointer)
  (num-patterns :uint)
  (patterns :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_exists_const" z3-c-types::Z3_ast
  "Similar to `Z3_mk_forall_const`. Create an existential quantifier using a list of constants that will form the set of bound variables."
  (c z3-c-types::Z3_context)
  (weight :uint)
  (num-bound :uint)
  (bound :pointer)
  (num-patterns :uint)
  (patterns :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_quantifier_const" z3-c-types::Z3_ast
  "Create a universal or existential quantifier using a list of constants that will form the set of bound variables."
  (c z3-c-types::Z3_context)
  (is-forall :bool)
  (weight :uint)
  (num-bound :uint)
  (bound :pointer)
  (num-patterns :uint)
  (patterns :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_quantifier_const_ex" z3-c-types::Z3_ast
  "Create a universal or existential quantifier using a list of constants that will form the set of bound variables."
  (c z3-c-types::Z3_context)
  (is-forall :bool)
  (weight :uint)
  (quantifier-id z3-c-types::Z3_symbol)
  (skolem-id z3-c-types::Z3_symbol)
  (num-bound :uint)
  (bound :pointer)
  (num-patterns :uint)
  (patterns :pointer)
  (num-no-patterns :uint)
  (no-patterns :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_lambda" z3-c-types::Z3_ast
  "Create a lambda expression. It takes an expression `body` that contains bound variables of the same sorts as the sorts listed in the array `sorts`. The bound variables are de-Bruijn indices created using `Z3_mk_bound`. The array `decl_names` contains the names that the quantified formula uses for the bound variables. Z3 applies the convention that the last element in the `decl_names` and `sorts` array refers to the variable with index 0, the second to last element of `decl_names` and `sorts` refers to the variable with index 1, etc. The sort of the resulting expression is `(Array` sorts range) where `range` is the sort of `body`. For example, if the lambda binds two variables of sort `Int` and `Bool,` and the `body` has sort `Real,` the sort of the expression is `(Array` Int Bool Real)."
  (c z3-c-types::Z3_context)
  (num-decls :uint)
  (sorts :pointer)
  (decl-names :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_mk_lambda_const" z3-c-types::Z3_ast
  "Create a lambda expression using a list of constants that form the set of bound variables"
  (c z3-c-types::Z3_context)
  (num-bound :uint)
  (bound :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_get_symbol_kind" z3-c-types::Z3_symbol_kind
  "Return `Z3_INT_SYMBOL` if the symbol was constructed using `Z3_mk_int_symbol`, and `Z3_STRING_SYMBOL` if the symbol was constructed using `Z3_mk_string_symbol`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_symbol))

(defcfun "Z3_get_symbol_int" :int
  "Return the symbol int value."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_symbol))

(defcfun "Z3_get_symbol_string" :string
  "Return the symbol name."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_symbol))

(defcfun "Z3_get_sort_name" z3-c-types::Z3_symbol
  "Return the sort name as a symbol."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_sort))

(defcfun "Z3_get_sort_id" :uint
  "Return a unique identifier for `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_sort_to_ast" z3-c-types::Z3_ast
  "Convert a `Z3_sort` into `Z3_ast`. This is just type casting."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_is_eq_sort" :bool
  "compare sorts."
  (c z3-c-types::Z3_context)
  (s1 z3-c-types::Z3_sort)
  (s2 z3-c-types::Z3_sort))

(defcfun "Z3_get_sort_kind" z3-c-types::Z3_sort_kind
  "Return the sort kind (e.g., array, tuple, int, bool, etc)."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort))

(defcfun "Z3_get_bv_sort_size" :uint
  "Return the size of the given bit-vector sort."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort))

(defcfun "Z3_get_finite_domain_sort_size" :bool
  "Store the size of the sort in `r`. Return `false` if the call failed. That is, Z3_get_sort_kind(s) == Z3_FINITE_DOMAIN_SORT"
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort)
  (r :pointer))

(defcfun "Z3_get_array_sort_domain" z3-c-types::Z3_sort
  "Return the domain of the given array sort. In the case of a multi-dimensional array, this function returns the sort of the first dimension."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort))

(defcfun "Z3_get_array_sort_domain_n" z3-c-types::Z3_sort
  "Return the i'th domain sort of an n-dimensional array."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort)
  (idx :uint))

(defcfun "Z3_get_array_sort_range" z3-c-types::Z3_sort
  "Return the range of the given array sort."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort))

(defcfun "Z3_get_tuple_sort_mk_decl" z3-c-types::Z3_func_decl
  "Return the constructor declaration of the given tuple sort."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort))

(defcfun "Z3_get_tuple_sort_num_fields" :uint
  "Return the number of fields of the given tuple sort."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort))

(defcfun "Z3_get_tuple_sort_field_decl" z3-c-types::Z3_func_decl
  "Return the i-th field declaration (i.e., projection function declaration) of the given tuple sort."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort)
  (i :uint))

(defcfun "Z3_get_datatype_sort_num_constructors" :uint
  "Return number of constructors for datatype."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort))

(defcfun "Z3_get_datatype_sort_constructor" z3-c-types::Z3_func_decl
  "Return idx'th constructor."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort)
  (idx :uint))

(defcfun "Z3_get_datatype_sort_recognizer" z3-c-types::Z3_func_decl
  "Return idx'th recognizer."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort)
  (idx :uint))

(defcfun "Z3_get_datatype_sort_constructor_accessor" z3-c-types::Z3_func_decl
  "Return idx_a'th accessor for the idx_c'th constructor."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_sort)
  (idx-c :uint)
  (idx-a :uint))

(defcfun "Z3_datatype_update_field" z3-c-types::Z3_ast
  "Update record field with a value."
  (c z3-c-types::Z3_context)
  (field-access z3-c-types::Z3_func_decl)
  (ast z3-c-types::Z3_ast)
  (value z3-c-types::Z3_ast))

(defcfun "Z3_get_relation_arity" :uint
  "Return arity of relation."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_get_relation_column" z3-c-types::Z3_sort
  "Return sort at i'th column of relation sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort)
  (col :uint))

(defcfun "Z3_mk_atmost" z3-c-types::Z3_ast
  "Pseudo-Boolean relations."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer)
  (k :uint))

(defcfun "Z3_mk_atleast" z3-c-types::Z3_ast
  "Pseudo-Boolean relations."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer)
  (k :uint))

(defcfun "Z3_mk_pble" z3-c-types::Z3_ast
  "Pseudo-Boolean relations."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer)
  (coeffs :pointer)
  (k :int))

(defcfun "Z3_mk_pbge" z3-c-types::Z3_ast
  "Pseudo-Boolean relations."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer)
  (coeffs :pointer)
  (k :int))

(defcfun "Z3_mk_pbeq" z3-c-types::Z3_ast
  "Pseudo-Boolean relations."
  (c z3-c-types::Z3_context)
  (num-args :uint)
  (args :pointer)
  (coeffs :pointer)
  (k :int))

(defcfun "Z3_func_decl_to_ast" z3-c-types::Z3_ast
  "Convert a `Z3_func_decl` into `Z3_ast`. This is just type casting."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_decl))

(defcfun "Z3_is_eq_func_decl" :bool
  "Compare terms."
  (c z3-c-types::Z3_context)
  (f1 z3-c-types::Z3_func_decl)
  (f2 z3-c-types::Z3_func_decl))

(defcfun "Z3_get_func_decl_id" :uint
  "Return a unique identifier for `f`."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_decl))

(defcfun "Z3_get_decl_name" z3-c-types::Z3_symbol
  "Return the constant declaration name as a symbol."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl))

(defcfun "Z3_get_decl_kind" z3-c-types::Z3_decl_kind
  "Return declaration kind corresponding to declaration."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl))

(defcfun "Z3_get_domain_size" :uint
  "Return the number of parameters of the given declaration."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl))

(defcfun "Z3_get_arity" :uint
  "Alias for `Z3_get_domain_size`."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl))

(defcfun "Z3_get_domain" z3-c-types::Z3_sort
  "Return the sort of the i-th parameter of the given function declaration."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (i :uint))

(defcfun "Z3_get_range" z3-c-types::Z3_sort
  "Return the range of the given declaration."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl))

(defcfun "Z3_get_decl_num_parameters" :uint
  "Return the number of parameters associated with a declaration."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl))

(defcfun "Z3_get_decl_parameter_kind" z3-c-types::Z3_parameter_kind
  "Return the parameter type associated with a declaration."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (idx :uint))

(defcfun "Z3_get_decl_int_parameter" :int
  "Return the integer value associated with an integer parameter."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (idx :uint))

(defcfun "Z3_get_decl_double_parameter" :double
  "Return the double value associated with an double parameter."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (idx :uint))

(defcfun "Z3_get_decl_symbol_parameter" z3-c-types::Z3_symbol
  "Return the double value associated with an double parameter."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (idx :uint))

(defcfun "Z3_get_decl_sort_parameter" z3-c-types::Z3_sort
  "Return the sort value associated with a sort parameter."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (idx :uint))

(defcfun "Z3_get_decl_ast_parameter" z3-c-types::Z3_ast
  "Return the expression value associated with an expression parameter."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (idx :uint))

(defcfun "Z3_get_decl_func_decl_parameter" z3-c-types::Z3_func_decl
  "Return the expression value associated with an expression parameter."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (idx :uint))

(defcfun "Z3_get_decl_rational_parameter" :string
  "Return the rational value, as a string, associated with a rational parameter."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl)
  (idx :uint))

(defcfun "Z3_app_to_ast" z3-c-types::Z3_ast
  "Convert a `Z3_app` into `Z3_ast`. This is just type casting."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_app))

(defcfun "Z3_get_app_decl" z3-c-types::Z3_func_decl
  "Return the declaration of a constant or function application."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_app))

(defcfun "Z3_get_app_num_args" :uint
  "Return the number of argument of an application. If `t` is an constant, then the number of arguments is 0."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_app))

(defcfun "Z3_get_app_arg" z3-c-types::Z3_ast
  "Return the i-th argument of the given application."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_app)
  (i :uint))

(defcfun "Z3_is_eq_ast" :bool
  "Compare terms."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_get_ast_id" :uint
  "Return a unique identifier for `t`. The identifier is unique up to structural equality. Thus, two ast nodes created by the same context and having the same children and same function symbols have the same identifiers. Ast nodes created in the same context, but having different children or different functions have different identifiers. Variables and quantifiers are also assigned different identifiers according to their structure."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_get_ast_hash" :uint
  "Return a hash code for the given AST. The hash code is structural but two different AST objects can map to the same hash. The result of `Z3_get_ast_id` returns an indentifier that is unique over the set of live AST objects."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_sort" z3-c-types::Z3_sort
  "Return the sort of an AST node."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_is_well_sorted" :bool
  "Return `true` if the given expression `t` is well sorted."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_get_bool_value" z3-c-types::Z3_lbool
  "Return `Z3_L_TRUE` if `a` is true, `Z3_L_FALSE` if it is false, and `Z3_L_UNDEF` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_ast_kind" z3-c-types::Z3_ast_kind
  "Return the kind of the given AST."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_is_app" :bool
  ""
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_is_numeral_ast" :bool
  ""
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_is_algebraic_number" :bool
  "Return `true` if the given AST is a real algebraic number."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_to_app" z3-c-types::Z3_app
  "Convert an `ast` into an `APP_AST`. This is just type casting."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_to_func_decl" z3-c-types::Z3_func_decl
  "Convert an AST into a FUNC_DECL_AST. This is just type casting."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_numeral_string" :string
  "Return numeral value, as a decimal string of a numeric constant term"
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_numeral_binary_string" :string
  "Return numeral value, as a binary string of a numeric constant term"
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_numeral_decimal_string" :string
  "Return numeral as a string in decimal notation. The result has at most `precision` decimal places."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (precision :uint))

(defcfun "Z3_get_numeral_double" :double
  "Return numeral as a double."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_numerator" z3-c-types::Z3_ast
  "Return the numerator (as a numeral AST) of a numeral AST of sort Real."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_denominator" z3-c-types::Z3_ast
  "Return the denominator (as a numeral AST) of a numeral AST of sort Real."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_numeral_small" :bool
  "Return numeral value, as a pair of 64 bit numbers if the representation fits."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (num :pointer)
  (den :pointer))

(defcfun "Z3_get_numeral_int" :bool
  "Similar to `Z3_get_numeral_string`, but only succeeds if the value can fit in a machine int. Return `true` if the call succeeded."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast)
  (i :pointer))

(defcfun "Z3_get_numeral_uint" :bool
  "Similar to `Z3_get_numeral_string`, but only succeeds if the value can fit in a machine unsigned int. Return `true` if the call succeeded."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast)
  (u :pointer))

(defcfun "Z3_get_numeral_uint64" :bool
  "Similar to `Z3_get_numeral_string`, but only succeeds if the value can fit in a machine `uint64_t` int. Return `true` if the call succeeded."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast)
  (u :pointer))

(defcfun "Z3_get_numeral_int64" :bool
  "Similar to `Z3_get_numeral_string`, but only succeeds if the value can fit in a machine `int64_t` int. Return `true` if the call succeeded."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast)
  (i :pointer))

(defcfun "Z3_get_numeral_rational_int64" :bool
  "Similar to `Z3_get_numeral_string`, but only succeeds if the value can fit as a rational number as machine `int64_t` int. Return `true` if the call succeeded."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast)
  (num :pointer)
  (den :pointer))

(defcfun "Z3_get_algebraic_number_lower" z3-c-types::Z3_ast
  "Return a lower bound for the given real algebraic number. The interval isolating the number is smaller than 1/10^precision. The result is a numeral AST of sort Real."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (precision :uint))

(defcfun "Z3_get_algebraic_number_upper" z3-c-types::Z3_ast
  "Return a upper bound for the given real algebraic number. The interval isolating the number is smaller than 1/10^precision. The result is a numeral AST of sort Real."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (precision :uint))

(defcfun "Z3_pattern_to_ast" z3-c-types::Z3_ast
  "Convert a Z3_pattern into Z3_ast. This is just type casting."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_pattern))

(defcfun "Z3_get_pattern_num_terms" :uint
  "Return number of terms in pattern."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_pattern))

(defcfun "Z3_get_pattern" z3-c-types::Z3_ast
  "Return i'th ast in pattern."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_pattern)
  (idx :uint))

(defcfun "Z3_get_index_value" :uint
  "Return index of de-Bruijn bound variable."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_is_quantifier_forall" :bool
  "Determine if an ast is a universal quantifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_is_quantifier_exists" :bool
  "Determine if ast is an existential quantifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_is_lambda" :bool
  "Determine if ast is a lambda expression."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_quantifier_weight" :uint
  "Obtain weight of quantifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_quantifier_num_patterns" :uint
  "Return number of patterns used in quantifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_quantifier_pattern_ast" z3-c-types::Z3_pattern
  "Return i'th pattern."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (i :uint))

(defcfun "Z3_get_quantifier_num_no_patterns" :uint
  "Return number of no_patterns used in quantifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_quantifier_no_pattern_ast" z3-c-types::Z3_ast
  "Return i'th no_pattern."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (i :uint))

(defcfun "Z3_get_quantifier_num_bound" :uint
  "Return number of bound variables of quantifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_quantifier_bound_name" z3-c-types::Z3_symbol
  "Return symbol of the i'th bound variable."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (i :uint))

(defcfun "Z3_get_quantifier_bound_sort" z3-c-types::Z3_sort
  "Return sort of the i'th bound variable."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (i :uint))

(defcfun "Z3_get_quantifier_body" z3-c-types::Z3_ast
  "Return body of quantifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_simplify" z3-c-types::Z3_ast
  "Interface to simplifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_simplify_ex" z3-c-types::Z3_ast
  "Interface to simplifier."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (p z3-c-types::Z3_params))

(defcfun "Z3_simplify_get_help" :string
  "Return a string describing all available parameters."
  (c z3-c-types::Z3_context))

(defcfun "Z3_simplify_get_param_descrs" z3-c-types::Z3_param_descrs
  "Return the parameter description set for the simplify procedure."
  (c z3-c-types::Z3_context))

(defcfun "Z3_update_term" z3-c-types::Z3_ast
  "Update the arguments of term `a` using the arguments `args`. The number of arguments `num_args` should coincide with the number of arguments to `a`. If `a` is a quantifier, then num_args has to be 1."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_substitute" z3-c-types::Z3_ast
  "Substitute every occurrence of `from[i]` in `a` with `to[i]`, for `i` smaller than `num_exprs`. The result is the new AST. The arrays `from` and `to` must have size `num_exprs`. For every `i` smaller than `num_exprs,` we must have that sort of `from[i]` must be equal to sort of `to[i]`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (num-exprs :uint)
  (from :pointer)
  (to :pointer))

(defcfun "Z3_substitute_vars" z3-c-types::Z3_ast
  "Substitute the free variables in `a` with the expressions in `to`. For every `i` smaller than `num_exprs,` the variable with de-Bruijn index `i` is replaced with term `to[i]`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (num-exprs :uint)
  (to :pointer))

(defcfun "Z3_translate" z3-c-types::Z3_ast
  "Translate/Copy the AST `a` from context `source` to context `target`. AST `a` must have been created using context `source`. \pre source != target"
  (source z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (target z3-c-types::Z3_context))

(defcfun "Z3_mk_model" z3-c-types::Z3_model
  "Create a fresh model object. It has reference count 0."
  (c z3-c-types::Z3_context))

(defcfun "Z3_model_inc_ref" :void
  "Increment the reference counter of the given model."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model))

(defcfun "Z3_model_dec_ref" :void
  "Decrement the reference counter of the given model."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model))

(defcfun "Z3_model_eval" :bool
  "Evaluate the AST node `t` in the given model. Return `true` if succeeded, and store the result in `v`."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (ast z3-c-types::Z3_ast)
  (model-completion :bool)
  (v :pointer))

(defcfun "Z3_model_get_const_interp" z3-c-types::Z3_ast
  "Return the interpretation (i.e., assignment) of constant `a` in the model `m`. Return `NULL,` if the model does not assign an interpretation for `a`. That should be interpreted as: the value of `a` does not matter."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (a z3-c-types::Z3_func_decl))

(defcfun "Z3_model_has_interp" :bool
  "Test if there exists an interpretation (i.e., assignment) for `a` in the model `m`."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (a z3-c-types::Z3_func_decl))

(defcfun "Z3_model_get_func_interp" z3-c-types::Z3_func_interp
  "Return the interpretation of the function `f` in the model `m`. Return `NULL,` if the model does not assign an interpretation for `f`. That should be interpreted as: the `f` does not matter."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (f z3-c-types::Z3_func_decl))

(defcfun "Z3_model_get_num_consts" :uint
  "Return the number of constants assigned by the given model."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model))

(defcfun "Z3_model_get_const_decl" z3-c-types::Z3_func_decl
  "Return the i-th constant in the given model."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (i :uint))

(defcfun "Z3_model_get_num_funcs" :uint
  "Return the number of function interpretations in the given model."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model))

(defcfun "Z3_model_get_func_decl" z3-c-types::Z3_func_decl
  "Return the declaration of the i-th function in the given model."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (i :uint))

(defcfun "Z3_model_get_num_sorts" :uint
  "Return the number of uninterpreted sorts that `m` assigns an interpretation to."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model))

(defcfun "Z3_model_get_sort" z3-c-types::Z3_sort
  "Return a uninterpreted sort that `m` assigns an interpretation."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (i :uint))

(defcfun "Z3_model_get_sort_universe" z3-c-types::Z3_ast_vector
  "Return the finite set of distinct values that represent the interpretation for sort `s`."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_model_translate" z3-c-types::Z3_model
  "translate model from context `c` to context `dst`."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (dst z3-c-types::Z3_context))

(defcfun "Z3_is_as_array" :bool
  "The `(_ as-array f)` AST node is a construct for assigning interpretations for arrays in Z3. It is the array such that forall indices `i` we have that `(select (_ as-array f) i)` is equal to `(f i)`. This procedure returns `true` if the `a` is an `as-array` AST node."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_get_as_array_func_decl" z3-c-types::Z3_func_decl
  "Return the function declaration `f` associated with a `(_ as_array f)` node."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_add_func_interp" z3-c-types::Z3_func_interp
  "Create a fresh func_interp object, add it to a model for a specified function. It has reference count 0."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (f z3-c-types::Z3_func_decl)
  (default-value z3-c-types::Z3_ast))

(defcfun "Z3_add_const_interp" :void
  "Add a constant interpretation."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (f z3-c-types::Z3_func_decl)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_func_interp_inc_ref" :void
  "Increment the reference counter of the given Z3_func_interp object."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_interp))

(defcfun "Z3_func_interp_dec_ref" :void
  "Decrement the reference counter of the given Z3_func_interp object."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_interp))

(defcfun "Z3_func_interp_get_num_entries" :uint
  "Return the number of entries in the given function interpretation."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_interp))

(defcfun "Z3_func_interp_get_entry" z3-c-types::Z3_func_entry
  "Return a \"point\" of the given function interpretation. It represents the value of `f` in a particular point."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_interp)
  (i :uint))

(defcfun "Z3_func_interp_get_else" z3-c-types::Z3_ast
  "Return the 'else' value of the given function interpretation."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_interp))

(defcfun "Z3_func_interp_set_else" :void
  "Return the 'else' value of the given function interpretation."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_interp)
  (else-value z3-c-types::Z3_ast))

(defcfun "Z3_func_interp_get_arity" :uint
  "Return the arity (number of arguments) of the given function interpretation."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_func_interp))

(defcfun "Z3_func_interp_add_entry" :void
  "add a function entry to a function interpretation."
  (c z3-c-types::Z3_context)
  (fi z3-c-types::Z3_func_interp)
  (args z3-c-types::Z3_ast_vector)
  (value z3-c-types::Z3_ast))

(defcfun "Z3_func_entry_inc_ref" :void
  "Increment the reference counter of the given `Z3_func_entry` object."
  (c z3-c-types::Z3_context)
  (e z3-c-types::Z3_func_entry))

(defcfun "Z3_func_entry_dec_ref" :void
  "Decrement the reference counter of the given `Z3_func_entry` object."
  (c z3-c-types::Z3_context)
  (e z3-c-types::Z3_func_entry))

(defcfun "Z3_func_entry_get_value" z3-c-types::Z3_ast
  "Return the value of this point."
  (c z3-c-types::Z3_context)
  (e z3-c-types::Z3_func_entry))

(defcfun "Z3_func_entry_get_num_args" :uint
  "Return the number of arguments in a `Z3_func_entry` object."
  (c z3-c-types::Z3_context)
  (e z3-c-types::Z3_func_entry))

(defcfun "Z3_func_entry_get_arg" z3-c-types::Z3_ast
  "Return an argument of a `Z3_func_entry` object."
  (c z3-c-types::Z3_context)
  (e z3-c-types::Z3_func_entry)
  (i :uint))

(defcfun "Z3_open_log" :bool
  "Log interaction to a file."
  (filename :string))

(defcfun "Z3_append_log" :void
  "Append user-defined string to interaction log."
  (string :string))

(defcfun "Z3_close_log" :void
  "Close interaction log."
  )

(defcfun "Z3_toggle_warning_messages" :void
  "Enable/disable printing warning messages to the console."
  (enabled :bool))

(defcfun "Z3_set_ast_print_mode" :void
  "Select mode for the format used for pretty-printing AST nodes."
  (c z3-c-types::Z3_context)
  (mode z3-c-types::Z3_ast_print_mode))

(defcfun "Z3_ast_to_string" :string
  "Convert the given AST node into a string."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_pattern_to_string" :string
  ""
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_pattern))

(defcfun "Z3_sort_to_string" :string
  ""
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_func_decl_to_string" :string
  ""
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_func_decl))

(defcfun "Z3_model_to_string" :string
  "Convert the given model into a string."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model))

(defcfun "Z3_benchmark_to_smtlib_string" :string
  "Convert the given benchmark into SMT-LIB formatted string."
  (c z3-c-types::Z3_context)
  (name :string)
  (logic :string)
  (status :string)
  (attributes :string)
  (num-assumptions :uint)
  (assumptions :pointer)
  (formula z3-c-types::Z3_ast))

(defcfun "Z3_parse_smtlib2_string" z3-c-types::Z3_ast_vector
  "Parse the given string using the SMT-LIB2 parser."
  (c z3-c-types::Z3_context)
  (str :string)
  (num-sorts :uint)
  (sort-names :pointer)
  (sorts :pointer)
  (num-decls :uint)
  (decl-names :pointer)
  (decls :pointer))

(defcfun "Z3_parse_smtlib2_file" z3-c-types::Z3_ast_vector
  "Similar to `Z3_parse_smtlib2_string`, but reads the benchmark from a file."
  (c z3-c-types::Z3_context)
  (file-name :string)
  (num-sorts :uint)
  (sort-names :pointer)
  (sorts :pointer)
  (num-decls :uint)
  (decl-names :pointer)
  (decls :pointer))

(defcfun "Z3_eval_smtlib2_string" :string
  "Parse and evaluate and SMT-LIB2 command sequence. The state from a previous call is saved so the next evaluation builds on top of the previous call."
  (x z3-c-types::Z3_context)
  (str :string))

(defcfun "Z3_get_error_code" z3-c-types::Z3_error_code
  "Return the error code for the last API call."
  (c z3-c-types::Z3_context))

(defcfun "Z3_set_error_handler" :void
  ""
  (c z3-c-types::Z3_context)
  (h :pointer))

(defcfun "Z3_set_error" :void
  "Set an error."
  (c z3-c-types::Z3_context)
  (e z3-c-types::Z3_error_code))

(defcfun "Z3_get_error_msg" :string
  "Return a string describing the given error code."
  (c z3-c-types::Z3_context)
  (err z3-c-types::Z3_error_code))

(defcfun "Z3_get_version" :void
  "Return Z3 version number information."
  (major :pointer)
  (minor :pointer)
  (build-number :pointer)
  (revision-number :pointer))

(defcfun "Z3_get_full_version" :string
  "Return a string that fully describes the version of Z3 in use."
  )

(defcfun "Z3_enable_trace" :void
  "Enable tracing messages tagged as `tag` when Z3 is compiled in debug mode. It is a NOOP otherwise"
  (tag :string))

(defcfun "Z3_disable_trace" :void
  "Disable tracing messages tagged as `tag` when Z3 is compiled in debug mode. It is a NOOP otherwise"
  (tag :string))

(defcfun "Z3_reset_memory" :void
  "Reset all allocated resources."
  )

(defcfun "Z3_finalize_memory" :void
  "Destroy all allocated resources."
  )

(defcfun "Z3_mk_goal" z3-c-types::Z3_goal
  "Create a goal (aka problem). A goal is essentially a set of formulas, that can be solved and/or transformed using tactics and solvers."
  (c z3-c-types::Z3_context)
  (models :bool)
  (unsat-cores :bool)
  (proofs :bool))

(defcfun "Z3_goal_inc_ref" :void
  "Increment the reference counter of the given goal."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_dec_ref" :void
  "Decrement the reference counter of the given goal."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_precision" z3-c-types::Z3_goal_prec
  "Return the \"precision\" of the given goal. Goals can be transformed using over and under approximations. A under approximation is applied when the objective is to find a model for a given goal. An over approximation is applied when the objective is to find a proof for a given goal."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_assert" :void
  "Add a new formula `a` to the given goal. The formula is split according to the following procedure that is applied until a fixed-point: Conjunctions are split into separate formulas. Negations are distributed over disjunctions, resulting in separate formulas. If the goal is `false,` adding new formulas is a no-op. If the formula `a` is `true,` then nothing is added. If the formula `a` is `false,` then the entire goal is replaced by the formula `false`."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_goal_inconsistent" :bool
  "Return `true` if the given goal contains the formula `false`."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_depth" :uint
  "Return the depth of the given goal. It tracks how many transformations were applied to it."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_reset" :void
  "Erase all formulas from the given goal."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_size" :uint
  "Return the number of formulas in the given goal."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_formula" z3-c-types::Z3_ast
  "Return a formula from the given goal."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal)
  (idx :uint))

(defcfun "Z3_goal_num_exprs" :uint
  "Return the number of formulas, subformulas and terms in the given goal."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_is_decided_sat" :bool
  "Return `true` if the goal is empty, and it is precise or the product of a under approximation."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_is_decided_unsat" :bool
  "Return `true` if the goal contains false, and it is precise or the product of an over approximation."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_translate" z3-c-types::Z3_goal
  "Copy a goal `g` from the context `source` to the context `target`."
  (source z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal)
  (target z3-c-types::Z3_context))

(defcfun "Z3_goal_convert_model" z3-c-types::Z3_model
  "Convert a model of the formulas of a goal to a model of an original goal. The model may be null, in which case the returned model is valid if the goal was established satisfiable."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal)
  (m z3-c-types::Z3_model))

(defcfun "Z3_goal_to_string" :string
  "Convert a goal into a string."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_goal_to_dimacs_string" :string
  "Convert a goal into a DIMACS formatted string. The goal must be in CNF. You can convert a goal to CNF by applying the tseitin-cnf tactic. Bit-vectors are not automatically converted to Booleans either, so if the caller intends to preserve satisfiability, it should apply bit-blasting tactics. Quantifiers and theory atoms will not be encoded."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_goal)
  (include-names :bool))

(defcfun "Z3_mk_tactic" z3-c-types::Z3_tactic
  "Return a tactic associated with the given name. The complete list of tactics may be obtained using the procedures `Z3_get_num_tactics` and `Z3_get_tactic_name`. It may also be obtained using the command `(help-tactic)` in the SMT 2.0 front-end."
  (c z3-c-types::Z3_context)
  (name :string))

(defcfun "Z3_tactic_inc_ref" :void
  "Increment the reference counter of the given tactic."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic))

(defcfun "Z3_tactic_dec_ref" :void
  "Decrement the reference counter of the given tactic."
  (c z3-c-types::Z3_context)
  (g z3-c-types::Z3_tactic))

(defcfun "Z3_mk_probe" z3-c-types::Z3_probe
  "Return a probe associated with the given name. The complete list of probes may be obtained using the procedures `Z3_get_num_probes` and `Z3_get_probe_name`. It may also be obtained using the command `(help-tactic)` in the SMT 2.0 front-end."
  (c z3-c-types::Z3_context)
  (name :string))

(defcfun "Z3_probe_inc_ref" :void
  "Increment the reference counter of the given probe."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_probe))

(defcfun "Z3_probe_dec_ref" :void
  "Decrement the reference counter of the given probe."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_probe))

(defcfun "Z3_tactic_and_then" z3-c-types::Z3_tactic
  "Return a tactic that applies `t1` to a given goal and `t2` to every subgoal produced by `t1`."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_tactic)
  (t2 z3-c-types::Z3_tactic))

(defcfun "Z3_tactic_or_else" z3-c-types::Z3_tactic
  "Return a tactic that first applies `t1` to a given goal, if it fails then returns the result of `t2` applied to the given goal."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_tactic)
  (t2 z3-c-types::Z3_tactic))

(defcfun "Z3_tactic_par_or" z3-c-types::Z3_tactic
  "Return a tactic that applies the given tactics in parallel."
  (c z3-c-types::Z3_context)
  (num :uint)
  (ts :pointer))

(defcfun "Z3_tactic_par_and_then" z3-c-types::Z3_tactic
  "Return a tactic that applies `t1` to a given goal and then `t2` to every subgoal produced by `t1`. The subgoals are processed in parallel."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_tactic)
  (t2 z3-c-types::Z3_tactic))

(defcfun "Z3_tactic_try_for" z3-c-types::Z3_tactic
  "Return a tactic that applies `t` to a given goal for `ms` milliseconds. If `t` does not terminate in `ms` milliseconds, then it fails."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic)
  (ms :uint))

(defcfun "Z3_tactic_when" z3-c-types::Z3_tactic
  "Return a tactic that applies `t` to a given goal is the probe `p` evaluates to true. If `p` evaluates to false, then the new tactic behaves like the skip tactic."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_probe)
  (ast z3-c-types::Z3_tactic))

(defcfun "Z3_tactic_cond" z3-c-types::Z3_tactic
  "Return a tactic that applies `t1` to a given goal if the probe `p` evaluates to true, and `t2` if `p` evaluates to false."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_probe)
  (t1 z3-c-types::Z3_tactic)
  (t2 z3-c-types::Z3_tactic))

(defcfun "Z3_tactic_repeat" z3-c-types::Z3_tactic
  "Return a tactic that keeps applying `t` until the goal is not modified anymore or the maximum number of iterations `max` is reached."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic)
  (max :uint))

(defcfun "Z3_tactic_skip" z3-c-types::Z3_tactic
  "Return a tactic that just return the given goal."
  (c z3-c-types::Z3_context))

(defcfun "Z3_tactic_fail" z3-c-types::Z3_tactic
  "Return a tactic that always fails."
  (c z3-c-types::Z3_context))

(defcfun "Z3_tactic_fail_if" z3-c-types::Z3_tactic
  "Return a tactic that fails if the probe `p` evaluates to false."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_probe))

(defcfun "Z3_tactic_fail_if_not_decided" z3-c-types::Z3_tactic
  "Return a tactic that fails if the goal is not trivially satisfiable (i.e., empty) or trivially unsatisfiable (i.e., contains false)."
  (c z3-c-types::Z3_context))

(defcfun "Z3_tactic_using_params" z3-c-types::Z3_tactic
  "Return a tactic that applies `t` using the given set of parameters."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic)
  (p z3-c-types::Z3_params))

(defcfun "Z3_probe_const" z3-c-types::Z3_probe
  "Return a probe that always evaluates to val."
  (x z3-c-types::Z3_context)
  (val :double))

(defcfun "Z3_probe_lt" z3-c-types::Z3_probe
  "Return a probe that evaluates to \"true\" when the value returned by `p1` is less than the value returned by `p2`."
  (x z3-c-types::Z3_context)
  (p1 z3-c-types::Z3_probe)
  (p2 z3-c-types::Z3_probe))

(defcfun "Z3_probe_gt" z3-c-types::Z3_probe
  "Return a probe that evaluates to \"true\" when the value returned by `p1` is greater than the value returned by `p2`."
  (x z3-c-types::Z3_context)
  (p1 z3-c-types::Z3_probe)
  (p2 z3-c-types::Z3_probe))

(defcfun "Z3_probe_le" z3-c-types::Z3_probe
  "Return a probe that evaluates to \"true\" when the value returned by `p1` is less than or equal to the value returned by `p2`."
  (x z3-c-types::Z3_context)
  (p1 z3-c-types::Z3_probe)
  (p2 z3-c-types::Z3_probe))

(defcfun "Z3_probe_ge" z3-c-types::Z3_probe
  "Return a probe that evaluates to \"true\" when the value returned by `p1` is greater than or equal to the value returned by `p2`."
  (x z3-c-types::Z3_context)
  (p1 z3-c-types::Z3_probe)
  (p2 z3-c-types::Z3_probe))

(defcfun "Z3_probe_eq" z3-c-types::Z3_probe
  "Return a probe that evaluates to \"true\" when the value returned by `p1` is equal to the value returned by `p2`."
  (x z3-c-types::Z3_context)
  (p1 z3-c-types::Z3_probe)
  (p2 z3-c-types::Z3_probe))

(defcfun "Z3_probe_and" z3-c-types::Z3_probe
  "Return a probe that evaluates to \"true\" when `p1` and `p2` evaluates to true."
  (x z3-c-types::Z3_context)
  (p1 z3-c-types::Z3_probe)
  (p2 z3-c-types::Z3_probe))

(defcfun "Z3_probe_or" z3-c-types::Z3_probe
  "Return a probe that evaluates to \"true\" when `p1` or `p2` evaluates to true."
  (x z3-c-types::Z3_context)
  (p1 z3-c-types::Z3_probe)
  (p2 z3-c-types::Z3_probe))

(defcfun "Z3_probe_not" z3-c-types::Z3_probe
  "Return a probe that evaluates to \"true\" when `p` does not evaluate to true."
  (x z3-c-types::Z3_context)
  (p z3-c-types::Z3_probe))

(defcfun "Z3_get_num_tactics" :uint
  "Return the number of builtin tactics available in Z3."
  (c z3-c-types::Z3_context))

(defcfun "Z3_get_tactic_name" :string
  "Return the name of the idx tactic."
  (c z3-c-types::Z3_context)
  (i :uint))

(defcfun "Z3_get_num_probes" :uint
  "Return the number of builtin probes available in Z3."
  (c z3-c-types::Z3_context))

(defcfun "Z3_get_probe_name" :string
  "Return the name of the `i` probe."
  (c z3-c-types::Z3_context)
  (i :uint))

(defcfun "Z3_tactic_get_help" :string
  "Return a string containing a description of parameters accepted by the given tactic."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic))

(defcfun "Z3_tactic_get_param_descrs" z3-c-types::Z3_param_descrs
  "Return the parameter description set for the given tactic object."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic))

(defcfun "Z3_tactic_get_descr" :string
  "Return a string containing a description of the tactic with the given name."
  (c z3-c-types::Z3_context)
  (name :string))

(defcfun "Z3_probe_get_descr" :string
  "Return a string containing a description of the probe with the given name."
  (c z3-c-types::Z3_context)
  (name :string))

(defcfun "Z3_probe_apply" :double
  "Execute the probe over the goal. The probe always produce a double value. \"Boolean\" probes return 0.0 for false, and a value different from 0.0 for true."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_probe)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_tactic_apply" z3-c-types::Z3_apply_result
  "Apply tactic `t` to the goal `g`."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic)
  (g z3-c-types::Z3_goal))

(defcfun "Z3_tactic_apply_ex" z3-c-types::Z3_apply_result
  "Apply tactic `t` to the goal `g` using the parameter set `p`."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic)
  (g z3-c-types::Z3_goal)
  (p z3-c-types::Z3_params))

(defcfun "Z3_apply_result_inc_ref" :void
  "Increment the reference counter of the given `Z3_apply_result` object."
  (c z3-c-types::Z3_context)
  (r z3-c-types::Z3_apply_result))

(defcfun "Z3_apply_result_dec_ref" :void
  "Decrement the reference counter of the given `Z3_apply_result` object."
  (c z3-c-types::Z3_context)
  (r z3-c-types::Z3_apply_result))

(defcfun "Z3_apply_result_to_string" :string
  "Convert the `Z3_apply_result` object returned by `Z3_tactic_apply` into a string."
  (c z3-c-types::Z3_context)
  (r z3-c-types::Z3_apply_result))

(defcfun "Z3_apply_result_get_num_subgoals" :uint
  "Return the number of subgoals in the `Z3_apply_result` object returned by `Z3_tactic_apply`."
  (c z3-c-types::Z3_context)
  (r z3-c-types::Z3_apply_result))

(defcfun "Z3_apply_result_get_subgoal" z3-c-types::Z3_goal
  "Return one of the subgoals in the `Z3_apply_result` object returned by `Z3_tactic_apply`."
  (c z3-c-types::Z3_context)
  (r z3-c-types::Z3_apply_result)
  (i :uint))

(defcfun "Z3_mk_solver" z3-c-types::Z3_solver
  "Create a new solver. This solver is a \"combined solver\" (see combined_solver module) that internally uses a non-incremental (solver1) and an incremental solver (solver2). This combined solver changes its behaviour based on how it is used and how its parameters are set."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_simple_solver" z3-c-types::Z3_solver
  "Create a new incremental solver."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_solver_for_logic" z3-c-types::Z3_solver
  "Create a new solver customized for the given logic. It behaves like `Z3_mk_solver` if the logic is unknown or unsupported."
  (c z3-c-types::Z3_context)
  (logic z3-c-types::Z3_symbol))

(defcfun "Z3_mk_solver_from_tactic" z3-c-types::Z3_solver
  "Create a new solver that is implemented using the given tactic. The solver supports the commands `Z3_solver_push` and `Z3_solver_pop`, but it will always solve each `Z3_solver_check` from scratch."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_tactic))

(defcfun "Z3_solver_translate" z3-c-types::Z3_solver
  "Copy a solver `s` from the context `source` to the context `target`."
  (source z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (target z3-c-types::Z3_context))

(defcfun "Z3_solver_import_model_converter" :void
  "Ad-hoc method for importing model conversion from solver."
  (ctx z3-c-types::Z3_context)
  (src z3-c-types::Z3_solver)
  (dst z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_help" :string
  "Return a string describing all solver available parameters."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_param_descrs" z3-c-types::Z3_param_descrs
  "Return the parameter description set for the given solver object."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_set_params" :void
  "Set the given solver using the given parameters."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (p z3-c-types::Z3_params))

(defcfun "Z3_solver_inc_ref" :void
  "Increment the reference counter of the given solver."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_dec_ref" :void
  "Decrement the reference counter of the given solver."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_interrupt" :void
  "Solver local interrupt. Normally you should use Z3_interrupt to cancel solvers because only one solver is enabled concurrently per context. However, per GitHub issue `1006`, there are use cases where it is more convenient to cancel a specific solver. Solvers that are not selected for interrupts are left alone."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_push" :void
  "Create a backtracking point."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_pop" :void
  "Backtrack `n` backtracking points."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (n :uint))

(defcfun "Z3_solver_reset" :void
  "Remove all assertions from the solver."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_num_scopes" :uint
  "Return the number of backtracking points."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_assert" :void
  "Assert a constraint into the solver."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_solver_assert_and_track" :void
  "Assert a constraint `a` into the solver, and track it (in the unsat) core using the Boolean constant `p`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (a z3-c-types::Z3_ast)
  (p z3-c-types::Z3_ast))

(defcfun "Z3_solver_from_file" :void
  "load solver assertions from a file."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (file-name :string))

(defcfun "Z3_solver_from_string" :void
  "load solver assertions from a string."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (file-name :string))

(defcfun "Z3_solver_get_assertions" z3-c-types::Z3_ast_vector
  "Return the set of asserted formulas on the solver."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_units" z3-c-types::Z3_ast_vector
  "Return the set of units modulo model conversion."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_trail" z3-c-types::Z3_ast_vector
  "Return the trail modulo model conversion, in order of decision level The decision level can be retrieved using `Z3_solver_get_level` based on the trail."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_non_units" z3-c-types::Z3_ast_vector
  "Return the set of non units in the solver state."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_levels" :void
  "retrieve the decision depth of Boolean literals (variables or their negations). Assumes a check-sat call and no other calls (to extract models) have been invoked."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (literals z3-c-types::Z3_ast_vector)
  (sz :uint)
  (levels :pointer))

(defcfun "Z3_solver_propagate_init" :void
  ""
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (user-context :pointer)
  (push-eh :pointer)
  (pop-eh :pointer)
  (fresh-eh :pointer))

(defcfun "Z3_solver_propagate_fixed" :void
  ""
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (fixed-eh :pointer))

(defcfun "Z3_solver_propagate_final" :void
  ""
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (final-eh :pointer))

(defcfun "Z3_solver_propagate_eq" :void
  ""
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (eq-eh :pointer))

(defcfun "Z3_solver_propagate_diseq" :void
  ""
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (eq-eh :pointer))

(defcfun "Z3_solver_propagate_created" :void
  ""
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (created-eh :pointer))

(defcfun "Z3_solver_propagate_declare" z3-c-types::Z3_func_decl
  ""
  (c z3-c-types::Z3_context)
  (name z3-c-types::Z3_symbol)
  (n :uint)
  (domain :pointer)
  (range z3-c-types::Z3_sort))

(defcfun "Z3_solver_propagate_register" :void
  "register an expression to propagate on with the solver. Only expressions of type Bool and type Bit-Vector can be registered for propagation."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (e z3-c-types::Z3_ast))

(defcfun "Z3_solver_propagate_register_cb" :void
  "register an expression to propagate on with the solver. Only expressions of type Bool and type Bit-Vector can be registered for propagation. Unlike \ref Z3_solver_propagate_register, this function takes a solver callback context as argument. It can be invoked during a callback to register new expressions."
  (c z3-c-types::Z3_context)
  (cb z3-c-types::Z3_solver_callback)
  (e z3-c-types::Z3_ast))

(defcfun "Z3_solver_propagate_consequence" :void
  "propagate a consequence based on fixed values. This is a callback a client may invoke during the fixed_eh callback. The callback adds a propagation consequence based on the fixed values of the `ids`."
  (c z3-c-types::Z3_context)
  (x z3-c-types::Z3_solver_callback)
  (num-fixed :uint)
  (fixed :pointer)
  (num-eqs :uint)
  (eq-lhs :pointer)
  (eq-rhs :pointer)
  (conseq z3-c-types::Z3_ast))

(defcfun "Z3_solver_check" z3-c-types::Z3_lbool
  "Check whether the assertions in a given solver are consistent or not."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_check_assumptions" z3-c-types::Z3_lbool
  "Check whether the assertions in the given solver and optional assumptions are consistent or not."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (num-assumptions :uint)
  (assumptions :pointer))

(defcfun "Z3_get_implied_equalities" z3-c-types::Z3_lbool
  "Retrieve congruence class representatives for terms."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (num-terms :uint)
  (terms :pointer)
  (class-ids :pointer))

(defcfun "Z3_solver_get_consequences" z3-c-types::Z3_lbool
  "retrieve consequences from solver that determine values of the supplied function symbols."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (assumptions z3-c-types::Z3_ast_vector)
  (variables z3-c-types::Z3_ast_vector)
  (consequences z3-c-types::Z3_ast_vector))

(defcfun "Z3_solver_cube" z3-c-types::Z3_ast_vector
  "extract a next cube for a solver. The last cube is the constant `true` or `false`. The number of (non-constant) cubes is by default 1. For the sat solver cubing is controlled using parameters sat.lookahead.cube.cutoff and sat.lookahead.cube.fraction."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (vars z3-c-types::Z3_ast_vector)
  (backtrack-level :uint))

(defcfun "Z3_solver_get_model" z3-c-types::Z3_model
  "Retrieve the model for the last `Z3_solver_check` or `Z3_solver_check_assumptions`"
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_proof" z3-c-types::Z3_ast
  "Retrieve the proof for the last `Z3_solver_check` or `Z3_solver_check_assumptions`"
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_unsat_core" z3-c-types::Z3_ast_vector
  "Retrieve the unsat core for the last `Z3_solver_check_assumptions` The unsat core is a subset of the assumptions `a`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_reason_unknown" :string
  "Return a brief justification for an \"unknown\" result (i.e., `Z3_L_UNDEF)` for the commands `Z3_solver_check` and `Z3_solver_check_assumptions`"
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_get_statistics" z3-c-types::Z3_stats
  "Return statistics for the given solver."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_to_string" :string
  "Convert a solver into a string."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver))

(defcfun "Z3_solver_to_dimacs_string" :string
  "Convert a solver into a DIMACS formatted string. \sa Z3_goal_to_diamcs_string for requirements."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_solver)
  (include-names :bool))

(defcfun "Z3_stats_to_string" :string
  "Convert a statistics into a string."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats))

(defcfun "Z3_stats_inc_ref" :void
  "Increment the reference counter of the given statistics object."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats))

(defcfun "Z3_stats_dec_ref" :void
  "Decrement the reference counter of the given statistics object."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats))

(defcfun "Z3_stats_size" :uint
  "Return the number of statistical data in `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats))

(defcfun "Z3_stats_get_key" :string
  "Return the key (a string) for a particular statistical data."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats)
  (idx :uint))

(defcfun "Z3_stats_is_uint" :bool
  "Return `true` if the given statistical data is a unsigned integer."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats)
  (idx :uint))

(defcfun "Z3_stats_is_double" :bool
  "Return `true` if the given statistical data is a double."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats)
  (idx :uint))

(defcfun "Z3_stats_get_uint_value" :uint
  "Return the unsigned value of the given statistical data."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats)
  (idx :uint))

(defcfun "Z3_stats_get_double_value" :double
  "Return the double value of the given statistical data."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_stats)
  (idx :uint))

(defcfun "Z3_get_estimated_alloc_size" :uint64
  "Return the estimated allocated memory in bytes."
  )

(defcfun "Z3_mk_ast_vector" z3-c-types::Z3_ast_vector
  "Return an empty AST vector."
  (c z3-c-types::Z3_context))

(defcfun "Z3_ast_vector_inc_ref" :void
  "Increment the reference counter of the given AST vector."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector))

(defcfun "Z3_ast_vector_dec_ref" :void
  "Decrement the reference counter of the given AST vector."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector))

(defcfun "Z3_ast_vector_size" :uint
  "Return the size of the given AST vector."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector))

(defcfun "Z3_ast_vector_get" z3-c-types::Z3_ast
  "Return the AST at position `i` in the AST vector `v`."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector)
  (i :uint))

(defcfun "Z3_ast_vector_set" :void
  "Update position `i` of the AST vector `v` with the AST `a`."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector)
  (i :uint)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_ast_vector_resize" :void
  "Resize the AST vector `v`."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector)
  (n :uint))

(defcfun "Z3_ast_vector_push" :void
  "Add the AST `a` in the end of the AST vector `v`. The size of `v` is increased by one."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_ast_vector_translate" z3-c-types::Z3_ast_vector
  "Translate the AST vector `v` from context `s` into an AST vector in context `t`."
  (s z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector)
  (ast z3-c-types::Z3_context))

(defcfun "Z3_ast_vector_to_string" :string
  "Convert AST vector into a string."
  (c z3-c-types::Z3_context)
  (v z3-c-types::Z3_ast_vector))

(defcfun "Z3_mk_ast_map" z3-c-types::Z3_ast_map
  "Return an empty mapping from AST to AST"
  (c z3-c-types::Z3_context))

(defcfun "Z3_ast_map_inc_ref" :void
  "Increment the reference counter of the given AST map."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map))

(defcfun "Z3_ast_map_dec_ref" :void
  "Decrement the reference counter of the given AST map."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map))

(defcfun "Z3_ast_map_contains" :bool
  "Return true if the map `m` contains the AST key `k`."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map)
  (k z3-c-types::Z3_ast))

(defcfun "Z3_ast_map_find" z3-c-types::Z3_ast
  "Return the value associated with the key `k`."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map)
  (k z3-c-types::Z3_ast))

(defcfun "Z3_ast_map_insert" :void
  "Store/Replace a new key, value pair in the given map."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map)
  (k z3-c-types::Z3_ast)
  (v z3-c-types::Z3_ast))

(defcfun "Z3_ast_map_erase" :void
  "Erase a key from the map."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map)
  (k z3-c-types::Z3_ast))

(defcfun "Z3_ast_map_reset" :void
  "Remove all keys from the given map."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map))

(defcfun "Z3_ast_map_size" :uint
  "Return the size of the given map."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map))

(defcfun "Z3_ast_map_keys" z3-c-types::Z3_ast_vector
  "Return the keys stored in the given map."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map))

(defcfun "Z3_ast_map_to_string" :string
  "Convert the given map into a string."
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_ast_map))

(defcfun "Z3_algebraic_is_value" :bool
  "Return `true` if `a` can be used as value in the Z3 real algebraic number package."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_is_pos" :bool
  "Return `true` if `a` is positive, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_is_neg" :bool
  "Return `true` if `a` is negative, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_is_zero" :bool
  "Return `true` if `a` is zero, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_sign" :int
  "Return 1 if `a` is positive, 0 if `a` is zero, and -1 if `a` is negative."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_add" z3-c-types::Z3_ast
  "Return the value a + b."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_sub" z3-c-types::Z3_ast
  "Return the value a - b."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_mul" z3-c-types::Z3_ast
  "Return the value a * b."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_div" z3-c-types::Z3_ast
  "Return the value a / b."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_root" z3-c-types::Z3_ast
  "Return the a^(1/k)"
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (k :uint))

(defcfun "Z3_algebraic_power" z3-c-types::Z3_ast
  "Return the a^k"
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (k :uint))

(defcfun "Z3_algebraic_lt" :bool
  "Return `true` if a < b, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_gt" :bool
  "Return `true` if a > b, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_le" :bool
  "Return `true` if a <= b, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_ge" :bool
  "Return `true` if a >= b, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_eq" :bool
  "Return `true` if a == b, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_neq" :bool
  "Return `true` if a != b, and `false` otherwise."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast)
  (b z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_roots" z3-c-types::Z3_ast_vector
  "Given a multivariate polynomial p(x_0, ..., x_{n-1}, x_n), returns the roots of the univariate polynomial p(a[0], ..., a[n-1], x_n)."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_ast)
  (n :uint)
  (a :pointer))

(defcfun "Z3_algebraic_eval" :int
  "Given a multivariate polynomial p(x_0, ..., x_{n-1}), return the sign of p(a[0], ..., a[n-1])."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_ast)
  (n :uint)
  (a :pointer))

(defcfun "Z3_algebraic_get_poly" z3-c-types::Z3_ast_vector
  "Return the coefficients of the defining polynomial."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_algebraic_get_i" :uint
  "Return which root of the polynomial the algebraic number represents."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_polynomial_subresultants" z3-c-types::Z3_ast_vector
  "Return the nonzero subresultants of `p` and `q` with respect to the \"variable\" `x`."
  (c z3-c-types::Z3_context)
  (p z3-c-types::Z3_ast)
  (q z3-c-types::Z3_ast)
  (x z3-c-types::Z3_ast))

(defcfun "Z3_rcf_del" :void
  "Delete a RCF numeral created using the RCF API."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_mk_rational" z3-c-types::Z3_rcf_num
  "Return a RCF rational using the given string."
  (c z3-c-types::Z3_context)
  (val :string))

(defcfun "Z3_rcf_mk_small_int" z3-c-types::Z3_rcf_num
  "Return a RCF small integer."
  (c z3-c-types::Z3_context)
  (val :int))

(defcfun "Z3_rcf_mk_pi" z3-c-types::Z3_rcf_num
  "Return Pi"
  (c z3-c-types::Z3_context))

(defcfun "Z3_rcf_mk_e" z3-c-types::Z3_rcf_num
  "Return e (Euler's constant)"
  (c z3-c-types::Z3_context))

(defcfun "Z3_rcf_mk_infinitesimal" z3-c-types::Z3_rcf_num
  "Return a new infinitesimal that is smaller than all elements in the Z3 field."
  (c z3-c-types::Z3_context))

(defcfun "Z3_rcf_mk_roots" :uint
  "Store in roots the roots of the polynomial `a[n-1]*x^{n-1` + ... + a[0]}. The output vector `roots` must have size `n`. It returns the number of roots of the polynomial."
  (c z3-c-types::Z3_context)
  (n :uint)
  (a :pointer)
  (roots :pointer))

(defcfun "Z3_rcf_add" z3-c-types::Z3_rcf_num
  "Return the value `a + b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_sub" z3-c-types::Z3_rcf_num
  "Return the value `a - b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_mul" z3-c-types::Z3_rcf_num
  "Return the value `a * b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_div" z3-c-types::Z3_rcf_num
  "Return the value `a / b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_neg" z3-c-types::Z3_rcf_num
  "Return the value `-a`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_inv" z3-c-types::Z3_rcf_num
  "Return the value `1/a`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_power" z3-c-types::Z3_rcf_num
  "Return the value `a^k`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (k :uint))

(defcfun "Z3_rcf_lt" :bool
  "Return `true` if `a < b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_gt" :bool
  "Return `true` if `a > b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_le" :bool
  "Return `true` if `a <= b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_ge" :bool
  "Return `true` if `a >= b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_eq" :bool
  "Return `true` if `a == b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_neq" :bool
  "Return `true` if `a != b`."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (b z3-c-types::Z3_rcf_num))

(defcfun "Z3_rcf_num_to_string" :string
  "Convert the RCF numeral into a string."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (compact :bool)
  (html :bool))

(defcfun "Z3_rcf_num_to_decimal_string" :string
  "Convert the RCF numeral into a string in decimal notation."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (prec :uint))

(defcfun "Z3_rcf_get_numerator_denominator" :void
  "Extract the \"numerator\" and \"denominator\" of the given RCF numeral. We have that `a = n/d`, moreover `n` and `d` are not represented using rational functions."
  (c z3-c-types::Z3_context)
  (a z3-c-types::Z3_rcf_num)
  (n :pointer)
  (d :pointer))

(defcfun "Z3_mk_fixedpoint" z3-c-types::Z3_fixedpoint
  "Create a new fixedpoint context."
  (c z3-c-types::Z3_context))

(defcfun "Z3_fixedpoint_inc_ref" :void
  "Increment the reference counter of the given fixedpoint context"
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_dec_ref" :void
  "Decrement the reference counter of the given fixedpoint context."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_add_rule" :void
  "Add a universal Horn clause as a named rule. The `horn_rule` should be of the form:"
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (rule z3-c-types::Z3_ast)
  (name z3-c-types::Z3_symbol))

(defcfun "Z3_fixedpoint_add_fact" :void
  "Add a Database fact."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (r z3-c-types::Z3_func_decl)
  (num-args :uint)
  (args :pointer))

(defcfun "Z3_fixedpoint_assert" :void
  "Assert a constraint to the fixedpoint context."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (axiom z3-c-types::Z3_ast))

(defcfun "Z3_fixedpoint_query" z3-c-types::Z3_lbool
  "Pose a query against the asserted rules."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (query z3-c-types::Z3_ast))

(defcfun "Z3_fixedpoint_query_relations" z3-c-types::Z3_lbool
  "Pose multiple queries against the asserted rules."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (num-relations :uint)
  (relations :pointer))

(defcfun "Z3_fixedpoint_get_answer" z3-c-types::Z3_ast
  "Retrieve a formula that encodes satisfying answers to the query."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_get_reason_unknown" :string
  "Retrieve a string that describes the last status returned by `Z3_fixedpoint_query`."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_update_rule" :void
  "Update a named rule. A rule with the same name must have been previously created."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (a z3-c-types::Z3_ast)
  (name z3-c-types::Z3_symbol))

(defcfun "Z3_fixedpoint_get_num_levels" :uint
  "Query the PDR engine for the maximal levels properties are known about predicate."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (pred z3-c-types::Z3_func_decl))

(defcfun "Z3_fixedpoint_get_cover_delta" z3-c-types::Z3_ast
  ""
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (level :int)
  (pred z3-c-types::Z3_func_decl))

(defcfun "Z3_fixedpoint_add_cover" :void
  "Add property about the predicate `pred`. Add a property of predicate `pred` at `level`. It gets pushed forward when possible."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (level :int)
  (pred z3-c-types::Z3_func_decl)
  (property z3-c-types::Z3_ast))

(defcfun "Z3_fixedpoint_get_statistics" z3-c-types::Z3_stats
  "Retrieve statistics information from the last call to `Z3_fixedpoint_query`."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_register_relation" :void
  "Register relation as Fixedpoint defined. Fixedpoint defined relations have least-fixedpoint semantics. For example, the relation is empty if it does not occur in a head or a fact."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (f z3-c-types::Z3_func_decl))

(defcfun "Z3_fixedpoint_set_predicate_representation" :void
  "Configure the predicate representation."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (f z3-c-types::Z3_func_decl)
  (num-relations :uint)
  (relation-kinds :pointer))

(defcfun "Z3_fixedpoint_get_rules" z3-c-types::Z3_ast_vector
  "Retrieve set of rules from fixedpoint context."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_get_assertions" z3-c-types::Z3_ast_vector
  "Retrieve set of background assertions from fixedpoint context."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_set_params" :void
  "Set parameters on fixedpoint context."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint)
  (p z3-c-types::Z3_params))

(defcfun "Z3_fixedpoint_get_help" :string
  "Return a string describing all fixedpoint available parameters."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_get_param_descrs" z3-c-types::Z3_param_descrs
  "Return the parameter description set for the given fixedpoint object."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_to_string" :string
  "Print the current rules and background axioms as a string. \param c - context. \param f - fixedpoint context. \param num_queries - number of additional queries to print. \param queries - additional queries."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint)
  (num-queries :uint)
  (queries :pointer))

(defcfun "Z3_fixedpoint_from_string" z3-c-types::Z3_ast_vector
  "Parse an SMT-LIB2 string with fixedpoint rules. Add the rules to the current fixedpoint context. Return the set of queries in the string."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint)
  (s :string))

(defcfun "Z3_fixedpoint_from_file" z3-c-types::Z3_ast_vector
  "Parse an SMT-LIB2 file with fixedpoint rules. Add the rules to the current fixedpoint context. Return the set of queries in the file."
  (c z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint)
  (s :string))

(defcfun "Z3_fixedpoint_init" :void
  ""
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (state :pointer))

(defcfun "Z3_fixedpoint_set_reduce_assign_callback" :void
  ""
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (cb :pointer))

(defcfun "Z3_fixedpoint_set_reduce_app_callback" :void
  ""
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (cb :pointer))

(defcfun "Z3_fixedpoint_add_callback" :void
  ""
  (ctx z3-c-types::Z3_context)
  (f z3-c-types::Z3_fixedpoint)
  (state :pointer)
  (new-lemma-eh :pointer)
  (predecessor-eh :pointer)
  (unfold-eh :pointer))

(defcfun "Z3_fixedpoint_add_constraint" :void
  ""
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (e z3-c-types::Z3_ast)
  (lvl :uint))

(defcfun "Z3_mk_optimize" z3-c-types::Z3_optimize
  "Create a new optimize context."
  (c z3-c-types::Z3_context))

(defcfun "Z3_optimize_inc_ref" :void
  "Increment the reference counter of the given optimize context"
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_dec_ref" :void
  "Decrement the reference counter of the given optimize context."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_assert" :void
  "Assert hard constraint to the optimization context."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (a z3-c-types::Z3_ast))

(defcfun "Z3_optimize_assert_and_track" :void
  "Assert tracked hard constraint to the optimization context."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (a z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_optimize_assert_soft" :uint
  "Assert soft constraint to the optimization context. \param c - context \param o - optimization context \param a - formula \param weight - a penalty for violating soft constraint. Negative weights convert into rewards. \param id - optional identifier to group soft constraints"
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (a z3-c-types::Z3_ast)
  (weight :string)
  (id z3-c-types::Z3_symbol))

(defcfun "Z3_optimize_maximize" :uint
  "Add a maximization constraint. \param c - context \param o - optimization context \param t - arithmetical term"
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_optimize_minimize" :uint
  "Add a minimization constraint. \param c - context \param o - optimization context \param t - arithmetical term"
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_optimize_push" :void
  "Create a backtracking point."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_pop" :void
  "Backtrack one level."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_check" z3-c-types::Z3_lbool
  "Check consistency and produce optimal values. \param c - context \param o - optimization context \param num_assumptions - number of additional assumptions \param assumptions - the additional assumptions"
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (num-assumptions :uint)
  (assumptions :pointer))

(defcfun "Z3_optimize_get_reason_unknown" :string
  "Retrieve a string that describes the last status returned by `Z3_optimize_check`."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_get_model" z3-c-types::Z3_model
  "Retrieve the model for the last `Z3_optimize_check`"
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_get_unsat_core" z3-c-types::Z3_ast_vector
  "Retrieve the unsat core for the last `Z3_optimize_check` The unsat core is a subset of the assumptions `a`."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_set_params" :void
  "Set parameters on optimization context."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (p z3-c-types::Z3_params))

(defcfun "Z3_optimize_get_param_descrs" z3-c-types::Z3_param_descrs
  "Return the parameter description set for the given optimize object."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_get_lower" z3-c-types::Z3_ast
  "Retrieve lower bound value or approximation for the i'th optimization objective."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (idx :uint))

(defcfun "Z3_optimize_get_upper" z3-c-types::Z3_ast
  "Retrieve upper bound value or approximation for the i'th optimization objective."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (idx :uint))

(defcfun "Z3_optimize_get_lower_as_vector" z3-c-types::Z3_ast_vector
  "Retrieve lower bound value or approximation for the i'th optimization objective. The returned vector is of length 3. It always contains numerals. The three numerals are coefficients `a,` `b,` `c` and encode the result of `Z3_optimize_get_lower` `a * infinity + b + c * epsilon`."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (idx :uint))

(defcfun "Z3_optimize_get_upper_as_vector" z3-c-types::Z3_ast_vector
  "Retrieve upper bound value or approximation for the i'th optimization objective."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (idx :uint))

(defcfun "Z3_optimize_to_string" :string
  "Print the current context as a string. \param c - context. \param o - optimization context."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_from_string" :void
  "Parse an SMT-LIB2 string with assertions, soft constraints and optimization objectives. Add the parsed constraints and objectives to the optimization context."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (s :string))

(defcfun "Z3_optimize_from_file" :void
  "Parse an SMT-LIB2 file with assertions, soft constraints and optimization objectives. Add the parsed constraints and objectives to the optimization context."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (s :string))

(defcfun "Z3_optimize_get_help" :string
  "Return a string containing a description of parameters accepted by optimize."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_get_statistics" z3-c-types::Z3_stats
  "Retrieve statistics information from the last call to `Z3_optimize_check`"
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_get_assertions" z3-c-types::Z3_ast_vector
  "Return the set of asserted formulas on the optimization context."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_get_objectives" z3-c-types::Z3_ast_vector
  "Return objectives on the optimization context. If the objective function is a max-sat objective it is returned as a Pseudo-Boolean (minimization) sum of the form `(+ (if f1 w1 0) (if f2 w2 0) ...)` If the objective function is entered as a maximization objective, then return the corresponding minimization objective. In this way the resulting objective function is always returned as a minimization objective."
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize))

(defcfun "Z3_optimize_register_model_eh" :void
  ""
  (c z3-c-types::Z3_context)
  (o z3-c-types::Z3_optimize)
  (m z3-c-types::Z3_model)
  (ctx :pointer)
  (model-eh :pointer))

(defcfun "Z3_mk_fpa_rounding_mode_sort" z3-c-types::Z3_sort
  "Create the RoundingMode sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_round_nearest_ties_to_even" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_rne" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_round_nearest_ties_to_away" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_rna" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_round_toward_positive" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_rtp" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_round_toward_negative" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_rtn" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_round_toward_zero" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the TowardZero rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_rtz" z3-c-types::Z3_ast
  "Create a numeral of RoundingMode sort which represents the TowardZero rounding mode."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_sort" z3-c-types::Z3_sort
  "Create a FloatingPoint sort."
  (c z3-c-types::Z3_context)
  (ebits :uint)
  (sbits :uint))

(defcfun "Z3_mk_fpa_sort_half" z3-c-types::Z3_sort
  "Create the half-precision (16-bit) FloatingPoint sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_sort_16" z3-c-types::Z3_sort
  "Create the half-precision (16-bit) FloatingPoint sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_sort_single" z3-c-types::Z3_sort
  "Create the single-precision (32-bit) FloatingPoint sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_sort_32" z3-c-types::Z3_sort
  "Create the single-precision (32-bit) FloatingPoint sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_sort_double" z3-c-types::Z3_sort
  "Create the double-precision (64-bit) FloatingPoint sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_sort_64" z3-c-types::Z3_sort
  "Create the double-precision (64-bit) FloatingPoint sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_sort_quadruple" z3-c-types::Z3_sort
  "Create the quadruple-precision (128-bit) FloatingPoint sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_sort_128" z3-c-types::Z3_sort
  "Create the quadruple-precision (128-bit) FloatingPoint sort."
  (c z3-c-types::Z3_context))

(defcfun "Z3_mk_fpa_nan" z3-c-types::Z3_ast
  "Create a floating-point NaN of sort `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_inf" z3-c-types::Z3_ast
  "Create a floating-point infinity of sort `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort)
  (negative :bool))

(defcfun "Z3_mk_fpa_zero" z3-c-types::Z3_ast
  "Create a floating-point zero of sort `s`."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort)
  (negative :bool))

(defcfun "Z3_mk_fpa_fp" z3-c-types::Z3_ast
  "Create an expression of FloatingPoint sort from three bit-vector expressions."
  (c z3-c-types::Z3_context)
  (sgn z3-c-types::Z3_ast)
  (exp z3-c-types::Z3_ast)
  (sig z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_numeral_float" z3-c-types::Z3_ast
  "Create a numeral of FloatingPoint sort from a float."
  (c z3-c-types::Z3_context)
  (v :float)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_numeral_double" z3-c-types::Z3_ast
  "Create a numeral of FloatingPoint sort from a double."
  (c z3-c-types::Z3_context)
  (v :double)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_numeral_int" z3-c-types::Z3_ast
  "Create a numeral of FloatingPoint sort from a signed integer."
  (c z3-c-types::Z3_context)
  (v :int)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_numeral_int_uint" z3-c-types::Z3_ast
  "Create a numeral of FloatingPoint sort from a sign bit and two integers."
  (c z3-c-types::Z3_context)
  (sgn :bool)
  (exp :int)
  (sig :uint)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_numeral_int64_uint64" z3-c-types::Z3_ast
  "Create a numeral of FloatingPoint sort from a sign bit and two 64-bit integers."
  (c z3-c-types::Z3_context)
  (sgn :bool)
  (exp :int64)
  (sig :uint64)
  (ty z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_abs" z3-c-types::Z3_ast
  "Floating-point absolute value"
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_neg" z3-c-types::Z3_ast
  "Floating-point negation"
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_add" z3-c-types::Z3_ast
  "Floating-point addition"
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_sub" z3-c-types::Z3_ast
  "Floating-point subtraction"
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_mul" z3-c-types::Z3_ast
  "Floating-point multiplication"
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_div" z3-c-types::Z3_ast
  "Floating-point division"
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_fma" z3-c-types::Z3_ast
  "Floating-point fused multiply-add."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast)
  (t3 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_sqrt" z3-c-types::Z3_ast
  "Floating-point square root"
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_rem" z3-c-types::Z3_ast
  "Floating-point remainder"
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_round_to_integral" z3-c-types::Z3_ast
  "Floating-point roundToIntegral. Rounds a floating-point number to the closest integer, again represented as a floating-point number."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_min" z3-c-types::Z3_ast
  "Minimum of floating-point numbers."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_max" z3-c-types::Z3_ast
  "Maximum of floating-point numbers."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_leq" z3-c-types::Z3_ast
  "Floating-point less than or equal."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_lt" z3-c-types::Z3_ast
  "Floating-point less than."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_geq" z3-c-types::Z3_ast
  "Floating-point greater than or equal."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_gt" z3-c-types::Z3_ast
  "Floating-point greater than."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_eq" z3-c-types::Z3_ast
  "Floating-point equality."
  (c z3-c-types::Z3_context)
  (t1 z3-c-types::Z3_ast)
  (t2 z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_is_normal" z3-c-types::Z3_ast
  "Predicate indicating whether `t` is a normal floating-point number."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_is_subnormal" z3-c-types::Z3_ast
  "Predicate indicating whether `t` is a subnormal floating-point number."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_is_zero" z3-c-types::Z3_ast
  "Predicate indicating whether `t` is a floating-point number with zero value, i.e., +zero or -zero."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_is_infinite" z3-c-types::Z3_ast
  "Predicate indicating whether `t` is a floating-point number representing +oo or -oo."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_is_nan" z3-c-types::Z3_ast
  "Predicate indicating whether `t` is a NaN."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_is_negative" z3-c-types::Z3_ast
  "Predicate indicating whether `t` is a negative floating-point number."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_is_positive" z3-c-types::Z3_ast
  "Predicate indicating whether `t` is a positive floating-point number."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_to_fp_bv" z3-c-types::Z3_ast
  "Conversion of a single IEEE 754-2008 bit-vector into a floating-point number."
  (c z3-c-types::Z3_context)
  (bv z3-c-types::Z3_ast)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_to_fp_float" z3-c-types::Z3_ast
  "Conversion of a FloatingPoint term into another term of different FloatingPoint sort."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_to_fp_real" z3-c-types::Z3_ast
  "Conversion of a term of real sort into a term of FloatingPoint sort."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_to_fp_signed" z3-c-types::Z3_ast
  "Conversion of a 2's complement signed bit-vector term into a term of FloatingPoint sort."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_to_fp_unsigned" z3-c-types::Z3_ast
  "Conversion of a 2's complement unsigned bit-vector term into a term of FloatingPoint sort."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_mk_fpa_to_ubv" z3-c-types::Z3_ast
  "Conversion of a floating-point term into an unsigned bit-vector."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast)
  (sz :uint))

(defcfun "Z3_mk_fpa_to_sbv" z3-c-types::Z3_ast
  "Conversion of a floating-point term into a signed bit-vector."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (ast z3-c-types::Z3_ast)
  (sz :uint))

(defcfun "Z3_mk_fpa_to_real" z3-c-types::Z3_ast
  "Conversion of a floating-point term into a real-numbered term."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_get_ebits" :uint
  "Retrieves the number of bits reserved for the exponent in a FloatingPoint sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_fpa_get_sbits" :uint
  "Retrieves the number of bits reserved for the significand in a FloatingPoint sort."
  (c z3-c-types::Z3_context)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_fpa_is_numeral_nan" :bool
  "Checks whether a given floating-point numeral is a NaN."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_is_numeral_inf" :bool
  "Checks whether a given floating-point numeral is a +oo or -oo."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_is_numeral_zero" :bool
  "Checks whether a given floating-point numeral is +zero or -zero."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_is_numeral_normal" :bool
  "Checks whether a given floating-point numeral is normal."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_is_numeral_subnormal" :bool
  "Checks whether a given floating-point numeral is subnormal."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_is_numeral_positive" :bool
  "Checks whether a given floating-point numeral is positive."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_is_numeral_negative" :bool
  "Checks whether a given floating-point numeral is negative."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_get_numeral_sign_bv" z3-c-types::Z3_ast
  "Retrieves the sign of a floating-point literal as a bit-vector expression."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_get_numeral_significand_bv" z3-c-types::Z3_ast
  "Retrieves the significand of a floating-point literal as a bit-vector expression."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_get_numeral_sign" :bool
  "Retrieves the sign of a floating-point literal."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast)
  (sgn :pointer))

(defcfun "Z3_fpa_get_numeral_significand_string" :string
  "Return the significand value of a floating-point numeral as a string."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_fpa_get_numeral_significand_uint64" :bool
  "Return the significand value of a floating-point numeral as a uint64."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast)
  (n :pointer))

(defcfun "Z3_fpa_get_numeral_exponent_string" :string
  "Return the exponent value of a floating-point numeral as a string."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast)
  (biased :bool))

(defcfun "Z3_fpa_get_numeral_exponent_int64" :bool
  "Return the exponent value of a floating-point numeral as a signed 64-bit integer"
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast)
  (n :pointer)
  (biased :bool))

(defcfun "Z3_fpa_get_numeral_exponent_bv" z3-c-types::Z3_ast
  "Retrieves the exponent of a floating-point literal as a bit-vector expression."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast)
  (biased :bool))

(defcfun "Z3_mk_fpa_to_ieee_bv" z3-c-types::Z3_ast
  "Conversion of a floating-point term into a bit-vector term in IEEE 754-2008 format."
  (c z3-c-types::Z3_context)
  (ast z3-c-types::Z3_ast))

(defcfun "Z3_mk_fpa_to_fp_int_real" z3-c-types::Z3_ast
  "Conversion of a real-sorted significand and an integer-sorted exponent into a term of FloatingPoint sort."
  (c z3-c-types::Z3_context)
  (rm z3-c-types::Z3_ast)
  (exp z3-c-types::Z3_ast)
  (sig z3-c-types::Z3_ast)
  (s z3-c-types::Z3_sort))

(defcfun "Z3_fixedpoint_query_from_lvl" z3-c-types::Z3_lbool
  "Pose a query against the asserted rules at the given level."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (query z3-c-types::Z3_ast)
  (lvl :uint))

(defcfun "Z3_fixedpoint_get_ground_sat_answer" z3-c-types::Z3_ast
  "Retrieve a bottom-up (from query) sequence of ground facts"
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_get_rules_along_trace" z3-c-types::Z3_ast_vector
  "Obtain the list of rules along the counterexample trace."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_get_rule_names_along_trace" z3-c-types::Z3_symbol
  "Obtain the list of rules along the counterexample trace."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint))

(defcfun "Z3_fixedpoint_add_invariant" :void
  "Add an invariant for the predicate `pred`. Add an assumed invariant of predicate `pred`."
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (pred z3-c-types::Z3_func_decl)
  (property z3-c-types::Z3_ast))

(defcfun "Z3_fixedpoint_get_reachable" z3-c-types::Z3_ast
  ""
  (c z3-c-types::Z3_context)
  (d z3-c-types::Z3_fixedpoint)
  (pred z3-c-types::Z3_func_decl))

(defcfun "Z3_qe_model_project" z3-c-types::Z3_ast
  "Project variables given a model"
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (num-bounds :uint)
  (bound :pointer)
  (body z3-c-types::Z3_ast))

(defcfun "Z3_qe_model_project_skolem" z3-c-types::Z3_ast
  "Project variables given a model"
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (num-bounds :uint)
  (bound :pointer)
  (body z3-c-types::Z3_ast)
  (map z3-c-types::Z3_ast_map))

(defcfun "Z3_model_extrapolate" z3-c-types::Z3_ast
  "Extrapolates a model of a formula"
  (c z3-c-types::Z3_context)
  (m z3-c-types::Z3_model)
  (fml z3-c-types::Z3_ast))

(defcfun "Z3_qe_lite" z3-c-types::Z3_ast
  ""
  (c z3-c-types::Z3_context)
  (vars z3-c-types::Z3_ast_vector)
  (body z3-c-types::Z3_ast))
