; Copyright (C) 2025, Matt Kaufmann and Konrad Slind
; Written by Matt Kaufmann and Konrad Slind
; License: A 3-clause BSD license.  See the LICENSE file distributed with ACL2.

; This book displays the axioms generated by the translater on the ex1 example.
; Specifically, it displays the encapsulate event generated by the
; import-theory call in ex1-thy.lisp.  Comments below explain that event and
; its groups of events, which may be viewed as the axioms exported by that
; encapsulate event.

(in-package "ZF")

; Include the book that imports the translator output into ACL2.
(include-book "ex1-thy")

; The next form guarantees that the encapsulate form below is already present
; upon evaluating the include-book form above.
(set-enforce-redundancy t)

(DEFUN HOL::EX1$HTA NIL
  (DECLARE (XARGS :GUARD T))
  (HTA0))

; The first argument of encapsulate is the list of signatures of function
; symbols introduced.  The other arguments can be divided into groups as
; explained in comments below.

(ENCAPSULATE (((HOL::EX1$PROP) => *)
              ((HOL::SUC *) => *)
              ((HOL::PRE *) => *)
              ((HOL::I *) => *)
              ((HOL::C *) => *)
              ((HOL::K *) => *)
              ((HOL::O *) => *)
              ((HOL::COMMA *) => *)
              ((HOL::FST *) => *)
              ((HOL::SND *) => *)
              ((HOL::UNCURRY *) => *)
              ((HOL::OPTION_BIND *) => *)
              ((HOL::OPTION_MAP *) => *)
              ((HOL::LIST_CASE *) => *)
              ((HOL::LIST_SIZE *) => *)
              ((HOL::MAP *) => *)
              ((HOL::FOLDR *) => *)
              ((HOL::FOLDL *) => *)
              ((HOL::MOD *) => *)
              ((HOL::DIV *) => *)
              ((HOL::ODD *) => *)
              ((HOL::EVEN *) => *)
              ((HOL::EXP *) => *))

; The first group of events below provides local definitions of the function
; symbols introduced above in a list of signatures.  They are trivial but they
; suffice for proving the theorems that follow, because those have
; (HOL::EVAL-EX1$PROP) as a hypothesis, whose local witness returns nil.
; Technically, the hypothesis is (FORCE (HOL::EX1$PROP)); but FORCE is the
; identity function, used only to support rewriting (see :DOC force).

 (LOCAL (DEFUN HOL::EX1$PROP NIL NIL))
 (LOCAL (DEFUN HOL::SUC (X) X))
 (LOCAL (DEFUN HOL::PRE (X) X))
 (LOCAL (DEFUN HOL::I (X) X))
 (LOCAL (DEFUN HOL::C (X) X))
 (LOCAL (DEFUN HOL::K (X) X))
 (LOCAL (DEFUN HOL::O (X) X))
 (LOCAL (DEFUN HOL::COMMA (X) X))
 (LOCAL (DEFUN HOL::FST (X) X))
 (LOCAL (DEFUN HOL::SND (X) X))
 (LOCAL (DEFUN HOL::UNCURRY (X) X))
 (LOCAL (DEFUN HOL::OPTION_BIND (X) X))
 (LOCAL (DEFUN HOL::OPTION_MAP (X) X))
 (LOCAL (DEFUN HOL::LIST_CASE (X) X))
 (LOCAL (DEFUN HOL::LIST_SIZE (X) X))
 (LOCAL (DEFUN HOL::MAP (X) X))
 (LOCAL (DEFUN HOL::FOLDR (X) X))
 (LOCAL (DEFUN HOL::FOLDL (X) X))
 (LOCAL (DEFUN HOL::MOD (X) X))
 (LOCAL (DEFUN HOL::DIV (X) X))
 (LOCAL (DEFUN HOL::ODD (X) X))
 (LOCAL (DEFUN HOL::EVEN (X) X))
 (LOCAL (DEFUN HOL::EXP (X) X))

; The next group of events deduces various set-theory axioms from
; (HOL::EX1$PROP).

 (DEFTHM HOL::EX1$PROP-IMPLIES-ZFC
   (IMPLIES (HOL::EX1$PROP) (ZFC))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EX1$PROP-IMPLIES-PROD2$PROP
   (IMPLIES (HOL::EX1$PROP) (PROD2$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EX1$PROP-IMPLIES-DOMAIN$PROP
   (IMPLIES (HOL::EX1$PROP) (DOMAIN$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EX1$PROP-IMPLIES-INVERSE$PROP
   (IMPLIES (HOL::EX1$PROP) (INVERSE$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EX1$PROP-IMPLIES-FINSEQS$PROP
   (IMPLIES (HOL::EX1$PROP) (FINSEQS$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EX1$PROP-IMPLIES-DIFF$PROP
   (IMPLIES (HOL::EX1$PROP) (DIFF$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EX1$PROP-IMPLIES-RESTRICT$PROP
   (IMPLIES (HOL::EX1$PROP)
            (RESTRICT$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EX1$PROP-IMPLIES-FUN-SPACE$PROP
   (IMPLIES (HOL::EX1$PROP)
            (FUN-SPACE$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)

; Each event in the next group introduces two conditional rewrite rules, as
; explained in comments added to the first of these.  Each has (HOL::EX1$PROP)
; as a hypothesis.

 (DEFTHM HOL::SUC$TYPE
   (IMPLIES (FORCE (HOL::EX1$PROP))
; SUC produces a valid HOL pair, whose type is as expected.
            (AND (HPP (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                      (HOL::EX1$HTA))
                 (EQUAL (HP-TYPE (HOL::SUC (TYP (:ARROW* :NUM :NUM))))
                        (TYP (:ARROW* :NUM :NUM))))))
 (DEFTHM HOL::PRE$TYPE
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (AND (HPP (HOL::PRE (TYP (:ARROW* :NUM :NUM)))
                      (HOL::EX1$HTA))
                 (EQUAL (HP-TYPE (HOL::PRE (TYP (:ARROW* :NUM :NUM))))
                        (TYP (:ARROW* :NUM :NUM))))))
 (DEFTHM HOL::I$TYPE
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (AND (HPP (HOL::I (TYP (:ARROW* HOL::A HOL::A)))
                      (HOL::EX1$HTA))
                 (EQUAL (HP-TYPE (HOL::I (TYP (:ARROW* HOL::A HOL::A))))
                        (TYP (:ARROW* HOL::A HOL::A))))))
 (DEFTHM HOL::C$TYPE
  (IMPLIES
    (FORCE (HOL::EX1$PROP))
    (AND (HPP (HOL::C (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::C)
                                    HOL::B HOL::A HOL::C)))
              (HOL::EX1$HTA))
         (EQUAL (HP-TYPE (HOL::C (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::C)
                                               HOL::B HOL::A HOL::C))))
                (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::C)
                              HOL::B HOL::A HOL::C))))))
 (DEFTHM HOL::K$TYPE
   (IMPLIES
        (FORCE (HOL::EX1$PROP))
        (AND (HPP (HOL::K (TYP (:ARROW* HOL::A HOL::B HOL::A)))
                  (HOL::EX1$HTA))
             (EQUAL (HP-TYPE (HOL::K (TYP (:ARROW* HOL::A HOL::B HOL::A))))
                    (TYP (:ARROW* HOL::A HOL::B HOL::A))))))
 (DEFTHM HOL::O$TYPE
  (IMPLIES (FORCE (HOL::EX1$PROP))
           (AND (HPP (HOL::O (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                           (:ARROW* HOL::C HOL::A)
                                           HOL::C HOL::B)))
                     (HOL::EX1$HTA))
                (EQUAL (HP-TYPE (HOL::O (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                                      (:ARROW* HOL::C HOL::A)
                                                      HOL::C HOL::B))))
                       (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                     (:ARROW* HOL::C HOL::A)
                                     HOL::C HOL::B))))))
 (DEFTHM HOL::COMMA$TYPE
  (IMPLIES
   (FORCE (HOL::EX1$PROP))
   (AND
    (HPP (HOL::COMMA (TYP (:ARROW* HOL::A HOL::B (:HASH HOL::A HOL::B))))
         (HOL::EX1$HTA))
    (EQUAL
       (HP-TYPE
            (HOL::COMMA (TYP (:ARROW* HOL::A HOL::B (:HASH HOL::A HOL::B)))))
       (TYP (:ARROW* HOL::A
                     HOL::B (:HASH HOL::A HOL::B)))))))
 (DEFTHM HOL::FST$TYPE
  (IMPLIES (FORCE (HOL::EX1$PROP))
           (AND (HPP (HOL::FST (TYP (:ARROW* (:HASH HOL::A HOL::B) HOL::A)))
                     (HOL::EX1$HTA))
                (EQUAL (HP-TYPE (HOL::FST (TYP (:ARROW* (:HASH HOL::A HOL::B)
                                                        HOL::A))))
                       (TYP (:ARROW* (:HASH HOL::A HOL::B)
                                     HOL::A))))))
 (DEFTHM HOL::SND$TYPE
  (IMPLIES (FORCE (HOL::EX1$PROP))
           (AND (HPP (HOL::SND (TYP (:ARROW* (:HASH HOL::A HOL::B) HOL::B)))
                     (HOL::EX1$HTA))
                (EQUAL (HP-TYPE (HOL::SND (TYP (:ARROW* (:HASH HOL::A HOL::B)
                                                        HOL::B))))
                       (TYP (:ARROW* (:HASH HOL::A HOL::B)
                                     HOL::B))))))
 (DEFTHM HOL::UNCURRY$TYPE
  (IMPLIES
   (FORCE (HOL::EX1$PROP))
   (AND
     (HPP (HOL::UNCURRY (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::C)
                                      (:HASH HOL::A HOL::B)
                                      HOL::C)))
          (HOL::EX1$HTA))
     (EQUAL
          (HP-TYPE (HOL::UNCURRY (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::C)
                                               (:HASH HOL::A HOL::B)
                                               HOL::C))))
          (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::C)
                        (:HASH HOL::A HOL::B)
                        HOL::C))))))
 (DEFTHM HOL::OPTION_BIND$TYPE
  (IMPLIES
   (FORCE (HOL::EX1$PROP))
   (AND
    (HPP (HOL::OPTION_BIND (TYP (:ARROW* (:OPTION HOL::B)
                                         (:ARROW* HOL::B (:OPTION HOL::A))
                                         (:OPTION HOL::A))))
         (HOL::EX1$HTA))
    (EQUAL
       (HP-TYPE
            (HOL::OPTION_BIND (TYP (:ARROW* (:OPTION HOL::B)
                                            (:ARROW* HOL::B (:OPTION HOL::A))
                                            (:OPTION HOL::A)))))
       (TYP (:ARROW* (:OPTION HOL::B)
                     (:ARROW* HOL::B (:OPTION HOL::A))
                     (:OPTION HOL::A)))))))
 (DEFTHM HOL::OPTION_MAP$TYPE
  (IMPLIES
   (FORCE (HOL::EX1$PROP))
   (AND
       (HPP (HOL::OPTION_MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                           (:OPTION HOL::A)
                                           (:OPTION HOL::B))))
            (HOL::EX1$HTA))
       (EQUAL (HP-TYPE (HOL::OPTION_MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                                      (:OPTION HOL::A)
                                                      (:OPTION HOL::B)))))
              (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                            (:OPTION HOL::A)
                            (:OPTION HOL::B)))))))
 (DEFTHM HOL::LIST_CASE$TYPE
  (IMPLIES
   (FORCE (HOL::EX1$PROP))
   (AND
    (HPP (HOL::LIST_CASE (TYP (:ARROW* (:LIST HOL::A)
                                       HOL::B
                                       (:ARROW* HOL::A (:LIST HOL::A) HOL::B)
                                       HOL::B)))
         (HOL::EX1$HTA))
    (EQUAL
     (HP-TYPE
         (HOL::LIST_CASE (TYP (:ARROW* (:LIST HOL::A)
                                       HOL::B
                                       (:ARROW* HOL::A (:LIST HOL::A) HOL::B)
                                       HOL::B))))
     (TYP (:ARROW* (:LIST HOL::A)
                   HOL::B
                   (:ARROW* HOL::A (:LIST HOL::A) HOL::B)
                   HOL::B))))))
 (DEFTHM HOL::LIST_SIZE$TYPE
  (IMPLIES
     (FORCE (HOL::EX1$PROP))
     (AND (HPP (HOL::LIST_SIZE (TYP (:ARROW* (:ARROW* HOL::A :NUM)
                                             (:LIST HOL::A)
                                             :NUM)))
               (HOL::EX1$HTA))
          (EQUAL (HP-TYPE (HOL::LIST_SIZE (TYP (:ARROW* (:ARROW* HOL::A :NUM)
                                                        (:LIST HOL::A)
                                                        :NUM))))
                 (TYP (:ARROW* (:ARROW* HOL::A :NUM)
                               (:LIST HOL::A)
                               :NUM))))))
 (DEFTHM HOL::MAP$TYPE
   (IMPLIES
        (FORCE (HOL::EX1$PROP))
        (AND (HPP (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                          (:LIST HOL::A)
                                          (:LIST HOL::B))))
                  (HOL::EX1$HTA))
             (EQUAL (HP-TYPE (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                                     (:LIST HOL::A)
                                                     (:LIST HOL::B)))))
                    (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                  (:LIST HOL::A)
                                  (:LIST HOL::B)))))))
 (DEFTHM HOL::FOLDR$TYPE
  (IMPLIES
   (FORCE (HOL::EX1$PROP))
   (AND
     (HPP (HOL::FOLDR (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::B)
                                    HOL::B (:LIST HOL::A)
                                    HOL::B)))
          (HOL::EX1$HTA))
     (EQUAL (HP-TYPE (HOL::FOLDR (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::B)
                                               HOL::B (:LIST HOL::A)
                                               HOL::B))))
            (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::B)
                          HOL::B (:LIST HOL::A)
                          HOL::B))))))
 (DEFTHM HOL::FOLDL$TYPE
  (IMPLIES
   (FORCE (HOL::EX1$PROP))
   (AND
     (HPP (HOL::FOLDL (TYP (:ARROW* (:ARROW* HOL::B HOL::A HOL::B)
                                    HOL::B (:LIST HOL::A)
                                    HOL::B)))
          (HOL::EX1$HTA))
     (EQUAL (HP-TYPE (HOL::FOLDL (TYP (:ARROW* (:ARROW* HOL::B HOL::A HOL::B)
                                               HOL::B (:LIST HOL::A)
                                               HOL::B))))
            (TYP (:ARROW* (:ARROW* HOL::B HOL::A HOL::B)
                          HOL::B (:LIST HOL::A)
                          HOL::B))))))
 (DEFTHM HOL::MOD$TYPE
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (AND (HPP (HOL::MOD (TYP (:ARROW* :NUM :NUM :NUM)))
                      (HOL::EX1$HTA))
                 (EQUAL (HP-TYPE (HOL::MOD (TYP (:ARROW* :NUM :NUM :NUM))))
                        (TYP (:ARROW* :NUM :NUM :NUM))))))
 (DEFTHM HOL::DIV$TYPE
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (AND (HPP (HOL::DIV (TYP (:ARROW* :NUM :NUM :NUM)))
                      (HOL::EX1$HTA))
                 (EQUAL (HP-TYPE (HOL::DIV (TYP (:ARROW* :NUM :NUM :NUM))))
                        (TYP (:ARROW* :NUM :NUM :NUM))))))
 (DEFTHM HOL::ODD$TYPE
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (AND (HPP (HOL::ODD (TYP (:ARROW* :NUM :BOOL)))
                      (HOL::EX1$HTA))
                 (EQUAL (HP-TYPE (HOL::ODD (TYP (:ARROW* :NUM :BOOL))))
                        (TYP (:ARROW* :NUM :BOOL))))))
 (DEFTHM HOL::EVEN$TYPE
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (AND (HPP (HOL::EVEN (TYP (:ARROW* :NUM :BOOL)))
                      (HOL::EX1$HTA))
                 (EQUAL (HP-TYPE (HOL::EVEN (TYP (:ARROW* :NUM :BOOL))))
                        (TYP (:ARROW* :NUM :BOOL))))))
 (DEFTHM HOL::EXP$TYPE
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (AND (HPP (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                      (HOL::EX1$HTA))
                 (EQUAL (HP-TYPE (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM))))
                        (TYP (:ARROW* :NUM :NUM :NUM))))))

; Each event in the next group corresponds to a clause in a HOL definition that
; has been translated.

 (DEFTHM HOL::HOL{SUC}
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::M HOL::HTA)
                 (EQUAL (HP-TYPE HOL::M) (TYP :NUM))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                         HOL::M)
                   (HP+ (HP-NUM 1) HOL::M))))
 (DEFTHM HOL::HOL{PRE}0
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (EQUAL (HAP* (HOL::PRE (TYP (:ARROW* :NUM :NUM)))
                         (HP-NUM 0))
                   (HP-NUM 0))))
 (DEFTHM HOL::HOL{PRE}1
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::M HOL::HTA)
                 (EQUAL (HP-TYPE HOL::M) (TYP :NUM))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::PRE (TYP (:ARROW* :NUM :NUM)))
                         (HAP* (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                               HOL::M))
                   HOL::M)))
 (DEFTHM HOL::HOL{I}
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::X HOL::HTA)
                 (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::I (TYP (:ARROW* HOL::A HOL::A)))
                         HOL::X)
                   HOL::X)))
 (DEFTHM HOL::HOL{C}
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::F HOL::HTA)
                 (EQUAL (HP-TYPE HOL::F)
                        (TYP (:ARROW* HOL::A HOL::B HOL::C)))
                 (HPP HOL::X HOL::HTA)
                 (EQUAL (HP-TYPE HOL::X) (TYP HOL::B))
                 (HPP HOL::Y HOL::HTA)
                 (EQUAL (HP-TYPE HOL::Y) (TYP HOL::A))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::C (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::C)
                                               HOL::B HOL::A HOL::C)))
                         HOL::F HOL::X HOL::Y)
                   (HAP* HOL::F HOL::Y HOL::X))))
 (DEFTHM HOL::HOL{K}
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::X HOL::HTA)
                 (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
                 (HPP HOL::Y HOL::HTA)
                 (EQUAL (HP-TYPE HOL::Y) (TYP HOL::B))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::K (TYP (:ARROW* HOL::A HOL::B HOL::A)))
                         HOL::X HOL::Y)
                   HOL::X)))
 (DEFTHM HOL::HOL{O}
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::F HOL::HTA)
                 (EQUAL (HP-TYPE HOL::F)
                        (TYP (:ARROW* HOL::A HOL::B)))
                 (HPP HOL::G HOL::HTA)
                 (EQUAL (HP-TYPE HOL::G)
                        (TYP (:ARROW* HOL::C HOL::A)))
                 (HPP HOL::X HOL::HTA)
                 (EQUAL (HP-TYPE HOL::X) (TYP HOL::C))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::O (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                               (:ARROW* HOL::C HOL::A)
                                               HOL::C HOL::B)))
                         HOL::F HOL::G HOL::X)
                   (HAP* HOL::F (HAP* HOL::G HOL::X)))))
 (DEFTHM HOL::HOL{COMMA}
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
        (HPP HOL::X HOL::HTA)
        (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
        (HPP HOL::Y HOL::HTA)
        (EQUAL (HP-TYPE HOL::Y) (TYP HOL::B))
        (FORCE (HOL::EX1$PROP)))
   (EQUAL
       (HAP* (HOL::COMMA (TYP (:ARROW* HOL::A HOL::B (:HASH HOL::A HOL::B))))
             HOL::X HOL::Y)
       (HP-COMMA HOL::X HOL::Y))))
 (DEFTHM HOL::HOL{FST}
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
             (HPP HOL::X HOL::HTA)
             (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
             (HPP HOL::Y HOL::HTA)
             (EQUAL (HP-TYPE HOL::Y) (TYP HOL::B))
             (FORCE (HOL::EX1$PROP)))
        (EQUAL (HAP* (HOL::FST (TYP (:ARROW* (:HASH HOL::A HOL::B) HOL::A)))
                     (HP-COMMA HOL::X HOL::Y))
               HOL::X)))
 (DEFTHM HOL::HOL{SND}
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
             (HPP HOL::X HOL::HTA)
             (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
             (HPP HOL::Y HOL::HTA)
             (EQUAL (HP-TYPE HOL::Y) (TYP HOL::B))
             (FORCE (HOL::EX1$PROP)))
        (EQUAL (HAP* (HOL::SND (TYP (:ARROW* (:HASH HOL::A HOL::B) HOL::B)))
                     (HP-COMMA HOL::X HOL::Y))
               HOL::Y)))
 (DEFTHM HOL::HOL{UNCURRY}
  (IMPLIES
      (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
           (HPP HOL::F HOL::HTA)
           (EQUAL (HP-TYPE HOL::F)
                  (TYP (:ARROW* HOL::A HOL::B HOL::C)))
           (HPP HOL::X HOL::HTA)
           (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
           (HPP HOL::Y HOL::HTA)
           (EQUAL (HP-TYPE HOL::Y) (TYP HOL::B))
           (FORCE (HOL::EX1$PROP)))
      (EQUAL (HAP* (HOL::UNCURRY (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::C)
                                               (:HASH HOL::A HOL::B)
                                               HOL::C)))
                   HOL::F (HP-COMMA HOL::X HOL::Y))
             (HAP* HOL::F HOL::X HOL::Y))))
 (DEFTHM HOL::HOL{OPTION_BIND}0
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
        (HPP HOL::F HOL::HTA)
        (EQUAL (HP-TYPE HOL::F)
               (TYP (:ARROW* HOL::B (:OPTION HOL::A))))
        (FORCE (HOL::EX1$PROP)))
   (EQUAL
      (HAP* (HOL::OPTION_BIND (TYP (:ARROW* (:OPTION HOL::B)
                                            (:ARROW* HOL::B (:OPTION HOL::A))
                                            (:OPTION HOL::A))))
            (HP-NONE (TYP HOL::B))
            HOL::F)
      (HP-NONE (TYP HOL::A)))))
 (DEFTHM HOL::HOL{OPTION_BIND}1
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
        (HPP HOL::X HOL::HTA)
        (EQUAL (HP-TYPE HOL::X) (TYP HOL::B))
        (HPP HOL::F HOL::HTA)
        (EQUAL (HP-TYPE HOL::F)
               (TYP (:ARROW* HOL::B (:OPTION HOL::A))))
        (FORCE (HOL::EX1$PROP)))
   (EQUAL
      (HAP* (HOL::OPTION_BIND (TYP (:ARROW* (:OPTION HOL::B)
                                            (:ARROW* HOL::B (:OPTION HOL::A))
                                            (:OPTION HOL::A))))
            (HP-SOME HOL::X)
            HOL::F)
      (HAP* HOL::F HOL::X))))
 (DEFTHM HOL::HOL{OPTION_MAP}0
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
             (HPP HOL::F HOL::HTA)
             (EQUAL (HP-TYPE HOL::F)
                    (TYP (:ARROW* HOL::A HOL::B)))
             (HPP HOL::X HOL::HTA)
             (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
             (FORCE (HOL::EX1$PROP)))
        (EQUAL (HAP* (HOL::OPTION_MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                                    (:OPTION HOL::A)
                                                    (:OPTION HOL::B))))
                     HOL::F (HP-SOME HOL::X))
               (HP-SOME (HAP* HOL::F HOL::X)))))
 (DEFTHM HOL::HOL{OPTION_MAP}1
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
             (HPP HOL::F HOL::HTA)
             (EQUAL (HP-TYPE HOL::F)
                    (TYP (:ARROW* HOL::A HOL::B)))
             (FORCE (HOL::EX1$PROP)))
        (EQUAL (HAP* (HOL::OPTION_MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                                    (:OPTION HOL::A)
                                                    (:OPTION HOL::B))))
                     HOL::F (HP-NONE (TYP HOL::A)))
               (HP-NONE (TYP HOL::B)))))
 (DEFTHM HOL::HOL{LIST_CASE}0
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
        (HPP HOL::V HOL::HTA)
        (EQUAL (HP-TYPE HOL::V) (TYP HOL::B))
        (HPP HOL::F HOL::HTA)
        (EQUAL (HP-TYPE HOL::F)
               (TYP (:ARROW* HOL::A (:LIST HOL::A) HOL::B)))
        (FORCE (HOL::EX1$PROP)))
   (EQUAL
    (HAP*
         (HOL::LIST_CASE (TYP (:ARROW* (:LIST HOL::A)
                                       HOL::B
                                       (:ARROW* HOL::A (:LIST HOL::A) HOL::B)
                                       HOL::B)))
         (HP-NIL (TYP HOL::A))
         HOL::V HOL::F)
    HOL::V)))
 (DEFTHM HOL::HOL{LIST_CASE}1
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
        (HPP HOL::A0 HOL::HTA)
        (EQUAL (HP-TYPE HOL::A0) (TYP HOL::A))
        (HPP HOL::A1 HOL::HTA)
        (EQUAL (HP-TYPE HOL::A1)
               (TYP (:LIST HOL::A)))
        (HPP HOL::V HOL::HTA)
        (EQUAL (HP-TYPE HOL::V) (TYP HOL::B))
        (HPP HOL::F HOL::HTA)
        (EQUAL (HP-TYPE HOL::F)
               (TYP (:ARROW* HOL::A (:LIST HOL::A) HOL::B)))
        (FORCE (HOL::EX1$PROP)))
   (EQUAL
    (HAP*
         (HOL::LIST_CASE (TYP (:ARROW* (:LIST HOL::A)
                                       HOL::B
                                       (:ARROW* HOL::A (:LIST HOL::A) HOL::B)
                                       HOL::B)))
         (HP-CONS HOL::A0 HOL::A1)
         HOL::V HOL::F)
    (HAP* HOL::F HOL::A0 HOL::A1))))
 (DEFTHM HOL::HOL{LIST_SIZE}0
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::F HOL::HTA)
                 (EQUAL (HP-TYPE HOL::F)
                        (TYP (:ARROW* HOL::A :NUM)))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::LIST_SIZE (TYP (:ARROW* (:ARROW* HOL::A :NUM)
                                                       (:LIST HOL::A)
                                                       :NUM)))
                         HOL::F (HP-NIL (TYP HOL::A)))
                   (HP-NUM 0))))
 (DEFTHM HOL::HOL{LIST_SIZE}1
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
        (HPP HOL::F HOL::HTA)
        (EQUAL (HP-TYPE HOL::F)
               (TYP (:ARROW* HOL::A :NUM)))
        (HPP HOL::A0 HOL::HTA)
        (EQUAL (HP-TYPE HOL::A0) (TYP HOL::A))
        (HPP HOL::A1 HOL::HTA)
        (EQUAL (HP-TYPE HOL::A1)
               (TYP (:LIST HOL::A)))
        (FORCE (HOL::EX1$PROP)))
   (EQUAL (HAP* (HOL::LIST_SIZE (TYP (:ARROW* (:ARROW* HOL::A :NUM)
                                              (:LIST HOL::A)
                                              :NUM)))
                HOL::F (HP-CONS HOL::A0 HOL::A1))
          (HP+ (HP-NUM 1)
               (HP+ (HAP* HOL::F HOL::A0)
                    (HAP* (HOL::LIST_SIZE (TYP (:ARROW* (:ARROW* HOL::A :NUM)
                                                        (:LIST HOL::A)
                                                        :NUM)))
                          HOL::F HOL::A1))))))
 (DEFTHM HOL::HOL{MAP}0
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::F HOL::HTA)
                 (EQUAL (HP-TYPE HOL::F)
                        (TYP (:ARROW* HOL::A HOL::B)))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                                 (:LIST HOL::A)
                                                 (:LIST HOL::B))))
                         HOL::F (HP-NIL (TYP HOL::A)))
                   (HP-NIL (TYP HOL::B)))))
 (DEFTHM HOL::HOL{MAP}1
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
             (HPP HOL::F HOL::HTA)
             (EQUAL (HP-TYPE HOL::F)
                    (TYP (:ARROW* HOL::A HOL::B)))
             (HPP HOL::H HOL::HTA)
             (EQUAL (HP-TYPE HOL::H) (TYP HOL::A))
             (HPP HOL::T HOL::HTA)
             (EQUAL (HP-TYPE HOL::T)
                    (TYP (:LIST HOL::A)))
             (FORCE (HOL::EX1$PROP)))
        (EQUAL (HAP* (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                             (:LIST HOL::A)
                                             (:LIST HOL::B))))
                     HOL::F (HP-CONS HOL::H HOL::T))
               (HP-CONS (HAP* HOL::F HOL::H)
                        (HAP* (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                                      (:LIST HOL::A)
                                                      (:LIST HOL::B))))
                              HOL::F HOL::T)))))
 (DEFTHM HOL::HOL{FOLDR}0
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
             (HPP HOL::F HOL::HTA)
             (EQUAL (HP-TYPE HOL::F)
                    (TYP (:ARROW* HOL::A HOL::B HOL::B)))
             (HPP HOL::E HOL::HTA)
             (EQUAL (HP-TYPE HOL::E) (TYP HOL::B))
             (FORCE (HOL::EX1$PROP)))
        (EQUAL (HAP* (HOL::FOLDR (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::B)
                                               HOL::B (:LIST HOL::A)
                                               HOL::B)))
                     HOL::F HOL::E (HP-NIL (TYP HOL::A)))
               HOL::E)))
 (DEFTHM HOL::HOL{FOLDR}1
  (IMPLIES
    (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
         (HPP HOL::F HOL::HTA)
         (EQUAL (HP-TYPE HOL::F)
                (TYP (:ARROW* HOL::A HOL::B HOL::B)))
         (HPP HOL::E HOL::HTA)
         (EQUAL (HP-TYPE HOL::E) (TYP HOL::B))
         (HPP HOL::X HOL::HTA)
         (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
         (HPP HOL::L HOL::HTA)
         (EQUAL (HP-TYPE HOL::L)
                (TYP (:LIST HOL::A)))
         (FORCE (HOL::EX1$PROP)))
    (EQUAL
         (HAP* (HOL::FOLDR (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::B)
                                         HOL::B (:LIST HOL::A)
                                         HOL::B)))
               HOL::F HOL::E (HP-CONS HOL::X HOL::L))
         (HAP* HOL::F HOL::X
               (HAP* (HOL::FOLDR (TYP (:ARROW* (:ARROW* HOL::A HOL::B HOL::B)
                                               HOL::B (:LIST HOL::A)
                                               HOL::B)))
                     HOL::F HOL::E HOL::L)))))
 (DEFTHM HOL::HOL{FOLDL}0
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
             (HPP HOL::F HOL::HTA)
             (EQUAL (HP-TYPE HOL::F)
                    (TYP (:ARROW* HOL::B HOL::A HOL::B)))
             (HPP HOL::E HOL::HTA)
             (EQUAL (HP-TYPE HOL::E) (TYP HOL::B))
             (FORCE (HOL::EX1$PROP)))
        (EQUAL (HAP* (HOL::FOLDL (TYP (:ARROW* (:ARROW* HOL::B HOL::A HOL::B)
                                               HOL::B (:LIST HOL::A)
                                               HOL::B)))
                     HOL::F HOL::E (HP-NIL (TYP HOL::A)))
               HOL::E)))
 (DEFTHM HOL::HOL{FOLDL}1
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
             (HPP HOL::F HOL::HTA)
             (EQUAL (HP-TYPE HOL::F)
                    (TYP (:ARROW* HOL::B HOL::A HOL::B)))
             (HPP HOL::E HOL::HTA)
             (EQUAL (HP-TYPE HOL::E) (TYP HOL::B))
             (HPP HOL::X HOL::HTA)
             (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
             (HPP HOL::L HOL::HTA)
             (EQUAL (HP-TYPE HOL::L)
                    (TYP (:LIST HOL::A)))
             (FORCE (HOL::EX1$PROP)))
        (EQUAL (HAP* (HOL::FOLDL (TYP (:ARROW* (:ARROW* HOL::B HOL::A HOL::B)
                                               HOL::B (:LIST HOL::A)
                                               HOL::B)))
                     HOL::F HOL::E (HP-CONS HOL::X HOL::L))
               (HAP* (HOL::FOLDL (TYP (:ARROW* (:ARROW* HOL::B HOL::A HOL::B)
                                               HOL::B (:LIST HOL::A)
                                               HOL::B)))
                     HOL::F (HAP* HOL::F HOL::E HOL::X)
                     HOL::L))))
 (DEFTHM HOL::HOL{DIV}
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
        (HPP HOL::N HOL::HTA)
        (EQUAL (HP-TYPE HOL::N) (TYP :NUM))
        (HPP HOL::K HOL::HTA)
        (EQUAL (HP-TYPE HOL::K) (TYP :NUM))
        (FORCE (HOL::EX1$PROP)))
   (EQUAL
    (HP-IMPLIES
       (HP< (HP-NUM 0) HOL::N)
       (HP-AND (HP= HOL::K
                    (HP+ (HP* (HAP* (HOL::DIV (TYP (:ARROW* :NUM :NUM :NUM)))
                                    HOL::K HOL::N)
                              HOL::N)
                         (HAP* (HOL::MOD (TYP (:ARROW* :NUM :NUM :NUM)))
                               HOL::K HOL::N)))
               (HP< (HAP* (HOL::MOD (TYP (:ARROW* :NUM :NUM :NUM)))
                          HOL::K HOL::N)
                    HOL::N)))
    (HP-TRUE))))
 (DEFTHM HOL::HOL{EVEN}0
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (EQUAL (HAP* (HOL::EVEN (TYP (:ARROW* :NUM :BOOL)))
                         (HP-NUM 0))
                   (HP-TRUE))))
 (DEFTHM HOL::HOL{EVEN}1
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::N HOL::HTA)
                 (EQUAL (HP-TYPE HOL::N) (TYP :NUM))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::EVEN (TYP (:ARROW* :NUM :BOOL)))
                         (HAP* (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                               HOL::N))
                   (HAP* (HOL::ODD (TYP (:ARROW* :NUM :BOOL)))
                         HOL::N))))
 (DEFTHM HOL::HOL{EVEN}2
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (EQUAL (HAP* (HOL::ODD (TYP (:ARROW* :NUM :BOOL)))
                         (HP-NUM 0))
                   (HP-FALSE))))
 (DEFTHM HOL::HOL{EVEN}3
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::N HOL::HTA)
                 (EQUAL (HP-TYPE HOL::N) (TYP :NUM))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::ODD (TYP (:ARROW* :NUM :BOOL)))
                         (HAP* (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                               HOL::N))
                   (HAP* (HOL::EVEN (TYP (:ARROW* :NUM :BOOL)))
                         HOL::N))))
 (DEFTHM HOL::HOL{EXP}0
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::M HOL::HTA)
                 (EQUAL (HP-TYPE HOL::M) (TYP :NUM))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                         HOL::M (HP-NUM 0))
                   (HP-NUM 1))))
 (DEFTHM HOL::HOL{EXP}1
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
                 (HPP HOL::M HOL::HTA)
                 (EQUAL (HP-TYPE HOL::M) (TYP :NUM))
                 (HPP HOL::N HOL::HTA)
                 (EQUAL (HP-TYPE HOL::N) (TYP :NUM))
                 (FORCE (HOL::EX1$PROP)))
            (EQUAL (HAP* (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                         HOL::M
                         (HAP* (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                               HOL::N))
                   (HP* HOL::M
                        (HAP* (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                              HOL::M HOL::N)))))
 (DEFTHM HOL::HOL{MAP_ID_I}
   (IMPLIES (FORCE (HOL::EX1$PROP))
            (EQUAL (HP= (HAP* (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::A)
                                                      (:LIST HOL::A)
                                                      (:LIST HOL::A))))
                              (HOL::I (TYP (:ARROW* HOL::A HOL::A))))
                        (HOL::I (TYP (:ARROW* (:LIST HOL::A)
                                              (:LIST HOL::A)))))
                   (HP-TRUE))))
 (DEFTHM HOL::HOL{MAP_O}
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EX1$HTA) HOL::HTA)
        (HPP HOL::F HOL::HTA)
        (EQUAL (HP-TYPE HOL::F)
               (TYP (:ARROW* HOL::B HOL::C)))
        (HPP HOL::G HOL::HTA)
        (EQUAL (HP-TYPE HOL::G)
               (TYP (:ARROW* HOL::A HOL::B)))
        (FORCE (HOL::EX1$PROP)))
   (EQUAL
     (HP= (HAP* (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::C)
                                        (:LIST HOL::A)
                                        (:LIST HOL::C))))
                (HAP* (HOL::O (TYP (:ARROW* (:ARROW* HOL::B HOL::C)
                                            (:ARROW* HOL::A HOL::B)
                                            HOL::A HOL::C)))
                      HOL::F HOL::G))
          (HAP* (HOL::O (TYP (:ARROW* (:ARROW* (:LIST HOL::B) (:LIST HOL::C))
                                      (:ARROW* (:LIST HOL::A) (:LIST HOL::B))
                                      (:LIST HOL::A)
                                      (:LIST HOL::C))))
                (HAP* (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::B HOL::C)
                                              (:LIST HOL::B)
                                              (:LIST HOL::C))))
                      HOL::F)
                (HAP* (HOL::MAP (TYP (:ARROW* (:ARROW* HOL::A HOL::B)
                                              (:LIST HOL::A)
                                              (:LIST HOL::B))))
                      HOL::G)))
     (HP-TRUE))))

; The final group of events says that :NUM and :BOOL are defined types in HOL
; type-alist (hta) introduced for the EX1 theory, and then disables the
; definition and executable-counterpart for that hta (i.e., for the zero-ary
; function, HOL::EX1$HTA).

 (DEFTHM HOL::HONS-ASSOC-EQUAL-NUM-EX1$HTA
   (HONS-ASSOC-EQUAL :NUM (HOL::EX1$HTA)))
 (DEFTHM HOL::HONS-ASSOC-EQUAL-BOOL-EX1$HTA
   (HONS-ASSOC-EQUAL :BOOL (HOL::EX1$HTA)))
 (IN-THEORY (DISABLE HOL::EX1$HTA (:E HOL::EX1$HTA))))
