; Copyright (C) 2025, Matt Kaufmann and Konrad Slind
; Written by Matt Kaufmann and Konrad Slind
; License: A 3-clause BSD license.  See the LICENSE file distributed with ACL2.

; This book displays the axioms generated by the translater on the eval_poly
; example.  Specifically, it displays the encapsulate event generated by the
; import-theory call in eval-poly-thy.lisp.  Comments below explain that event
; and its groups of events, which may be viewed as the axioms exported by that
; encapsulate event.

; A comment at the end shows the translation of the goal theorem.

(in-package "ZF")

; Include the book that imports the translator output into ACL2.
(include-book "eval-poly-thy")

; The next form guarantees that the encapsulate form below is already present
; upon evaluating the include-book form above.
(set-enforce-redundancy t)

; The first argument of encapsulate is the list of signatures of function
; symbols introduced.  The other arguments can be divided into groups as
; explained in comments below.

(ENCAPSULATE (((HOL::EVAL-POLY$PROP) => *)
              ((HOL::COND *) => *)
              ((HOL::COMMA *) => *)
              ((HOL::FST *) => *)
              ((HOL::SND *) => *)
              ((HOL::SUC *) => *)
              ((HOL::<= *) => *)
              ((HOL::HD *) => *)
              ((HOL::NULL *) => *)
              ((HOL::EXP *) => *)
              ((HOL::POLYP *) => *)
              ((HOL::EVAL_POLY *) => *)
              ((HOL::SUM_POLYS *) => *))

; The first group of events below provides local definitions of the function
; symbols introduced above in a list of signatures.  They are trivial but they
; suffice for proving the theorems that follow, because those have
; (HOL::EVAL-POLY$PROP) as a hypothesis, whose local witness returns nil.
; Technically, the hypothesis is (FORCE (HOL::EVAL-POLY$PROP)); but FORCE is
; the identity function, used only to support rewriting (see :DOC force).

 (LOCAL (DEFUN HOL::EVAL-POLY$PROP NIL NIL))
 (LOCAL (DEFUN HOL::COND (X) X))
 (LOCAL (DEFUN HOL::COMMA (X) X))
 (LOCAL (DEFUN HOL::FST (X) X))
 (LOCAL (DEFUN HOL::SND (X) X))
 (LOCAL (DEFUN HOL::SUC (X) X))
 (LOCAL (DEFUN HOL::<= (X) X))
 (LOCAL (DEFUN HOL::HD (X) X))
 (LOCAL (DEFUN HOL::NULL (X) X))
 (LOCAL (DEFUN HOL::EXP (X) X))
 (LOCAL (DEFUN HOL::POLYP (X) X))
 (LOCAL (DEFUN HOL::EVAL_POLY (X) X))
 (LOCAL (DEFUN HOL::SUM_POLYS (X) X))

; The next group of events deduces various set-theory axioms from
; (HOL::EVAL-POLY$PROP).

 (DEFTHM HOL::EVAL-POLY$PROP-IMPLIES-ZFC
   (IMPLIES (HOL::EVAL-POLY$PROP) (ZFC))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EVAL-POLY$PROP-IMPLIES-PROD2$PROP
   (IMPLIES (HOL::EVAL-POLY$PROP)
            (PROD2$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EVAL-POLY$PROP-IMPLIES-DOMAIN$PROP
   (IMPLIES (HOL::EVAL-POLY$PROP)
            (DOMAIN$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EVAL-POLY$PROP-IMPLIES-INVERSE$PROP
   (IMPLIES (HOL::EVAL-POLY$PROP)
            (INVERSE$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EVAL-POLY$PROP-IMPLIES-FINSEQS$PROP
   (IMPLIES (HOL::EVAL-POLY$PROP)
            (FINSEQS$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EVAL-POLY$PROP-IMPLIES-DIFF$PROP
   (IMPLIES (HOL::EVAL-POLY$PROP)
            (DIFF$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EVAL-POLY$PROP-IMPLIES-RESTRICT$PROP
   (IMPLIES (HOL::EVAL-POLY$PROP)
            (RESTRICT$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)
 (DEFTHM HOL::EVAL-POLY$PROP-IMPLIES-FUN-SPACE$PROP
   (IMPLIES (HOL::EVAL-POLY$PROP)
            (FUN-SPACE$PROP))
   :RULE-CLASSES :FORWARD-CHAINING)

; Each event in the next group introduces two conditional rewrite rules, as
; explained in comments added to the first of these.  Each has
; (HOL::EVAL-POLY$PROP) as a hypothesis.

 (DEFTHM HOL::COND$TYPE
  (IMPLIES
   (FORCE (HOL::EVAL-POLY$PROP))
   (AND
; COND produces a valid HOL pair:
      (HPP (HOL::COND (TYP (:ARROW* :BOOL HOL::A HOL::A HOL::A)))
           (HOL::EVAL-POLY$HTA))
; The type of the HOL pair produced by COND is as expected:
      (EQUAL (HP-TYPE (HOL::COND (TYP (:ARROW* :BOOL HOL::A HOL::A HOL::A))))
             (TYP (:ARROW* :BOOL HOL::A HOL::A HOL::A))))))
 (DEFTHM HOL::COMMA$TYPE
  (IMPLIES
   (FORCE (HOL::EVAL-POLY$PROP))
   (AND
    (HPP (HOL::COMMA (TYP (:ARROW* HOL::A HOL::B (:HASH HOL::A HOL::B))))
         (HOL::EVAL-POLY$HTA))
    (EQUAL
       (HP-TYPE
            (HOL::COMMA (TYP (:ARROW* HOL::A HOL::B (:HASH HOL::A HOL::B)))))
       (TYP (:ARROW* HOL::A
                     HOL::B (:HASH HOL::A HOL::B)))))))
 (DEFTHM HOL::FST$TYPE
  (IMPLIES (FORCE (HOL::EVAL-POLY$PROP))
           (AND (HPP (HOL::FST (TYP (:ARROW* (:HASH HOL::A HOL::B) HOL::A)))
                     (HOL::EVAL-POLY$HTA))
                (EQUAL (HP-TYPE (HOL::FST (TYP (:ARROW* (:HASH HOL::A HOL::B)
                                                        HOL::A))))
                       (TYP (:ARROW* (:HASH HOL::A HOL::B)
                                     HOL::A))))))
 (DEFTHM HOL::SND$TYPE
  (IMPLIES (FORCE (HOL::EVAL-POLY$PROP))
           (AND (HPP (HOL::SND (TYP (:ARROW* (:HASH HOL::A HOL::B) HOL::B)))
                     (HOL::EVAL-POLY$HTA))
                (EQUAL (HP-TYPE (HOL::SND (TYP (:ARROW* (:HASH HOL::A HOL::B)
                                                        HOL::B))))
                       (TYP (:ARROW* (:HASH HOL::A HOL::B)
                                     HOL::B))))))
 (DEFTHM HOL::SUC$TYPE
   (IMPLIES (FORCE (HOL::EVAL-POLY$PROP))
            (AND (HPP (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                      (HOL::EVAL-POLY$HTA))
                 (EQUAL (HP-TYPE (HOL::SUC (TYP (:ARROW* :NUM :NUM))))
                        (TYP (:ARROW* :NUM :NUM))))))
 (DEFTHM HOL::<=$TYPE
   (IMPLIES (FORCE (HOL::EVAL-POLY$PROP))
            (AND (HPP (HOL::<= (TYP (:ARROW* :NUM :NUM :BOOL)))
                      (HOL::EVAL-POLY$HTA))
                 (EQUAL (HP-TYPE (HOL::<= (TYP (:ARROW* :NUM :NUM :BOOL))))
                        (TYP (:ARROW* :NUM :NUM :BOOL))))))
 (DEFTHM HOL::HD$TYPE
   (IMPLIES
        (FORCE (HOL::EVAL-POLY$PROP))
        (AND (HPP (HOL::HD (TYP (:ARROW* (:LIST HOL::A) HOL::A)))
                  (HOL::EVAL-POLY$HTA))
             (EQUAL (HP-TYPE (HOL::HD (TYP (:ARROW* (:LIST HOL::A) HOL::A))))
                    (TYP (:ARROW* (:LIST HOL::A) HOL::A))))))
 (DEFTHM HOL::NULL$TYPE
  (IMPLIES
       (FORCE (HOL::EVAL-POLY$PROP))
       (AND (HPP (HOL::NULL (TYP (:ARROW* (:LIST HOL::A) :BOOL)))
                 (HOL::EVAL-POLY$HTA))
            (EQUAL (HP-TYPE (HOL::NULL (TYP (:ARROW* (:LIST HOL::A) :BOOL))))
                   (TYP (:ARROW* (:LIST HOL::A) :BOOL))))))
 (DEFTHM HOL::EXP$TYPE
   (IMPLIES (FORCE (HOL::EVAL-POLY$PROP))
            (AND (HPP (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                      (HOL::EVAL-POLY$HTA))
                 (EQUAL (HP-TYPE (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM))))
                        (TYP (:ARROW* :NUM :NUM :NUM))))))
 (DEFTHM HOL::POLYP$TYPE
  (IMPLIES
     (FORCE (HOL::EVAL-POLY$PROP))
     (AND (HPP (HOL::POLYP (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                         :BOOL)))
               (HOL::EVAL-POLY$HTA))
          (EQUAL (HP-TYPE (HOL::POLYP (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                    :BOOL))))
                 (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                               :BOOL))))))
 (DEFTHM HOL::EVAL_POLY$TYPE
  (IMPLIES
   (FORCE (HOL::EVAL-POLY$PROP))
   (AND
      (HPP (HOL::EVAL_POLY (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                         :NUM :NUM)))
           (HOL::EVAL-POLY$HTA))
      (EQUAL (HP-TYPE (HOL::EVAL_POLY (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                    :NUM :NUM))))
             (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                           :NUM :NUM))))))
 (DEFTHM HOL::SUM_POLYS$TYPE
  (IMPLIES
   (FORCE (HOL::EVAL-POLY$PROP))
   (AND
    (HPP (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                       (:LIST (:HASH :NUM :NUM))
                                       (:LIST (:HASH :NUM :NUM)))))
         (HOL::EVAL-POLY$HTA))
    (EQUAL
         (HP-TYPE (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                (:LIST (:HASH :NUM :NUM))
                                                (:LIST (:HASH :NUM :NUM))))))
         (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                       (:LIST (:HASH :NUM :NUM))
                       (:LIST (:HASH :NUM :NUM))))))))

; Each event in the next group corresponds to a clause in a HOL definition that
; has been translated.

 (DEFTHM HOL::HOL{COND}0
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                            HOL::HTA)
             (HPP HOL::X HOL::HTA)
             (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
             (HPP HOL::Y HOL::HTA)
             (EQUAL (HP-TYPE HOL::Y) (TYP HOL::A))
             (FORCE (HOL::EVAL-POLY$PROP)))
        (EQUAL (HAP* (HOL::COND (TYP (:ARROW* :BOOL HOL::A HOL::A HOL::A)))
                     (HP-TRUE)
                     HOL::X HOL::Y)
               HOL::X)))
 (DEFTHM HOL::HOL{COND}1
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                            HOL::HTA)
             (HPP HOL::X HOL::HTA)
             (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
             (HPP HOL::Y HOL::HTA)
             (EQUAL (HP-TYPE HOL::Y) (TYP HOL::A))
             (FORCE (HOL::EVAL-POLY$PROP)))
        (EQUAL (HAP* (HOL::COND (TYP (:ARROW* :BOOL HOL::A HOL::A HOL::A)))
                     (HP-FALSE)
                     HOL::X HOL::Y)
               HOL::Y)))
 (DEFTHM HOL::HOL{COMMA}
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                       HOL::HTA)
        (HPP HOL::X HOL::HTA)
        (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
        (HPP HOL::Y HOL::HTA)
        (EQUAL (HP-TYPE HOL::Y) (TYP HOL::B))
        (FORCE (HOL::EVAL-POLY$PROP)))
   (EQUAL
       (HAP* (HOL::COMMA (TYP (:ARROW* HOL::A HOL::B (:HASH HOL::A HOL::B))))
             HOL::X HOL::Y)
       (HP-COMMA HOL::X HOL::Y))))
 (DEFTHM HOL::HOL{FST}
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                            HOL::HTA)
             (HPP HOL::X HOL::HTA)
             (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
             (HPP HOL::Y HOL::HTA)
             (EQUAL (HP-TYPE HOL::Y) (TYP HOL::B))
             (FORCE (HOL::EVAL-POLY$PROP)))
        (EQUAL (HAP* (HOL::FST (TYP (:ARROW* (:HASH HOL::A HOL::B) HOL::A)))
                     (HP-COMMA HOL::X HOL::Y))
               HOL::X)))
 (DEFTHM HOL::HOL{SND}
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                            HOL::HTA)
             (HPP HOL::X HOL::HTA)
             (EQUAL (HP-TYPE HOL::X) (TYP HOL::A))
             (HPP HOL::Y HOL::HTA)
             (EQUAL (HP-TYPE HOL::Y) (TYP HOL::B))
             (FORCE (HOL::EVAL-POLY$PROP)))
        (EQUAL (HAP* (HOL::SND (TYP (:ARROW* (:HASH HOL::A HOL::B) HOL::B)))
                     (HP-COMMA HOL::X HOL::Y))
               HOL::Y)))
 (DEFTHM HOL::HOL{SUC}
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                                HOL::HTA)
                 (HPP HOL::M HOL::HTA)
                 (EQUAL (HP-TYPE HOL::M) (TYP :NUM))
                 (FORCE (HOL::EVAL-POLY$PROP)))
            (EQUAL (HAP* (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                         HOL::M)
                   (HP+ (HP-NUM 1) HOL::M))))
 (DEFTHM HOL::HOL{<=}
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                                HOL::HTA)
                 (HPP HOL::X HOL::HTA)
                 (EQUAL (HP-TYPE HOL::X) (TYP :NUM))
                 (HPP HOL::Y HOL::HTA)
                 (EQUAL (HP-TYPE HOL::Y) (TYP :NUM))
                 (FORCE (HOL::EVAL-POLY$PROP)))
            (EQUAL (HAP* (HOL::<= (TYP (:ARROW* :NUM :NUM :BOOL)))
                         HOL::X HOL::Y)
                   (HP-OR (HP< HOL::X HOL::Y)
                          (HP= HOL::X HOL::Y)))))
 (DEFTHM HOL::HOL{HD}
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                                HOL::HTA)
                 (HPP HOL::H HOL::HTA)
                 (EQUAL (HP-TYPE HOL::H) (TYP HOL::A))
                 (HPP HOL::T HOL::HTA)
                 (EQUAL (HP-TYPE HOL::T)
                        (TYP (:LIST HOL::A)))
                 (FORCE (HOL::EVAL-POLY$PROP)))
            (EQUAL (HAP* (HOL::HD (TYP (:ARROW* (:LIST HOL::A) HOL::A)))
                         (HP-CONS HOL::H HOL::T))
                   HOL::H)))
 (DEFTHM HOL::HOL{NULL}0
   (IMPLIES (FORCE (HOL::EVAL-POLY$PROP))
            (EQUAL (HAP* (HOL::NULL (TYP (:ARROW* (:LIST HOL::A) :BOOL)))
                         (HP-NIL (TYP HOL::A)))
                   (HP-TRUE))))
 (DEFTHM HOL::HOL{NULL}1
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                                HOL::HTA)
                 (HPP HOL::H HOL::HTA)
                 (EQUAL (HP-TYPE HOL::H) (TYP HOL::A))
                 (HPP HOL::T HOL::HTA)
                 (EQUAL (HP-TYPE HOL::T)
                        (TYP (:LIST HOL::A)))
                 (FORCE (HOL::EVAL-POLY$PROP)))
            (EQUAL (HAP* (HOL::NULL (TYP (:ARROW* (:LIST HOL::A) :BOOL)))
                         (HP-CONS HOL::H HOL::T))
                   (HP-FALSE))))
 (DEFTHM HOL::HOL{EXP}0
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                                HOL::HTA)
                 (HPP HOL::M HOL::HTA)
                 (EQUAL (HP-TYPE HOL::M) (TYP :NUM))
                 (FORCE (HOL::EVAL-POLY$PROP)))
            (EQUAL (HAP* (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                         HOL::M (HP-NUM 0))
                   (HP-NUM 1))))
 (DEFTHM HOL::HOL{EXP}1
   (IMPLIES (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                                HOL::HTA)
                 (HPP HOL::M HOL::HTA)
                 (EQUAL (HP-TYPE HOL::M) (TYP :NUM))
                 (HPP HOL::N HOL::HTA)
                 (EQUAL (HP-TYPE HOL::N) (TYP :NUM))
                 (FORCE (HOL::EVAL-POLY$PROP)))
            (EQUAL (HAP* (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                         HOL::M
                         (HAP* (HOL::SUC (TYP (:ARROW* :NUM :NUM)))
                               HOL::N))
                   (HP* HOL::M
                        (HAP* (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                              HOL::M HOL::N)))))
 (DEFTHM HOL::HOL{POLYP}0
   (IMPLIES (FORCE (HOL::EVAL-POLY$PROP))
            (EQUAL (HAP* (HOL::POLYP (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                   :BOOL)))
                         (HP-NIL (TYP (:HASH :NUM :NUM))))
                   (HP-TRUE))))
 (DEFTHM HOL::HOL{POLYP}1
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                       HOL::HTA)
        (HPP HOL::R HOL::HTA)
        (EQUAL (HP-TYPE HOL::R)
               (TYP (:LIST (:HASH :NUM :NUM))))
        (HPP HOL::E HOL::HTA)
        (EQUAL (HP-TYPE HOL::E) (TYP :NUM))
        (HPP HOL::C HOL::HTA)
        (EQUAL (HP-TYPE HOL::C) (TYP :NUM))
        (FORCE (HOL::EVAL-POLY$PROP)))
   (EQUAL
    (HAP* (HOL::POLYP (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                    :BOOL)))
          (HP-CONS (HP-COMMA HOL::C HOL::E)
                   HOL::R))
    (HP-AND
     (HAP* (HOL::POLYP (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                     :BOOL)))
           HOL::R)
     (HP-AND
      (HP-NOT (HP= HOL::C (HP-NUM 0)))
      (HP-AND
       (HAP* (HOL::<= (TYP (:ARROW* :NUM :NUM :BOOL)))
             (HP-NUM 0)
             HOL::E)
       (HP-OR
            (HAP* (HOL::NULL (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                           :BOOL)))
                  HOL::R)
            (HP< (HAP* (HOL::SND (TYP (:ARROW* (:HASH :NUM :NUM) :NUM)))
                       (HAP* (HOL::HD (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                    (:HASH :NUM :NUM))))
                             HOL::R))
                 HOL::E))))))))
 (DEFTHM HOL::HOL{EVAL_POLY}0
   (IMPLIES
        (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                            HOL::HTA)
             (HPP HOL::V HOL::HTA)
             (EQUAL (HP-TYPE HOL::V) (TYP :NUM))
             (FORCE (HOL::EVAL-POLY$PROP)))
        (EQUAL (HAP* (HOL::EVAL_POLY (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                   :NUM :NUM)))
                     (HP-NIL (TYP (:HASH :NUM :NUM)))
                     HOL::V)
               (HP-NUM 0))))
 (DEFTHM HOL::HOL{EVAL_POLY}1
  (IMPLIES
    (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                        HOL::HTA)
         (HPP HOL::V HOL::HTA)
         (EQUAL (HP-TYPE HOL::V) (TYP :NUM))
         (HPP HOL::R HOL::HTA)
         (EQUAL (HP-TYPE HOL::R)
                (TYP (:LIST (:HASH :NUM :NUM))))
         (HPP HOL::E HOL::HTA)
         (EQUAL (HP-TYPE HOL::E) (TYP :NUM))
         (HPP HOL::C HOL::HTA)
         (EQUAL (HP-TYPE HOL::C) (TYP :NUM))
         (FORCE (HOL::EVAL-POLY$PROP)))
    (EQUAL (HAP* (HOL::EVAL_POLY (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                               :NUM :NUM)))
                 (HP-CONS (HP-COMMA HOL::C HOL::E)
                          HOL::R)
                 HOL::V)
           (HP+ (HP* HOL::C
                     (HAP* (HOL::EXP (TYP (:ARROW* :NUM :NUM :NUM)))
                           HOL::V HOL::E))
                (HAP* (HOL::EVAL_POLY (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                    :NUM :NUM)))
                      HOL::R HOL::V)))))
 (DEFTHM HOL::HOL{SUM_POLYS}0
  (IMPLIES
      (FORCE (HOL::EVAL-POLY$PROP))
      (EQUAL (HAP* (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM)))))
                   (HP-NIL (TYP (:HASH :NUM :NUM)))
                   (HP-NIL (TYP (:HASH :NUM :NUM))))
             (HP-NIL (TYP (:HASH :NUM :NUM))))))
 (DEFTHM HOL::HOL{SUM_POLYS}1
  (IMPLIES
      (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                          HOL::HTA)
           (HPP HOL::V7 HOL::HTA)
           (EQUAL (HP-TYPE HOL::V7)
                  (TYP (:LIST (:HASH :NUM :NUM))))
           (HPP HOL::V6 HOL::HTA)
           (EQUAL (HP-TYPE HOL::V6)
                  (TYP (:HASH :NUM :NUM)))
           (FORCE (HOL::EVAL-POLY$PROP)))
      (EQUAL (HAP* (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM)))))
                   (HP-NIL (TYP (:HASH :NUM :NUM)))
                   (HP-CONS HOL::V6 HOL::V7))
             (HP-CONS HOL::V6 HOL::V7))))
 (DEFTHM HOL::HOL{SUM_POLYS}2
  (IMPLIES
      (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                          HOL::HTA)
           (HPP HOL::V3 HOL::HTA)
           (EQUAL (HP-TYPE HOL::V3)
                  (TYP (:LIST (:HASH :NUM :NUM))))
           (HPP HOL::V2 HOL::HTA)
           (EQUAL (HP-TYPE HOL::V2)
                  (TYP (:HASH :NUM :NUM)))
           (FORCE (HOL::EVAL-POLY$PROP)))
      (EQUAL (HAP* (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM)))))
                   (HP-CONS HOL::V2 HOL::V3)
                   (HP-NIL (TYP (:HASH :NUM :NUM))))
             (HP-CONS HOL::V2 HOL::V3))))
 (DEFTHM HOL::HOL{SUM_POLYS}3
  (IMPLIES
   (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                       HOL::HTA)
        (HPP HOL::R2 HOL::HTA)
        (EQUAL (HP-TYPE HOL::R2)
               (TYP (:LIST (:HASH :NUM :NUM))))
        (HPP HOL::R1 HOL::HTA)
        (EQUAL (HP-TYPE HOL::R1)
               (TYP (:LIST (:HASH :NUM :NUM))))
        (HPP HOL::E2 HOL::HTA)
        (EQUAL (HP-TYPE HOL::E2) (TYP :NUM))
        (HPP HOL::E1 HOL::HTA)
        (EQUAL (HP-TYPE HOL::E1) (TYP :NUM))
        (HPP HOL::C2 HOL::HTA)
        (EQUAL (HP-TYPE HOL::C2) (TYP :NUM))
        (HPP HOL::C1 HOL::HTA)
        (EQUAL (HP-TYPE HOL::C1) (TYP :NUM))
        (FORCE (HOL::EVAL-POLY$PROP)))
   (EQUAL
    (HAP* (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                        (:LIST (:HASH :NUM :NUM))
                                        (:LIST (:HASH :NUM :NUM)))))
          (HP-CONS (HP-COMMA HOL::C1 HOL::E1)
                   HOL::R1)
          (HP-CONS (HP-COMMA HOL::C2 HOL::E2)
                   HOL::R2))
    (HAP*
     (HOL::COND (TYP (:ARROW* :BOOL (:LIST (:HASH :NUM :NUM))
                              (:LIST (:HASH :NUM :NUM))
                              (:LIST (:HASH :NUM :NUM)))))
     (HP= HOL::E1 HOL::E2)
     (HP-CONS
          (HP-COMMA (HP+ HOL::C1 HOL::C2) HOL::E1)
          (HAP* (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                              (:LIST (:HASH :NUM :NUM))
                                              (:LIST (:HASH :NUM :NUM)))))
                HOL::R1 HOL::R2))
     (HAP*
        (HOL::COND (TYP (:ARROW* :BOOL (:LIST (:HASH :NUM :NUM))
                                 (:LIST (:HASH :NUM :NUM))
                                 (:LIST (:HASH :NUM :NUM)))))
        (HP< HOL::E1 HOL::E2)
        (HP-CONS
             (HP-COMMA HOL::C2 HOL::E2)
             (HAP* (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM)))))
                   (HP-CONS (HP-COMMA HOL::C1 HOL::E1)
                            HOL::R1)
                   HOL::R2))
        (HP-CONS
             (HP-COMMA HOL::C1 HOL::E1)
             (HAP* (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM)))))
                   HOL::R1
                   (HP-CONS (HP-COMMA HOL::C2 HOL::E2)
                            HOL::R2))))))))

; The final group of events says that :NUM and :BOOL are defined types in HOL
; type-alist (hta) introduced for the EVAL-POLY theory, and then disables the
; definition and executable-counterpart for that hta (i.e., for the zero-ary
; function, HOL::EVAL-POLY$HTA).

 (DEFTHM HOL::HONS-ASSOC-EQUAL-NUM-EVAL-POLY$HTA
   (HONS-ASSOC-EQUAL :NUM (HOL::EVAL-POLY$HTA)))
 (DEFTHM HOL::HONS-ASSOC-EQUAL-BOOL-EVAL-POLY$HTA
   (HONS-ASSOC-EQUAL :BOOL (HOL::EVAL-POLY$HTA)))
 (IN-THEORY (DISABLE HOL::EVAL-POLY$HTA
                     (:E HOL::EVAL-POLY$HTA))))

; Finally, here is the goal.  It may be seen at the end of the output generated
; by the following commands.

; (include-book "eval-poly-thy")
; (include-book "../acl2/hol-theory-print")
; (in-package "ZF")
; (hol-theory-print acl2::*standard-co* acl2::state)

#|
(DEFTHM HOL::HOL{EVAL_SUM_POLY_DISTRIB}
 (IMPLIES
  (AND (ALIST-SUBSETP (HOL::EVAL-POLY$HTA)
                      HOL::HTA)
       (HPP HOL::X HOL::HTA)
       (EQUAL (HP-TYPE HOL::X)
              (TYP (:LIST (:HASH :NUM :NUM))))
       (HPP HOL::Y HOL::HTA)
       (EQUAL (HP-TYPE HOL::Y)
              (TYP (:LIST (:HASH :NUM :NUM))))
       (HPP HOL::V HOL::HTA)
       (EQUAL (HP-TYPE HOL::V) (TYP :NUM))
       (FORCE (HOL::EVAL-POLY$PROP)))
  (EQUAL
   (HP-IMPLIES
    (HP-AND (HAP* (HOL::POLYP (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                            :BOOL)))
                  HOL::X)
            (HAP* (HOL::POLYP (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                            :BOOL)))
                  HOL::Y))
    (HP=
       (HAP* (HOL::EVAL_POLY (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                           :NUM :NUM)))
             (HAP* (HOL::SUM_POLYS (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM))
                                                 (:LIST (:HASH :NUM :NUM)))))
                   HOL::X HOL::Y)
             HOL::V)
       (HP+ (HAP* (HOL::EVAL_POLY (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                :NUM :NUM)))
                  HOL::X HOL::V)
            (HAP* (HOL::EVAL_POLY (TYP (:ARROW* (:LIST (:HASH :NUM :NUM))
                                                :NUM :NUM)))
                  HOL::Y HOL::V))))
   (HP-TRUE))))
|#
