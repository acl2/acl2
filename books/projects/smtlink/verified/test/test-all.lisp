(in-package "SMT")
(include-book "../expand-cp")
(include-book "../type-inference")
(include-book "../reorder-hypotheses")
(include-book "../term-replacement")
(include-book "../type-extract")
(ld "test-smtlink-hint.lisp")

(define test ((cl pseudo-term-listp)
              (hints smtlink-hint-p)
              state)
  :verify-guards nil
  (b* ((cl (pseudo-term-list-fix cl))
       (hints (smtlink-hint-fix hints))
       ((mv & expanded-term state) (expand-cp cl hints state))
       (- (cw "after expand-cp: ~q0" (cdar expanded-term)))
       (reordered-term
        (reorder-hypotheses-cp (cdar expanded-term) hints))
       (- (cw "after reorder-hypotheses-cp: ~q0" (cdar reordered-term)))
       ((mv & typed-goal-1 state)
        (type-judge-bottomup-cp (cdar reordered-term) hints state))
       (- (cw "after bottomup: ~q0" (cdar typed-goal-1)))
       ((mv & typed-goal-2 state)
        (type-judge-topdown-cp (cdar typed-goal-1) hints state))
       (- (cw "after topdown: ~q0" (cdar typed-goal-2)))
       ((mv & term-after-replacement state)
        (term-replacement-cp (cdar typed-goal-2) hints state))
       (- (cw "after term-replacement-cp: ~q0" (cdar term-after-replacement)))
       (term-after-extract
        (type-extract-cp (cdar term-after-replacement) hints))
       (- (cw "after type-extract-cp: ~q0" (cdar term-after-extract)))
       (final (cadr term-after-extract)))
  (value final)))

;; (defun term1 ()
;;   '(if (if (integerp x)
;;            (rationalp y)
;;          'nil)
;;        (not (< (binary-+ (binary-* x y) (binary-* x y))
;;                (binary-* '2 (binary-* x y))))
;;      't)
;;   )

;; (test (list (term1)) (my-hint) state)

;; (defun term2 ()
;;   '(if (if (integerp x)
;;            (rationalp y)
;;          'nil)
;;        (< (foo x y) '0)
;;      't)
;;   )

;; (test (list (term2)) (my-hint) state)

;; (defun term3 ()
;;   '(if (if (integerp x)
;;            (rationalp y)
;;          'nil)
;;        (< ((lambda (a b) (binary-+ a b)) x y) '0)
;;      't))

;; (test (list (term3)) (my-hint) state)

;; (defun term4 ()
;;   '(if (if (< x y)
;;            (if (integerp x)
;;                (rationalp y)
;;              'nil)
;;          'nil)
;;        (< (foo x y) '0)
;;      't)
;;   )

;; (test (list (term4)) (my-hint) state)

(defun term5 ()
  '(if (if (integerp x)
           (rationalp y)
         'nil)
       (not (< (binary-+ (binary-* (ifix x) y) (binary-* x y))
               (binary-* '2 (binary-* x (rfix y)))))
     't))

(test (list (term5)) (my-hint) state)
