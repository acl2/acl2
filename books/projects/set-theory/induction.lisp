; Copyright (C) 2025, Matt Kaufmann
; Written by Matt Kaufmann
; License: A 3-clause BSD license.  See the LICENSE file distributed with ACL2.

; This book provides a macro, prove-inductive-suffices, for proving that if if
; a predicate P is inductive then it holds of all sets.  Here, "P is inductive"
; means that whenever P holds for all elements of a set, P holds for that set.

(in-package "ZF")

(include-book "tc")

(local (include-book "induction-support"))

(defstub in-pred (x) t)

(defun-sk in-pred-holds-below (s)
  (forall x
    (implies (in x s)
             (in-pred x))))

(defun-sk in-pred-is-inductive ()
  (forall s
    (implies (in-pred-holds-below s)
             (in-pred s))))

; {x \in s: ~p(x)} where p is in-pred
; Introduces in-pred-complement$prop.
(zsub in-pred-complement (s)
      x                 ; x
      s                 ; s (see comment above)
      (not (in-pred x)) ; u
      )

(defthmz in-pred-holds-when-inductive
  (implies (in-pred-is-inductive)
           (in-pred s))
  :hints (("Goal" :use (in-pred-holds-when-inductive-2
                        in-pred-holds-when-inductive-3)))
  :props (zfc in-pred-complement$prop inverse$prop prod2$prop domain$prop
              tc-fn$prop))

(defun prove-inductive-suffices-fn (pred params)
  (declare (xargs :guard (and (symbolp pred)
                              (symbol-listp params)
                              (not (member-eq 's params)))))
  (let ((pred-holds-when-inductive
         (add-suffix pred "-HOLDS-WHEN-INDUCTIVE"))
        (pred-holds-below
         (add-suffix pred "-HOLDS-BELOW"))
        (pred-holds-below-witness
         (add-suffix pred "-HOLDS-BELOW-WITNESS"))
        (pred-holds-below-necc
         (add-suffix pred "-HOLDS-BELOW-NECC"))
        (pred-is-inductive
         (add-suffix pred "-IS-INDUCTIVE"))
        (pred-is-inductive-witness
         (add-suffix pred "-IS-INDUCTIVE-WITNESS"))
        (pred-is-inductive-necc
         (add-suffix pred "-IS-INDUCTIVE-NECC"))
        (pred-complement
         (add-suffix pred "-COMPLEMENT"))
        (pred-complement$prop
         (add-suffix pred "-COMPLEMENT$PROP"))
        (pred-complement$comprehension
         (add-suffix pred "-COMPLEMENT$COMPREHENSION")))
    `(progn
       (defun-sk ,pred-holds-below (s ,@params)
         (forall x
           (implies (in x s)
                    (,pred x ,@params))))

       (defun-sk ,pred-is-inductive ,params
         (forall s
           (implies (,pred-holds-below s ,@params)
                    (,pred s ,@params))))

       (zsub ,pred-complement (s ,@params) x s (not (,pred x ,@params)))

       (defthmz ,pred-holds-when-inductive
         (implies (,pred-is-inductive ,@params)
                  (,pred s ,@params))
         :hints (("Goal"
                  :in-theory (union-theories
                              '((:t ,pred-is-inductive)
                                (:t ,pred-holds-below))
                              (theory 'minimal-theory))
                  :by (:functional-instance
                       in-pred-holds-when-inductive
                       (in-pred
                        (lambda (s) (,pred s ,@params)))
                       (in-pred-holds-below
                        (lambda (s)
                          (,pred-holds-below s ,@params)))
                       (in-pred-holds-below-witness
                        (lambda (s)
                          (,pred-holds-below-witness s ,@params)))
                       (in-pred-is-inductive
                        (lambda ()
                          (,pred-is-inductive ,@params)))
                       (in-pred-is-inductive-witness
                        (lambda ()
                          (,pred-is-inductive-witness ,@params)))
                       (in-pred-complement
                        (lambda (s)
                          (,pred-complement s ,@params)))
                       (in-pred-complement$prop ,pred-complement$prop)))

; It would be nice to give a :by and :use hint together, where the :use hint is
; applied to the conjunction of the goals generated by the :by hint.  Since
; that is not allowed (at least, not as of this writing), we supply a :use hint
; that should suffice for each of the generated subgoals.

                 '(:use
                   (,pred-holds-below
                    ,pred-holds-below-necc
                    ,pred-is-inductive
                    ,pred-is-inductive-necc
                    ,pred-complement$comprehension)))
         :props (zfc ,pred-complement$prop inverse$prop prod2$prop domain$prop
                     tc-fn$prop)))))

(defmacro prove-inductive-suffices (pred &optional params)
  (declare (xargs :guard (symbolp pred)))
  (prove-inductive-suffices-fn pred params))

; A test without parameters:
(local
 (encapsulate
   ()
   (defstub in-pred2 (x) t)
   (prove-inductive-suffices in-pred2)
   (set-enforce-redundancy t)
   (DEFTHMZ IN-PRED2-HOLDS-WHEN-INDUCTIVE
     (IMPLIES (IN-PRED2-IS-INDUCTIVE)
              (IN-PRED2 S))
     :PROPS (ZFC IN-PRED2-COMPLEMENT$PROP INVERSE$PROP
                 PROD2$PROP DOMAIN$PROP TC-FN$PROP))))

; A test with parameters:
(local
 (encapsulate
   ()
   (defstub in-pred3 (x a b) t)
   (prove-inductive-suffices in-pred3 (a b))
   (set-enforce-redundancy t)
   (DEFTHMZ IN-PRED3-HOLDS-WHEN-INDUCTIVE
     (IMPLIES (IN-PRED3-IS-INDUCTIVE A B)
              (IN-PRED3 S A B))
     :PROPS (ZFC IN-PRED3-COMPLEMENT$PROP INVERSE$PROP
                 PROD2$PROP DOMAIN$PROP TC-FN$PROP))))
