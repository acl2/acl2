Lisp translation of C++ common expressions
==========================================

General
=======
  The tanslation of a RAC is done in three steps:

    * preprocess: it is done by G++ and it is the same as C or C++ but the
      comments needs to be kept in order to keep the guards (RAC begin/end).

    * C++ parser: parse the preprocess file and output a partially translated
      AST. Implemented under src/.

    * lisp/translate.lisp: Take the S-Statements generated by the parser and
      finises the translation.

  All those step are performed by the RAC script, which is generated from
  src/rac-skel.

C++ parser
==========

Here the global process of the parse:

* First an AST (defined in program/parser/ast) is generated from the file using
  flex and bison (implemented in program/parser).

* Then, the AST is modified (for example, expressions are typed) and semantic
  checks are performed using the vistor design pattern (all are implemented in
  program/process).

* And last, the program is display as S-expressions by using the ACL2Expr
  methods defined in the AST. This will be moved to its own pass later.

AST
---

All the nodes have a NodesID used for the visitor dispatch. If you add a new
AST node you should always update astnodes.def and visitor.h/hxx

To avoid repetitive code, x-macros (see astnodes.def) are used to generate code
for the operators (operator.def define the C++ symbol and their enumeration
names), types (types.def containts the hierarchy) and ASTNodes (astnodes.def
same as types.def).

They are two types of nodes: statement and expression. The expressions are
always pure (they don't have side effects) and have an associated type. The
statements are everything else (control flow, variable and function
declaration, ...). A SimpleStatement is a statement that does not include
substatements.

Here a quick overview of the AST nodes hierarchy (Expression and Statement are
disjointed):
```
Expression                        Statement
  |                                 |
  +--Constant                       +--SimpleStatement
  |   |                             |    |
  |   +--Integer                    |    +--SymDec
  |   +--Boolean                    |    |    |
  |                                 |    |    +--EnumConstDec
  +--Parenthesis                    |    |    +--VarDec
  +--SymRef                         |    |    +--ConstDec
  +--FunCall                        |    |    +--TempParamDec
  |    |                            |    |
  |    +--TempCall                  |    +--MulVarDec
  |                                 |    +--MulConstDec
  +--Initializer                    |    +--BreakStmt
  +--ArrayRef                       |    +--ReturnStmt
  +--StructRef                      |    +--NullStmt
  +--Subrange                       |    +--Assertion
  +--PrefixExpr                     |    +--Assignment
  +--CastExpr                       |    +--MultipleAssignment
  +--BinaryExpr                     |
  +--CondExpr                       +--Block
  +--MultipleValue                  +--IfStmt
                                    +--ForStmt
                                    +--CaseSwitchStmt
                                    +--FunDef
                                         |
                                         +--Builtin
                                         +--Template
```

Parser
------
  flex/bison
  TODO C++ mode

Process
-------

Appart from basic parsing (done by bison) and some very specific work, most of
the translation and checks should be implemented in separate passes using the
vistor provided (program/process/process/visitor.h).

To create to new pass, you should look at visitor.h and astdumper.h/cpp. They
should be enough to understand how to use it. You can also look at clang's
documentation about their RecursiveASTVisitor wich was used as example to
create visitor.h.

Instead of returning `false` when you detected an error, you should use the
error() function provided in returnfalse.h (this is how error bypass works).

When modifying the AST, you MUST update the visitor traversal in visitor.hxx
and program/parser/ast/astnodes.def. Be carefull to not add loops or multiple
pass on the same nodes. Also, check if the leafs are still leafs, it changes
the traversal.

For now, those pass are applied (in this order):

* TypingAction
* (only in pedantic mode) RACConstraint
* (only in pedantic mode) ForConstraints
* MarkAssertionAction

Utils
-----

To report errors in the parser or in a pass, you should use DiagnosticHandler,
see program/parser/utils/diagnostics.h for more details.

Also, program/parser/utils/utils.h contains some usefull functions. format()
should be replace the standard's one when switching to C++20. NEVER use List<>
in any case, it is only their because all the code has not been refactore yet.

Tips for test and debug
--------------

To know how to run the regression test, see tests/README.md. Even if thoose
tests should covered most parts of the parse, it a good idea to test the
translations on some real life models (like the ones in examples). Every new
feature/bug discovered must be covered by a test. If a bug is discovered but no
fix are implemented, it should still be a test covering it with the "bug" flag
set in the yaml.

By default, the parser will be compile in release mode (with all optimisation
and without the debuging symbols), to debug use 'make debug'.

For more in depth debuging, the -dump-ast is really usefull to understand
what's happening. For now, it only display the name of the nodes and the
expression's types. Fell free to add more information if needed. To debug the
bisno parser, you can use -trace-parser. For more details, see bison
documentation.

Also, the diagnostics (program/parser/utils/diagnostics.h) can be really
usefull to know which parts of the input code cause a bug.

Version
-------

The version is generated from the ACL2 version (grep from the README) and the
commit hash. If build outside of a git repository, we only keep the ACL2
version (anyway it should be from a relase). If something fails, the header
should be still generated with an "unknown version". If you did not run make,
version.h does not exist, it is normal if your editor reports an error.

TODOs
=====

* switch bison parser to C++ mode
* continue to refactore
* lift for restriction
* c++20 format
* generate a list of type usable in Lisp
* track location of types (deref typedef)
* display "true" C++ type
* better error message when the type is a typedef.
