; AleoVM Library
;
; Copyright (C) 2025 Provable Inc.
;
; License: See the LICENSE file distributed with this library.
;
; Authors: Alessandro Coglio (www.alessandrocoglio.info)
;          Eric McCarthy (bendyarm on GitHub)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "ALEOVM")

(include-book "boolean-check")
(include-book "pow2sum-vectors")

(local (include-book "../library-extensions/arithmetic"))
(local (include-book "../library-extensions/digits"))
(local (include-book "../library-extensions/r1cses"))

(local (include-book "kestrel/arithmetic-light/expt" :dir :system))
(local (include-book "kestrel/arithmetic-light/mod" :dir :system))
(local (include-book "kestrel/prime-fields/prime-fields-rules" :dir :system))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The unsigned subtraction gadgets generated by snarkVM
; include a linear combination that is slightly more complex than expected:
; this is explained in unsigned-small-sub.lisp.
; It is easier to verify the subtraction gadget
; using a version of the gadget with a simpler linear combination,
; and then show it equivalent to the snarkVM gadget version,
; so that the theorems proved for the simpler version transfer easily.

; Here we define the simpler, optimized gadget.
; (In this case the optimization makes the gadget simpler,
; rather than more complicated.)
; This gadget is similar to unsigned-small-add,
; but there is an extra 2^n monomial in the linear combination,
; and the vector for ys is negated.
; Thus, this gadget computes (xs - ys) + 2^n instead of xs + ys.

; In this gadget, 'small' has the same meaning explained
; in the file that defines unsigned-small-add.

(define unsigned-small-sub-opt-vector ((xs symbol-listp)
                                       (ys symbol-listp)
                                       (p primep))
  :guard (equal (len ys) (len xs))
  :returns (vec r1cs::sparse-vectorp :hyp :guard)
  (append (pow2sum-vector xs 0)
          (list (list (expt 2 (len xs)) 1))
          (pow2sum-neg-prime-vector ys 0 p)))

(define unsigned-small-sub-opt-gadget ((xs symbol-listp)
                                       (ys symbol-listp)
                                       (zs symbol-listp)
                                       (p primep))
  :guard (and (equal (len ys) (len xs))
              (equal (len zs) (1+ (len xs)))
              (< (1+ (len xs)) (integer-length p)))
  :returns (constrs r1cs::r1cs-constraint-listp :hyp :guard)
  (append (boolean-check-gadget-list zs p)
          (list (r1cs::make-r1cs-constraint
                 :a (unsigned-small-sub-opt-vector xs ys p)
                 :b (list (list 1 1))
                 :c (pow2sum-vector zs 0)))))

; The correctness (soundness and completeness) theorem below
; is proved similarly to unsigned-small-add,
; but the lemma needs to be modified slightly, in a way that should be obvious.
; We also find that we need to disable a rule about expt,
; otherwise the proof fails.

(defruled unsigned-small-sub-opt-gadget-correct
  (implies (and (primep p)
                (< (1+ (len xs)) (integer-length p))
                (symbol-listp xs)
                (symbol-listp ys)
                (symbol-listp zs)
                (equal (len ys) (len xs))
                (equal (len zs) (1+ (len xs)))
                (r1cs::r1cs-valuationp asg p)
                (r1cs::valuation-binds-allp asg xs)
                (r1cs::valuation-binds-allp asg ys)
                (r1cs::valuation-binds-allp asg zs))
           (b* ((xs$ (lookup-equal-list xs asg))
                (ys$ (lookup-equal-list ys asg))
                (zs$ (lookup-equal-list zs asg)))
             (implies (and (bit-listp xs$)
                           (bit-listp ys$))
                      (equal (r1cs::r1cs-constraints-holdp
                              (unsigned-small-sub-opt-gadget xs ys zs p)
                              asg
                              p)
                             (and (bit-listp zs$)
                                  (equal (lebits=>nat zs$)
                                         (+ (- (lebits=>nat xs$)
                                               (lebits=>nat ys$))
                                            (expt 2 (len xs)))))))))
  :do-not-induct t
  :use ((:instance diff-offset-expt2-upper-bound
                   (n (len xs))
                   (a (lebits=>nat (lookup-equal-list xs asg)))
                   (b (lebits=>nat (lookup-equal-list ys asg))))
        (:instance expt2-mono
                   (a (len zs))
                   (b (1- (integer-length p)))))
  :enable (unsigned-small-sub-opt-gadget
           unsigned-small-sub-opt-vector
           boolean-check-gadget-list-to-bit-listp
           r1cs::r1cs-constraint-holdsp
           pow2sum-vector-to-mod-of-lebits=>nat
           pow2sum-neg-prime-vector-to-mod-of-lebits=>nat
           r1cs::dot-product-of-append
           r1cs::dot-product
           pfield::add
           lebits=>nat-less-when-len-less
           positive->=-expt2-of-integer-length-minus-1)
  :disable acl2::<-of-expt-and-expt-same-base)
