; SV - Symbolic Vector Hardware Analysis Framework
; Copyright (C) 2014-2015 Centaur Technology
;
; Contact:
;   Centaur Technology Formal Verification Group
;   7600-C N. Capital of Texas Highway, Suite 300, Austin, TX 78731, USA.
;   http://www.centtech.com/
;
; License: (An MIT/X11-style license)
;
;   Permission is hereby granted, free of charge, to any person obtaining a
;   copy of this software and associated documentation files (the "Software"),
;   to deal in the Software without restriction, including without limitation
;   the rights to use, copy, modify, merge, publish, distribute, sublicense,
;   and/or sell copies of the Software, and to permit persons to whom the
;   Software is furnished to do so, subject to the following conditions:
;
;   The above copyright notice and this permission notice shall be included in
;   all copies or substantial portions of the Software.
;
;   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;   DEALINGS IN THE SOFTWARE.
;
; Original authors: Sol Swords <sswords@centtech.com>

(in-package "SV")

;; (include-book "debug")
(include-book "eval-phases")
(include-book "probe")
(include-book "fsm-obj")
(include-book "../svex/rewrite")
(include-book "../mods/moddb")
(include-book "../mods/path-string")
(include-book "std/strings/hexify" :dir :system)
(include-book "expand")
(include-book "../svex/env-ops")
(include-book "../svex/override-types")
(include-book "centaur/misc/hons-extra" :Dir :system)
(local (in-theory (disable (tau-system))))

;; (include-book "std/stobjs/updater-independence" :dir :system)
;; This tool operates from an initialized DEBUGDATA stobj, as generated by
;; svtv-debug-core, or (without dumping a vcd) by svtv-debug-init followed by
;; svtv-debug-set-svtv.

;; It takes an input alist and expands it to an environment for each phase and
;; initial state so that we can evaluate a signal at a given phase.

;; Then we start from some given signal (an output/internal name or path and
;; phase).  We can evaluate that signal using svex-eval-svtv-phases.


(defprod chase-position
  ((path path-p)
   ;; Integerp largely because it's occasionally convenient to have a phase of -1 to denote initial states.
   (phase integerp :rule-classes :type-prescription)
   (rsh natp :rule-classes :type-prescription)
   (mask 4vmask-p)))


(deflist chase-stack :elt-type chase-position :true-listp t)



(local (defun svtv-chase-data-renaming (field-names)
         (b* (((when (atom field-names)) nil)
              (field (car field-names))
              (new-field (intern$ (cat "SVTV-CHASE-DATA->" (symbol-name field)) "SV"))
              (update (intern$ (cat "UPDATE-" (symbol-name field)) "SV"))
              (new-update (intern$ (cat "SET-SVTV-CHASE-DATA->" (symbol-name field)) "SV"))
              (pred (intern$ (cat (symbol-name field) "P") "SV"))
              (new-pred (intern$ (cat "SVTV-CHASE-DATA->" (symbol-name field) "P") "SV")))
           (cons (list field new-field)
                 (cons (list update new-update)
                       (cons (list pred new-pred)
                             (svtv-chase-data-renaming (cdr field-names))))))))

(fty::defoption maybe-svtv-evaldata svtv-evaldata-p)



(make-event
 (b* ((fields
       `((stack :type (satisfies chase-stack-p) :initially nil)
         (sigtype :type symbol)
         (vars :type (satisfies 4vmask-alist-p))
         (expr :type (satisfies svex-p) :initially ,(svex-x))
         ;; (new-phase :type (integer 0 *) :initially 0)
         (evaldata :type (satisfies svtv-evaldata-p) :initially ,(make-svtv-evaldata))
         (evaldata2 :type (satisfies maybe-svtv-evaldata-p) :initially nil)
         (data2-offset :type integer :initially 0)
         (smartp :initially t)
         (phaselabels :type (satisfies symbol-listp))
         (updates :type (satisfies svex-alist-p))
         (delays :type (satisfies svex-alist-p))
         (assigns :type (satisfies svex-alist-p))
         (override-alist :type (satisfies svex-alist-p))
         (modidx :type (integer 0 *) :initially 0)
         (probes :type (satisfies svtv-probealist-p))
         (namemap :type (satisfies svtv-name-lhs-map-p))
         (print-with-mask-mode :type symbol :initially :default)
         (print-overrides-mode :type symbol :initially nil)))
      (field-names (strip-cars fields))
      (renaming (svtv-chase-data-renaming field-names))
      ;; (fns (append '(debugdatap create-debugdata)
      ;;              (acl2::strip-cadrs renaming)))
      (make-binder (std::da-make-binder 'svtv-chase-data field-names)))
   
   `(progn
      (defstobj svtv-chase-data
        ,@fields
        :renaming ,renaming)
      (in-theory (disable create-svtv-chase-data svtv-chase-datap))
      ,make-binder)))





;; There are basically three types of signals/svex variables used here:
;;  - If V is a key of nextstates/delays, then it is a previous state signal.
;;  - If V is a key of updates/assigns, then it is an internal signal.
;;  - If V appears in an expression (value) of updates or nextstates but is not
;;  a key of either one, then it is a primary input.

;;    A previous state signal cannot also be an internal signal (a key of
;;    nextstates cannot also be a key of updates).  But each V that is a
;;    previous state/key of updates is also a key of delays, and the
;;    corresponding value in delays is an internal signal or primary input that
;;    is also the nextstate of V.

;; The keys of nextstates should be the same as those of delays.  The keys of
;; updates should be the same as those of assigns.


;; We want to support exploring the design by walking through following
;; dependencies back to drivers. Generally we'll have a stack starting from
;; some signal and going back though its drivers (across phases).

;; The current position will be tracked as a variable, phase, right-shift, and
;; mask.  The mask is relative to the right-shift, so the caremask for the
;; whole variable is mask << right-shift.

;; We'll find dependencies of a variable modulo the caremask, and the resulting
;; dependency variables will be reported along with their caremasks.
;; Internally we'll use right-shifts and masks, but when we print things out to
;; the user we'll want to translate back to relative indices.  E.g. if a
;; variable is declared as x[10:2] and we have a rightshift of 3 and mask
;; #b101, we'll show the range as x[7:5].


(define svtv-chase-normalize-var/phase ((var svar-p)
                                        (phase integerp))
  :returns (mv (new-var svar-p)
               (new-phase natp :rule-classes :type-prescription))
  (b* (((svar var))
       (eff-delay (min var.delay (lifix phase)))
       (new-delay (- var.delay eff-delay)))
    (mv (change-svar var :delay new-delay) (- (lifix phase) eff-delay)))
  ///
  ;; (defret svar-addr-p-of-<fn>
  ;;   (implies (svar-addr-p var)
  ;;            (svar-addr-p new-var))
  ;;   :hints(("Goal" :in-theory (enable svar-addr-p))))
  )

(define svtv-chase-eval-override ((var svar-p)
                                  (phase integerp)
                                  (evaldata svtv-evaldata-p)
                                  &key
                                  (svtv-chase-data 'svtv-chase-data))
  :returns (mv (override-mask integerp)
               (override-val 4vec-p)
               (computed-val 4vec-p))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  (b* (((mv var phase) (svtv-chase-normalize-var/phase var phase))
       ((svtv-chase-data svtv-chase-data))
       ((svtv-evaldata evaldata))
       ((when (< 0 (svar->delay var)))
        (b* ((val (svex-env-lookup var evaldata.initst)))
          (mv 0 0 val)))
       (override-mux (svex-fastlookup var svtv-chase-data.override-alist))
       (computed-expr (svex-compose (svex-var var) svtv-chase-data.updates))
       (computed-val (svex-eval-svtv-phases computed-expr phase evaldata))
       ((unless override-mux)
        (mv 0 0 computed-val))
       (override-test-expr (svex-var (svar-change-override var :test)))
       (override-val-expr (svex-var (svar-change-override var :val))))
    (mv (4vec-1mask (svex-eval-svtv-phases override-test-expr phase evaldata))
        (svex-eval-svtv-phases override-val-expr phase evaldata)
        computed-val)))
  
(define svtv-chase-eval ((var svar-p)
                         (phase integerp)
                         (evaldata svtv-evaldata-p)
                         &key
                         (svtv-chase-data 'svtv-chase-data))
  :returns (val 4vec-p)
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  (b* (((mv var phase) (svtv-chase-normalize-var/phase var phase))
       ((svtv-chase-data svtv-chase-data))
       ((svtv-evaldata evaldata))
       ((when (< 0 (svar->delay var)))
        (svex-env-lookup var evaldata.initst))
       (override-mux (svex-fastlookup var svtv-chase-data.override-alist))
       (overridden-val (svex-compose (or override-mux (svex-var var)) svtv-chase-data.updates)))
    (svex-eval-svtv-phases overridden-val phase evaldata)))


(define svtv-chase-evallist ((vars svarlist-p)
                             (phase integerp)
                             (evaldata svtv-evaldata-p)
                             &key
                             (svtv-chase-data 'svtv-chase-data))
  :returns (vals 4veclist-p)
  (if (atom vars)
      nil
    (cons (svtv-chase-eval (car vars) phase evaldata)
          (svtv-chase-evallist (cdr vars) phase evaldata)))
  ///
  (defret len-of-<fn>
    (equal (len vals) (len vars))))
       


(define svex-mask-alist-to-4vmask-alist ((x svex-mask-alist-p))
  :returns (new-x 4vmask-alist-p)
  (if (atom x)
      nil
    (if (and (mbt (and (consp (car x)) (svex-p (caar x))))
             (svex-case (caar x) :var)
             (not (sparseint-equal (cdar x) 0)))
        (cons (cons (svex-var->name (caar x))
                    (sparseint-fix (cdar x)))
              (svex-mask-alist-to-4vmask-alist (cdr x)))
      (svex-mask-alist-to-4vmask-alist (cdr x)))))


(local (defthm svarlist-p-alist-keys-when-4vmask-alist-p
         (implies (4vmask-alist-p x)
                  (svarlist-p (alist-keys x)))
         :hints(("Goal" :in-theory (enable alist-keys)))))


;; (local
;;  (defsection svarlist-addr-p-of-svexlist-compute-masks
;;    (defret member-vars-of-svex-args-apply-masks
;;      (implies (and (not (member v (svexlist-vars args)))
;;                    (not (member v (svexlist-vars (svex-mask-alist-keys mask-al)))))
;;               (not (member v (svexlist-vars (svex-mask-alist-keys mask-al1)))))
;;      :hints(("Goal" :in-theory (enable svex-args-apply-masks)))
;;      :fn svex-args-apply-masks)

;;    (defret member-vars-of-svexlist-compute-masks
;;      (implies (and (not (member v (svexlist-vars x)))
;;                    (not (member v (svexlist-vars (svex-mask-alist-keys mask-al)))))
;;               (not (member v (svexlist-vars (svex-mask-alist-keys mask-al1)))))
;;      :hints(("Goal" :in-theory (enable svexlist-compute-masks)))
;;      :fn svexlist-compute-masks)

;;    (defret member-alist-keys-of-svex-mask-alist-to-4vmask-alist
;;      (implies (not (member v (svexlist-vars (svex-mask-alist-keys x))))
;;               (not (member v (alist-keys new-x))))
;;      :hints(("Goal" :in-theory (enable svex-mask-alist-to-4vmask-alist
;;                                        svex-mask-alist-keys
;;                                        alist-keys)))
;;      :fn svex-mask-alist-to-4vmask-alist)))


(local (in-theory (disable fast-alist-clean)))

(local
 (encapsulate nil
   (defthm svex-mask-alist-p-of-fast-alist-fork
     (implies (and (svex-mask-alist-p x)
                   (svex-mask-alist-p y))
              (svex-mask-alist-p (fast-alist-fork x y))))

   (local (defthm cdr-last-when-svex-mask-alist-p
            (implies (svex-mask-alist-p x)
                     (equal (cdr (last x)) nil))))



   (defthm svex-mask-alist-p-of-fast-alist-clean
     (implies (svex-mask-alist-p x)
              (svex-mask-alist-p (fast-alist-clean x)))
     :hints(("Goal" :in-theory (enable fast-alist-clean svex-mask-alist-p))))))



(define svexlist-compute-masks-with-eval ((x svexlist-p)
                                          (mask-al svex-mask-alist-p)
                                          (env svex-env-p))
  :returns (mask-al1 svex-mask-alist-p)
  (b* (((when (atom x))
        (mbe :logic (svex-mask-alist-fix mask-al)
             :exec mask-al))
       (first (car x))
       ((when (not (eq (svex-kind first) :call)))
        (svexlist-compute-masks-with-eval (cdr x) mask-al env))
       (mask (svex-mask-lookup first mask-al))
       ((when (sparseint-equal mask 0))
        (svexlist-compute-masks-with-eval (cdr x) mask-al env))
       (args (svex-call->args first))
       (argvals (4veclist-quote (svexlist-eval args env)))
       (argmasks (svex-argmasks mask
                                (svex-call->fn first)
                                argvals))
       (mask-al (svex-args-apply-masks args argmasks mask-al)))
    (svexlist-compute-masks-with-eval (cdr x) mask-al env)))

(local (defthm true-listp-when-svarlist-p
         (implies (svarlist-p x)
                  (true-listp x))))

(define svtv-chase-expr-deps ((expr svex-p)
                              (phase natp)
                              (rsh natp)
                              (mask 4vmask-p)
                              (evaldata svtv-evaldata-p)
                              &key
                              (svtv-chase-data 'svtv-chase-data))
  :returns (deps svex-mask-alist-p)
  (b* (((mv toposort al) (svex-toposort expr nil nil))
       (- (fast-alist-free al))
       ((svtv-chase-data svtv-chase-data))
       (start-mask-al (svex-mask-acons expr (sparseint-ash mask rsh) nil))
       ((unless svtv-chase-data.smartp)
        (fast-alist-free
         (fast-alist-clean
          (svexlist-compute-masks toposort start-mask-al))))
       (vars (svex-collect-vars expr))
       (env (make-fast-alist (pairlis$ vars (svtv-chase-evallist vars phase evaldata))))
       (mask-al (fast-alist-free
                 (fast-alist-clean
                  (svexlist-compute-masks-with-eval
                   toposort (svex-mask-acons expr (sparseint-ash mask rsh) nil)
                   env)))))
    (fast-alist-free env)
    mask-al))
       


;; Non-X-monotonic
;; Results in a 1 at bits where the inputs differ, 0 where they don't
(define 4vec-bitdiff ((x 4vec-p)
                      (y 4vec-p))
  :returns (bitdiff 4vec-p)
  (b* (((4vec x)) ((4vec y)))
    (2vec (logior (logxor x.upper y.upper)
                  (logxor x.lower y.lower)))))

(define 4veclist-bitdiff ((x 4veclist-p)
                          (y 4veclist-p))
  :guard (eql (len x) (len y))
  :returns (diffs 4veclist-p)
  (if (or (atom x) (atom y))
      nil
    (cons (4vec-bitdiff (car x) (car y))
          (4veclist-bitdiff (cdr x) (cdr y))))
  ///
  (defret len-of-<fn>
    (equal (len diffs)
           (min (len x) (len y)))))


(define svtv-chase-deps ((var svar-p)
                         (phase natp)
                         (rsh natp)
                         (mask 4vmask-p)
                         &key
                         (svtv-chase-data 'svtv-chase-data))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  :returns (mv (type symbolp :rule-classes :type-prescription)
               (vars 4vmask-alist-p)
               (vars2 4vmask-alist-p)
               (diffs svex-env-p)
               (expr svex-p))
  (b* (((svtv-chase-data svtv-chase-data))
       (phase (lnfix phase))
       (var (svar-fix var))
       (type
        (b* ((svex (svex-fastlookup var svtv-chase-data.updates))
             ((when svex)
              :update)
             (prev-var-look (hons-get var (svex-alist-fix svtv-chase-data.delays)))
             ((when prev-var-look)
              (if (eql phase 0)
                  :initst
                :prevst)))
          :input))

       ((when (or (eq type :input)
                  (eq type :initst)))
        (mv type nil nil nil (svex-var var)))

       ((when (eq type :prevst))
        (mv type (list (cons var (sparseint-ash mask rsh))) (list (cons var (sparseint-ash mask rsh)))
            nil ;; diffs?
            (svex-var var)))

       (expr (svex-fastlookup var svtv-chase-data.assigns))

       ((unless expr)
        (mv :error nil nil nil (svex-x)))

       
       
       (mask-al (svtv-chase-expr-deps expr phase rsh mask svtv-chase-data.evaldata))
       ((mv mask-al2 diffs)
        (if svtv-chase-data.evaldata2
            (let ((phase2  (+ phase svtv-chase-data.data2-offset)))
              (if (<= 0 phase2)
                  (mv (svtv-chase-expr-deps expr phase2 rsh mask svtv-chase-data.evaldata2)
                      (b* ((expr-vars (svex-collect-vars expr))
                           (expr-var-vals1 (svtv-chase-evallist expr-vars phase svtv-chase-data.evaldata))
                           (expr-var-vals2 (svtv-chase-evallist expr-vars phase2 svtv-chase-data.evaldata2))
                           (diffs (4veclist-bitdiff expr-var-vals1 expr-var-vals2)))
                        (make-fast-alist (pairlis$ expr-vars diffs))))
                (mv nil nil)))
          (mv nil nil)))
       
       (vars (svex-mask-alist-to-4vmask-alist mask-al))
       (vars2 (svex-mask-alist-to-4vmask-alist mask-al2)))
    (mv type vars vars2 diffs expr))
  ///
  ;; (local (defthm svar-addr-p-lookup-in-svar-map
  ;;          (implies (And (svarlist-addr-p (svar-map-vars x))
  ;;                        (hons-assoc-equal k (svar-map-fix x)))
  ;;                   (svar-addr-p (cdr (hons-assoc-equal k (svar-map-fix x)))))
  ;;          :hints(("Goal" :in-theory (e/d (svar-map-vars svar-map-fix)
  ;;                                         (hons-assoc-equal-of-svar-map-fix))
  ;;                  :induct (svar-map-vars x)))
  ;;          :rule-classes
  ;;          ((:rewrite :corollary
  ;;            (implies (And (svarlist-addr-p (svar-map-vars x))
  ;;                          (svar-p k)
  ;;                          (hons-assoc-equal k x))
  ;;                   (svar-addr-p (cdr (hons-assoc-equal k x))))))))

  ;; (local (defthm member-svex-mask-alist-keys-of-fast-alist-fork
  ;;          (implies (and (not (member v (svexlist-vars (svex-mask-alist-keys x))))
  ;;                        (not (member v (svexlist-vars (svex-mask-alist-keys y)))))
  ;;                   (not (member v (svexlist-vars (svex-mask-alist-keys (fast-alist-fork x y))))))
  ;;          :hints(("Goal" :in-theory (enable svex-mask-alist-keys)))))

  ;; (local (defthm svex-mask-alist-keys-of-atom
  ;;          (implies (atom x)
  ;;                   (equal (svex-mask-alist-keys x) nil))
  ;;          :hints(("Goal" :in-theory (enable svex-mask-alist-keys)))))

  ;; (defret svarlist-addr-p-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (alist-keys vars)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))

  

  ;; (defret svarlist-addr-p-expr-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (svex-vars expr)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))
  )


(define svtv-chase-normalize-masks ((rsh natp) (mask 4vmask-p) (mask2 4vmask-p))
  :returns (mv (new-rsh natp :rule-classes :type-prescription)
               (new-mask 4vmask-p)
               (new-mask2 4vmask-p)
               (union 4vmask-p))
  (b* ((union (sparseint-bitor (4vmask-fix mask) (4vmask-fix mask2)))
       (mask-rsh (sparseint-trailing-0-count union))
       (norm-mask (sparseint-ash (4vmask-fix mask) (- mask-rsh)))
       (norm-mask2 (sparseint-ash (4vmask-fix mask2) (- mask-rsh))))
    (mv (+ mask-rsh (lnfix rsh))
        norm-mask norm-mask2
        (sparseint-ash union (- mask-rsh))))
  ///
  (local (include-book "centaur/bitops/ihsext-basics" :dir :system))
  (local (include-book "arithmetic/top" :dir :system))


  (local (defthm trailing-0-count-of-logior-lte
           (and (implies (not (zip x))
                         (<= (bitops::trailing-0-count (logior x y)) (bitops::trailing-0-count x)))
                (implies (not (zip y))
                         (<= (bitops::trailing-0-count (logior x y)) (bitops::trailing-0-count y))))
           :hints(("Goal" :in-theory (enable* bitops::trailing-0-count
                                              bitops::ihsext-recursive-redefs
                                              bitops::ihsext-inductions)
                   :induct (logior x y)))))
  
  (local (defthm ash-of-trailing-0-count
           (equal (ash (logtail (bitops::trailing-0-count x) x)
                       (bitops::trailing-0-count x))
                  (ifix x))
           :hints(("Goal" :in-theory (enable* bitops::trailing-0-count
                                              bitops::ihsext-recursive-redefs)))))

  (local (defthm trailing-0-count-of-logtail
           (implies (<= (nfix n) (bitops::trailing-0-count x))
                    (equal (bitops::trailing-0-count (logtail n x))
                           (- (bitops::trailing-0-count x) (nfix n))))
           :hints(("Goal" :in-theory (e/d* (bitops::trailing-0-count
                                              bitops::ihsext-recursive-redefs
                                              bitops::ihsext-inductions)
                                           (bitops::logcdr-of-logtail))
                   :induct (logtail n x)))))
  
  (local (defthm trailing-0-count-of-ash
           (implies (<= (- (ifix n)) (bitops::trailing-0-count x))
                    (equal (bitops::trailing-0-count (ash x n))
                           (if (zip x)
                               0
                             (+ (bitops::trailing-0-count x) (ifix n)))))
           :hints(("Goal" :in-theory (enable* bitops::trailing-0-count
                                              bitops::ihsext-recursive-redefs
                                              bitops::ihsext-inductions)
                   :induct (ash x n)))))
           

  (local (defthm trailing-0-count-when-logtail-equal-0
           (implies (and (not (zip x))
                         (equal (logtail n x) 0))
                    (< (bitops::trailing-0-count x) (nfix n)))
           :hints(("Goal" :in-theory (enable* bitops::trailing-0-count
                                              bitops::ihsext-recursive-redefs
                                              bitops::ihsext-inductions)))
           :rule-classes :linear))
  
  (local (defthm ash-of-trailing-0-count-gen
           (implies (and (natp n)
                         (<= n (bitops::trailing-0-count x)))
                    (equal (ash (logtail n x)
                                n)
                           (ifix x)))
           :hints (("goal" :use ((:instance ash-of-trailing-0-count
                                  (x (ash (logtail n x)
                                          n)))
                                 (:instance ash-of-trailing-0-count
                                  (x x)))
                    :in-theory (disable ash-of-trailing-0-count)))))

  (defret <fn>-correct
    (equal (ash (sparseint-val new-mask) new-rsh)
           (ash (sparseint-val (4vmask-fix mask)) (nfix rsh)))
    :hints (("goal" :in-theory (disable bitops::ash-of-ash)
             :use ((:instance bitops::ash-of-ash
                    (x (logtail (BITOPS::TRAILING-0-COUNT (logior (SPARSEINT-VAL (4vmask-fix MASK))
                                                                  (SPARSEINT-VAL (4vmask-fix MASK2))))
                                (sparseint-val (4vmask-fix mask))))
                    (sh1 (BITOPS::TRAILING-0-COUNT (logior (SPARSEINT-VAL (4vmask-fix MASK))
                                                                  (SPARSEINT-VAL (4vmask-fix MASK2)))))
                    (sh2 (nfix rsh))))
             :cases ((zip (sparseint-val (4vmask-fix mask)))))))

  (defret <fn>-correct2
    (equal (ash (sparseint-val new-mask2) new-rsh)
           (ash (sparseint-val (4vmask-fix mask2)) (nfix rsh)))
    :hints (("goal" :in-theory (disable bitops::ash-of-ash)
             :use ((:instance bitops::ash-of-ash
                    (x (logtail (BITOPS::TRAILING-0-COUNT (logior (SPARSEINT-VAL (4vmask-fix MASK))
                                                                  (SPARSEINT-VAL (4vmask-fix MASK2))))
                                (sparseint-val (4vmask-fix mask2))))
                    (sh1 (BITOPS::TRAILING-0-COUNT (logior (SPARSEINT-VAL (4vmask-fix MASK))
                                                                  (SPARSEINT-VAL (4vmask-fix MASK2)))))
                    (sh2 (nfix rsh))))
             :cases ((zip (sparseint-val (4vmask-fix mask2))))))))

(define svtv-chase-var-declared-width ((var svar-p)
                                       (modidx natp)
                                       &key
                                       ((moddb moddb-ok) 'moddb))
  :returns (width maybe-posp :rule-classes :type-prescription)
  :guard (< modidx (moddb->nmods moddb))
  (b* (((svar var))
       ((unless (address-p var.name)) nil)
       (path (address->path var.name))
       ((mv err wire & &) (moddb-path->wireidx/decl path modidx moddb))
       ((when err) nil)
       ((wire wire)))
    wire.width))


(define svtv-chase-var-name/range ((var svar-p)
                                   (rsh natp)
                                   (mask 4vmask-p)
                                   (modidx natp)
                                   &key
                                   ((moddb moddb-ok) 'moddb))
  :returns (mv (name-range-msg)
               (width maybe-posp :rule-classes :type-prescription))
  :guard (< modidx (moddb->nmods moddb))
  (b* (((svar var))
       (maskwidth (and (not (sparseint-< mask 0))
                       (sparseint-length mask)))
       ((unless (address-p var.name))
        (b* (((when maskwidth)
              (mv (msg "~x0[~x1:~x2]" var.name (1- maskwidth) rsh) (max 1 maskwidth))))
          (cw! "Warning: For non-address variable ~x0, caremask was ~
                unbounded!~%" var)
          (mv (msg "~x0[??:~x1]" var.name rsh) nil)))
       (path (address->path var.name))
       (name (path->string-top path))
       ((mv err wire & &) (moddb-path->wireidx/decl path modidx moddb))
       ((when err)
        (cw! "[ERROR finding wire ~s0]: ~@1~%" (path->string-top path) err)
        (b* (((when maskwidth)
              (mv (msg "~s0[~x1:~x2]" name (1- maskwidth) rsh) (max 1 maskwidth))))
          (cw! "Warning: For unrecognized wire ~s0, caremask was unbounded!~%" name)
          (mv (msg "~s0[??:~x1]" (path->string-top path) rsh) nil)))
       ((wire wire))
       (width (if maskwidth
                  (min (max 1 maskwidth) wire.width)
                wire.width))
       (lsb (if wire.revp
                (- (+ wire.low-idx (- wire.width 1)) rsh)
              (+ rsh wire.low-idx)))
       (msb (if wire.revp
                (- lsb (- width 1))
              (+ lsb (- width 1)))))
    (mv (msg "~s0[~x1:~x2]" name msb lsb) width)))

;;  signame[4:0]:                #ux1E
;;  caremask:                    #ux1F
;; Value results from an override--
;;  override mask:                #uxc
;;  override value:               #uxf
;;  computed value:              #ux16
;; (Phase NEXT-PHASE = #x1.)


;; Printing for Chase --

;; Most things we print have a label on the left and a 4vec or integer value on
;; the right, to be printed in hex. If we are doing a chase comparison, we
;; might have another column of 4vec/integer values.  We want to right-justify
;; all such integer and 4vec values to the same point in the line.
;; Unfortunately, though, we need to support arbitrary ACL2 msg objects as the
;; labels in the left column, which means we can't determine how wide they will
;; print.  Instead, we'll just arbitrarily fix a left column width and use the
;; ~t directive to tab out to it, which means if the message doesn't fit in
;; that width we'll just go to the next line.

;; Non-integer 4vec values will be printed as:     ( #uxabcdabcd        ;; <-- "upper"
;;                                                   . #uxcadbca )      ;; <-- "lower"
;; Non-integer 4vec values will be printed as:    ( #uxABCD_ABCD
;;                                                  . #uxCA_DBCA )       (actual output)
;; If the "lower" is longer then it might instead look like:
;;                                                 (     #uxabcd        ;; <-- "upper"
;;                                                  . #uxdcbabcd )      ;; <-- "lower"
;; If the "lower" is longer then it might instead look like:
;;                                                (      #uxABCD
;;                                                 . #uxDCB_ABCD )       (actual output)
;;  -- the left paren is always at least 1 character to the left of the dot
;;  -- the dot is always one space before from the start of the "lower"
;;  -- the right paren is one space after the end of the "lower"
;;  -- the rightmost characters of "upper" and "lower" are in the same column.
;; Integer values are printed lined up with the 4vec uppers and lowers
;;  as in:                                                #ux10a
;;  as in:                                                #ux10A         (actual output)
;; We also allow lines with strings only and no 4vec.


;; BOZO we should put this in a more general book
(define msg-fix ((x msgp))
  :returns (new-x msgp)
  :inline t
  (mbe :logic (if (msgp x) x "")
       :exec x)
  ///
  (defthm msg-fix-when-msgp
    (implies (msgp x)
             (equal (msg-fix x) x)))

  (defthm msgp-of-msg
    (implies (and (stringp str)
                  (character-alistp args))
             (msgp (cons str args))))

  (defthm msgp-of-str
    (implies (stringp x)
             (msgp x)))
  
  (in-theory (disable msgp))
  
  (fty::deffixtype msg :pred msgp :fix msg-fix :equiv msg-equiv :define t))

(defprod 3col4vecline
  ((label msgp)
   (val maybe-4vec-p)
   (val2 maybe-4vec-p))
  :layout :tree)

(deflist 3col4vecs :elt-type 3col4vecline :true-listp t)

(define 4vec-print-width ((x 4vec-p))
  :returns (width posp :rule-classes :type-prescription)
  (if (2vec-p x)
      (length (str::hexify (2vec->val x)))
    (max (+ 3 (length (str::hexify (4vec->lower x))))
         (+ 2 (length (str::hexify (4vec->upper x)))))))

(define 3col4vec-min-space-between-columns ()
  :inline t
  2)

(define 3col4vec-left-column-width ()
  :inline t
  40)

(define 3col4vecline-valcolumn-width ((x 3col4vecline-p))
  :returns (width posp :rule-classes :type-prescription)
  (b* (((3col4vecline x)))
    (+ (3col4vec-min-space-between-columns)
       (if x.val (4vec-print-width x.val) 0))))

(define 3col4vecs-valcolumn-max-width ((x 3col4vecs-p))
  :returns (width posp :rule-classes :type-prescription)
  (if (atom x)
      (3col4vec-min-space-between-columns)
    (max (3col4vecline-valcolumn-width (car x))
         (3col4vecs-valcolumn-max-width (cdr x)))))

(define 3col4vecline-val2column-width ((x 3col4vecline-p))
  :returns (width posp :rule-classes :type-prescription)
  (b* (((3col4vecline x)))
    (+ (3col4vec-min-space-between-columns)
       (if x.val2 (4vec-print-width x.val2) 0))))

(define 3col4vecs-val2column-max-width ((x 3col4vecs-p))
  :returns (width posp :rule-classes :type-prescription)
  (if (atom x)
      (3col4vec-min-space-between-columns)
    (max (3col4vecline-val2column-width (car x))
         (3col4vecs-val2column-max-width (cdr x)))))

(local (in-theory (disable hexify explode-atom max)))


(define print-3col4vec-maybe-4vec ((column-width posp)
                                   (val maybe-4vec-p))
  :returns (mv (upper-msg msgp)
               (lower-msg msgp))
  ;; This prints out to column-width+2 to accommodate the right paren after the lower value.
  (b* (((unless val)
        (b* ((msg (msg "~_0" (+ 2 column-width))))
          (mv msg msg)))
       ((when (2vec-p val))
        (b* ((str (str::hexify (2vec->val val)))
             (len (length str))
             (spaces (- (lposfix column-width) len)))
          (mv (msg "~_0~s1  " spaces str)
              (msg "~_0" (+ 2 column-width)))))
       ((4vec val))
       (upper-str (str::hexify val.upper))
       (lower-str (str::hexify val.lower))
       (upper-len (length upper-str))
       (lower-len (length lower-str))
       (full-len (max (+ 3 lower-len) (+ 2 upper-len)))
       (spaces-before-lparen (- (lposfix column-width) full-len))
       (spaces-after-lparen (+ 1 (max 0 (+ 1 (- lower-len upper-len)))))
       (spaces-before-dot (- (lposfix column-width) (+ 2 lower-len))))
    (mv (msg "~_0(~_1~s2  " spaces-before-lparen spaces-after-lparen upper-str)
        (msg "~_0. ~s1 )" spaces-before-dot lower-str))))


(define print-3col4vecline ((valcolumn-width posp)
                            (val2column-width posp)
                            (x 3col4vecline-p))
  :returns (msg msgp)
  (b* (((3col4vecline x))
       ((unless (or x.val x.val2))
        (msg "~@0~%" x.label))
       ((mv val-upper val-lower) (print-3col4vec-maybe-4vec valcolumn-width x.val))
       ((mv val2-upper val2-lower) (print-3col4vec-maybe-4vec val2column-width x.val2))
       ((when (not x.val2))
        (if (2vec-p x.val)
            (msg "~@0~t1~@2~%" x.label (3col4vec-left-column-width) val-upper)
          (msg "~@0~t1~@2~%~t3~@4~%" x.label (3col4vec-left-column-width) val-upper (3col4vec-left-column-width) val-lower)))
       ((when (and (or (not x.val) (2vec-p x.val))
                   (2vec-p x.val2)))
        (msg "~@0~t1~@2~@3~%" x.label (3col4vec-left-column-width) val-upper val2-upper)))
    (msg "~@0~t1~@2~@3~%~t4~@5~@6~%" x.label (3col4vec-left-column-width) val-upper val2-upper
         (3col4vec-left-column-width) val-lower val2-lower)))

(define print-3col4vecs-aux ((valcolumn-width posp)
                             (val2column-width posp)
                             (x 3col4vecs-p))
  :returns (msg msgp)
  (if (atom x)
      ""
    (msg "~@0~@1"
         (print-3col4vecline valcolumn-width val2column-width (car x))
         (print-3col4vecs-aux valcolumn-width val2column-width (cdr x)))))

(define print-3col4vecs ((x 3col4vecs-p))
  :returns (msg msgp)
  (b* ((val-column (3col4vecs-valcolumn-max-width x))
       (val2-column (3col4vecs-val2column-max-width x)))
    (print-3col4vecs-aux val-column val2-column x)))


#||
(set-fmt-hard-right-margin 200 state)
(set-fmt-soft-right-margin 100 state)
(cw "~@0"
(print-3col4vecs
 (list
  (3col4vecline "Most things we print have a label on the left and a 4vec or integer value on" nil nil)
  (3col4vecline "the right, to be printed in hex. We want to right-justify all such integer" nil nil)
  (3col4vecline "and 4vec values to the same point in the line." nil nil)
  (3col4vecline "Non-integer 4vec values will be printed as:"
                (4vec #uxabcdabcd #uxcadbca ) nil)
  (3col4vecline "If the \"lower\" is longer then it" nil nil)
  (3col4vecline "might instead look like:" (4vec #uxabcd #uxdcbabcd ) nil)
  (3col4vecline " -- the left paren is always at least 1 character to the left of the dot" nil nil)
  (3col4vecline " -- the dot is always one space before from the start of the \"lower\"" nil nil)
  (3col4vecline " -- the right paren is one space after the end of the \"lower\"" nil nil)
  (3col4vecline " -- the rightmost characters of \"upper\" and \"lower\" are in the same column." nil nil)
  (3col4vecline "Integer values are printed lined up with the 4vec uppers and lowers" nil nil)
  (3col4vecline " as in:" #ux10a nil)
  (3col4vecline "We also allow lines with strings only and no 4vec." nil nil))))


(cw "~@0"
(print-3col4vecs
 (list
  (3col4vecline "Now testing printing two 4vecs" nil nil)
  (3col4vecline "Both 4vecs" (4vec #uxabcdabcd #uxcadbca) (4vec #uxcad #uxabcdabcda))
  (3col4vecline "First empty" nil (4vec #uxabcdabcd #uxcadbca))
  (3col4vecline "Second empty" (4vec #uxcad #uxabcdabcda) nil)
  (3col4vecline "Both 2vecs" 100 40)
  (3col4vecline "first 2vec" 1000 (4vec #uxabcdabcd #uxcadbca))
  (3col4vecline "second 2vec" (4vec #uxabcdabcd #uxcadbca) 1000000)
  (3col4vecline "empty/2vec" nil 30)
  (3col4vecline "2vec/empty" 800 nil))))

;; should output (minus the ";; " left column:)

;; Most things we print have a label on the left and a 4vec or integer value on
;; the right, to be printed in hex. We want to right-justify all such integer
;; and 4vec values to the same point in the line.
;; Non-integer 4vec values will be printed as:                  ( #uxABCD_ABCD
;;                                                                . #uxCA_DBCA )
;; If the "lower" is longer then it might instead look like:    (      #uxABCD
;;                                                               . #uxDCB_ABCD )
;;  -- the left paren is always at least 1 character to the left of the dot
;;  -- the dot is always one space before from the start of the "lower"
;;  -- the right paren is one space after the end of the "lower"
;;  -- the rightmost characters of "upper" and "lower" are in the same column.
;; Integer values are printed lined up with the 4vec uppers and lowers
;;  as in:                                                              #ux10A
;; We also allow lines with strings only and no 4vec.
||#

(define 3col4vec-maybe-line (cond
                             (label msgp)
                             (val maybe-4vec-p)
                             (val2 maybe-4vec-p))
  :returns (line 3col4vecs-p)
  (and cond
       (list (3col4vecline label val val2))))

(define maybe-loghead ((width maybe-posp)
                       (x integerp))
  :returns (new-x integerp :rule-classes :type-prescription)
  (if width (loghead (lposfix width) x) (lifix x)))

(define maybe-4vec-zero-ext ((width maybe-posp)
                             (x 4vec-p))
  :returns (new-x 4vec-p)
  (if width (4vec-zero-ext (2vec (lposfix width)) x) (4vec-fix x)))


(define svtv-chase-basic-signal-data ((val 4vec-p)
                                      (rsh natp)
                                      (width maybe-posp)
                                      (mask integerp))
  :returns (mv (shifted-val 4vec-p)
               (masked-val 4vec-p)
               (nonbool-mask integerp))
  (b* ((shifted-val  (maybe-4vec-zero-ext width (4vec-shift-core (- (lnfix rsh)) val)))
       (masked-val (4vec-bitand shifted-val (2vec mask)))
       (nonbool-mask (logxor (4vec->upper shifted-val) (4vec->lower shifted-val))))
    (mv shifted-val masked-val nonbool-mask)))



(define svtv-chase-override-signal-data ((var svar-p)
                                         (phase natp)
                                         (rsh natp)
                                         (width maybe-posp)
                                         (mask integerp)
                                         (evaldata svtv-evaldata-p)
                                         (print-with-masked-val)
                                         &key
                                         (svtv-chase-data 'svtv-chase-data))
  :returns (mv (override-mask integerp)
               (masked-override-mask integerp)
               (override-val 4vec-p)
               (computed-val 4vec-p))

  (b* (((mv override-mask override-val computed-val)
        (svtv-chase-eval-override var phase evaldata))
       (override-mask (maybe-loghead width (ash override-mask (- (lnfix rsh)))))
       (masked-override-mask (logand override-mask mask))

       (override-val (maybe-4vec-zero-ext width (4vec-shift-core (- (lnfix rsh)) override-val)))
       (override-val (if print-with-masked-val
                         (4vec-bitand override-val (2vec masked-override-mask ))
                       override-val))
       (computed-val (maybe-4vec-zero-ext width (4vec-shift-core (- (lnfix rsh)) computed-val)))
       (computed-val (if print-with-masked-val
                         (4vec-bitand computed-val
                                      (2vec (logand mask (lognot override-mask))))
                       computed-val)))
    (mv override-mask
        masked-override-mask
        override-val
        computed-val)))

(define svtv-chase-print-with-masked-val ((print-with-mask-mode symbolp)
                                          (shifted-val 4vec-p)
                                          (masked-val 4vec-p)
                                          (shifted-val2 maybe-4vec-p)
                                          (masked-val2 maybe-4vec-p))
  (case print-with-mask-mode
    ((t) t)
    ((nil) nil)
    (t (and (or (not (2vec-p shifted-val))
                (and shifted-val2
                     (not (2vec-p shifted-val2))))
            (2vec-p masked-val)
            (or (not masked-val2)
                (2vec-p masked-val2))))))


(define svtv-chase-print-signal ((index acl2::maybe-natp "index to print at the beginning, if applicable")
                                 (var svar-p)
                                 (phase natp)
                                 (rsh natp)
                                 (mask 4vmask-p)
                                 (mask2 4vmask-p)
                                 (print-overrides)
                                 &key
                                 ((moddb moddb-ok) 'moddb)
                                 (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (svar-addr-p var)
          (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :prepwork ((local (in-theory (e/d (svar-addr-p)
                                    (str::hexify max member-equal ash logior logxor lognot
                                                 append acl2::append-of-cons
                                                 acl2::append-when-not-consp not
                                                 moddb->nmods moddb->nmods1p
                                                 nth
                                                 moddbp)))))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  :returns (lines 3col4vecs-p)

  (b* (((mv rsh mask mask2 union-mask) (svtv-chase-normalize-masks rsh mask mask2))
       ((mv name/range width)
        (svtv-chase-var-name/range var rsh union-mask (svtv-chase-data->modidx svtv-chase-data)))
       ;; Mask and width now are both relative to rsh.  I.e., shift first, then mask/truncate.
       (delay (svar->delay var))
       (delay-msg (if (eql delay 0)
                      ""
                    (msg " (delay ~x0)" delay)))
       ((svtv-chase-data svtv-chase-data))

       (mask (sparseint-val mask))
       (mask2 (sparseint-val mask2))
       
       (val (svtv-chase-eval var phase svtv-chase-data.evaldata))
       ((mv shifted-val masked-val nonbool-mask)
        (svtv-chase-basic-signal-data val rsh width mask))

       (val2 (and svtv-chase-data.evaldata2
                  (let ((phase2  (+ phase svtv-chase-data.data2-offset)))
                    (and (<= 0 phase2)
                         (svtv-chase-eval var phase2 svtv-chase-data.evaldata2)))))
       ((mv shifted-val2 masked-val2 nonbool-mask2)
        (if val2
            (svtv-chase-basic-signal-data val2 rsh width mask2)
          (mv nil nil nil)))
       
       (print-with-mask-mode (svtv-chase-data->print-with-mask-mode svtv-chase-data))
       (print-with-masked-val (svtv-chase-print-with-masked-val print-with-mask-mode
                                                                shifted-val masked-val shifted-val2 masked-val2))
       (printed-val (if print-with-masked-val
                        masked-val
                      shifted-val))
       (printed-val2 (if print-with-masked-val
                         masked-val2
                       shifted-val2))
       (first-lines (append (list (3col4vecline
                                   (msg "~@0 ~@1~@2"
                                        (if index (msg "~x0." index) "")
                                        name/range
                                        delay-msg)
                                   printed-val
                                   printed-val2))
                            (3col4vec-maybe-line
                             print-with-masked-val
                             (if (eq print-with-mask-mode t)
                                 "(value masked due to MASK-ALWAYS setting -- ? for help)"
                               "(value masked to make it 2valued -- ? for help)")
                              nil nil)
                            (3col4vec-maybe-line (or (not (2vec-p shifted-val))
                                                     (and val2 (not (2vec-p shifted-val2))))
                                                 "  non-Boolean portion:"
                                                 (2vec nonbool-mask)
                                                 (and val2 (2vec nonbool-mask2)))))
       (caremask-lines (list (3col4vecline "  caremask:" (2vec mask) (and val2 (2vec mask2)))))
       ((unless print-overrides)
        (append first-lines caremask-lines))


       ((mv override-mask masked-override-mask override-val computed-val)
        (svtv-chase-override-signal-data var phase rsh width mask svtv-chase-data.evaldata print-with-masked-val))

       ((mv override-mask2 masked-override-mask2 override-val2 computed-val2)
        (if val2
            (svtv-chase-override-signal-data var (+ phase svtv-chase-data.data2-offset) rsh width mask2 svtv-chase-data.evaldata2 print-with-masked-val)
          (mv nil nil nil nil)))
       
       ((when (and (eql masked-override-mask 0)
                   (or (not val2)
                       (eql masked-override-mask2 0))))
        (append first-lines caremask-lines))

       (override-lines (list
                        (3col4vecline "Value results from an override --" nil nil)
                        (3col4vecline "  Override mask:" (2vec override-mask) (and val2 (2vec override-mask2)))
                        (3col4vecline "  Override val:"  override-val override-val2)
                        (3col4vecline "  Computed val:"  computed-val computed-val2))))
    (append first-lines caremask-lines override-lines)))


(local (defthm len-equal-0
         (equal (equal (len x) 0)
                (not (consp x)))))

(define svtv-chase-print-signals ((index natp)
                                  (vars svarlist-p)
                                  (masks 4vmask-alist-p)
                                  (masks2 4vmask-alist-p)
                                  (phase natp)
                                  (print-overrides)
                                  &key
                                  ((moddb moddb-ok) 'moddb)
                                  (svtv-chase-data 'svtv-chase-data))
  :guard (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
  :guard-hints (("goal" :in-theory (enable alist-keys))
                (and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  :returns (lines 3col4vecs-p)
  (if (atom vars)
      nil
    (append (list (3col4vecline
                   (if (svtv-chase-data->evaldata2 svtv-chase-data)
                       "----              -----              -----              -----              -----              -----              -----              -----"
                     "----              -----              -----              -----              -----")
                   nil nil))
            (svtv-chase-print-signal (lnfix index)
                                     (car vars)
                                     phase
                                     0
                                     (or (cdr (hons-get (car vars) (4vmask-alist-fix masks))) 0)
                                     (or (cdr (hons-get (car vars) (4vmask-alist-fix masks2))) 0)
                                     print-overrides)
            (svtv-chase-print-signals (1+ (lnfix index)) (cdr vars) masks masks2 phase print-overrides))))

      
                     
         
(local (defthm len-alist-keys-when-4vmask-alist-p
         (implies (4vmask-alist-p x)
                  (equal (len (alist-keys x))
                         (len x)))
         :hints(("Goal" :in-theory (enable alist-keys)))))



(define svtv-labelpair-p (x)
  (or (integerp x) ;; no label, just offset
      (symbolp x) ;; no offset, just label
      (and (consp x)
           (symbolp (car x))
           (consp (cdr x))
           (integerp (cadr x))
           (not (cddr x)))))

(define svtv-chase-phase-labelpair-aux ((phase natp)
                                        (phaselabels symbol-listp))
  ;; Scans through the phase labels and returns either the phase label at
  ;; phase, the last phase label before phase and the offset of phase from that
  ;; label, or NIL if no label was found at or before phase.
  :returns (labelpair svtv-labelpair-p
                      :hints(("Goal" :in-theory (enable svtv-labelpair-p))))
  (if (zp phase)
      (mbe :logic (acl2::symbol-fix (car phaselabels))
           :exec (car phaselabels))
    (if (car phaselabels)
        (or (svtv-chase-phase-labelpair-aux (1- phase) (cdr phaselabels))
            (list (mbe :logic (acl2::symbol-fix (car phaselabels))
                       :exec (car phaselabels))
                  phase))
      (svtv-chase-phase-labelpair-aux (1- phase) (cdr phaselabels)))))

(define svtv-chase-phase-labelpair ((phase integerp)
                                    (phaselabels symbol-listp))
  :returns (labelpair svtv-labelpair-p
                      :hints ((and stable-under-simplificationp
                                   '(:in-theory (enable svtv-labelpair-p)))))
  ;; Returns either:
  ;;  - the phase label exactly at phase,
  ;;  - the last phase label before phase and the offset of phase at that label,
  ;;  - phase itself if no labels before phase.
  (if (< (lifix phase) 0)
      (lifix phase)
    (or (svtv-chase-phase-labelpair-aux phase phaselabels)
        (lnfix phase))))

(define svtv-chase-labelpair-phase ((labelpair svtv-labelpair-p)
                                    (phaselabels symbol-listp))
  :prepwork ((local (in-theory (enable svtv-labelpair-p))))
  :returns (phase acl2::maybe-integerp :rule-classes :type-prescription)
  (b* (((when (integerp labelpair))
        labelpair)
       (name (if (consp labelpair)
                 (car labelpair)
               labelpair))
       (offset (if (consp labelpair)
                   (lifix (cadr labelpair))
                 0))
       (label-index (acl2::index-of name phaselabels)))
    (and label-index (+ label-index offset))))


    
(local (in-theory (disable nth update-nth)))


(define svtv-chase-mask-alists-sort-vars ((vars svarlist-p)
                                          (masks 4vmask-alist-p)
                                          (masks2 4vmask-alist-p)
                                          (diffs svex-env-p))
  :returns (mv (diff-overlap svarlist-p)
               (overlap svarlist-p)
               (both svarlist-p)
               (first svarlist-p)
               (second svarlist-p))
  :prepwork ((local (in-theory (disable svarlist-p-when-subsetp-equal logand member-equal hons-assoc-equal))))
  (b* (((when (atom vars)) (mv nil nil nil nil nil))
       (var1 (svar-fix (car vars)))
       (mask1 (or (cdr (hons-get var1 (4vmask-alist-fix masks))) 0))
       (mask2 (or (cdr (hons-get var1 (4vmask-alist-fix masks2))) 0))
       (diff (or (cdr (hons-get var1 (svex-env-fix diffs))) 0))
       ((mv diff-overlap overlap both first second)
        (svtv-chase-mask-alists-sort-vars (cdr vars) masks masks2 diffs))
       (mask-overlap (sparseint-bitand mask1 mask2))
       ((when (not (sparseint-equal 0 mask-overlap)))
        (b* ((masked-diff (4vec-bitand (2vec (sparseint-val mask-overlap)) diff)))
          (if (eql masked-diff 0)
              (mv diff-overlap (cons var1 overlap) both first second)
            (mv (cons var1 diff-overlap) overlap both first second))))
       ((when (not (sparseint-equal 0 mask1)))
        (if (sparseint-equal 0 mask2)
            (mv diff-overlap overlap both (cons var1 first) second)
          (mv diff-overlap overlap (cons var1 both) first second)))
       ((when (not (sparseint-equal 0 mask2)))
        (mv diff-overlap overlap both first (cons var1 second))))
    (mv diff-overlap overlap both first second)))


(local
 (include-book "std/osets/element-list" :dir :system))

(local
 (fty::deflist svarlist :elt-type svar :true-listp t :elementp-of-nil nil))

(define svtv-chase-mask-alists-sorted-vars ((masks 4vmask-alist-p)
                                            (masks2 4vmask-alist-p)
                                            (diffs svex-env-p))
  :prepwork ((local (defthm true-listp-when-svarlist-p-rw
                      (implies (svarlist-p x) (true-listp x)))))
  :returns (sorted-vars svarlist-p)
  (b* ((masks (4vmask-alist-fix masks))
       (masks2 (4vmask-alist-fix masks2))
       ((when (atom masks2)) (mergesort (alist-keys masks)))
       (vars (union (mergesort (alist-keys masks)) (mergesort (alist-keys masks2))))
       ((mv diff-overlap overlap both first second)
        (svtv-chase-mask-alists-sort-vars vars masks masks2 diffs)))
    (append diff-overlap overlap both first second)))

(define svtv-chase-mask-intersect-alist ((vars svarlist-p)
                                         (masks 4vmask-alist-p)
                                         (masks2 4vmask-alist-p)
                                         (include-masks2))
  :returns (intersect-masks 4vmask-alist-p)
  (b* (((when (atom vars)) nil)
       (var1 (svar-fix (car vars)))
       (masks (4vmask-alist-fix masks))
       (masks2 (4vmask-alist-fix masks2))
       (mask1 (or (cdr (hons-get var1 masks)) 0)))
    (cons (cons (svar-fix (car vars))
                (if include-masks2
                    (sparseint-bitand mask1
                                      (or (cdr (hons-get var1 masks2)) 0))
                  mask1))
          (svtv-chase-mask-intersect-alist (cdr vars) masks masks2 include-masks2))))

(define svtv-chase-signal ((var svar-p)
                           (phase integerp)
                           (rsh natp)
                           (mask 4vmask-p)
                           &key
                           (svtv-chase-data 'svtv-chase-data)
                           ((moddb moddb-ok) 'moddb))
  :guard (and ;; (svar-addr-p var)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap))))
  :returns (mv (type symbolp :rule-classes :type-prescription)
               (vars 4vmask-alist-p)
               (expr svex-p))
  (b* (((svtv-chase-data svtv-chase-data))
       ((mv var phase) (svtv-chase-normalize-var/phase var phase))
       (signal-lines (svtv-chase-print-signal nil var phase rsh mask mask t))
       (phase-line (list (3col4vecline
                          (msg "(Phase ~@0.)"
                               (b* ((pair (svtv-chase-phase-labelpair phase svtv-chase-data.phaselabels)))
                                 (if (equal pair phase)
                                     (msg "~x0" phase)
                                   (msg "~x0 = ~x1" pair phase))))
                          nil nil)))
       ((mv type mask-alist mask-alist2 diffs expr)
        (svtv-chase-deps var phase rsh mask))
       ((acl2::with-fast mask-alist mask-alist2))
       (vars (svtv-chase-mask-alists-sorted-vars mask-alist mask-alist2 diffs))
       (deps-lines
        (b* (((when (eq type :error))
              (list (3col4vecline "Error! Somehow this signal wasn't what we expected." nil nil)))
             ((when (eq type :input))
              (list (3col4vecline "Primary input." nil nil)))
             ((when (eq type :initst))
              (list (3col4vecline "Initial state." nil nil)))
             ((when (eq type :prevst))
              (cons (3col4vecline "Previous state var." nil nil)
                    (svtv-chase-print-signals 0 vars mask-alist mask-alist2 phase svtv-chase-data.print-overrides-mode))))
          (cons (3col4vecline "Internal signal; dependencies:" nil nil)
                (svtv-chase-print-signals 0 vars mask-alist mask-alist2 phase
                                          svtv-chase-data.print-overrides-mode))))
       (last-line (list (3col4vecline "================================================================================" nil nil)))
       (msg (print-3col4vecs
             (append signal-lines phase-line deps-lines last-line))))
    (cw! "~@0" msg)
    (mv type (svtv-chase-mask-intersect-alist
              vars mask-alist mask-alist2
              svtv-chase-data.evaldata2)
        expr))
  ///
  ;; (defret svarlist-addr-p-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (alist-keys vars)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))

  

  ;; (defret svarlist-addr-p-expr-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (svex-vars expr)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))
  )

;; (define svar-addr-p! (x)
;;   :enabled t
;;   (and (svar-p x)
;;        (svar-addr-p x)))

;; (define 4vmask-alist-addr-p! (x)
;;   :enabled t
;;   (and (4vmask-alist-p x)
;;        (svarlist-addr-p (alist-keys x))))

;; (define svex-addr-p! (x)
;;   :enabled t
;;   (and (svex-p x)
;;        (svarlist-addr-p (svex-vars x))))


(define svtv-chase-signal-data ((pos chase-position-p)
                                &key
                                ((moddb moddb-ok) 'moddb)
                                (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (chase-position-addr-p pos)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :guard-hints (("goal" :in-theory (enable svtv-chase-datap
                                           ;; chase-position-addr-p
                                           ;; chase-stack-addr-p
                                           )))
  :returns (new-svtv-chase-data)
  (b* (((chase-position pos))
       ((mv type vars expr)
        (svtv-chase-signal (make-svar :name (make-address :path pos.path))
                           pos.phase pos.rsh pos.mask))
       ((when (eq type :error))
        (cw! "[Error -- discrepancy between stored updates and assignments!]~%")
        svtv-chase-data)
       (svtv-chase-data (set-svtv-chase-data->stack (cons pos (svtv-chase-data->stack svtv-chase-data))
                                            svtv-chase-data))
       (svtv-chase-data (set-svtv-chase-data->sigtype type svtv-chase-data))
       (svtv-chase-data (set-svtv-chase-data->vars vars svtv-chase-data))
       (svtv-chase-data (set-svtv-chase-data->expr expr svtv-chase-data))
       ;; (svtv-chase-data (set-svtv-chase-data->new-phase new-phase svtv-chase-data))
       )
    svtv-chase-data)
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))


(define svtv-chase-range ((pos chase-position-p)
                          (msb integerp)
                          (lsb integerp)
                          &key
                          ((moddb moddb-ok) 'moddb)
                          (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (chase-position-addr-p pos)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable ;; chase-position-addr-p
                                   ;; svar-addr-p
                                   svtv-chase-datap))))
  :returns (new-svtv-chase-data)
  :prepwork ((local (in-theory (disable logmask not))))
  (b* ((modidx (svtv-chase-data->modidx svtv-chase-data))
       ((chase-position pos))
       ;; (path (address->path (svar->name pos.var)))
       ((mv err wire & &) (moddb-path->wireidx/decl pos.path modidx moddb))
       ((when err)
        (cw! "[ERROR finding wire ~s0]: ~@1~%" (path->string-top pos.path) err)
        svtv-chase-data)
       ((wire wire))
       (msb (lifix msb))
       (lsb (lifix lsb))
       (wire-lsb (if wire.revp
                     (+ wire.low-idx (- wire.width 1))
                   wire.low-idx))
       (wire-msb (if wire.revp
                     wire.low-idx
                   (+ wire.low-idx (- wire.width 1))))
       ((unless (if wire.revp
                    (and (<= wire-msb msb) (<= msb lsb) (<= lsb wire-lsb))
                  (and (<= wire-lsb lsb) (<= lsb msb) (<= msb wire-msb))))
        (cw! "Bad range for ~s0: declared range is [~x1:~x2]~%"
             (path->string-top pos.path) wire-msb wire-lsb)
        svtv-chase-data)
       (width (if wire.revp
                  (+ 1 (- lsb msb))
                (+ 1 (- msb lsb))))
       (rsh (if wire.revp (- wire-lsb lsb) (- lsb wire-lsb)))
       (mask (logmask width))
       (new-pos (change-chase-position pos
                                       :rsh rsh
                                       :mask (int-to-sparseint mask))))
    (svtv-chase-signal-data new-pos))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))

;; (local
;;  (defsection lhs-addr-p-of-svtv-wire->lhs

;;    (defret lhs-addr-p-of-svtv-1wire->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-1wire->lhs
;;                                        )))
;;      :fn svtv-1wire->lhs)

;;    (local (defthm member-lhs-vars-of-append
;;             (implies (and (not (member v (lhs-vars a)))
;;                           (not (member v (lhs-vars b))))
;;                      (not (member v (lhs-vars (append a b )))))
;;             :hints(("Goal" :in-theory (enable lhs-vars)))))

;;    (defret lhs-addr-p-of-svtv-concat->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-concat->lhs
;;                                        )))
;;      :fn svtv-concat->lhs)

;;    (defret lhs-addr-p-of-svtv-wire->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-wire->lhs)))
;;      :fn svtv-wire->lhs)))


;; (local (include-book "centaur/bitops/ihsext-basics" :dir :system
(local (in-theory (disable logmask)))

(define svtv-chase-goto-lhs ((lhs lhs-p)
                             (phase natp)
                             (debug-source-obj)
                             &key
                             ((moddb moddb-ok) 'moddb)
                             (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints (("goal" :in-theory (e/d (svtv-mod-alias-guard
                                           ;; chase-position-addr-p
                                           svtv-chase-datap)
                                        (logmask))
                 :do-not-induct t))
  ;; :prepwork ((local (defthm svar-addr-p-of-lhatom-var->name
  ;;                     (implies (and (lhatom-case x :var)
  ;;                                   (svarlist-addr-p (lhatom-vars x)))
  ;;                              (svar-addr-p (lhatom-var->name x)))
  ;;                     :hints(("Goal" :in-theory (enable lhatom-vars)))))
  ;;            (local (defthm member-vars-of-lhrange->atom
  ;;                     (implies (and (not (member v (lhs-vars x)))
  ;;                                   (consp x))
  ;;                              (not (member v (lhatom-vars (lhrange->atom (car x))))))
  ;;                     :hints(("Goal" :in-theory (enable lhs-vars)))))
  ;;            (local (in-theory (disable lhs-vars-when-consp))))
  :guard-debug t
  :returns (new-svtv-chase-data)
  (b* (((when (atom lhs))
        (cw! "Error interpreting name: ~x0~%" debug-source-obj)
        svtv-chase-data)
       ((when (consp (cdr lhs)))
        (cw! "Error interpreting name: ~x0 was a concatenation~%" debug-source-obj)
        svtv-chase-data)
       ((lhrange lhrange) (car lhs))
       ((unless (lhatom-case lhrange.atom :var))
        (cw! "Error interpreting name: ~x0 had no variable component~%" debug-source-obj)
        svtv-chase-data)
       ((lhatom-var lhrange.atom))
       ((svar lhrange.atom.name))
       ((unless (address-p lhrange.atom.name.name))
        (cw! "Error interpreting name: ~x0 produced a variable that was not an address~%" debug-source-obj)
        svtv-chase-data)
       (pos (make-chase-position :path (address->path lhrange.atom.name.name)
                                 :phase phase
                                 :rsh lhrange.atom.rsh
                                 :mask (int-to-sparseint (logmask lhrange.w)))))
    (svtv-chase-signal-data pos))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))
       

(define svtv-chase-goto ((str stringp)
                         (labelpair svtv-labelpair-p)
                         &key
                         ((moddb moddb-ok) 'moddb)
                         (aliases 'aliases)
                         (svtv-chase-data 'svtv-chase-data))
  :guard (and (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (svtv-chase-data->modidx svtv-chase-data) moddb)
                  (aliass-length aliases)))
  :guard-hints (("goal" :in-theory (e/d (svtv-mod-alias-guard
                                           ;; chase-position-addr-p
                                           svtv-chase-datap)
                                        (logmask))
                 :do-not-induct t))
  :guard-debug t
  :returns (new-svtv-chase-data)
  (b* (((mv err lhs) (svtv-wire->lhs str (svtv-chase-data->modidx svtv-chase-data) moddb aliases))
       ((when err)
        (cw! "Error interpreting name: ~s0~%" str)
        svtv-chase-data)
       (phase (svtv-chase-labelpair-phase labelpair (svtv-chase-data->phaselabels svtv-chase-data)))
       ((unless phase)
        (cw! "Error interpreting phase: ~x0 -- label not found~%" labelpair)
        svtv-chase-data)
       ((unless (<= 0 phase))
        (cw! "Error interpreting phase: ~x0 -- normalized to negative value: ~x1~%" labelpair phase)
        svtv-chase-data))
    (svtv-chase-goto-lhs lhs phase str))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))

(define svtv-chase-goto-output ((name)
                                &key
                                ((moddb moddb-ok) 'moddb)
                                (svtv-chase-data 'svtv-chase-data))
  :guard (and (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :guard-hints (("goal" :in-theory (e/d (svtv-mod-alias-guard
                                           ;; chase-position-addr-p
                                           svtv-chase-datap)
                                        (logmask))
                 :do-not-induct t))
  :guard-debug t
  :returns (new-svtv-chase-data)
  (b* (((svtv-chase-data svtv-chase-data))
       (probe? (hons-assoc-equal name svtv-chase-data.probes))
       ((unless probe?)
        (cw! "Error: no output named ~x0~%" name)
        svtv-chase-data)
       ((svtv-probe probe) (cdr probe?))
       (lhs? (hons-assoc-equal probe.signal svtv-chase-data.namemap))
       ((unless lhs?)
        (cw! "Error: found output named ~x0 pointing to signal ~x1 but no such entry in namemap~%"
             name probe.signal)
        svtv-chase-data)
       (lhs (cdr lhs?)))
    (svtv-chase-goto-lhs lhs probe.time name))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))
       

(define svtv-chase-print (&key
                          ((moddb moddb-ok) 'moddb)
                          (svtv-chase-data 'svtv-chase-data))
  :guard (and (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb)))
  :returns new-svtv-chase-data
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap)
                       :do-not-induct t))
                ;; (and stable-under-simplificationp
                ;;      '(:in-theory (enable chase-position-addr-p)))
                )
  (b* ((stack (svtv-chase-data->stack svtv-chase-data))
       ((unless (consp stack))
        (cw! "Empty stack! Use (G \"path\" phase) to choose a signal, ? for more options.~%")
        svtv-chase-data)
       (pos (car stack))
       (svtv-chase-data (set-svtv-chase-data->stack (cdr stack) svtv-chase-data))
       (svtv-chase-data (svtv-chase-signal-data pos)))
    svtv-chase-data)
  ///
  (defmacro svtv-chase-print! (&rest args)
    `(b* ((svtv-chase-data (svtv-chase-print . ,args)))
       (mv nil svtv-chase-data state)))

  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))

(defconst *chase-usage*
  "
What you can enter at the SVTV-CHASE prompt:

 ?                  prints this help message

 X                  Exit the chase read-eval-print loop.

 P                  prints the current state, including the next signal choices

 (G \"path\" phase) Go to the signal named by the given path at the given phase.
                    The phase may be specified as a natural number (offset), 
                    a phase label from the defsvtv form, or a combination
                    (label num), meaning the numth phase after label.

 (O name)           Go to the signal/phase corresponding to the named pipeline output.

 (R MSB LSB)        Select the given MSB:LSB range of the current signal

 Natural number     Select the given choice of next signal
 B                  Go back to the previous signal on the stack.

 EXPR               Print the assignment for the current signal.
 (EXPR N)           Print the assignment expression, limiting nesting depth to N.

 SMARTP             Toggle data-aware dependency reduction feature
                    (reduces the number of irrelevant signals listed).
                    On by default.

 (EV form)          Evaluates form using simple-translate-and-eval 
                    and prints the result.  You need to set up an attachment
                    to do this, which you can do by running
                    (sv::setup-ev-for-chase) in the ACL2 loop.  You can undo this
                    with (sv::unsetup-ev-for-chase).

 MASK-ALWAYS
 MASK-NEVER
 MASK-DEFAULT       Affects whether signal values are ANDed with the caremask before
                    printing.  The default is to only AND the value with the mask if
                    the unmasked value is not 2valued and the masked value is 2valued.
                    The -always and -never settings change this to always/never 
                    (respectively) AND the value with the mask.

 OVERRIDES-VERBOSE
 OVERRIDES-DEFAULT  Affects whether the derivation of signal values from overrides is
                    printed for only the current signal (default) or for all
                    dependencies as well (verbose).
")

(defmacro setup-ev-for-chase ()
  '(progn
     (defttag trans)
     (defattach (simple-translate-and-eval-logic acl2::simple-translate-and-eval-cmp)
       :skip-checks t)))

(defmacro unsetup-ev-for-chase ()
  '(progn
     (defttag nil)
     (defattach (simple-translate-and-eval-logic nil))))

;; (local (defthm chase-position-addr-p-car-when-chase-stack-addr-p
;;          (implies (and (svtv-chase-data->stack-addr-p x)
;;                        (consp x))
;;                   (svtv-chase-data->position-addr-p (car x)))
;;          :hints(("Goal" :in-theory (enable chase-stack-addr-p)))))

;; (local (defthm chase-stack-addr-p-cdr-when-chase-stack-addr-p
;;          (implies (svtv-chase-data->stack-addr-p x)
;;                   (svtv-chase-data->stack-addr-p (cdr x)))
;;          :hints(("Goal" :in-theory (enable chase-stack-addr-p)))))


(local (defthm nth-when-4vmask-alist-p
         (implies (and (4vmask-alist-p x)
                       (< (nfix n) (len x)))
                  (and (consp (nth n x))
                       (svar-p (car (nth n x)))
                       (sparseint-p (cdr (nth n x)))))
         :hints(("Goal" :in-theory (enable nth)))))

;; (local (defthm nth-svar-addr-p-when-4vmask-alist-p
;;          (implies (and (4vmask-alist-p x)
;;                        (svarlist-addr-p (alist-keys x))
;;                        (< (nfix n) (len x)))
;;                   (svar-addr-p (car (nth n x))))
;;          :hints(("Goal" :in-theory (enable nth alist-keys)))))

(local (in-theory (disable read-object
                           open-input-channel-p1
                           member)))

(include-book "std/io/file-measure" :dir :system)
(local (include-book "std/io/open-channels" :dir :system))
(local (in-theory (disable file-measure)))

(verify-termination evisc-tuple)
(verify-guards evisc-tuple)


(encapsulate
  (((simple-translate-and-eval-logic
     * * * * * * state * * *) => (mv * *)
    :formals (x alist ok-stobj-names msg ctx wrld state aok safe-mode gc-off)
    :guard t))
  (set-ignore-ok t)
  (set-irrelevant-formals-ok t)
  (local (defun simple-translate-and-eval-logic (x alist ok-stobj-names msg ctx wrld state aok safe-mode gc-off)
           (declare (xargs :stobjs state))
           (mv nil nil))))


(local (in-theory (disable w)))

(local (defthm w-of-read-object
         (equal (w (mv-nth 2 (read-object channel state)))
                (w state))
         :hints(("Goal" :in-theory (enable w read-object
                                           ;; Matt K. addition for 5/8/2023 change to
                                           ;; read-object to call iprint-oracle-updates:
                                           read-acl2-oracle update-acl2-oracle
                                           ;; Matt K. mod for conversion of
                                           ;; eviscerate-top to logic mode:
                                           acl2::iprint-oracle-updates)))))

(define svtv-chase-rep (&key
                        ((moddb moddb-ok) 'moddb)
                        (svtv-chase-data 'svtv-chase-data)
                        (aliases 'aliases)
                        (state 'state))
  :guard (and (open-input-channel-p *standard-oi* :object state)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (svtv-chase-data->modidx svtv-chase-data) moddb)
                  (aliass-length aliases))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap)
                       :do-not-induct t)
                ;; (and stable-under-simplificationp
                ;;      '(:in-theory (enable chase-position-addr-p)))
                ))
  :returns (mv exitp new-svtv-chase-data new-state)
  (b* ((- (cw! "SVTV-CHASE > "))
       ((mv err obj state) (read-object *standard-oi* state))
       ((when err)
        (mv t svtv-chase-data state))
       ((when (natp obj))
        (b* ((vars (svtv-chase-data->vars svtv-chase-data))
             (stack (svtv-chase-data->stack svtv-chase-data))
             ((unless (consp stack))
              (cw! "Empty stack! Use (G \"path\" phase) to choose a signal, ? for more options.~%")
              (mv nil svtv-chase-data state))
             ((chase-position pos) (car stack))
             ((unless (< obj (len vars)))
              (cw "Out of range! Enter P to print current state, ? for more options.~%")
              (mv nil svtv-chase-data state))
             ((cons new-var new-mask) (nth obj vars))
             ;; ((mv rsh mask) (svtv-chase-normalize-mask 0 new-mask))
             ((mv new-var new-phase) (svtv-chase-normalize-var/phase new-var pos.phase))
             (name (svar->name new-var))
             ((unless (address-p name))
              (cw! "The chosen signal isn't an address, so it must be an ~
                    auxiliary variable supporting an override.~%Enter P to ~
                    print current state, ? for more options.~%")
              (mv nil svtv-chase-data state))
             (svtv-chase-data (svtv-chase-signal-data
                               (make-chase-position
                                :path (address->path name)
                                :phase (- new-phase (svar->delay new-var))
                                :rsh 0 :mask new-mask))))
          (mv nil svtv-chase-data state)))
       ((when (symbolp obj))
        (b* ((objname (symbol-name obj))
             ((when (equal objname "?"))
              (cw! *chase-usage*)
              (mv nil svtv-chase-data state))
             ((when (equal objname "P"))
              (svtv-chase-print!))
             ((when (equal objname "EXPR"))
              (cw! "~x0~%" (svtv-chase-data->expr svtv-chase-data))
              (mv nil svtv-chase-data state))
             ;; Too bad, walkabout isn't in logic mode
             ;; ((when (equal objname "WALK"))
             ;;  (b* (((mv ?err ?val state) (acl2::walkabout (chase-expr svtv-chase-data) state)))
             ;;    (mv nil svtv-chase-data state)))
             ((when (equal objname "B"))
              (b* ((stack (svtv-chase-data->stack svtv-chase-data))
                   ((unless (and (consp stack)
                                 (consp (cdr stack))))
                    (cw! "At end of stack!~%")
                    (mv nil svtv-chase-data state))
                   (svtv-chase-data (set-svtv-chase-data->stack (cdr stack) svtv-chase-data)))
                (svtv-chase-print!)))
             ((when (equal objname "X"))
              (mv t svtv-chase-data state))
             ((when (equal objname "SMARTP"))
              (b* ((smartp (svtv-chase-data->smartp svtv-chase-data))
                   (new-smartp (not smartp))
                   (svtv-chase-data (set-svtv-chase-data->smartp new-smartp svtv-chase-data)))
                (cw! "Turned data-aware dependency reduction ~s0.~%"
                     (if new-smartp "on" "off"))
                (svtv-chase-print!)))

             ((when (equal objname "MASK-ALWAYS"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-with-mask-mode t svtv-chase-data)))
                (cw! "Changed mask mode: always apply caremask to signal values~%")
                (mv nil svtv-chase-data state)))
             ((when (equal objname "MASK-NEVER"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-with-mask-mode nil svtv-chase-data)))
                (cw! "Changed mask mode: never apply caremask to signal values~%")
                (mv nil svtv-chase-data state)))
             ((when (equal objname "MASK-DEFAULT"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-with-mask-mode :default svtv-chase-data)))
                (cw! "Changed mask mode: apply caremask to signal values if it results in a 2vec~%")
                (mv nil svtv-chase-data state)))
             ((when (equal objname "OVERRIDES-VERBOSE"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-overrides-mode t svtv-chase-data)))
                (cw! "Changed override mode: print overrides for dependencies~%")
                (mv nil svtv-chase-data state)))
             ((when (equal objname "OVERRIDES-DEFAULT"))
              (b* ((svtv-chase-data (set-svtv-chase-data->print-overrides-mode nil svtv-chase-data)))
                (cw! "Changed override mode: print overrides only for current signal~%")
                (mv nil svtv-chase-data state))))
          (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
          (mv nil svtv-chase-data state)))
       ((when (and (consp obj)
                   (symbolp (car obj))))
        (b* ((objname (symbol-name (car obj)))
             (args (cdr obj))
             ((when (equal objname "R"))
              (b* (((unless (and (consp args)
                                 (integerp (car args))
                                 (consp (cdr args))
                                 (integerp (cadr args))
                                 (not (cddr args))))
                    (cw! "R directive must be of the form (R MSB LSB) where MSB and LSB are integers.  ? for more options.~%")
                    (mv nil svtv-chase-data state))
                   (stack (svtv-chase-data->stack svtv-chase-data))
                   ((unless (consp stack))
                    (cw! "Empty stack! Use (G \"path\") to choose a signal, ? for more options.~%")
                    (mv nil svtv-chase-data state))
                   (pos (car stack))
                   (svtv-chase-data (svtv-chase-range pos (car args) (cadr args))))
                (mv nil svtv-chase-data state)))
             ((when (equal objname "G"))
              (b* (((unless (and (consp args)
                                 (stringp (car args))
                                 (consp (cdr args))
                                 (svtv-labelpair-p (cadr args))
                                 (not (cddr args))))
                    (cw! "G directive must be of the form (G \"path\" phase) ~
                          where the first argument is a string and the second ~
                          is either a natural number offset, a phase label ~
                          (symbol), or a list (label offset).~%")
                    (mv nil svtv-chase-data state))
                   (svtv-chase-data (svtv-chase-goto (car args) (cadr args))))
                (mv nil svtv-chase-data state)))
             ((when (equal objname "O"))
              (b* (((unless (and (consp args)
                                 (not (cdr args))))
                    (cw! "O directive must be of the form (O name).~%")
                    (mv nil svtv-chase-data state))
                   (svtv-chase-data (svtv-chase-goto-output (car args))))
                (mv nil svtv-chase-data state)))
             ((when (equal objname "EXPR"))
              (b* (((unless (and (consp args)
                                 (acl2::maybe-natp (car args))
                                 (not (cdr args))))
                    (cw! "EXPR directive must be of the form (EXPR depth).~%")
                    (mv nil svtv-chase-data state)))
                (acl2::fmt-to-comment-window! "~x0~%"
                                              `((#\0 . ,(svtv-chase-data->expr svtv-chase-data)))
                                              0 (evisc-tuple (car args) nil nil nil) nil)
                (mv nil svtv-chase-data state)))
             ((when (equal objname "EV"))
              (b* (((unless (and (consp args)
                                 (not (cdr args))))
                    (cw! "EV directive must be of the form (EV term).~%")
                    (mv nil svtv-chase-data state))
                   (attachment (fgetprop 'simple-translate-and-eval-logic 'acl2::attachment nil (w state)))
                   ((unless (and attachment
                                 (alistp attachment)
                                 (eq (cdr (assoc-eq 'simple-translate-and-eval-logic attachment))
                                     'acl2::simple-translate-and-eval-cmp)))
                    (cw! "In order to use EV you must set ~x0 as the ~
                          attachment for ~x1, as in the following ~
                          form:~%~x2~%Note that to (mostly) undo this you may ~
                          do:~%~x3~%"
                         'acl2::simple-translate-and-eval-cmp
                         'simple-translate-and-eval-logic
                         '(setup-ev-for-chase)
                         '(unsetup-ev-for-chase))
                    (mv nil svtv-chase-data state))
                   ((mv err term-dot-val)
                    (simple-translate-and-eval-logic (car args) nil nil "The argument to EV"
                                                     'svtv-chase-rep (w state) state t nil nil))
                   ((when (or err (not (consp term-dot-val))))
                    (cw! "Failed to evaluate: ~@0~%" term-dot-val)
                    (mv nil svtv-chase-data state)))
                (cw! "~x0~%" (cdr term-dot-val))
                (mv nil svtv-chase-data state))))
          (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
          (mv nil svtv-chase-data state))))
    (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
    (mv nil svtv-chase-data state))
  ///
  (defret file-measure-of-svtv-chase-rep-weak
    (<= (file-measure *standard-oi* new-state)
        (file-measure *standard-oi* state))
    :rule-classes :linear)

  (defret file-measure-of-svtv-chase-rep-strong
    (implies (not exitp)
             (< (file-measure *standard-oi* new-state)
                (file-measure *standard-oi* state)))
    :rule-classes :linear)

  (defret open-input-channel-p1-of-<fn>
    (implies (open-input-channel-p1 *standard-oi* :object state)
             (open-input-channel-p1 *standard-oi* :object new-state)))
  
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->smartp*
                                               *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*
                                               *svtv-chase-data->print-with-mask-mode*
                                               *svtv-chase-data->print-overrides-mode*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))
    :hints(("Goal" :in-theory (enable member-equal)))))

  

(define svtv-chase-repl1 (&key
                         ((moddb moddb-ok) 'moddb)
                         (aliases 'aliases)
                         (svtv-chase-data 'svtv-chase-data)
                         (state 'state))
  :guard (and (open-input-channel-p *standard-oi* :object state)
              ;; (svarlist-addr-p (svexlist-collect-vars (svex-alist-vals (debugdata->override-assigns debugdata))))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (svtv-chase-data->modidx svtv-chase-data) moddb)
                  (aliass-length aliases))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap)
                       :do-not-induct t)))
  :returns (mv new-svtv-chase-data new-state)
  :measure (file-measure *standard-oi* state)
  :parents (svtv-chase)
  :short "Re-enter the @(see svtv-chase) read-eval-print loop, with no change to the environment or SVTV."
  (b* (((mv exitp svtv-chase-data state) (svtv-chase-rep))
       ((when exitp)
        (cw! "~%Exiting SVTV-CHASE.  You may execute ~x0 to re-enter or ~x1 ~
              to change the simulation inputs.~%"
             '(svtv-chase-repl) '(svtv-chase-update env))
        (mv svtv-chase-data state)))
    (svtv-chase-repl1))

  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->smartp*
                                               *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*
                                               *svtv-chase-data->print-with-mask-mode*
                                               *svtv-chase-data->print-overrides-mode*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))



; Matt K. mod to accommodate change to guards for fmt-hard-right-margin and
; fmt-soft-right-margin around August 2023.
(local (in-theory (enable acl2::all-boundp-initial-global-table)))

(verify-termination fmt-hard-right-margin)
(verify-termination fmt-soft-right-margin)


(local (defthm open-input-channel-p1-of-put-global
         (equal (open-input-channel-p1 channel type (put-global key val state))
                (open-input-channel-p1 channel type state))
         :hints(("Goal" :in-theory (enable open-input-channel-p1
                                           open-input-channels
                                           put-global
                                           update-global-table)))))

(local (in-theory (disable put-global)))

(define svtv-chase-repl (&key
                         ((moddb moddb-ok) 'moddb)
                         (aliases 'aliases)
                         (svtv-chase-data 'svtv-chase-data)
                         (state 'state))
  :guard (and (open-input-channel-p *standard-oi* :object state)
              (< (svtv-chase-data->modidx svtv-chase-data) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (svtv-chase-data->modidx svtv-chase-data) moddb)
                  (aliass-length aliases)))
  :prepwork ((local (in-theory (disable nth))))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable svtv-chase-datap)
                       :do-not-induct t)))
  :returns (mv new-svtv-chase-data new-state)

  ;; Just wraps svtv-chase-repl1 with a setting of the fmt margins.
  (b* ((hard (pos-fix (and (boundp-global 'fmt-hard-right-margin state)
                           (f-get-global 'fmt-hard-right-margin state))))
       (soft (pos-fix (and (boundp-global 'fmt-soft-right-margin state)
                           (f-get-global 'fmt-soft-right-margin state))))
       (state (set-fmt-hard-right-margin 200 state))
       (state (set-fmt-soft-right-margin 150 state))
       ((mv svtv-chase-data state) (svtv-chase-repl1))
       (state (set-fmt-soft-right-margin soft state))
       (state (set-fmt-hard-right-margin hard state)))
    (mv svtv-chase-data state))
  ///
  (defret nth-of-<fn>
    (implies (not (member-equal (nfix n) (list *svtv-chase-data->smartp*
                                               *svtv-chase-data->stack*
                                               *svtv-chase-data->sigtype*
                                               *svtv-chase-data->vars*
                                               *svtv-chase-data->expr*
                                               *svtv-chase-data->print-with-mask-mode*
                                               *svtv-chase-data->print-overrides-mode*)))
             (equal (nth n new-svtv-chase-data)
                    (nth n svtv-chase-data)))))


