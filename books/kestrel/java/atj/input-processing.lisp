; Java Library
;
; Copyright (C) 2019 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "JAVA")

(include-book "aij-notions")
(include-book "primitives")
(include-book "test-structures")

(include-book "kestrel/std/system/pure-raw-p" :dir :system)
(include-book "kestrel/std/system/rawp" :dir :system)
(include-book "kestrel/std/system/ubody" :dir :system)
(include-book "kestrel/std/system/unquote-term" :dir :system)
(include-book "kestrel/utilities/doublets" :dir :system)
(include-book "kestrel/utilities/er-soft-plus" :dir :system)
(include-book "kestrel/utilities/error-checking/top" :dir :system)
(include-book "kestrel/utilities/event-macros/xdoc-constructors" :dir :system)
(include-book "oslib/top" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-input-processing
 atj
 (xdoc::p
  "As part of input processing,
   we collect the names of all the ACL2 functions to be translated to Java,
   as determined by @('fn1'), ..., @('fnp').
   As we do that,
   we also check that they satisfy the constraints
   stated in the user documentation.")
 (xdoc::p
  "This collection and checking of the ACL2 functions
   is realized via a worklist algorithm.
   The worklist is initialized with @('fn1'), ..., @('fnp').
   At each step, a function @('fn') is taken from the worklist and processed.
   If @('fn') satisfies all the necessary constraints,
   it is added to a list of collected functions (which is initially empty);
   otherwise, we stop with an error.
   If @('fn') is defined,
   we collect the functions that occur in its defining body
   and add them to the worklist,
   except for those that are already in the worklist or in the collected list
   (so that we do not process the same function twice).
   Note that by adding @('fn') to the collected list
   before examining the functions that occur in its defining body,
   we ensure termination in the presence of
   (singly or mutually) recursive functions.
   We proceed like this until the worklist is empty (or an error occurs).
   If there are no errors, at the end
   we will have checked all the functions
   transitively called by @('fn1'), ..., @('fnp'),
   and the collected list will contain all the functions
   that must be translated to Java.
   This is the basic algorithm, but there are some complications,
   described in the following.")
 (xdoc::p
  "A complication arises from
   calls of @(tsee return-last) whose first argument is @('\'acl2::mbe1-raw'),
   which are calls of @(tsee mbe) in translated form.
   As explained in the user documentation,
   when the @(':guards') input of ATJ is @('nil'),
   the Java code generated by ATJ executes ``in the logic'',
   and in particular executes the @(':logic') parts of @(tsee mbe)s;
   when instead the @(':guards') input of ATJ is @('t'),
   the Java code generated by ATJ assumes the satisfaction of the guards,
   and in particular executes the @(':exec') parts of @(tsee mbe)s.
   Thus, when we recursively collect the functions
   from the body of a defined function,
   when we encounter these calls of @(tsee return-last),
   we selectively descend into the @(':logic') or @(':exec') part
   (based on the value of the @(':guards') input),
   ignoring the other part.")
 (xdoc::p
  "Another complication arises from
   calls of @(tsee return-last) whose first argument is @('\'acl2::progn'),
   which are calls of @(tsee prog2$) and @(tsee progn$) in translated form.
   As explained in the documentation,
   code is generated from the last argument only,
   but the other arguments must be checked to satisfy constraints as well.
   Thus, we use two worklists and two collected lists:
   one worklist and one collected list for the functions
   for which Java code must be generated,
   and one worklist and one collected list for the functions
   that must be only checked to satisfy the constraints.
   At the end of the iteration,
   the first collected list is used to generate Java code,
   while the second collected list is discarded;
   however, this second collected list is used during the iteration,
   to keep track of the functions already checked
   that do not appear in the worklists or in the first collected list.
   The function @('fn') is always taken from the first worklist,
   unless this worklist is empty, in which case it is taken from the second:
   in other words, the first worklist is processed first,
   and then the second one;
   the iteration terminates when both worklists are empty.")
 (xdoc::p
  "Yet another complication arises from
   calls of functions in @(tsee *atj-primitive-fns*),
   which are translated directly to Java primitive literals and operations
   when @(':deep') is @('nil') and @(':guards') is @('t').
   Under these conditions, when @('fn') is taken from a worklist,
   it is added to the collected list and its defining body is not examined;
   i.e. it is treated like a natively implemented function,
   which it is in a sense.")
 (xdoc::p
  "As an optimization, ACL2 functions natively implemented in Java,
   as well as functions in @(tsee *atj-primitive-fns*)
   if @(':deep') is @('nil') and @(':guards') is @('t'),
   are never added to the worklists and collected lists.
   This is because they are known to satisfy the necessary constraints,
   and they are terminal nodes in the call graph being traversed.
   In fact, the worklist is initialized
   with possibly a subset of @('fn1'), ..., @('fnp'),
   obtained by removing any natively implemented functions
   (while the ones in @(tsee *atj-primitive-fns*),
   when @(':deep') is @('nil') and @(':guards') is @('t'),
   are already ruled out by input validation).
   When descending into the defining of a function,
   natively implemented functions,
   and functions in @(tsee *atj-primitive-fns*) when applicable,
   are skipped over, not checked against worlists and collected lists,
   and not added to any worklist.")
 (xdoc::p
  "Further details and complications of the worklist algorithm
   are explained in the implementing functions."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-process-targets ((targets true-listp) deep guards ctx state)
  :returns (mv erp (result null) state)
  :short "Process the @('fn1'), ..., @('fnp') inputs."
  :long
  (xdoc::topstring
   (xdoc::p
    "Here we only check @('fn1'), ..., @('fnp') themselves.
     We collect and check the called functions
     after checking the remaining inputs;
     see @(tsee atj-process-inputs)."))
  (b* (((er &) (case (len targets)
                 (0 (er-soft+ ctx t nil
                              "At least one target function must be supplied."))
                 (1 (ensure-function-name$ (car targets)
                                           (msg "The ~x0 input" (car targets))
                                           t nil))
                 (t (ensure-list-functions$ targets
                                            (msg "The ~&0 inputs" targets)
                                            t nil))))
       ((er &) (ensure-list-no-duplicates$ targets
                                           (msg "The target functions ~&0"
                                                targets)
                                           t nil))
       ((unless (or (eq deep nil)
                    (eq guards t))) (value nil))
       (target-prims (intersection-eq targets *atj-primitive-fns*))
       ((when (null target-prims)) (value nil)))
    (er-soft+ ctx t nil
              "Since the :DEEP input is (perhaps by default) NIL ~
               and the :GUARDS input is T, ~
               ~@0."
              (if (= (len target-prims) 1)
                  (msg "the function ~x0 cannot be specified as target"
                       (car target-prims))
                (msg "the functions ~&0 cannot be specified as targets")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-process-java-package ((java-package) ctx state)
  :returns (mv erp (nothing null) state)
  :verify-guards nil
  :short "Process the @(':java-package') input."
  (b* (((er &) (ensure-string-or-nil$ java-package
                                      "The :JAVA-PACKAGE input"
                                      t nil))
       ((unless (or (null java-package)
                    (atj-string-ascii-java-package-name-p java-package)))
        (er-soft+ ctx t nil
                  "The :JAVA-PACKAGE input ~x0 is not ~
                   NIL or a valid Java package name ~
                   consisting of only ASCII characters."
                  java-package))
       ((when (equal java-package *aij-package*))
        (er-soft+ ctx t nil
                  "The :JAVA-PACKAGE input ~x0 must differ from ~
                   the name of the Java package of AIJ ~x1."
                  java-package *aij-package*)))
    (value nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atj-default-java-class*
  :short "Default Java class name to use if @(':java-class') is @('nil')."
  "Acl2Code"
  ///
  (assert-event (stringp *atj-default-java-class*)))

(define atj-process-java-class (java-class ctx state)
  :returns (mv erp
               (java-class$ "A @(tsee stringp).")
               state)
  :verify-guards nil
  :short "Process the @(':java-class') input."
  (b* (((er &) (ensure-string-or-nil$ java-class
                                      "The :JAVA-CLASS input"
                                      t nil))
       ((unless (or (null java-class)
                    (atj-string-ascii-java-identifier-p java-class)))
        (er-soft+ ctx t nil
                  "The :JAVA-CLASS input ~x0 is not ~
                   NIL or a valid Java class name ~
                   consisting of only ASCII characters."
                  java-class))
       (name (or java-class *atj-default-java-class*)))
    (value name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-ensure-terms-quoted-constants
  ((qcs pseudo-term-listp "@('qc1'), @('qc2'), etc.")
   (fn symbolp "The @('fn') in @('(fn qc1 qc2 ...)'); just for error messages.")
   (term "One of the test terms @('termj'); just for error messages.")
   ctx
   state)
  :returns (mv erp (nothing null) state)
  :short "Cause an error if
          any argument of the call @('(fn qc1 qc2 ...)')
          to which a test term translates
          is not a quoted constant."
  (b* (((when (endp qcs)) (value nil))
       (qc (car qcs))
       ((unless (quotep qc))
        (er-soft+ ctx t nil
                  "The term ~x0 that is an argument of ~
                   the function call (~x1 ...) that translates ~
                   the test term ~x2 in the :TESTS input, ~
                   must be a quoted constant."
                  qc fn term)))
    (atj-ensure-terms-quoted-constants (cdr qcs) fn term ctx state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-process-tests (tests
                           (targets$ symbol-listp)
                           (guards$ booleanp)
                           ctx
                           state)
  :returns (mv erp
               (tests$ "An @(tsee atj-test-listp).")
               state)
  :mode :program ; because of TRANS-EVAL
  :short "Process the @(':tests') input."
  :long
  (xdoc::topstring
   (xdoc::p
    "After evaluating @(':tests')
     and ensuring that the result is a list of doublets,
     we convert it into an alist and we ensure that the keys are unique.
     Then we process each pair in the alist.")
   (xdoc::p
    "For each pair in the alist,
     we first ensure that the name is a non-empty string
     consisting only of letters and digits.
     Then we translate the term (ensuring that the translation succeeds),
     and we ensure that it has the form @('(fn qc1 qc2 ...)'),
     where @('fn') is one of the target functions
     and @('qc1'), @('qc2'), etc. are quoted constants.
     (Note that these checks imply that the term is ground,
     so this condition does not need to be checked explicitly.)
     We unquote @('qc1'), @('qc2'), etc., obtaining a list of argument values.
     We evaluate the call @('(fn qc1 qc2 ...)'), obtaining a result value.
     We create an @(tsee atj-test) aggregate for each test."))
  (b* (((er (cons & tests)) (trans-eval tests ctx state nil))
       (description "The :TESTS input")
       ((er &) (ensure-doublet-list$ tests description t nil))
       (alist (doublets-to-alist tests))
       (names (strip-cars alist))
       (description (msg
                     "The list ~x0 of names of the tests in the :TESTS input"
                     names))
       ((er &) (ensure-list-no-duplicates$ names description t nil)))
    (atj-process-tests-aux alist targets$ guards$ ctx state))

  :prepwork
  ((define atj-process-tests-aux ((tests-alist alistp)
                                  (targets$ symbol-listp)
                                  (guards$ booleanp)
                                  ctx
                                  state)
     :returns (mv erp
                  tests$ ; ATJ-TEST-LISTP
                  state)
     :mode :program ; because of TRANS-EVAL
     :parents nil
     (b* (((when (endp tests-alist)) (value nil))
          ((cons (cons name term) tests-alist) tests-alist)
          ((er &) (ensure-string$ name
                                  (msg "The test name ~x0 in the :TESTS input"
                                       name)
                                  t nil))
          ((when (equal name ""))
           (er-soft+ ctx t nil "The test name ~x0 in the :TESTS input ~
                                cannot be the empty string." name))
          ((unless (chars-in-charset-p (explode name) (alpha/digit-chars)))
           (er-soft+ ctx t nil "The test name ~x0 in the :TESTS input ~
                                must contain only letters and digits." name))
          ((er (list term$ &))
           (ensure-term$ term
                         (msg "The test term ~x0 in the :TESTS input" term)
                         t nil))
          ((when (or (variablep term$)
                     (fquotep term$)
                     (flambda-applicationp term$)))
           (er-soft+ ctx t nil
                     "The test term ~x0 in the :TESTS input ~
                      must translate to ~
                      the application of a named function." term))
          (fn (ffn-symb term$))
          ((er &) (ensure-member-of-list$
                   fn
                   targets$
                   (msg "among the target functions ~&0." targets$)
                   (msg "The function ~x0 called by ~
                         the test term ~x1 in the :TESTS input"
                        fn term)
                   t nil))
          (qcs (fargs term$))
          ((er &) (atj-ensure-terms-quoted-constants qcs fn term ctx state))
          (args (unquote-term-list qcs))
          ((er &) (if guards$
                      (b* ((guard (subcor-var (formals fn (w state))
                                              qcs
                                              (uguard fn (w state))))
                           ((er (cons & guard-satisfied))
                            (trans-eval guard ctx state nil)))
                        (if (not guard-satisfied)
                            (er-soft+ ctx t nil
                                      "The test term ~x0 in the :TESTS input ~
                                       must translate to a function call ~
                                       where the guards are satisfied, ~
                                       because the :GUARDS input is T." term)
                          (value nil)))
                    (value nil)))
          ((er (cons & res)) (trans-eval term$ ctx state nil))
          (agg (atj-test name fn args res))
          ((er aggs)
           (atj-process-tests-aux tests-alist targets$ guards$ ctx state)))
       (value (cons agg aggs))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-process-output-dir (output-dir
                                (java-class$ stringp)
                                (tests$ atj-test-listp)
                                ctx
                                state)
  :returns (mv erp
               (result "A tuple @('(output-file$ output-file-test$)')
                        satisfying
                        @('(typed-tuplep stringp maybe-stringp)'),
                        where @('output-file$') is the path
                        of the generated main Java file,
                        and @('output-file-test$') is
                        @('nil') if the @(':tests') input is @('nil'),
                        otherwise it is the path
                        of the generated test Java file.")
               state)
  :verify-guards nil
  :short "Process the @(':output-dir') input."
  (b* (((er &) (ensure-string$ output-dir "The :OUTPUT-DIR input" t nil))
       ((mv err/msg kind state) (oslib::file-kind output-dir))
       ((when (or err/msg
                  (not (eq kind :directory))))
        (er-soft+ ctx t nil
                  "The output directory ~x0 is invalid."
                  output-dir))
       (file (oslib::catpath output-dir
                             (concatenate 'string java-class$ ".java")))
       ((er &) (b* (((mv err/msg exists state) (oslib::path-exists-p file))
                    ((when err/msg)
                     (er-soft+ ctx t nil
                               "The existence of the output path ~x0 ~
                                cannot be tested." file))
                    ((when (not exists)) (value :this-is-irrelevant))
                    ((mv err/msg kind state) (oslib::file-kind file))
                    ((when err/msg)
                     (er-soft+ ctx t nil
                               "The kind of the output path ~x0 ~
                                cannot be tested." file))
                    ((when (not (eq kind :regular-file)))
                     (er-soft+ ctx t nil
                               "The output path ~x0 ~
                                exists but is not a regular file." file)))
                 (value :this-is-irrelevant)))
       (file-test (if tests$
                      (oslib::catpath output-dir
                                      (concatenate 'string
                                                   java-class$
                                                   "Tests.java"))
                    nil))
       ((er &) (b* (((when (null file-test)) (value :this-is-irrelevant))
                    ((mv err/msg exists state) (oslib::path-exists-p file-test))
                    ((when err/msg)
                     (er-soft+ ctx t nil
                               "The existence of the output path ~x0 ~
                                cannot be tested." file-test))
                    ((when (not exists)) (value :this-is-irrelevant))
                    ((mv err/msg kind state) (oslib::file-kind file-test))
                    ((when err/msg)
                     (er-soft+ ctx t nil
                               "The kind of the output path ~x0 ~
                                cannot be tested." file-test))
                    ((when (not (eq kind :regular-file)))
                     (er-soft+ ctx t nil
                               "The output path ~x0 ~
                                exists but is not a regular file." file-test)))
                 (value :this-is-irrelevant))))
    (value (list file file-test))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defines atj-collect-fns-in-term
  :short "Collect all the functions in a term,
          in the course of the worklist algorithm."
  :long
  (xdoc::topstring
   (xdoc::p
    "See the "
    (xdoc::seetopic "atj-input-processing" "overview")
    " of the worklist algorithm first.")
   (xdoc::p
    "This is called on the defining body
     of the function removed from the worklist,
     and recursively on subterms of the defining body.")
   (xdoc::p
    "Besides the term, this function takes as arguments
     the two worklists and the two collected lists:
     the @('-gen') suffix stands for `generation',
     i.e. the functions for which Java code must be generated;
     the @('-chk') suffix stands for `checking',
     i.e. the functions that must be just checked.
     The collected lists are only used to see
     which of the functions encountered in the term
     have already been processed by the worklist algorithm.
     The worklists are updated as appropriate,
     and eventually returned.")
   (xdoc::p
    "This function also takes an argument flag @('gen?') saying whether
     we are examining a term from (a function from) the first worklist
     or a term from a function from (a function from) the second worklist.")
   (xdoc::p
    "Since variables and quoted constants contain no functions,
     we return the worklists unchanged in these cases.")
   (xdoc::p
    "Note that a term @('(mbe :logic a :exec b)')
     is translated to @('(return-last \'acl2::mbe1-raw b a)').
     Thus, when @(':guards') is @('nil')
     we descend into the third argument of @(tsee return-last),
     while when @(':guards') is @('t')
     we descend into the second argument of @(tsee return-last).")
   (xdoc::p
    "Note that a term @('(prog2$ a b)')
     is translated to @('(return-last \'acl2::progn a b)')
     (and @(tsee progn$) is translated into a nest of @(tsee prog2$)s).
     Thus, when we encounter this kind of call,
     when we descend into the argument @('a')
     we set the @('gen?') flag to @('nil'),
     while when we descend into the argument @('b')
     we leave the @('gen?') flag unchanged.")
   (xdoc::p
    "If we encounter a call of @(tsee return-last) of some other form,
     we immediately return because such other forms are not supported.
     In this case, the third result of the function is set to @('t'),
     so that the caller can immediately recognize the situation
     and cause the iteration to terminate.")
   (xdoc::p
    "If we encounter a call of anything other than @(tsee return-last),
     we recursively process the arguments,
     propagating any error signaled by the third result.")
   (xdoc::p
    "If the call is of a lambda expression,
     we conclude by recursively processing
     the body of the lambda expression.")
   (xdoc::p
    "Otherwise, the call is of a named function (not @(tsee return-last)).
     If it is a natively implemented function,
     or in @(tsee *atj-primitive-fns*) when applicable,
     we do not add it to the worklist,
     because it satisfies all the necessary constraints
     and does not have a defining body to be inspected.
     Otherwise, we add the function to the appropriate worklist
     (the exact worklist is determined by the @('gen?') flag),
     unless it is already there or in a collected list.
     If @('gen?') is @('t') and the function is already
     in @('worklist-chk') or @('collected-chk')
     but not in @('worklist-gen') or @('collected-gen'),
     we need to add it to @('worklist-gen') nonetheless,
     because it must eventually end up in @('collected-gen')
     in order to generate code for it.
     Thus, if @('gen?') is @('t'),
     we only check it against @('worklist-gen') and @('collected-gen'),
     and if we add it to @('worklist-gen')
     we also remove it from @('worklist-chk') if present there
     (with @(tsee remove1) because worklists never have duplicates;
     if it is not present, no change to @('worklist-chk') occurs),
     so that the function is not processed again.
     We do not need to remove the function from @('collected-chk')
     because, when @('gen?') is @('t'), that collected list is always empty:
     the reason is that the iteration
     first processes @('worklist-gen') completely
     (during this processing @('gen?') is @('t')),
     keeping @('collected-chk') empty,
     and then it processes @('worklist-chk'),
     and it is during this processing (when @('gen?') is thus @('nil'))
     that @('collected-chk') gets populated."))

  (define atj-collect-fns-in-term ((term pseudo-termp)
                                   (gen? booleanp)
                                   (worklist-gen symbol-listp)
                                   (worklist-chk symbol-listp)
                                   (collected-gen symbol-listp)
                                   (collected-chk symbol-listp)
                                   (deep$ booleanp)
                                   (guards$ booleanp))
    :returns (mv (new-worklist-gen symbol-listp :hyp :guard)
                 (new-worklist-chk symbol-listp :hyp :guard)
                 (unsuppported-return-last? booleanp))
    (b* (((when (variablep term)) (mv worklist-gen worklist-chk nil))
         ((when (fquotep term)) (mv worklist-gen worklist-chk nil))
         (fn (ffn-symb term))
         ((when (and (eq fn 'return-last)
                     (quotep (fargn term 1)))) ; this should be always true
          (b* ((1st-arg (fargn term 1)))
            (case (unquote 1st-arg)
              (acl2::mbe1-raw (if guards$
                                  (atj-collect-fns-in-term (fargn term 2)
                                                           gen?
                                                           worklist-gen
                                                           worklist-chk
                                                           collected-gen
                                                           collected-chk
                                                           deep$
                                                           guards$)
                                (atj-collect-fns-in-term (fargn term 3)
                                                         gen?
                                                         worklist-gen
                                                         worklist-chk
                                                         collected-gen
                                                         collected-chk
                                                         deep$
                                                         guards$)))
              (acl2::progn (b* (((mv worklist-gen
                                     worklist-chk
                                     unsuppported-return-last?)
                                 (atj-collect-fns-in-term (fargn term 2)
                                                          nil
                                                          worklist-gen
                                                          worklist-chk
                                                          collected-gen
                                                          collected-chk
                                                          deep$
                                                          guards$))
                                ((when unsuppported-return-last?)
                                 (mv worklist-gen worklist-chk t)))
                             (atj-collect-fns-in-term (fargn term 3)
                                                      gen?
                                                      worklist-gen
                                                      worklist-chk
                                                      collected-gen
                                                      collected-chk
                                                      deep$
                                                      guards$)))
              (t (mv worklist-gen worklist-chk t)))))
         ((mv worklist-gen worklist-chk unsupported-return-last?)
          (atj-collect-fns-in-terms (fargs term)
                                    gen?
                                    worklist-gen
                                    worklist-chk
                                    collected-gen
                                    collected-chk
                                    deep$
                                    guards$))
         ((when unsupported-return-last?) (mv worklist-gen worklist-chk t))
         ((when (flambdap fn)) (atj-collect-fns-in-term (lambda-body fn)
                                                        gen?
                                                        worklist-gen
                                                        worklist-chk
                                                        collected-gen
                                                        collected-chk
                                                        deep$
                                                        guards$))
         ((when (aij-nativep fn)) (mv worklist-gen worklist-chk nil))
         ((when (and (eq deep$ nil)
                     (eq guards$ t)
                     (member-eq fn *atj-primitive-fns*)))
          (mv worklist-gen worklist-chk nil)))
      (if gen?
          (if (or (member-eq fn worklist-gen)
                  (member-eq fn collected-gen))
              (mv worklist-gen worklist-chk nil)
            (mv (cons fn worklist-gen)
                (remove1-eq fn worklist-chk)
                nil))
        (if (or (member-eq fn worklist-gen)
                (member-eq fn worklist-chk)
                (member-eq fn collected-gen)
                (member-eq fn collected-chk))
            (mv worklist-gen worklist-chk nil)
          (mv worklist-gen
              (cons fn worklist-chk)
              nil)))))

  (define atj-collect-fns-in-terms ((terms pseudo-term-listp)
                                    (gen? booleanp)
                                    (worklist-gen symbol-listp)
                                    (worklist-chk symbol-listp)
                                    (collected-gen symbol-listp)
                                    (collected-chk symbol-listp)
                                    (deep$ booleanp)
                                    (guards$ booleanp))
    :returns (mv (new-worklist-gen symbol-listp :hyp :guard)
                 (new-worklist-chk symbol-listp :hyp :guard)
                 (unsuppported-return-last? booleanp))
    (b* (((when (endp terms)) (mv worklist-gen worklist-chk nil))
         ((mv worklist-gen worklist-chk unsuppported-return-last?)
          (atj-collect-fns-in-term (car terms)
                                   gen?
                                   worklist-gen
                                   worklist-chk
                                   collected-gen
                                   collected-chk
                                   deep$
                                   guards$))
         ((when unsuppported-return-last?) (mv worklist-gen worklist-chk t)))
      (atj-collect-fns-in-terms (cdr terms)
                                gen?
                                worklist-gen
                                worklist-chk
                                collected-gen
                                collected-chk
                                deep$
                                guards$)))

  :prepwork
  ((defrule returns-lemma
     (implies (symbol-listp x)
              (symbol-listp (remove1-equal a x)))))

  :verify-guards nil ; done below
  ///
  (verify-guards atj-collect-fns-in-term
    :hints (("Goal" :expand (pseudo-termp term)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-worklist-iterate ((worklist-gen symbol-listp)
                              (worklist-chk symbol-listp)
                              (collected-gen symbol-listp)
                              (collected-chk symbol-listp)
                              (deep$ booleanp)
                              (guards$ booleanp)
                              (verbose$ booleanp)
                              ctx
                              state)
  :returns (mv erp
               (fns "A @(tsee symbol-listp).")
               state)
  :mode :program ; because termination takes a bit of work
  :short "Worklist algorithm iteration."
  :long
  (xdoc::topstring
   (xdoc::p
    "See the "
    (xdoc::seetopic "atj-input-processing" "overview")
    " of the worklist algorithm first.")
   (xdoc::p
    "The iteration ends when both worklists are empty.
     When that happens, we return the collected list of functions
     for which code must be generated.")
   (xdoc::p
    "We always pick the next function from @('worklist-gen'),
     until it is empty; then we switch to @('worklist-chk').
     Since we start with all empty lists except @('worklist-gen')
     (see the caller of this function),
     as we go through @('worklist-gen') we may populate
     @('collected-gen') and @('worklist-chk'),
     but not @('collected-chk').
     When we go through @('worklist-chk'),
     we may further populate @('collected-chk'),
     but not @('worklist-gen') or @('collected-gen').")
   (xdoc::codeblock
    "Initial lists:"
    "  (...) () () ()"
    "After processing the first worklist:"
    "  () (...) (...) ()"
    "After processing the second worklist:"
    "  () () (...) (...)")
   (xdoc::p
    "The iteration terminates because
     there is a finite number of functions in the ACL2 world,
     but for simplicity we leave this function in program mode
     to avoid having to articulate the termination proof.")
   (xdoc::p
    "Note that, as explained in the overview of the algorithm,
     functions natively implemented, which include the ACL2 primitive functions,
     never appear in the worklists and collected lists.
     Thus, when we encounter a function without an unnormalized body,
     we stop with an error.")
   (xdoc::p
    "If the function satisfies all the needed constraints,
     its name is printed in verbose mode.
     The caller of this function precedes this printing
     with a suitable message (see the caller).")
   (xdoc::p
    "It should be an invariant that there are no duplicate function symbols
     in the four lists (worklists and collected lists) altogether;
     i.e. each list is free of duplicates,
     and the lists are pairwise disjoint.")
   (xdoc::p
    "Note that since @(tsee atj-collect-fns-in-term)
     extends the worklists via @(tsee cons),
     and since the fixpoint iteration picks the next function via @(tsee car),
     we visit the call graph depth-first;
     the worklists are used as stacks."))
  (b* (((when (and (endp worklist-gen)
                   (endp worklist-chk))) (value collected-gen))
       ((mv fn
            gen?
            worklist-gen
            worklist-chk) (if (consp worklist-gen)
                              (mv (car worklist-gen)
                                  t
                                  (cdr worklist-gen)
                                  worklist-chk)
                            (mv (car worklist-chk)
                                nil
                                worklist-gen
                                (cdr worklist-chk))))
       ((when (and (rawp fn state)
                   (not (pure-raw-p fn))))
        (er-soft+ ctx t nil
                  "The function ~x0 has raw Lisp code ~
                   and is not in the whitelist; ~
                   therefore, code generation cannot proceed." fn))
       ((unless (no-stobjs-p fn (w state)))
        (er-soft+ ctx t nil
                  "The function ~x0 has input or output stobjs; ~
                   therefore, code generation cannot proceed." fn))
       (body (ubody fn (w state)))
       ((unless body)
        (er-soft+ ctx t nil
                  "The function ~x0 has no unnormalized body; ~
                   therefore, code generation cannot proceed." fn))
       ((run-when verbose$)
        (cw "  ~x0~%" fn))
       ((mv collected-gen
            collected-chk) (if gen?
                               (mv (cons fn collected-gen)
                                   collected-chk)
                             (mv collected-gen
                                 (cons fn collected-chk))))
       ((mv worklist-gen worklist-chk unsuppported-return-last?)
        (atj-collect-fns-in-term body
                                 gen?
                                 worklist-gen
                                 worklist-chk
                                 collected-gen
                                 collected-chk
                                 deep$
                                 guards$))
       ((when unsuppported-return-last?)
        (er-soft+ ctx t nil
                  "The function RETURN-LAST is used ~
                   with an unsupported first argument; ~
                   therefore, code generation cannot proceed.")))
    (atj-worklist-iterate worklist-gen
                          worklist-chk
                          collected-gen
                          collected-chk
                          deep$
                          guards$
                          verbose$
                          ctx state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-fns-to-translate ((targets$ symbol-listp)
                              (deep$ booleanp)
                              (guards$ booleanp)
                              (verbose$ booleanp)
                              ctx
                              state)
  :returns (mv erp
               (fns-to-translate "A @(tsee symbol-listp).")
               state)
  :mode :program ; because of ATJ-WORKLIST-ITERATE
  :short "Collect the names of all the ACL2 functions to be translated to Java,
          checking that they satisfy all the necessary constraints."
  :long
  (xdoc::topstring
   (xdoc::p
    "See the "
    (xdoc::seetopic "atj-input-processing" "overview")
    " of the worklist algorithm first.")
   (xdoc::p
    "We start the worklist iteration with the targets supplied by the user,
     minus any natively implemented function,
     as discussed in the overview.
     Currently the natively implemented functions
     are exactly the ACL2 primitive functions.")
   (xdoc::p
    "The returned list of function names should have no duplicates,
     but we double-check that for robustness.
     The list is in no particular order."))
  (b* (((run-when verbose$)
        (cw "~%ACL2 functions to translate to Java:~%"))
       (worklist-gen (set-difference-eq
                      targets$
                      (strip-cars *primitive-formals-and-guards*)))
       ((er fns) (atj-worklist-iterate worklist-gen
                                       nil
                                       nil
                                       nil
                                       deep$
                                       guards$
                                       verbose$
                                       ctx
                                       state))
       ((unless (no-duplicatesp-eq fns))
        (value (raise "Internal error: ~
                       the list ~x0 of collected function names ~
                       has duplicates."
                      fns))))
    (value fns)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-pkgs-to-translate ((verbose$ booleanp) state)
  :returns (pkgs "A @(tsee string-listp).")
  :verify-guards nil
  :short "Collect all the ACL2 packages to be translated to Java."
  :long
  (xdoc::topstring
   (xdoc::p
    "Here `translate to Java' really means `build a Java representation of'.")
   (xdoc::p
    "For now we return all the current packages.
     In the future, it might be possible to reduce them
     to just the ones referenced by the functions to be translated to Java."))
  (b* ((pkgs (known-packages state))
       ((run-when verbose$)
        (cw "~%Known ACL2 packages:~%")
        (atj-show-pkgs pkgs)))
    pkgs)

  :prepwork
  ((define atj-show-pkgs ((pkgs string-listp))
     :returns (nothing null)
     :parents nil
     (if (endp pkgs)
         nil
       (b* ((- (cw "  ~s0~%" (car pkgs))))
         (atj-show-pkgs (cdr pkgs)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atj-allowed-options*
  :short "Keyword options accepted by @(tsee atj)."
  (list :deep
        :guards
        :java-package
        :java-class
        :output-dir
        :tests
        :verbose)
  ///
  (assert-event (symbol-listp *atj-allowed-options*))
  (assert-event (no-duplicatesp-eq *atj-allowed-options*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define atj-process-inputs ((args true-listp) ctx state)
  :returns (mv erp
               (result "A tuple @('(fns-to-translate
                                    pkgs
                                    deep$
                                    guards$
                                    java-package$
                                    java-class$
                                    output-file$
                                    output-file-test$
                                    tests$
                                    verbose$)')
                        satisfying
                        @('(typed-tuplep symbol-listp
                                         string-listp
                                         booleanp
                                         booleanp
                                         maybe-stringp
                                         stringp
                                         stringp
                                         maybe-stringp
                                         atj-test-listp
                                         booleanp
                                         result)'),
                        where @('fns-to-translate') are the functions
                        to be translated to Java,
                        @('pkgs') are the packages
                        whose representation must be built in Java,
                        @('deep$') is the @(':deep') input,
                        @('guards$') is the @(':guards') input,
                        @('java-package$') is the @(':java-package') input,
                        @('java-class$) is the result of
                        @(tsee atj-process-java-class),
                        @('output-file$') and @('output-file-test$')
                        are the result of (tsee atj-process-output-dir),
                        @('tests$') is the result of
                        @(tsee atj-process-tests), and
                        @('verbose$') is the @(':verbose') input.")
               state)
  :mode :program ; because of ATJ-FNS-TO-TRANSLATE and ATJ-PROCESS-TESTS
  :short "Ensure that the inputs to @(tsee atj) are valid."
  :long
  (xdoc::topstring
   (xdoc::p
    "We process the inputs in order,
     except that @(':output-dir') is processed after @(':tests')
     because the result of processing the latter
     is used in processing the former.")
   (xdoc::p
    "We also collect, check, and return the functions
     for which code must be generated.
     We also collect and return the packages
     whose representation must be built in Java;
     for now these are all the current packages,
     but it might be possible to reduce them
     to just the ones referenced by the functions."))
  (b* (((mv erp targets options) (partition-rest-and-keyword-args
                                  args *atj-allowed-options*))
       ((when erp) (er-soft+ ctx t nil
                             "The inputs must be the names of ~
                              one or more target functions ~
                              followed by the options ~&0."
                             *atj-allowed-options*))
       (deep (cdr (assoc-eq :deep options)))
       (guards (cdr (assoc-eq :guards options)))
       (java-package (cdr (assoc-eq :java-package options)))
       (java-class (cdr (assoc-eq :java-class options)))
       (output-dir (or (cdr (assoc-eq :output-dir options)) "."))
       (tests (cdr (assoc-eq :tests options)))
       (verbose (cdr (assoc-eq :verbose options)))
       ((er &) (atj-process-targets targets deep guards ctx state))
       ((er &) (ensure-boolean$ deep "The :DEEP intput" t nil))
       ((er &) (ensure-boolean$ guards "The :GUARDS intput" t nil))
       ((er &) (atj-process-java-package java-package ctx state))
       ((er java-class$) (atj-process-java-class java-class ctx state))
       ((er tests$) (atj-process-tests tests targets guards ctx state))
       ((er (list output-file$
                  output-file-test$)) (atj-process-output-dir
                                       output-dir java-class$ tests$ ctx state))
       ((er &) (ensure-boolean$ verbose "The :VERBOSE input" t nil))
       ((er fns-to-translate) (atj-fns-to-translate
                               targets deep guards verbose ctx state))
       (pkgs (atj-pkgs-to-translate verbose state)))
    (value (list fns-to-translate
                 pkgs
                 deep
                 guards
                 java-package
                 java-class$
                 output-file$
                 output-file-test$
                 tests$
                 verbose))))
