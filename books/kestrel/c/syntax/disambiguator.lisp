; C Library
;
; Copyright (C) 2024 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (www.alessandrocoglio.info)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "C$")

(include-book "abstract-syntax-operations")
(include-book "unambiguity")

(include-book "std/util/error-value-tuples" :dir :system)

(local (include-book "std/alists/top" :dir :system))

(local (include-book "kestrel/built-ins/disable" :dir :system))
(local (acl2::disable-most-builtin-logic-defuns))
(local (acl2::disable-builtin-rewrite-rules-for-defaults))
(set-induction-depth-limit 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ disambiguator
  :parents (syntax-for-tools)
  :short "Disambiguator of the C abstract syntax for tools."
  :long
  (xdoc::topstring
   (xdoc::p
    "As discussed in the "
    (xdoc::seetopic "abstract-syntax" "abstract syntax")
    ", the syntax of C is inherently syntactically ambiguous,
     in ways that can be disambiguated only via a (static) semantic analysis.
     Here we define such semantic analysis, which we call `disambiguator'.
     The disambiguator does not check the full static validity of the code,
     but it performs sufficient checks to disambiguate
     the abstract syntax trees generated by the @(see parser).
     The disambiguator transforms the abstract syntax trees,
     generating unambiguous ones.")
   (xdoc::p
    "The abstract syntax trees generated by the parser
     contains the following ambiguities,
     which the disambiguator resolves as indicated:")
   (xdoc::ul
    (xdoc::li
     "Identifiers used as expressions
      are always classified as identifier expressions
      (i.e. the @(':ident') case of @(tsee expr))
      by the parser,
      but some of them may be enumeration constants.
      The disambiguator re-classifies the latter as required.")
    (xdoc::li
     "Some constructs include ambiguous expressions or type names,
      represented by the type @(tsee amb-expr/tyname).
      The disambiguator turns those constructs into unambiguous ones,
      by choosing either an expression or a type name.")
    (xdoc::li
     "Some constructs include ambiguous declarators or abstract declarators,
      represented by the type @(tsee amb-declor/absdeclor).
      The disambiguator turns those constructs into unambiguous ones,
      by choosing either a declarator or an abstract declarator.")
    (xdoc::li
     "Some constructs include ambiguous declarations or statements,
      represented by the type @(tsee amb-decl/stmt).
      The disambiguator turns those constructs into unambiguous ones,
      by choosing either a declaration or a statement.")
    (xdoc::li
     "Function declarators whose parameters are all identifiers
      are always classified as parameter type lists by the parser,
      but some of them may be identifier lists.
      The disambiguator re-classifies the latter as required.")
    (xdoc::li
     "Some expressions may be cast expressions or binary expressions,
      represented by the @(':cast/...-ambig') cases of @(tsee expr).
      The disambiguator turns these into
      unambiguous case or binary expressions.")
    (xdoc::li
     "The initializing part of a @('for') loop may be ambiguously
      a declaration or an expression followed by a semicolon,
      represented by the @(':for-ambig') case of @(tsee stmt).
      The disambiguator turns these ambiguous @('for') loops
      into unambiguous ones."))
   (xdoc::p
    "The disambiguator does not perform a full (static) semantic analysis,
     but only a light-weight one, enough for disambiguation.
     If the code is statically valid, the disambiguation must work.
     If the code is not statically valid, the disambiguation may fail;
     in some cases, the disambiguator reports the cause of invalidity,
     but in other cases it may not have enough information.")
   (xdoc::p
    "The disambiguation is performed by scanning the code,
     transforming it as applicable (re-classifying or choosing constructs).
     This needs certain information about the identifiers in the code,
     which we build and use.
     For instance, when we encounter an enumeration specifier,
     we need to record the information that the identifiers of the enumerators
     are enumeration constants,
     so that, if we later encounter an expression with that identifier,
     we can re-classify from an identifier expression to an enumeration constant
     (this is the first of the ambiguities listed above).
     In essence, we need a symbol table of identifiers;
     not a full one that would be needed to check the full validity of the code,
     but one with sufficient information to disambiguate.
     We need to take into account the scoping rules of C of course,
     since the same identifier
     may have different meaning in different scopes.
     We call these symbol tables `disambiguation tables'.")
   (xdoc::p
    "We use "
    (xdoc::seetopic "acl2::error-value-tuples" "error-value tuples")
    " to handle errors in the disambiguator.")
   (xdoc::p
    "The fixtype and functions in the implementation of the disambiguator
     are prefixed by @('dimb'), which stands for `DIsaMBiguator'.")
   (xdoc::p
    "For now we leave the GCC extensions unchanged,
     i.e. we do not apply the disambiguation to them,
     even though they may contain expression.
     Some initial experiments reveal that we will need to
     treat these GCC extensions in a more dedicated way.
     For instance, the @('access') attribute may include
     the arguments @('read_only'), @('write_only'), and @('read_write').
     Grammatically these are expressions,
     but it seems that they have just a special meaning, like keywords,
     in the context of the @('access') attribute,
     but they are likely not keywords elsewhere.
     A naive treatment would attempt to resolve those arguments,
     which are not in the disambiguation table."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::deftagsum dimb-kind
  :short "Fixtype of kinds of identifiers in disambiguation tables."
  :long
  (xdoc::topstring
   (xdoc::p
    "For each identifier in the disambiguation table,
     we track whether the identifier
     (i) a @('typedef') name, or
     (ii) an object or function, or
     (iii) an enumeration constant.
     Not all identifiers fit these categories;
     for instance, structure and union tags correspond to none of the above.
     However, for disambiguation purposes,
     we do not need to track all identifiers,
     but just the kinds just listed.
     Note also that we do not need to distinguish between objects and functions,
     as they are treated the same for disambiguation purposes."))
  (:typedef ())
  (:objfun ())
  (:enumconst ())
  :pred dimb-kindp)

;;;;;;;;;;

(defirrelevant irr-dimb-kind
  :short "An irrelevant kind of identifiers in disambiguation tables."
  :type dimb-kindp
  :body (dimb-kind-typedef))

;;;;;;;;;;;;;;;;;;;;

(fty::defoption dimb-kind-option
  dimb-kind
  :short "Fixtype of optional kinds of identifiers in disambiguation tables."
  :long
  (xdoc::topstring
   (xdoc::p
    "Kinds of identifiers in disambiguation tables
     are defined in @(tsee dimb-kind)."))
  :pred dimb-kind-optionp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::defalist dimb-scope
  :short "Fixtype of scopes in disambiguation tables."
  :long
  (xdoc::topstring
   (xdoc::p
    "An identifier may have different meanings in different scopes,
     but it must have one meaning within the same scope.
     Thus, we represent scopes as alists from identifiers to their kinds."))
  :key-type ident
  :val-type dimb-kind
  :true-listp t
  :keyp-of-nil nil
  :valp-of-nil nil
  :pred dimb-scopep
  :prepwork ((set-induction-depth-limit 1))

  ///

  (defrule dimb-kindp-of-cdr-of-assoc-equal-when-dimb-scopep
    (implies (dimb-scopep scope)
             (iff (dimb-kindp (cdr (assoc-equal ident scope)))
                  (assoc-equal ident scope)))
    :induct t
    :enable (dimb-scopep assoc-equal)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::deflist dimb-table
  :short "Fixtype of disambiguation tables."
  :long
  (xdoc::topstring
   (xdoc::p
    "A disambiguation table associates kinds to identifiers,
     with the mapping organized into scopes.
     Starting from the outer scope,
     i.e. the file scope [C:6.2.1/4],
     traversing the code enters and exits
     block scopes and prototype scopes [C:6.2.1/4],
     in a stack-like fashion.
     So we represent a disambiguation table as
     a list of disambiguation scopes.")
   (xdoc::p
    "The list should be never empty,
     but using @(':non-emptyp t') in this fixtype
     generates a false subgoal.
     It should be possible to improve @(tsee fty::deflist)
     to work with this option in this fixtype,
     but for now we just allow empty lists in the fixtype."))
  :elt-type dimb-scope
  :true-listp t
  :elementp-of-nil t
  :pred dimb-tablep
  :prepwork ((local (in-theory (enable nfix)))))

;;;;;;;;;;;;;;;;;;;;

(defirrelevant irr-dimb-table
  :short "An irrelevant disambiguation table."
  :type dimb-tablep
  :body nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-init-table ()
  :returns (table dimb-tablep)
  :short "Initial disambiguation table."
  :long
  (xdoc::topstring
   (xdoc::p
    "This consists of a single empty scope,
     which is the file scope.
     We use one disambiguation table for each translation unit."))
  (list nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-push-scope ((table dimb-tablep))
  :returns (new-table dimb-tablep)
  :short "Push a scope into the disambiguation table."
  :long
  (xdoc::topstring
   (xdoc::p
    "We add an empty scope.
     The top of the stack is on the left,
     so we push via @(tsee cons).
     Also see @(tsee dimb-pop-scope)."))
  (cons nil (dimb-table-fix table))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-pop-scope ((table dimb-tablep))
  :returns (new-table dimb-tablep)
  :short "Pop a scope from the disambiguation table."
  :long
  (xdoc::topstring
   (xdoc::p
    "It is an internal error if the table is empty;
     it should never be empty.
     We should replace this with guards and proofs.")
   (xdoc::p
    "We remove the top scope, via @(tsee cdr).
     Recall that the stack top is on the left;
     see @(tsee dimb-push-scope)."))
  (if (consp table)
      (dimb-table-fix (cdr table))
    (raise "Internal error: empty disambiguation table."))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-lookup-ident ((ident identp) (table dimb-tablep))
  :returns (kind? dimb-kind-optionp)
  :short "Look up an identifier in the disambiguation table."
  :long
  (xdoc::topstring
   (xdoc::p
    "According the visibility and hiding rules [C:6.2.1/2],
     we look up the identifier starting from the innermost scope.
     We stop as soon as we find a match.
     We return @('nil') if we reach the outermost scope
     without finding a match."))
  (b* (((when (endp table)) nil)
       (scope (dimb-scope-fix (car table)))
       (ident+kind (assoc-equal (ident-fix ident) scope))
       ((when ident+kind) (dimb-kind-fix (cdr ident+kind))))
    (dimb-lookup-ident ident (cdr table)))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-add-ident ((ident identp) (kind dimb-kindp) (table dimb-tablep))
  :returns (new-table dimb-tablep)
  :short "Add an identifier and its kind to the disambiguation table."
  :long
  (xdoc::topstring
   (xdoc::p
    "It is an internal error if the table is empty;
     it should never be empty.
     We should replace this with guards and proofs.")
   (xdoc::p
    "We add the identifier to the innermost (i.e. top) scope.
     If the identifier is already in the innermost scope,
     we override its mapping with the new one.
     This is necessary to handle re-declarations of the same identifier,
     which are allowed under suitable conditions;
     in particular, the kind of the identifier should not change.
     But we override the mapping unconditionally,
     even if the new kind differs from the old kind:
     this situation should only happen with invalid code,
     in which case it does not matter how we disambiguate it exactly."))
  (b* (((when (endp table))
        (raise "Internal error: empty disambiguation table."))
       (scope (dimb-scope-fix (car table)))
       (new-scope (acons (ident-fix ident) (dimb-kind-fix kind) scope))
       (new-table (cons new-scope (cdr table))))
    (dimb-table-fix new-table))
  :guard-hints (("Goal" :in-theory (enable acons)))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-cast/call-to-cast ((tyname tynamep)
                                (inc/dec inc/dec-op-listp)
                                (arg exprp))
  :returns (cast-expr exprp)
  :short "Disambiguate an ambiguous cast or call expression
          to be a cast expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "The form @('(X) IncDec (E)Pr') of an ambiguous call or cast expression
     is described in detail in @(tsee expr): refer to that description.
     This ambiguous expression is disambiguated in @(tsee dimb-expr),
     by first disambiguating whether @('X') is a type name or an expression.
     Based on that, the constituents of that ambiguous expression
     must be re-arranged into an unambiguous expression:
     this is done by this function,
     for the case in which @('X') is a type name.
     The case in which @('X') is an expression
     is handled in @(tsee dimb-cast/call-to-call).")
   (xdoc::p
    "In this function,
     @('tyname') is @('X'),
     @('inc/dec') is @('IncDec'), and
     @('arg') is @('(E)Pr').
     If @('X') is a type name,
     the increment and decrement operators, if any,
     are pre-increment and pre-decrement operators
     applied to the expression @('(E)Pr').
     We apply them and we form a cast expression."))
  (make-expr-cast :type tyname
                  :arg (apply-pre-inc/dec-ops inc/dec arg))
  :hooks (:fix)

  ///

  (defret expr-unambp-of-dimb-cast/call-to-cast
    (expr-unambp cast-expr)
    :hyp (and (tyname-unambp tyname)
              (expr-unambp arg))))

;;;;;;;;;;;;;;;;;;;;

(define dimb-cast/call-to-call ((fun exprp)
                                (inc/dec inc/dec-op-listp)
                                (rest exprp))
  :returns (call-expr exprp)
  :short "Disambiguate an ambiguous cast or call expression
          to be a call expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "The form @('(X) IncDec (E)Pr') of an ambiguous call or cast expression
     is described in detail in @(tsee expr): refer to that description.
     This ambiguous expression is disambiguated in @(tsee dimb-expr),
     by first disambiguating whether @('X') is a type name or an expression.
     Based on that, the constituents of that ambiguous expression
     must be re-arranged into an unambiguous expression:
     this is done by this function,
     for the case in which @('X') is an expression.
     The case in which @('X') is a type name
     is handled in @(tsee dimb-cast/call-to-call).")
   (xdoc::p
    "In this function,
     @('fun') is @('X'),
     @('inc/dec') is @('IncDec'), and
     @('rest') is @('(E)Pr').
     If @('X') is an expression,
     the increment and decrement operators, if any,
     are post-increment and post-decrement operators
     applied to the expression @('X').
     We apply them and we form a call expression.
     To do so, we need to separate @('(E)') and @('Pr'),
     turn @('(E)') into @('(E1,...,En)') according to the comma operators,
     and then apply the @('Pr') to the call @('(X)(E1,...,En)').")
   (xdoc::p
    "We perform the latter transformation via a recursion,
     because we need to go through the individual postfix constructs of @('Pr'),
     till we reach @('(E)'),
     and then we re-apply the postfix constructs of @('Pr')."))
  (b* ((fun (expr-paren fun))
       (fun (apply-post-inc/dec-ops fun inc/dec)))
    (dimb-cast/call-to-call-loop fun rest))
  :hooks (:fix)

  :prepwork

  ((define dimb-cast/call-to-call-loop ((fun exprp) (rest exprp))
     :returns (new-expr exprp)
     :parents nil
     (b* (((when (expr-case rest :paren))
           (b* ((args (expr-to-asg-expr-list (expr-paren->unwrap rest))))
             (make-expr-funcall :fun fun :args args)))
          ((when (expr-case rest :arrsub))
           (b* ((expr
                 (dimb-cast/call-to-call-loop fun (expr-arrsub->arg1 rest))))
             (make-expr-arrsub :arg1 expr :arg2 (expr-arrsub->arg2 rest))))
          ((when (expr-case rest :funcall))
           (b* ((expr
                 (dimb-cast/call-to-call-loop fun (expr-funcall->fun rest))))
             (make-expr-funcall :fun expr :args (expr-funcall->args rest))))
          ((when (expr-case rest :member))
           (b* ((expr
                 (dimb-cast/call-to-call-loop fun (expr-member->arg rest))))
             (make-expr-member :arg expr :name (expr-member->name rest))))
          ((when (expr-case rest :memberp))
           (b* ((expr
                 (dimb-cast/call-to-call-loop fun (expr-memberp->arg rest))))
             (make-expr-memberp :arg expr :name (expr-memberp->name rest)))))
       (prog2$
        (raise "Internal error: unexpected expression ~x0." (expr-fix fun))
        (irr-expr)))
     :measure (expr-count rest)
     :hints (("Goal" :in-theory (enable o< o-finp)))
     :verify-guards :after-returns
     :hooks (:fix)

     ///

     (defret expr-unambp-of-dimb-cast/call-to-call-loop
       (expr-unambp new-expr)
       :hyp (and (expr-unambp fun)
                 (expr-unambp rest))
       :hints (("Goal" :induct t :in-theory (enable irr-expr))))))

  ///

  (defret expr-unambp-of-dimb-cast/call-to-call
    (expr-unambp call-expr)
    :hyp (and (expr-unambp fun)
              (expr-unambp rest))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-cast/mul-to-cast ((tyname tynamep)
                               (inc/dec inc/dec-op-listp)
                               (arg exprp))
  :returns (cast-expr exprp)
  :short "Disambiguate an ambiguous cast or multiplication expression
          to be a cast expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is analogous in purpose to @(tsee dimb-cast/call-to-cast),
     but for a different kind of ambiguous expression.
     Note that the @('*'), which is unary in this disambiguation,
     is implicit in the abstract syntax of the ambiguous expression."))
  (make-expr-cast :type tyname
                  :arg (make-expr-unary
                        :op (unop-indir)
                        :arg (apply-pre-inc/dec-ops inc/dec arg)))
  :hooks (:fix)

  ///

  (defret expr-unambp-of-dimb-cast/mul-to-cast
    (expr-unambp cast-expr)
    :hyp (and (tyname-unambp tyname)
              (expr-unambp arg))))

;;;;;;;;;;;;;;;;;;;;

(define dimb-cast/mul-to-mul ((arg1 exprp)
                              (inc/dec inc/dec-op-listp)
                              (arg2 exprp))
  :returns (mul-expr exprp)
  :short "Disambiguate an ambiguous cast or multiplication expression
          to be a multiplication expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is analogous in purpose to @(tsee dimb-cast/call-to-call),
     but for a different kind of ambiguous expression.
     Note that the @('*'), which is binary in this disambiguation,
     is implicit in the abstract syntax of the ambiguous expression."))
  (make-expr-binary :op (binop-mul)
                    :arg1 (apply-post-inc/dec-ops arg1 inc/dec)
                    :arg2 arg2)
  :hooks (:fix)

  ///

  (defret expr-unambp-of-dimb-cast/mul-to-mul
    (expr-unambp mul-expr)
    :hyp (and (expr-unambp arg1)
              (expr-unambp arg2))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-cast/addsub-to-cast ((tyname tynamep)
                                  (inc/dec inc/dec-op-listp)
                                  (arg exprp)
                                  (plus/minus unopp))
  :guard (or (unop-case plus/minus :plus)
             (unop-case plus/minus :minus))
  :returns (expr exprp)
  :short "Disambiguate an ambiguous cast or addition/subtraction expression
          to be a cast expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is analogous in purpose to @(tsee dimb-cast/call-to-cast),
     but for a different kind of ambiguous expression,
     actually two kinds, which are very similar and thus handled together;
     the two kinds are selected by the unary operator passed as input.
     Note that the @('+') or @('-'), which is unary in this disambiguation,
     is implicit in the abstract syntax of the ambiguous expression.")
   (xdoc::p
    "There is also an extra complexity here.
     In the @(':cast/add-ambig') and @(':cast/sub-ambig') cases of @(tsee expr),
     the @('arg/arg2') component is parsed as a multiplicative expression
     (see the @(see parser)),
     because that is what is required
     if the ambiguous cast or addition/subtraction
     turns out to be an addition or subtraction.
     But if it turns out to be a cast, we may need to re-organize things.
     For instance, consider the ambiguous expression")
   (xdoc::codeblock
    "(X) + Y * Z")
   (xdoc::p
    "which first the pattern @('(X) IncDec + E') in @(tsee expr),
     with empty @('IncDec') in this case.
     If @('X') is a type name,
     then the cast expression is only @('(X) +Y'), without the @('* Z') part,
     which instead forms an outer multiplication expression.
     In other words, if @('E') has the form @('E1 * E2'),
     we need to return the expression @('[(X) +E1] * E2'),
     where the square brackets convey the grouping.
     Note that @('E1') could be also a multiplication @('E11 * E12'),
     and in that case we must return @('[[(X) +E11] * E12] * E2').
     So in general we need a recursion to find
     the leftmost sub-expression of @('E') that is not a multiplication,
     form the cast with it, and then re-apply the nest of multiplications.
     By construction of the parser, @('E') will not include operations
     with lower priority than multiplication."))
  (b* (((mv mul? arg1 arg2) (check-expr-mul arg))
       ((when (not mul?))
        (make-expr-cast
         :type tyname
         :arg (make-expr-unary :op plus/minus
                               :arg (apply-pre-inc/dec-ops inc/dec arg))))
       (expr (dimb-cast/addsub-to-cast tyname inc/dec arg1 plus/minus)))
    (make-expr-binary :op (binop-mul) :arg1 expr :arg2 arg2))
  :measure (expr-count arg)
  :hints (("Goal" :in-theory (enable o< o-finp)))
  :verify-guards :after-returns
  :hooks (:fix)

  ///

  (defret expr-unambp-of-dimb-cast/addsub-to-cast
    (expr-unambp expr)
    :hyp (and (tyname-unambp tyname)
              (expr-unambp arg))
    :hints (("Goal" :induct t))))

;;;;;;;;;;;;;;;;;;;;

(define dimb-cast/addsub-to-addsub ((arg1 exprp)
                                    (inc/dec inc/dec-op-listp)
                                    (arg2 exprp)
                                    (add/sub binopp))
  :guard (or (binop-case add/sub :add)
             (binop-case add/sub :sub))
  :returns (expr exprp)
  :short "Disambiguate an ambiguous cast or addition/subtraction expression
          to be an addition or subtraction expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is analogous in purpose to @(tsee dimb-cast/call-to-call),
     but for a different kind of ambiguous expression,
     actually two kinds, which are very similar and thus handled together;
     the two kinds are selected by the binary operator passed as input.
     Note that the @('+') or @('-'), which is binary in this disambiguation,
     is implicit in the abstract syntax of the ambiguous expression."))
  (make-expr-binary :op add/sub
                    :arg1 (apply-post-inc/dec-ops arg1 inc/dec)
                    :arg2 arg2)
  :hooks (:fix)

  ///

  (defret expr-unambp-of-dimb-cast/addsub-to-addsub
    (expr-unambp expr)
    :hyp (and (expr-unambp arg1)
              (expr-unambp arg2))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-cast/and-to-cast ((tyname tynamep)
                               (inc/dec inc/dec-op-listp)
                               (arg exprp))
  :returns (expr exprp)
  :short "Disambiguate an ambiguous cast or conjunction expression
          to be a cast expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is analogous in purpose to @(tsee dimb-cast/call-to-cast),
     but for a different kind of ambiguous expression.
     Note that the @('&'), which is unary in this disambiguation,
     is implicit in the abstract syntax of the ambiguous expression.
     There is also a complication similar to @(tsee dimb-cast/addsub-to-cast),
     but here we need to handle not just multiplications,
     but all the binary expressions of priority higher than binary @('&')."))
  (b* (((mv bin? op arg1 arg2) (check-expr-binary arg))
       ((unless (and bin?
                     (member-eq (binop-kind op)
                                '(:mul :div :rem
                                  :add :sub
                                  :shl :shr
                                  :lt :gt :le :ge
                                  :eq :ne))))
        (make-expr-cast
         :type tyname
         :arg (make-expr-unary :op (unop-address)
                               :arg (apply-pre-inc/dec-ops inc/dec arg))))
       (expr (dimb-cast/and-to-cast tyname inc/dec arg1)))
    (make-expr-binary :op op :arg1 expr :arg2 arg2))
  :measure (expr-count arg)
  :hints (("Goal" :in-theory (enable o< o-finp)))
  :verify-guards :after-returns
  :hooks (:fix)

  ///

  (defret expr-unambp-of-dimb-cast/and-to-cast
    (expr-unambp expr)
    :hyp (and (tyname-unambp tyname)
              (expr-unambp arg))
    :hints (("Goal" :induct t))))

;;;;;;;;;;;;;;;;;;;;

(define dimb-cast/and-to-and ((arg1 exprp)
                              (inc/dec inc/dec-op-listp)
                              (arg2 exprp))
  :returns (expr exprp)
  :short "Disambiguate an ambiguous cast or conjunction expression
          to be a conjunction expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is analogous in purpose to @(tsee dimb-cast/call-to-call),
     but for a different kind of ambiguous expression.
     Note that the @('&'), which is binary in this disambiguation,
     is implicit in the abstract syntax of the ambiguous expression."))
  (make-expr-binary :op (binop-bitand)
                    :arg1 (apply-post-inc/dec-ops arg1 inc/dec)
                    :arg2 arg2)
  :hooks (:fix)

  ///

  (defret expr-unambp-of-dimb-cast/and-to-and
    (expr-unambp expr)
    :hyp (and (expr-unambp arg1)
              (expr-unambp arg2))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-params-to-names ((params paramdecl-listp)
                              (fundefp booleanp)
                              (table dimb-tablep))
  :returns (mv (yes/no booleanp) (names ident-listp))
  :short "Disambiguate a list of parameter declarations to a list of names,
          if appropriate."
  :long
  (xdoc::topstring
   (xdoc::p
    "There are two kinds of direct function declarators,
     both in the grammar and in the abstract syntax:
     one has a (non-empty) list of parameter declarations
     optionally followed by ellipsis;
     the other has a possibly empty list of names.")
   (xdoc::p
    "The second kind is allowed to be non-empty only if
     the function declarator is part of a function definition
     [C:6.7.6.3/3].
     This is indicated by the flag @('fundefp') passed to this ACL2 function.")
   (xdoc::p
    "The parser always creates the first kind,
     because a name, which is an identifier, is syntactically ambiguous:
     it could be a parameter name, or it could be a @('typedef') name.
     Also, if there are no parameters,
     the parser does not bother creating the second kind of declarator:
     it creates an empty list of parameter declarations,
     because this needs to be disambiguated anyhow.")
   (xdoc::p
    "This ACL2 function checks whether
     a possibly empty list of parameter declarations
     should in fact be a list of names.
     This is the case when either the list is empty,
     or the @('fundefp') flag is @('t') and
     every parameter declaration consists of
     a single type specifier consisting of a @('typedef') name,
     but that identifier does not identify a @('typedef') name in scope.
     This means that, for example, if we have two identifiers @('x') and @('y'),
     one of which is a @('typedef') name but the other one is not,
     the re-classification to names fails;
     one @('typedef') name suffices to re-classify the parameters to names.
     [C:6.7.6.3/11] says that @('typedef') names have priority,
     but strictly speaking it mentions only parameter declarations,
     not also identifier lists;
     nonetheless, some simple experiments with GCC show that
     this priority of @('typedef') names also applies to
     the choice between parameter declarations and identifier lists,
     and not just withing parameter declarations
     (this aspect is dealt with elsewhere,
     in the code to disambiguate parameter declarations).
     So, in the example above with @('x') and @('y'),
     the code is in fact invalid.")
   (xdoc::p
    "This ACL2 function returns a boolean saying whether
     the parameter declarations are re-classified into names,
     and in this case it also returns the list of names, whieh may be empty.
     If the check for any element of the list,
     the re-classification fails,
     and the caller will do its own processing and disamguation
     of the (non-empty) list of parameter declarations,
     which will then remain parameter declarations (not names)
     after that processing and disambiguation."))
  (b* (((when (endp params)) (mv t nil))
       ((unless fundefp) (mv nil nil)))
    (dimb-params-to-names-loop params table))
  :hooks (:fix)

  :prepwork
  ((define dimb-params-to-names-loop ((params paramdecl-listp)
                                      (table dimb-tablep))
     :returns (mv (yes/no booleanp) (names ident-listp))
     :parents nil
     (b* (((when (endp params)) (mv t nil))
          (param (car params))
          ((unless (paramdeclor-case (paramdecl->decl param) :none))
           (mv nil nil))
          (declspecs (paramdecl->spec param))
          ((unless (and (consp declspecs) (endp (cdr declspecs))))
           (mv nil nil))
          (declspec (car declspecs))
          ((unless (declspec-case declspec :tyspec)) (mv nil nil))
          (tyspec (declspec-tyspec->unwrap declspec))
          ((unless (type-spec-case tyspec :typedef)) (mv nil nil))
          (ident (type-spec-typedef->name tyspec))
          (kind? (dimb-lookup-ident ident table))
          ((when (equal kind? (dimb-kind-typedef))) (mv nil nil))
          ((mv yes/no names) (dimb-params-to-names-loop (cdr params) table))
          ((unless yes/no) (mv nil nil)))
       (mv t (cons ident names)))
     :hooks (:fix))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defines dimb-exprs/decls
  :short "Disambiguate expressions, declarations, and related artifacts."
  :long
  (xdoc::topstring
   (xdoc::p
    "In general, to disambiguate a construct,
     first we recursively disambiguate its sub-constructs,
     then we either join them into an updated construct,
     or perform a disambiguation of the construct itself if needed.")
   (xdoc::p
    "In general, the disambiguation of a construct
     may involve the extension of the disambiguation table.
     For instance, the mere occurrence of an enumeration specifier
     in the type name that is part of a cast expression
     extends the disambiguation table with enumeration constants."))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-expr ((expr exprp) (table dimb-tablep))
    :returns (mv erp (new-expr exprp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an expression."
    :long
    (xdoc::topstring
     (xdoc::p
      "If an expression is an identifier, we look it up in the table
       to see whether it should be re-classified as an enumeration constant.")
     (xdoc::p
      "A constant or string literal is left unchanged;
       there is nothing to disambiguate.
       If the constant is an enumeration constant,
       we could check that the identifier is in the table
       and has the kind of enumeration constant.
       However, the parser never generates enumeration constants,
       so there is no need to do that.")
     (xdoc::p
      "We recursively disambiguate sub-expressions,
       and other sub-entities (e.g. generic associations, type names),
       following the recursive structure of the types.")
     (xdoc::p
      "We call a separate function to disambiguate
       an ambiguous @('sizeof') expression.
       Depending on whether the result is an expression or a type name,
       we re-classify the expression into an unambiguous one.")
     (xdoc::p
      "An ambiguous cast or call is described in detail in @(tsee expr):
       refer to that documentation to understand how it is disambiguated here;
       recall that it has the form @('(X) IncDec (E)Pr').
       We call a separate function to disambiguate
       the initial expression or type name, @('X').
       Based on the result, we re-classify the expression as a cast or call,
       using separate ACL2 functions.")
     (xdoc::p
      "The other kinds of ambiguous cast or binary expressions
       are described in detail in @(tsee expr):
       refer to that documentation to understand how it is disambiguated here;
       recall that is has the form @('(X) IncDec O E'),
       where @('O') is an ambiguous unary or binary operator.
       We call a separate function to disambiguate
       the initial expression or type name, @('X').
       Based on the result,
       we re-classify the expression as a cast or a binary one,
       using separate ACL2 functions."))
    (b* (((reterr) (irr-expr) (irr-dimb-table)))
      (expr-case
       expr
       :ident
       (b* ((kind (dimb-lookup-ident expr.unwrap table))
            ((unless kind)
             (reterr (msg "The identifier ~x0 is used as an expression ~
                           but is not in scope."
                          (ident->unwrap expr.unwrap)))))
         (dimb-kind-case
          kind
          :typedef (reterr (msg "The identifier ~x0 denotes a typedef ~
                                 but it is used as an expression."
                                (ident->unwrap expr.unwrap)))
          :objfun (retok (expr-fix expr)
                         (dimb-table-fix table))
          :enumconst (retok (expr-const (const-enum expr.unwrap))
                            (dimb-table-fix table))))
       :const
       (retok (expr-fix expr) (dimb-table-fix table))
       :string
       (retok (expr-fix expr) (dimb-table-fix table))
       :paren
       (b* (((erp new-expr table) (dimb-expr expr.unwrap table)))
         (retok (expr-paren new-expr) table))
       :gensel
       (b* (((erp new-control table) (dimb-expr expr.control table))
            ((erp new-assocs table) (dimb-genassoc-list expr.assocs table)))
         (retok (make-expr-gensel :control new-control
                                  :assocs new-assocs)
                table))
       :arrsub
       (b* (((erp new-arg1 table) (dimb-expr expr.arg1 table))
            ((erp new-arg2 table) (dimb-expr expr.arg2 table)))
         (retok (make-expr-arrsub :arg1 new-arg1
                                  :arg2 new-arg2)
                table))
       :funcall
       (b* (((erp new-fun table) (dimb-expr expr.fun table))
            ((erp new-args table) (dimb-expr-list expr.args table)))
         (retok (make-expr-funcall :fun new-fun :args new-args)
                table))
       :member
       (b* (((erp new-arg table) (dimb-expr expr.arg table)))
         (retok (make-expr-member :arg new-arg :name expr.name)
                table))
       :memberp
       (b* (((erp new-arg table) (dimb-expr expr.arg table)))
         (retok (make-expr-memberp :arg new-arg :name expr.name)
                (dimb-table-fix table)))
       :complit
       (b* (((erp new-type table) (dimb-tyname expr.type table))
            ((erp new-elems table) (dimb-desiniter-list expr.elems table)))
         (retok (make-expr-complit :type new-type
                                   :elems new-elems
                                   :final-comma expr.final-comma)
                table))
       :unary
       (b* (((erp new-arg table) (dimb-expr expr.arg table)))
         (retok (make-expr-unary :op expr.op
                                 :arg new-arg)
                table))
       :sizeof
       (b* (((erp new-tyname table) (dimb-tyname expr.type table)))
         (retok (expr-sizeof new-tyname) table))
       :sizeof-ambig
       (b* (((erp expr-or-tyname table)
             (dimb-amb-expr/tyname expr.expr/tyname table)))
         (expr/tyname-case
          expr-or-tyname
          :expr (retok (make-expr-unary
                        :op (unop-sizeof)
                        :arg expr-or-tyname.unwrap)
                       table)
          :tyname (retok (expr-sizeof expr-or-tyname.unwrap)
                         table)))
       :alignof
       (b* (((erp new-tyname table) (dimb-tyname expr.type table)))
         (retok (make-expr-alignof :type new-tyname :uscores expr.uscores)
                table))
       :cast
       (b* (((erp new-type table) (dimb-tyname expr.type table))
            ((erp new-arg table) (dimb-expr expr.arg table)))
         (retok (make-expr-cast :type new-type
                                :arg new-arg)
                table))
       :binary
       (b* (((erp new-arg1 table) (dimb-expr expr.arg1 table))
            ((erp new-arg2 table) (dimb-expr expr.arg2 table)))
         (retok (make-expr-binary :op expr.op
                                  :arg1 new-arg1
                                  :arg2 new-arg2)
                table))
       :cond
       (b* (((erp new-test table) (dimb-expr expr.test table))
            ((erp new-then table) (dimb-expr expr.then table))
            ((erp new-else table) (dimb-expr expr.else table)))
         (retok (make-expr-cond :test new-test
                                :then new-then
                                :else new-else)
                table))
       :comma
       (b* (((erp new-first table) (dimb-expr expr.first table))
            ((erp new-next table) (dimb-expr expr.next table)))
         (retok (make-expr-comma :first new-first
                                 :next new-next)
                table))
       :cast/call-ambig
       (b* (((erp expr/tyname table)
             (dimb-amb-expr/tyname expr.type/fun table))
            ((erp new-arg/rest table) (dimb-expr expr.arg/rest table)))
         (expr/tyname-case
          expr/tyname
          :tyname
          (retok
           (dimb-cast/call-to-cast (expr/tyname-tyname->unwrap expr/tyname)
                                   expr.inc/dec
                                   new-arg/rest)
           table)
          :expr
          (retok
           (dimb-cast/call-to-call (expr/tyname-expr->unwrap expr/tyname)
                                   expr.inc/dec
                                   new-arg/rest)
           table)))
       :cast/mul-ambig
       (b* (((erp expr/tyname table)
             (dimb-amb-expr/tyname expr.type/arg1 table))
            ((erp new-arg/arg2 table) (dimb-expr expr.arg/arg2 table)))
         (expr/tyname-case
          expr/tyname
          :tyname
          (retok
           (dimb-cast/mul-to-cast (expr/tyname-tyname->unwrap expr/tyname)
                                  expr.inc/dec
                                  new-arg/arg2)
           table)
          :expr
          (retok
           (dimb-cast/mul-to-mul (expr/tyname-expr->unwrap expr/tyname)
                                 expr.inc/dec
                                 new-arg/arg2)
           table)))
       :cast/add-ambig
       (b* (((erp expr/tyname table)
             (dimb-amb-expr/tyname expr.type/arg1 table))
            ((erp new-arg/arg2 table) (dimb-expr expr.arg/arg2 table)))
         (expr/tyname-case
          expr/tyname
          :tyname
          (retok
           (dimb-cast/addsub-to-cast (expr/tyname-tyname->unwrap expr/tyname)
                                     expr.inc/dec
                                     new-arg/arg2
                                     (unop-plus))
           table)
          :expr
          (retok
           (dimb-cast/addsub-to-addsub (expr/tyname-expr->unwrap expr/tyname)
                                       expr.inc/dec
                                       new-arg/arg2
                                       (binop-add))
           table)))
       :cast/sub-ambig
       (b* (((erp expr/tyname table)
             (dimb-amb-expr/tyname expr.type/arg1 table))
            ((erp new-arg/arg2 table) (dimb-expr expr.arg/arg2 table)))
         (expr/tyname-case
          expr/tyname
          :tyname
          (retok
           (dimb-cast/addsub-to-cast (expr/tyname-tyname->unwrap expr/tyname)
                                     expr.inc/dec
                                     new-arg/arg2
                                     (unop-minus))
           table)
          :expr
          (retok
           (dimb-cast/addsub-to-addsub (expr/tyname-expr->unwrap expr/tyname)
                                       expr.inc/dec
                                       new-arg/arg2
                                       (binop-sub))
           table)))
       :cast/and-ambig
       (b* (((erp expr/tyname table)
             (dimb-amb-expr/tyname expr.type/arg1 table))
            ((erp new-arg/arg2 table) (dimb-expr expr.arg/arg2 table)))
         (expr/tyname-case
          expr/tyname
          :tyname
          (retok
           (dimb-cast/and-to-cast (expr/tyname-tyname->unwrap expr/tyname)
                                  expr.inc/dec
                                  new-arg/arg2)
           table)
          :expr
          (retok
           (dimb-cast/and-to-and (expr/tyname-expr->unwrap expr/tyname)
                                 expr.inc/dec
                                 new-arg/arg2)
           table)))))
    :measure (expr-count expr))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-expr-list ((exprs expr-listp) (table dimb-tablep))
    :returns (mv erp (new-exprs expr-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of expressions."
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp exprs)) (retok nil (dimb-table-fix table)))
         ((erp new-expr table) (dimb-expr (car exprs) table))
         ((erp new-exprs table) (dimb-expr-list (cdr exprs) table)))
      (retok (cons new-expr new-exprs) table))
    :measure (expr-list-count exprs))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-expr-option ((expr? expr-optionp) (table dimb-tablep))
    :returns (mv erp (new-expr? expr-optionp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an optional expression."
    (b* (((reterr) nil (irr-dimb-table)))
      (expr-option-case
       expr?
       :some (dimb-expr expr?.val table)
       :none (retok nil (dimb-table-fix table))))
    :measure (expr-option-count expr?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-const-expr ((cexpr const-exprp) (table dimb-tablep))
    :returns (mv erp (new-cexpr const-exprp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a constant expression."
    (b* (((reterr) (irr-const-expr) (irr-dimb-table))
         ((erp new-expr table) (dimb-expr (const-expr->unwrap cexpr) table)))
      (retok (const-expr new-expr) table))
    :measure (const-expr-count cexpr))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-const-expr-option ((cexpr? const-expr-optionp)
                                  (table dimb-tablep))
    :returns (mv erp (new-cexpr? const-expr-optionp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an optional constant expression."
    (b* (((reterr) nil (irr-dimb-table)))
      (const-expr-option-case
       cexpr?
       :some (dimb-const-expr cexpr?.val table)
       :none (retok nil (dimb-table-fix table))))
    :measure (const-expr-option-count cexpr?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-genassoc ((assoc genassocp) (table dimb-tablep))
    :returns (mv erp (new-assoc genassocp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a generic association."
    (b* (((reterr) (irr-genassoc) (irr-dimb-table)))
      (genassoc-case
       assoc
       :type (b* (((erp new-tyname table) (dimb-tyname assoc.type table))
                  ((erp new-expr table) (dimb-expr assoc.expr table)))
               (retok (make-genassoc-type :type new-tyname
                                          :expr new-expr)
                      table))
       :default (b* (((erp new-expr table) (dimb-expr assoc.expr table)))
                  (retok (genassoc-default new-expr) table))))
    :measure (genassoc-count assoc))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-genassoc-list ((assocs genassoc-listp) (table dimb-tablep))
    :returns (mv erp (new-assocs genassoc-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of generic associations."
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp assocs)) (retok nil (dimb-table-fix table)))
         ((erp new-assoc table) (dimb-genassoc (car assocs) table))
         ((erp new-assocs table) (dimb-genassoc-list (cdr assocs) table)))
      (retok (cons new-assoc new-assocs) table))
    :measure (genassoc-list-count assocs))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-type-spec ((tyspec type-specp) (table dimb-tablep))
    :returns (mv erp (new-tyspec type-specp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a type specifier."
    :long
    (xdoc::topstring
     (xdoc::p
      "A type specifier may affect the disambiguation table,
       by adding identifiers to it.
       Thus, this function returns
       not only a disambiguated type specifier,
       but also a possibly updated table.")
     (xdoc::p
      "The only type specifier that affect the disambiguation table
       is an enumeration specifiers,
       which extends the table with information about
       the enumeration constants it introduces.
       This is actually done by a separate function,
       the one that processes the enumerators.")
     (xdoc::p
      "Note that the disambiguation table contains no information
       about the structure, union, and enumeration tags:
       so we do need to extend the table when we encounter
       the corresponding type specifiers.
       Members or structures and unions also do not affect
       the disambiguation table,
       since the table contains no information about any of them.")
     (xdoc::p
      "If we encounter a @('typedef') name,
       we need to check that it is in the disambiguation table,
       with the right kind."))
    (b* (((reterr) (irr-type-spec) (irr-dimb-table)))
      (type-spec-case
       tyspec
       :void (retok (type-spec-void) (dimb-table-fix table))
       :char (retok (type-spec-char) (dimb-table-fix table))
       :short (retok (type-spec-short) (dimb-table-fix table))
       :int (retok (type-spec-int) (dimb-table-fix table))
       :long (retok (type-spec-long) (dimb-table-fix table))
       :float (retok (type-spec-float) (dimb-table-fix table))
       :double (retok (type-spec-double) (dimb-table-fix table))
       :signed (retok (type-spec-signed tyspec.uscores) (dimb-table-fix table))
       :unsigned (retok (type-spec-unsigned) (dimb-table-fix table))
       :bool (retok (type-spec-bool) (dimb-table-fix table))
       :complex (retok (type-spec-complex) (dimb-table-fix table))
       :atomic (b* (((erp new-type table) (dimb-tyname tyspec.type table)))
                 (retok (type-spec-atomic new-type) table))
       :struct (b* (((erp new-strunispec table)
                     (dimb-strunispec tyspec.unwrap table)))
                 (retok (type-spec-struct new-strunispec)
                        table))
       :union (b* (((erp new-strunispec table)
                    (dimb-strunispec tyspec.unwrap table)))
                (retok (type-spec-union new-strunispec)
                       table))
       :enum (b* (((erp new-enumspec table)
                   (dimb-enumspec tyspec.unwrap table)))
               (retok (type-spec-enum new-enumspec) table))
       :typedef (b* ((kind (dimb-lookup-ident tyspec.name table))
                     ((unless kind)
                      (reterr
                       (msg "The identifier ~x0 is used as a type specifier ~
                             but it is not in scope."
                            (ident->unwrap tyspec.name)))))
                  (dimb-kind-case
                   kind
                   :typedef (retok (type-spec-typedef tyspec.name)
                                   (dimb-table-fix table))
                   :objfun (reterr
                            (msg "The identifier ~x0 denotes ~
                                  an object or function ~
                                  but it is used as a typedef name."
                                 (ident->unwrap tyspec.name)))
                   :enumconst (reterr
                               (msg "The identifier ~x0 denotes ~
                                     an enumeration constant ~
                                     but it is used as a typedef name."
                                    (ident->unwrap tyspec.name)))))
       :int128 (retok (type-spec-int128) (dimb-table-fix table))
       :float128 (retok (type-spec-float128) (dimb-table-fix table))
       :builtin-va-list (retok (type-spec-builtin-va-list)
                               (dimb-table-fix table))
       :typeof-expr
       (b* (((erp new-expr table) (dimb-expr tyspec.expr table)))
         (retok (make-type-spec-typeof-expr :expr new-expr
                                            :uscores tyspec.uscores)
                table))
       :typeof-type
       (b* (((erp new-tyname table) (dimb-tyname tyspec.type table)))
         (retok (make-type-spec-typeof-type :type new-tyname
                                            :uscores tyspec.uscores)
                table))
       :typeof-ambig
       (b* (((erp expr/tyname table)
             (dimb-amb-expr/tyname tyspec.expr/type table)))
         (expr/tyname-case
          expr/tyname
          :expr (retok (make-type-spec-typeof-expr :expr expr/tyname.unwrap
                                                   :uscores tyspec.uscores)
                       table)
          :tyname (retok (make-type-spec-typeof-type :type expr/tyname.unwrap
                                                     :uscores tyspec.uscores)
                         table)))))
    :measure (type-spec-count tyspec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-spec/qual ((specqual spec/qual-p) (table dimb-tablep))
    :returns (mv erp (new-specqual spec/qual-p) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a specifier or qualifier."
    :long
    (xdoc::topstring
     (xdoc::p
      "Type qualifiers are left unchanged.
       Type specifiers may extend the disambiguation table."))
    (b* (((reterr) (irr-spec/qual) (irr-dimb-table)))
      (spec/qual-case
       specqual
       :tyspec (b* (((erp new-tyspec table)
                     (dimb-type-spec specqual.unwrap table)))
                 (retok (spec/qual-tyspec new-tyspec)
                        table))
       :tyqual (retok (spec/qual-tyqual specqual.unwrap)
                      (dimb-table-fix table))
       :align (b* (((erp new-alignspec table)
                    (dimb-align-spec specqual.unwrap table)))
                (retok (spec/qual-align new-alignspec)
                       table))
       :attrib (retok (spec/qual-attrib specqual.unwrap)
                      (dimb-table-fix table))))
    :measure (spec/qual-count specqual))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-spec/qual-list ((specquals spec/qual-listp) (table dimb-tablep))
    :returns (mv erp (new-specquals spec/qual-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of specifiers and qualifiers."
    :long
    (xdoc::topstring
     (xdoc::p
      "We process them in order, threading through the table,
       which may be updated by each."))
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp specquals)) (retok nil (dimb-table-fix table)))
         ((erp new-specqual table) (dimb-spec/qual (car specquals) table))
         ((erp new-specquals table) (dimb-spec/qual-list (cdr specquals) table)))
      (retok (cons new-specqual new-specquals) table))
    :measure (spec/qual-list-count specquals))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-align-spec ((alignspec align-specp) (table dimb-tablep))
    :returns (mv erp (new-alignspec align-specp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an alignment specifier."
    :long
    (xdoc::topstring
     (xdoc::p
      "For an ambiguous alignment specifier,
       we disambiguate the underlying type name or expression,
       and then return one of the two kinds of
       unambiguous alignment specifiers."))
    (b* (((reterr) (irr-align-spec) (irr-dimb-table)))
      (align-spec-case
       alignspec
       :alignas-type
       (b* (((erp new-type table) (dimb-tyname alignspec.type table)))
         (retok (align-spec-alignas-type new-type) table))
       :alignas-expr
       (b* (((erp new-arg table) (dimb-const-expr alignspec.arg table)))
         (retok (align-spec-alignas-expr new-arg) table))
       :alignas-ambig
       (b* (((erp expr/tyname table)
             (dimb-amb-expr/tyname alignspec.type/arg table)))
         (expr/tyname-case
          expr/tyname
          :expr (retok (align-spec-alignas-expr (const-expr expr/tyname.unwrap))
                       table)
          :tyname (retok (align-spec-alignas-type expr/tyname.unwrap)
                         table)))))
    :measure (align-spec-count alignspec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-declspec ((declspec declspecp)
                         (kind dimb-kindp)
                         (table dimb-tablep))
    :returns (mv erp
                 (new-declspec declspecp)
                 (new-kind dimb-kindp)
                 (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a declaration specifier."
    :long
    (xdoc::topstring
     (xdoc::p
      "Declaration specifiers (may) precede declarators,
       which add identifiers to the current scope.
       For our disambiguation purposes,
       we need to determine which @(tsee dimb-kind)
       those identifiers denote, which, for declarators,
       is either @(':objfun') or @(':typedef').
       It is @(':typedef') if the list of declaration specifiers
       includes the @('typedef') storage class specifier;
       otherwise, it is @(':objfun').
       Thus, when going through the declaration specifiers,
       we initialize the kind to @(':objfun'),
       and change it to @(':typedef') if we encounter a @('typedef').
       This is why this ACL2 function takes and returns
       a disambiguation kind, i.e. a value of type @(tsee dimb-kind)."))
    (b* (((reterr) (irr-declspec) (irr-dimb-kind) (irr-dimb-table)))
      (declspec-case
       declspec
       :stocla (if (stor-spec-case declspec.unwrap :typedef)
                   (retok (declspec-fix declspec)
                          (dimb-kind-typedef)
                          (dimb-table-fix table))
                 (retok (declspec-fix declspec)
                        (dimb-kind-fix kind)
                        (dimb-table-fix table)))
       :tyspec (b* (((erp new-tyspec table)
                     (dimb-type-spec declspec.unwrap table)))
                 (retok (declspec-tyspec new-tyspec)
                        (dimb-kind-fix kind)
                        (dimb-table-fix table)))
       :tyqual (retok (declspec-fix declspec)
                      (dimb-kind-fix kind)
                      (dimb-table-fix table))
       :funspec (retok (declspec-fix declspec)
                       (dimb-kind-fix kind)
                       (dimb-table-fix table))
       :align (b* (((erp new-alignspec table)
                    (dimb-align-spec declspec.unwrap table)))
                (retok (declspec-align new-alignspec)
                       (dimb-kind-fix kind)
                       table))
       :attrib (retok (declspec-fix declspec)
                      (dimb-kind-fix kind)
                      (dimb-table-fix table))))
    :measure (declspec-count declspec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-declspec-list ((declspecs declspec-listp)
                              (kind dimb-kindp)
                              (table dimb-tablep))
    :returns (mv erp
                 (new-declspecs declspec-listp)
                 (new-kind dimb-kindp)
                 (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of declaration specifiers."
    :long
    (xdoc::topstring
     (xdoc::p
      "See @(tsee dimb-declspec) for an explanation of
       the disambiguation kind passed as input and returned as output."))
    (b* (((reterr) nil (irr-dimb-kind) (irr-dimb-table))
         ((when (endp declspecs)) (retok nil
                                         (dimb-kind-fix kind)
                                         (dimb-table-fix table)))
         ((erp new-declspec kind table)
          (dimb-declspec (car declspecs) kind table))
         ((erp new-declspecs kind table)
          (dimb-declspec-list (cdr declspecs) kind table)))
      (retok (cons new-declspec new-declspecs) kind table))
    :measure (declspec-list-count declspecs))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-initer ((initer initerp) (table dimb-tablep))
    :returns (mv erp (new-initer initerp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an initializer."
    (b* (((reterr) (irr-initer) (irr-dimb-table)))
      (initer-case
       initer
       :single (b* (((erp new-expr table) (dimb-expr initer.expr table)))
                 (retok (initer-single new-expr) table))
       :list (b* (((erp new-elems table)
                   (dimb-desiniter-list initer.elems table)))
               (retok (make-initer-list :elems new-elems
                                        :final-comma initer.final-comma)
                      table))))
    :measure (initer-count initer))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-initer-option ((initer? initer-optionp) (table dimb-tablep))
    :returns (mv erp (new-initer? initer-optionp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an optional initializer."
    (b* (((reterr) nil (irr-dimb-table)))
      (initer-option-case
       initer?
       :some (dimb-initer initer?.val table)
       :none (retok nil (dimb-table-fix table))))
    :measure (initer-option-count initer?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-desiniter ((desiniter desiniterp) (table dimb-tablep))
    :returns (mv erp (new-desiniter desiniterp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an initializer with optional designations."
    (b* (((reterr) (irr-desiniter) (irr-dimb-table))
         ((desiniter desiniter) desiniter)
         ((erp new-designs table) (dimb-designor-list desiniter.design table))
         ((erp new-initer table) (dimb-initer desiniter.init table)))
      (retok (make-desiniter :design new-designs :init new-initer)
             table))
    :measure (desiniter-count desiniter))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-desiniter-list ((desiniters desiniter-listp) (table dimb-tablep))
    :returns (mv erp (new-desiniters desiniter-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of initializers with optional designations."
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp desiniters)) (retok nil (dimb-table-fix table)))
         ((erp new-desiniter table) (dimb-desiniter (car desiniters) table))
         ((erp new-desiniters table)
          (dimb-desiniter-list (cdr desiniters) table)))
      (retok (cons new-desiniter new-desiniters) table))
    :measure (desiniter-list-count desiniters))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-designor ((design designorp) (table dimb-tablep))
    :returns (mv erp (new-design designorp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a designator."
    (b* (((reterr) (irr-designor) (irr-dimb-table)))
      (designor-case
       design
       :sub (b* (((erp new-index table) (dimb-const-expr design.index table)))
              (retok (designor-sub new-index) table))
       :dot (retok (designor-dot design.name) (dimb-table-fix table))))
    :measure (designor-count design))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-designor-list ((designs designor-listp) (table dimb-tablep))
    :returns (mv erp (new-designs designor-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of designators."
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp designs)) (retok nil (dimb-table-fix table)))
         ((erp new-design table) (dimb-designor (car designs) table))
         ((erp new-designs table) (dimb-designor-list (cdr designs) table)))
      (retok (cons new-design new-designs) table))
    :measure (designor-list-count designs))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-declor ((declor declorp) (fundefp booleanp) (table dimb-tablep))
    :returns (mv erp (new-declor declorp) (ident identp) (table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a declarator."
    :long
    (xdoc::topstring
     (xdoc::p
      "A declarator adds an identifier to the scope.
       This function returns the identifier.
       Its addition to the disambiguation table is performed
       outside of this function,
       after processing the top-level declarator
       in the construct of interest.")
     (xdoc::p
      "The pointer part of a declarator does not contribute to the table
       and does not need to be disambiguated.
       So we recursively disambiguate the direct declarator,
       which also gives us the identifier,
       and then we re-add the pointer part.")
     (xdoc::p
      "The @('fundefp') flag passed to this function
       says whether we are disambiguating
       the declarator of a function definition or not.
       It is used to determine whether,
       when disambiguating the parameters of a function declarator,
       the new scope pushed for the function prototype
       should be popped at the end of the function declarator or not.
       If the declarator is not part of a function definition,
       then that scope must be popped;
       but if instead the declarator is part of a function definition,
       that scope is the block scope of the definition,
       and must not be popped.
       Here by `part of a function definition' of course we mean
       the one that introduces the name of the function being defined."))
    (b* (((reterr) (irr-declor) (irr-ident) (irr-dimb-table))
         ((declor declor) declor)
         ((erp new-dirdeclor ident table)
          (dimb-dirdeclor declor.decl fundefp table)))
      (retok (make-declor :pointers declor.pointers
                          :decl new-dirdeclor)
             ident
             table))
    :measure (declor-count declor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-declor-option ((declor? declor-optionp) (table dimb-tablep))
    :returns (mv erp
                 (new-declor? declor-optionp)
                 (ident? ident-optionp)
                 (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an optional declarator."
    :long
    (xdoc::topstring
     (xdoc::p
      "As with similar disambiguation functions,
       this lifts @(tsee dimb-declor) to optional declarators.
       Since the declarator may be absent,
       we also generalize the returned identifier to be an optional one.")
     (xdoc::p
      "Note that we call @(tsee dimb-declor) with
       @('nil') as the @('fundefp') flag,
       because if we are disambiguating an optional declarator
       we are not disambiguating the declarator of a defined function."))
    (b* (((reterr) nil nil (irr-dimb-table)))
      (declor-option-case
       declor?
       :some (dimb-declor declor?.val nil table)
       :none (retok nil nil (dimb-table-fix table))))
    :measure (declor-option-count declor?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-dirdeclor ((dirdeclor dirdeclorp)
                          (fundefp booleanp)
                          (table dimb-tablep))
    :returns (mv erp
                 (new-dirdeclor dirdeclorp)
                 (ident identp)
                 (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a direct declarator."
    :long
    (xdoc::topstring
     (xdoc::p
      "As explained in @(tsee dimb-declor),
       a (direct) declarator adds an identifier to the scope.
       So here we return the identifer,
       recursively extracted from the direct declarator.
       The actual addition to the disambiguation table
       is performed outside this function.")
     (xdoc::p
      "The purpose of the @('fundefp') flag is
       the same as in @(tsee dimb-declor),
       which in fact passes it to this function.
       Here we make use of it, as explained below.")
     (xdoc::p
      "We recursively disambiguate the inner declarator and direct declarator,
       from which we obtain the identifier.
       We also recursively disambiguate any expressions in array declarators.")
     (xdoc::p
      "For function declarators,
       the parser only produces @(':function-params'),
       never @(':function-names').
       However, here we also process @(':function-names'),
       so that the disambiguator is idempotent.
       We push a new scope, for uniformity with the treatment
       described in the next paragraph.")
     (xdoc::p
      "For a @(':function-params'),
       first we attempt to turn it into a @(':function-names'), if applicable.
       we also push a new scope if @('fundefp') is @('t'),
       for the reason explained below.
       If we cannot turn the @(':function-params') into @(':function-names'),
       we disambiguate it (into another @(':function-params')) as follows.
       We push a new scope for the function prototype [C:6.2.1/2] [C:6.2.1/4].
       We call a separate function to disambiguate each parameter declaration.
       Then, based on the @('fundefp') flag,
       we pop the scope (if the flag is @('nil')),
       or we leave the scope there (if the flag is @('t')):
       in the latter case, this will be the scope of the function definition.
       So that is the reason why we push a scope
       also in the case, described above,
       that we turn @(':function-params') into @(':function-names'):
       either way, we are pushing a scope for the function definition.
       If the code is valid, the function definition
       will indeed have parameter declarations,
       and so the disambiguator will do the right thing;
       if the code is invalid,
       it does not actually matter what the disambiguator does."))
    (b* (((reterr) (irr-dirdeclor) (irr-ident) (irr-dimb-table)))
      (dirdeclor-case
       dirdeclor
       :ident
       (retok (dirdeclor-fix dirdeclor) dirdeclor.unwrap (dimb-table-fix table))
       :paren
       (b* (((erp new-declor ident table)
             (dimb-declor dirdeclor.unwrap fundefp table)))
         (retok (dirdeclor-paren new-declor) ident table))
       :array
       (b* (((erp new-dirdeclor ident table)
             (dimb-dirdeclor dirdeclor.decl fundefp table))
            ((erp new-expr? table) (dimb-expr-option dirdeclor.expr? table)))
         (retok (make-dirdeclor-array :decl new-dirdeclor
                                      :tyquals dirdeclor.tyquals
                                      :expr? new-expr?)
                ident
                table))
       :array-static1
       (b* (((erp new-dirdeclor ident table)
             (dimb-dirdeclor dirdeclor.decl fundefp table))
            ((erp new-expr table) (dimb-expr dirdeclor.expr table)))
         (retok (make-dirdeclor-array-static1 :decl new-dirdeclor
                                              :tyquals dirdeclor.tyquals
                                              :expr new-expr)
                ident
                table))
       :array-static2
       (b* (((erp new-dirdeclor ident table)
             (dimb-dirdeclor dirdeclor.decl fundefp table))
            ((erp new-expr table) (dimb-expr dirdeclor.expr table)))
         (retok (make-dirdeclor-array-static2 :decl new-dirdeclor
                                              :tyquals dirdeclor.tyquals
                                              :expr new-expr)
                ident
                table))
       :array-star
       (b* (((erp new-dirdeclor ident table)
             (dimb-dirdeclor dirdeclor.decl fundefp table)))
         (retok (make-dirdeclor-array-star :decl new-dirdeclor
                                           :tyquals dirdeclor.tyquals)
                ident
                table))
       :function-params
       (b* (((erp new-dirdeclor ident table)
             (dimb-dirdeclor dirdeclor.decl fundefp table))
            ((mv yes/no names)
             (dimb-params-to-names dirdeclor.params fundefp table))
            ((when yes/no)
             (retok (make-dirdeclor-function-names :decl new-dirdeclor
                                                   :names names)
                    ident
                    (if fundefp
                        (dimb-push-scope table)
                      table)))
            (table (dimb-push-scope table))
            ((erp new-params table)
             (dimb-paramdecl-list dirdeclor.params table))
            (table (if fundefp
                       table
                     (dimb-pop-scope table))))
         (retok (make-dirdeclor-function-params :decl new-dirdeclor
                                                :params new-params
                                                :ellipsis dirdeclor.ellipsis)
                ident
                table))
       :function-names
       (b* (((erp new-dirdeclor ident table)
             (dimb-dirdeclor dirdeclor.decl fundefp table)))
         (retok (make-dirdeclor-function-names :decl new-dirdeclor
                                               :names dirdeclor.names)
                ident
                (if fundefp
                    (dimb-push-scope table)
                  table)))))
    :measure (dirdeclor-count dirdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-absdeclor ((absdeclor absdeclorp) (table dimb-tablep))
    :returns (mv erp (new-absdeclor absdeclorp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an abstract declarator."
    :long
    (xdoc::topstring
     (xdoc::p
      "The disambiguation of an abstract declarator
       is similar to the one of a declarator,
       but an abstract declarator does not introduce an identifiers,
       and so there is no identifier to return here."))
    (b* (((reterr) (irr-absdeclor) (irr-dimb-table))
         ((absdeclor absdeclor) absdeclor)
         ((erp new-decl? table)
          (dimb-dirabsdeclor-option absdeclor.decl? table)))
      (retok (make-absdeclor :pointers absdeclor.pointers
                             :decl? new-decl?)
             table))
    :measure (absdeclor-count absdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-absdeclor-option ((absdeclor? absdeclor-optionp)
                                 (table dimb-tablep))
    :returns (mv erp (new-absdeclor? absdeclor-optionp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an optional abstract declarator."
    (b* (((reterr) nil nil (irr-dimb-table)))
      (absdeclor-option-case
       absdeclor?
       :some (dimb-absdeclor absdeclor?.val table)
       :none (retok nil (dimb-table-fix table))))
    :measure (absdeclor-option-count absdeclor?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-dirabsdeclor ((dirabsdeclor dirabsdeclorp) (table dimb-tablep))
    :returns (mv erp (new-dirabsdeclor dirabsdeclorp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a direct abstract declarator."
    :long
    (xdoc::topstring
     (xdoc::p
      "The handling is similar to @(tsee dimb-dirdeclor),
       but no identifier is returned.
       There is also no handling of possible function parameter names."))
    (b* (((reterr) (irr-dirabsdeclor) (irr-dimb-table)))
      (dirabsdeclor-case
       dirabsdeclor
       :dummy-base
       (prog2$
        (raise "Internal error: dummy base case of direct abstract declarator.")
        (reterr t))
       :paren
       (b* (((erp new-absdeclor table)
             (dimb-absdeclor dirabsdeclor.unwrap table)))
         (retok (dirabsdeclor-paren new-absdeclor)
                table))
       :array
       (b* (((erp new-decl? table)
             (dimb-dirabsdeclor-option dirabsdeclor.decl? table))
            ((erp new-expr? table)
             (dimb-expr-option dirabsdeclor.expr? table)))
         (retok (make-dirabsdeclor-array :decl? new-decl?
                                         :tyquals dirabsdeclor.tyquals
                                         :expr? new-expr?)
                table))
       :array-static1
       (b* (((erp new-decl? table)
             (dimb-dirabsdeclor-option dirabsdeclor.decl? table))
            ((erp new-expr table) (dimb-expr dirabsdeclor.expr table)))
         (retok (make-dirabsdeclor-array-static1 :decl? new-decl?
                                                 :tyquals dirabsdeclor.tyquals
                                                 :expr new-expr)
                table))
       :array-static2
       (b* (((erp new-decl? table)
             (dimb-dirabsdeclor-option dirabsdeclor.decl? table))
            ((erp new-expr table) (dimb-expr dirabsdeclor.expr table)))
         (retok (make-dirabsdeclor-array-static2 :decl? new-decl?
                                                 :tyquals dirabsdeclor.tyquals
                                                 :expr new-expr)
                table))
       :array-star
       (b* (((erp new-decl? table)
             (dimb-dirabsdeclor-option dirabsdeclor.decl? table)))
         (retok (dirabsdeclor-array-star new-decl?)
                table))
       :function
       (b* (((erp new-decl? table)
             (dimb-dirabsdeclor-option dirabsdeclor.decl? table))
            (table (dimb-push-scope table))
            ((erp new-params table)
             (dimb-paramdecl-list dirabsdeclor.params table))
            (table (dimb-pop-scope table)))
         (retok (make-dirabsdeclor-function :decl? new-decl?
                                            :params new-params
                                            :ellipsis dirabsdeclor.ellipsis)
                table))))
    :measure (dirabsdeclor-count dirabsdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-dirabsdeclor-option ((dirabsdeclor? dirabsdeclor-optionp)
                                    (table dimb-tablep))
    :returns (mv erp
                 (new-dirabsdeclor? dirabsdeclor-optionp)
                 (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an optional direct abstract declarator."
    (b* (((reterr) nil (irr-dimb-table)))
      (dirabsdeclor-option-case
       dirabsdeclor?
       :some (dimb-dirabsdeclor dirabsdeclor?.val table)
       :none (retok nil (dimb-table-fix table))))
    :measure (dirabsdeclor-option-count dirabsdeclor?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-paramdecl ((paramdecl paramdeclp) (table dimb-tablep))
    :returns (mv erp (new-paramdecl paramdeclp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a parameter declaration."
    :long
    (xdoc::topstring
     (xdoc::p
      "We start by disambiguating the declaration specifiers,
       which may result in extending the disambiguation table.
       In valid code, the @('typedef') storage class specifier
       cannot occur among the declaration specifiers of a parameter declaration,
       so we ignore the disambiguation kind returned by
       the ACL2 function that processes the declaration specifiers;
       when we call that function, we initialize the kind to @(':objfun'),
       and if the code is valid that will be also the returned kind.
       Then we call a separate function to disambiguate the parameter declarator
       (which is a notion in our abstract syntax, not in [C]);
       see @(tsee paramdeclor))."))
    (b* (((reterr) (irr-paramdecl) (irr-dimb-table))
         ((paramdecl paramdecl) paramdecl)
         ((erp new-spec & table)
          (dimb-declspec-list paramdecl.spec (dimb-kind-objfun) table))
         ((erp new-decl table)
          (dimb-paramdeclor paramdecl.decl table)))
      (retok (make-paramdecl :spec new-spec :decl new-decl) table))
    :measure (paramdecl-count paramdecl))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-paramdecl-list ((paramdecls paramdecl-listp) (table dimb-tablep))
    :returns (mv erp (new-paramdecls paramdecl-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of parameter declarations."
    :long
    (xdoc::topstring
     (xdoc::p
      "We process each one, threading through the table."))
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp paramdecls)) (retok nil (dimb-table-fix table)))
         ((erp new-paramdecl table)
          (dimb-paramdecl (car paramdecls) table))
         ((erp new-paramdecls table)
          (dimb-paramdecl-list (cdr paramdecls) table)))
      (retok (cons new-paramdecl new-paramdecls) table))
    :measure (paramdecl-list-count paramdecls))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-paramdeclor ((paramdeclor paramdeclorp) (table dimb-tablep))
    :returns (mv erp (new-paramdeclor paramdeclorp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a parameter declarator."
    :long
    (xdoc::topstring
     (xdoc::p
      "A declarator is recursively disambiguated,
       and the identifier is added to the disambiguation table,
       as denoting an object or function.")
     (xdoc::p
      "An abstract declarator is recursively disambiguated,
       but since it does not introduce an identifier,
       the disambiguation table is left unchanged.")
     (xdoc::p
      "An absent parameter declarator is left unchanged,
       and so is the disambiguation table.")
     (xdoc::p
      "An ambiguous declarator or abstract declarator
       is disambiguated to a declarator or abstractor declarator,
       thus re-classifying the parameter declarator.
       If the disambiguation is in favor of a declarator,
       the identifier is also added to the disambiguation table.")
     (xdoc::p
      "Note that we call @(tsee dimb-declor)
       with @('nil') as the @('fundefp') flag,
       because the declarator passed to that function
       is for a parameter, not for a defined function."))
    (b* (((reterr) (irr-paramdeclor) (irr-dimb-table)))
      (paramdeclor-case
       paramdeclor
       :declor
       (b* (((erp new-declor ident table)
             (dimb-declor paramdeclor.unwrap nil table))
            (table (dimb-add-ident ident (dimb-kind-objfun) table)))
         (retok (paramdeclor-declor new-declor) table))
       :absdeclor
       (b* (((erp new-absdeclor table)
             (dimb-absdeclor paramdeclor.unwrap table)))
         (retok (paramdeclor-absdeclor new-absdeclor) (dimb-table-fix table)))
       :none
       (retok (paramdeclor-none) (dimb-table-fix table))
       :ambig
       (b* (((erp declor/absdeclor ident? table)
             (dimb-amb-declor/absdeclor paramdeclor.unwrap table)))
         (declor/absdeclor-case
          declor/absdeclor
          :declor
          (b* (((unless ident?)
                (raise "Internal error: declarator without identifier.")
                (reterr t))
               (table (dimb-add-ident ident? (dimb-kind-objfun) table)))
            (retok (paramdeclor-declor declor/absdeclor.unwrap) table))
          :absdeclor
          (retok (paramdeclor-absdeclor declor/absdeclor.unwrap)
                 (dimb-table-fix table))))))
    :measure (paramdeclor-count paramdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-tyname ((tyname tynamep) (table dimb-tablep))
    :returns (mv erp (new-tyname tynamep) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a type name."
    (b* (((reterr) (irr-tyname) (irr-dimb-table))
         ((tyname tyname) tyname)
         ((erp new-specqual table) (dimb-spec/qual-list tyname.specqual table))
         ((erp new-decl? table) (dimb-absdeclor-option tyname.decl? table)))
      (retok (make-tyname :specqual new-specqual :decl? new-decl?)
             table))
    :measure (tyname-count tyname))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-strunispec ((strunispec strunispecp) (table dimb-tablep))
    :returns (mv erp (new-strunispec strunispecp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a structure or union specifier."
    :long
    (xdoc::topstring
     (xdoc::p
      "The disambiguation table is unaffected as we go through the members;
       the table has no information about structure and union members."))
    (b* (((reterr) (irr-strunispec) (irr-dimb-table))
         ((strunispec strunispec) strunispec)
         ((erp new-members table)
          (dimb-structdecl-list strunispec.members table)))
      (retok (make-strunispec :name strunispec.name :members new-members)
             table))
    :measure (strunispec-count strunispec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-structdecl ((structdecl structdeclp) (table dimb-tablep))
    :returns (mv erp (new-structdecl structdeclp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a structure declaration."
    (b* (((reterr) (irr-structdecl) (irr-dimb-table)))
      (structdecl-case
       structdecl
       :member
       (b* (((erp new-specqual table)
             (dimb-spec/qual-list structdecl.specqual table))
            ((erp new-declor table)
             (dimb-structdeclor-list structdecl.declor table)))
         (retok (make-structdecl-member :extension structdecl.extension
                                        :specqual new-specqual
                                        :declor new-declor
                                        :attrib structdecl.attrib)
                table))
       :statassert
       (b* (((erp new-statassert table)
             (dimb-statassert structdecl.unwrap table)))
         (retok (structdecl-statassert new-statassert)
                table))))
    :measure (structdecl-count structdecl))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-structdecl-list ((structdecls structdecl-listp)
                                (table dimb-tablep))
    :returns (mv erp (new-structdecls structdecl-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of structure declarations."
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp structdecls)) (retok nil (dimb-table-fix table)))
         ((erp new-structdecl table) (dimb-structdecl (car structdecls) table))
         ((erp new-structdecls table)
          (dimb-structdecl-list (cdr structdecls) table)))
      (retok (cons new-structdecl new-structdecls) table))
    :measure (structdecl-list-count structdecls))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-structdeclor ((structdeclor structdeclorp) (table dimb-tablep))
    :returns (mv erp (new-structdeclor structdeclorp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a structure declarator."
    :long
    (xdoc::topstring
     (xdoc::p
      "Recall that the disambiguation table
       does not keep track of structure and union members.
       This is why we ignore the identifier, if any,
       returned from disambiguating the optional declarator."))
    (b* (((reterr) (irr-structdeclor) (irr-dimb-table))
         ((structdeclor structdeclor) structdeclor)
         ((erp new-declor? & table)
          (dimb-declor-option structdeclor.declor? table))
         ((erp new-expr? table)
          (dimb-const-expr-option structdeclor.expr? table)))
      (retok (make-structdeclor :declor? new-declor? :expr? new-expr?)
             table))
    :measure (structdeclor-count structdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-structdeclor-list ((structdeclors structdeclor-listp)
                                  (table dimb-tablep))
    :returns (mv erp
                 (new-structdeclors structdeclor-listp)
                 (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of structure declarators."
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp structdeclors)) (retok nil (dimb-table-fix table)))
         ((erp new-structdeclor table)
          (dimb-structdeclor (car structdeclors) table))
         ((erp new-structdeclors table)
          (dimb-structdeclor-list (cdr structdeclors) table)))
      (retok (cons new-structdeclor new-structdeclors) table))
    :measure (structdeclor-list-count structdeclors))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-enumspec ((enumspec enumspecp) (table dimb-tablep))
    :returns (mv erp (new-enumspec enumspecp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an enumeration specifier."
    :long
    (xdoc::topstring
     (xdoc::p
      "This also extends the disambiguation table
       with the names of the enumerators (i.e. enumeration constants).
       The scope of an enumeration constant starts
       just after the appearance of its enumerator [C:6.2.1/7].
       The extension of the table is actually done by
       the function that disambiguates the enumerators."))
    (b* (((reterr) (irr-enumspec) (irr-dimb-table))
         ((enumspec enumspec) enumspec)
         ((erp new-list table) (dimb-enumer-list enumspec.list table)))
      (retok (make-enumspec :name enumspec.name
                            :list new-list
                            :final-comma enumspec.final-comma)
             table))
    :measure (enumspec-count enumspec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-enumer ((enumer enumerp) (table dimb-tablep))
    :returns (mv erp (new-enumer enumerp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an enumerator."
    :long
    (xdoc::topstring
     (xdoc::p
      "We disambiguate the constant expression, if present.
       We also add the name to the disambiguation table."))
    (b* (((reterr) (irr-enumer) (irr-dimb-table))
         ((enumer enumer) enumer)
         ((erp new-value table) (dimb-const-expr-option enumer.value table))
         (table (dimb-add-ident enumer.name (dimb-kind-enumconst) table)))
      (retok (make-enumer :name enumer.name :value new-value) table))
    :measure (enumer-count enumer))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-enumer-list ((enumers enumer-listp) (table dimb-tablep))
    :returns (mv erp (new-enumers enumer-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a list of enumerators."
    :long
    (xdoc::topstring
     (xdoc::p
      "Each enumerator updates the disambiguation table,
       which we thread through."))
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp enumers)) (retok nil (dimb-table-fix table)))
         ((erp new-enumer table) (dimb-enumer (car enumers) table))
         ((erp new-enumers table) (dimb-enumer-list (cdr enumers) table)))
      (retok (cons new-enumer new-enumers) table))
    :measure (enumer-list-count enumers))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-statassert ((statassert statassertp) (table dimb-tablep))
    :returns (mv erp (new-statassert statassertp) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate a static assertion declaration."
    (b* (((reterr) (irr-statassert) (irr-dimb-table))
         ((statassert statassert) statassert)
         ((erp new-test table) (dimb-const-expr statassert.test table)))
      (retok (make-statassert :test new-test :message statassert.message)
             table))
    :measure (statassert-count statassert))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-amb-expr/tyname ((expr/tyname amb-expr/tyname-p)
                                (table dimb-tablep))
    :returns (mv erp (expr-or-tyname expr/tyname-p) (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an ambiguous expression or type name."
    :long
    (xdoc::topstring
     (xdoc::p
      "An ambiguous expression or type name is represented as
       a pair of an expression and a type name
       (with the same concrete syntax appearance).
       We attempt to disambiguate both the expression and the type name,
       independently from each other.
       In valid code, one of them must succeed and the other one must fail:
       then we disambiguate in favor of the one that succeeded.
       If none or both succeed, the code must be invalid."))
    (b* (((reterr) (irr-expr/tyname) (irr-dimb-table))
         ((amb-expr/tyname expr/tyname) expr/tyname)
         ((mv erp-expr new-expr table-expr)
          (dimb-expr expr/tyname.expr table))
         ((mv erp-tyname new-tyname table-tyname)
          (dimb-tyname expr/tyname.tyname table)))
      (if erp-expr
          ;; expr fails:
          (if erp-tyname
              ;; tyname fails:
              (reterr (msg "In the ambiguous expression or type name ~x0, ~
                            neither the expression nor the type name ~
                            can be successfully disambiguated ~
                            given the current table ~x1. ~
                            The code must be invalid, ~
                            because at least one must succeed.~%~%~
                            These are the failures for each:~%~%~
                            ~@2~%~%~@3"
                           (amb-expr/tyname-fix expr/tyname)
                           (dimb-table-fix table)
                           erp-expr
                           erp-tyname))
            ;; tyname succeeds:
            (retok (expr/tyname-tyname new-tyname) table-tyname))
        ;; expr succeeds:
        (if erp-tyname
            ;; tyname fails:
            (retok (expr/tyname-expr new-expr) table-expr)
          ;; tyname succeeds:
          (reterr (msg "In the ambiguous expression or type name ~x0, ~
                        both the expression and the type name ~
                        are successfully disambiguated ~
                        given the current table ~x1. ~
                        The code must be invalid, ~
                        because at most one must succeed."
                       (amb-expr/tyname-fix expr/tyname)
                       (dimb-table-fix table))))))
    :measure (amb-expr/tyname-count expr/tyname))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-amb-declor/absdeclor ((declor/absdeclor amb-declor/absdeclor-p)
                                     (table dimb-tablep))
    :returns (mv erp
                 (declor-or-absdeclor declor/absdeclor-p)
                 (ident? ident-optionp)
                 (new-table dimb-tablep))
    :parents (disambiguator dimb-exprs/decls)
    :short "Disambiguate an ambiguous declarator or abstract declarator."
    :long
    (xdoc::topstring
     (xdoc::p
      "An ambiguous declarator or abstract declarator is represented as
       a pair of a declarator and an abstract declarator
       (with the same concrete syntax appearance).
       We attempt to disambiguate
       both the declarator and the abstract declarator,
       independently from each other.
       If both fail, the code is invalid.
       If one of them succeeds while the other fails,
       we have a disambiguation.
       There are cases in which both can succeed,
       for instance in @('void f(int(x));')
       the @('(x)') could be a parenthesized declarator for identifier @('x'),
       but if a @('typedef') for @('x') is in scope,
       it could be also an abstract function declarator,
       where @('x') is the type of the (inner) parameter.
       [C:6.7.6.3/11] says that in this case
       the @('typedef') interpretation takes priority.
       Thus, in general,
       if both attempted disambiguations
       (as declarator and as abstract declarator)
       succeed, we check if
       the identifier returned by the successful disambiguation as declarator
       denotes a @('typedef') name:
       if the check succeeds,
       we keep the disambiguation as abstract declarator
       and discard the one as declarator.
       If instead the check fails, we return an error:
       we conjecture that this should only happen if the code is invalid,
       but this needs further investigation.")
     (xdoc::p
      "If the ambiguous declarator or abstract declarator
       turns out to be a declarator,
       we also return the identifier it declares.
       If it turns out to be an abstract declarator instead,
       we return @('nil').
       So, in general, this function returns an optional identifier,
       besides the disambiguated declarator or abstract declarator.")
     (xdoc::p
      "In the call of @(tsee dimb-declor)
       we pass @('nil') as the @('fundefp') flag,
       because if we are disambiguating a declarator or abstract declarator,
       it means that we are disambiguating a parameter declarator,
       and not the declarator of a defined function."))
    (b* (((reterr) (irr-declor/absdeclor) nil (irr-dimb-table))
         ((amb-declor/absdeclor declor/absdeclor) declor/absdeclor)
         ((mv erp-declor new-declor ident table-declor)
          (dimb-declor declor/absdeclor.declor nil table))
         ((mv erp-absdeclor new-absdeclor table-absdeclor)
          (dimb-absdeclor declor/absdeclor.absdeclor table)))
      (if erp-declor
          ;; declor fails:
          (if erp-absdeclor
              ;; absdeclor fails:
              (reterr (msg "In the ambiguous ~
                            declarator or abstract declarator ~x0, ~
                            neither the declarator nor the abstract declarator ~
                            can be successfully disambiguated ~
                            given the current table ~x1. ~
                            The code must be invalid, ~
                            because at least one must succeed.~%~%~
                            These are the failures for each:~%~%~
                            ~@2~%~%~@3"
                           (amb-declor/absdeclor-fix declor/absdeclor)
                           (dimb-table-fix table)
                           erp-declor
                           erp-absdeclor))
            ;; absdeclor succeeds:
            (retok (declor/absdeclor-absdeclor new-absdeclor)
                   nil
                   table-absdeclor))
        ;; declor succeeds:
        (if erp-absdeclor
            ;; absdeclor fails:
            (retok (declor/absdeclor-declor new-declor)
                   ident
                   table-declor)
          ;; absdeclor succeeds:
          (b* ((kind (dimb-lookup-ident ident table)))
            (if (equal kind (dimb-kind-typedef))
                (retok (declor/absdeclor-absdeclor new-absdeclor)
                       nil
                       table-absdeclor)
              (reterr (msg "In the ambiguous ~
                            declarator or abstract declarator ~x0, ~
                            both the declarator and the abstract declarator ~
                            are successfully disambiguated ~
                            given the current table ~x1, ~
                            and the identifier ~x2 in the declarator ~
                            is not a typedef name. ~
                            The code must be invalid, ~
                            because at most one must succeed."
                           (amb-declor/absdeclor-fix declor/absdeclor)
                           (dimb-table-fix table)
                           ident)))))))
    :measure (amb-declor/absdeclor-count declor/absdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  :hints (("Goal" :in-theory (enable o< o-finp)))

  :verify-guards :after-returns

  ///

  (fty::deffixequiv-mutual dimb-exprs/decls)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defret-mutual dimb-exprs/decls
    (defret expr-unambp-of-dimb-expr
      (implies (not erp)
               (expr-unambp new-expr))
      :fn dimb-expr)
    (defret expr-list-unambp-of-dimb-expr-list
      (implies (not erp)
               (expr-list-unambp new-exprs))
      :fn dimb-expr-list)
    (defret expr-option-unambp-of-dimb-expr-option
      (implies (not erp)
               (expr-option-unambp new-expr?))
      :fn dimb-expr-option)
    (defret const-expr-unambp-of-dimb-const-expr
      (implies (not erp)
               (const-expr-unambp new-cexpr))
      :fn dimb-const-expr)
    (defret const-expr-option-unambp-of-dimb-const-expr-option
      (implies (not erp)
               (const-expr-option-unambp new-cexpr?))
      :fn dimb-const-expr-option)
    (defret genassoc-unambp-of-dimb-genassoc
      (implies (not erp)
               (genassoc-unambp new-assoc))
      :fn dimb-genassoc)
    (defret genassoc-list-unambp-of-dimb-genassoc-list
      (implies (not erp)
               (genassoc-list-unambp new-assocs))
      :fn dimb-genassoc-list)
    (defret type-spec-unambp-of-dimb-type-spec
      (implies (not erp)
               (type-spec-unambp new-tyspec))
      :fn dimb-type-spec)
    (defret spec/qual-unambp-of-dimb-spec/qual
      (implies (not erp)
               (spec/qual-unambp new-specqual))
      :fn dimb-spec/qual)
    (defret spec/qual-list-unambp-of-dimb-spec/qual-list
      (implies (not erp)
               (spec/qual-list-unambp new-specquals))
      :fn dimb-spec/qual-list)
    (defret align-spec-unambp-of-dimb-align-spec
      (implies (not erp)
               (align-spec-unambp new-alignspec))
      :fn dimb-align-spec)
    (defret declspec-unambp-of-dimb-declspec
      (implies (not erp)
               (declspec-unambp new-declspec))
      :fn dimb-declspec)
    (defret declspec-list-unambp-of-dimb-declspec-list
      (implies (not erp)
               (declspec-list-unambp new-declspecs))
      :fn dimb-declspec-list)
    (defret initer-unambp-of-dimb-initer
      (implies (not erp)
               (initer-unambp new-initer))
      :fn dimb-initer)
    (defret initer-option-unambp-of-dimb-initer-option
      (implies (not erp)
               (initer-option-unambp new-initer?))
      :fn dimb-initer-option)
    (defret desiniter-unambp-of-dimb-desiniter
      (implies (not erp)
               (desiniter-unambp new-desiniter))
      :fn dimb-desiniter)
    (defret desiniter-list-unambp-of-dimb-desiniter-list
      (implies (not erp)
               (desiniter-list-unambp new-desiniters))
      :fn dimb-desiniter-list)
    (defret designor-unambp-of-dimb-designor
      (implies (not erp)
               (designor-unambp new-design))
      :fn dimb-designor)
    (defret designor-list-unambp-of-dimb-designor-list
      (implies (not erp)
               (designor-list-unambp new-designs))
      :fn dimb-designor-list)
    (defret declor-unambp-of-dimb-declor
      (implies (not erp)
               (declor-unambp new-declor))
      :fn dimb-declor)
    (defret declor-option-unambp-of-dimb-declor-option
      (implies (not erp)
               (declor-option-unambp new-declor?))
      :fn dimb-declor-option)
    (defret dirdeclor-unambp-of-dimb-dirdeclor
      (implies (not erp)
               (dirdeclor-unambp new-dirdeclor))
      :fn dimb-dirdeclor)
    (defret absdeclor-unambp-of-dimb-absdeclor
      (implies (not erp)
               (absdeclor-unambp new-absdeclor))
      :fn dimb-absdeclor)
    (defret absdeclor-option-unambp-of-dimb-absdeclor-option
      (implies (not erp)
               (absdeclor-option-unambp new-absdeclor?))
      :fn dimb-absdeclor-option)
    (defret dirabsdeclor-unambp-of-dimb-dirabsdeclor
      (implies (not erp)
               (dirabsdeclor-unambp new-dirabsdeclor))
      :fn dimb-dirabsdeclor)
    (defret dirabsdeclor-option-unambp-of-dimb-dirabsdeclor-option
      (implies (not erp)
               (dirabsdeclor-option-unambp new-dirabsdeclor?))
      :fn dimb-dirabsdeclor-option)
    (defret paramdecl-unambp-of-dimb-paramdecl
      (implies (not erp)
               (paramdecl-unambp new-paramdecl))
      :fn dimb-paramdecl)
    (defret paramdecl-list-unambp-of-dimb-paramdecl-list
      (implies (not erp)
               (paramdecl-list-unambp new-paramdecls))
      :fn dimb-paramdecl-list)
    (defret paramdeclor-unambp-of-dimb-paramdeclor
      (implies (not erp)
               (paramdeclor-unambp new-paramdeclor))
      :fn dimb-paramdeclor)
    (defret tyname-unambp-of-dimb-tyname
      (implies (not erp)
               (tyname-unambp new-tyname))
      :fn dimb-tyname)
    (defret strunispec-unambp-of-dimb-strunispec
      (implies (not erp)
               (strunispec-unambp new-strunispec))
      :fn dimb-strunispec)
    (defret structdecl-unambp-of-dimb-structdecl
      (implies (not erp)
               (structdecl-unambp new-structdecl))
      :fn dimb-structdecl)
    (defret structdecl-list-unambp-of-dimb-structdecl-list
      (implies (not erp)
               (structdecl-list-unambp new-structdecls))
      :fn dimb-structdecl-list)
    (defret structdeclor-unambp-of-dimb-structdeclor
      (implies (not erp)
               (structdeclor-unambp new-structdeclor))
      :fn dimb-structdeclor)
    (defret structdeclor-list-unambp-of-dimb-structdeclor-list
      (implies (not erp)
               (structdeclor-list-unambp new-structdeclors))
      :fn dimb-structdeclor-list)
    (defret enumspec-unambp-of-dimb-enumspec
      (implies (not erp)
               (enumspec-unambp new-enumspec))
      :fn dimb-enumspec)
    (defret enumer-unambp-of-dimb-enumer
      (implies (not erp)
               (enumer-unambp new-enumer))
      :fn dimb-enumer)
    (defret enumer-list-unambp-of-dimb-enumer-list
      (implies (not erp)
               (enumer-list-unambp new-enumers))
      :fn dimb-enumer-list)
    (defret statassert-unambp-of-dimb-statassert
      (implies (not erp)
               (statassert-unambp new-statassert))
      :fn dimb-statassert)
    (defret expr/tyname-unambp-of-dimb-amb-expr/tyname
      (implies (not erp)
               (expr/tyname-unambp expr-or-tyname))
      :fn dimb-amb-expr/tyname)
    (defret declor/absdeclor-unambp-of-dimb-amb-declor/absdeclor
      (implies (not erp)
               (declor/absdeclor-unambp declor-or-absdeclor))
      :fn dimb-amb-declor/absdeclor)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-initdeclor ((ideclor initdeclorp)
                         (kind dimb-kindp)
                         (table dimb-tablep))
  :returns (mv erp (new-ideclor initdeclorp) (new-table dimb-tablep))
  :short "Disambiguate an initializer declarator."
  :long
  (xdoc::topstring
   (xdoc::p
    "An initializer declarator is part of a declaration.
     At the end of the initializer declarator,
     the declared identifier is added to the disambiguation table,
     with the appropriate kind,
     which comes from the preceding declaration specifiers,
     and is passed to this function.")
   (xdoc::p
    "We pass @('nil') as the @('fundefp') flag to @(tsee dimb-declor),
     because an initializer declarator is not
     the declarator of a defined function."))
  (b* (((reterr) (irr-initdeclor) (irr-dimb-table))
       ((initdeclor ideclor) ideclor)
       ((erp new-declor ident table) (dimb-declor ideclor.declor nil table))
       ((erp new-init? table) (dimb-initer-option ideclor.init? table))
       (table (dimb-add-ident ident kind table)))
    (retok (make-initdeclor :declor new-declor :init? new-init?)
           table))
  :hooks (:fix)

  ///

  (defret initdeclor-unambp-of-dimb-initdeclor
    (implies (not erp)
             (initdeclor-unambp new-ideclor))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-initdeclor-list ((ideclors initdeclor-listp)
                              (kind dimb-kindp)
                              (table dimb-tablep))
  :returns (mv erp (new-ideclors initdeclor-listp) (new-table dimb-tablep))
  :short "Disambiguate a list of initializer declarators."
  :long
  (xdoc::topstring
   (xdoc::p
    "We process each one, in order.
     The kind is the same for all of them,
     obtained from the enclosing declaration,
     and passed to this function as input."))
  (b* (((reterr) nil (irr-dimb-table))
       ((when (endp ideclors)) (retok nil (dimb-table-fix table)))
       ((erp new-ideclor table) (dimb-initdeclor (car ideclors) kind table))
       ((erp new-ideclors table)
        (dimb-initdeclor-list (cdr ideclors) kind table)))
    (retok (cons new-ideclor new-ideclors) table))
  :hooks (:fix)

  ///

  (defret initdeclor-list-unambp-of-dimb-initdeclor-list
    (implies (not erp)
             (initdeclor-list-unambp new-ideclors))
    :hints (("Goal" :induct t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-decl ((decl declp) (table dimb-tablep))
  :returns (mv erp (new-decl declp) (new-table dimb-tablep))
  :short "Disambiguate a declaration."
  :long
  (xdoc::topstring
   (xdoc::p
    "First we process the declaration specifiers,
     which, as explained in @(tsee dimb-declspec),
     determine whether the (one or more) identifiers
     introduced by the declarators
     denote @('typedef') names or objects/functions.
     We pass the returned kind to the code that disambiguates
     the initializer declarators."))
  (b* (((reterr) (irr-decl) (irr-dimb-table)))
    (decl-case
     decl
     :decl
     (b* (((erp new-specs kind table)
           (dimb-declspec-list decl.specs (dimb-kind-objfun) table))
          ((erp new-init table)
           (dimb-initdeclor-list decl.init kind table)))
       (retok (make-decl-decl :extension decl.extension
                              :specs new-specs
                              :init new-init
                              :asm? decl.asm?
                              :attrib decl.attrib)
              table))
     :statassert
     (b* (((erp new-statassert table) (dimb-statassert decl.unwrap table)))
       (retok (decl-statassert new-statassert) table))))
  :hooks (:fix)

  ///

  (defret decl-unambp-of-dimb-decl
    (implies (not erp)
             (decl-unambp new-decl))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-decl-list ((decls decl-listp) (table dimb-tablep))
  :returns (mv erp (new-decls decl-listp) (new-table dimb-tablep))
  :short "Disambiguate a list of declarations."
  :long
  (xdoc::topstring
   (xdoc::p
    "The disambiguation table is threaded through."))
  (b* (((reterr) nil (dimb-table-fix table))
       ((when (endp decls)) (retok nil (dimb-table-fix table)))
       ((erp new-decl table) (dimb-decl (car decls) table))
       ((erp new-decls table) (dimb-decl-list (cdr decls) table)))
    (retok (cons new-decl new-decls) table))
  :verify-guards :after-returns
  :hooks (:fix)

  ///

  (defret decl-list-unambp-of-dimb-decl-list
    (implies (not erp)
             (decl-list-unambp new-decls))
    :hints (("Goal" :induct t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-label ((label labelp) (table dimb-tablep))
  :returns (mv erp (new-label labelp) (new-table dimb-tablep))
  :short "Disambiguate a label."
  :long
  (xdoc::topstring
   (xdoc::p
    "This may affect the disambiguation table,
     for a label that is a constant expression."))
  (b* (((reterr) (irr-label) (irr-dimb-table)))
    (label-case
     label
     :name (retok (label-fix label) (dimb-table-fix table))
     :const (b* (((erp new-cexpr table) (dimb-const-expr label.unwrap table)))
              (retok (label-const new-cexpr) table))
     :default (retok (label-fix label) (dimb-table-fix table))))
  :hooks (:fix)

  ///

  (defret label-unambp-of-dimb-label
    (implies (not erp)
             (label-unambp new-label))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-amb-decl/stmt ((decl/stmt amb-decl/stmt-p) (table dimb-tablep))
  :returns (mv erp (decl-or-stmt decl/stmt-p) (new-table dimb-tablep))
  :short "Disambiguate an ambiguous declaration or statement."
  :long
  (xdoc::topstring
   (xdoc::p
    "An ambiguous declaration or statement is represented as
     a pair of a declaration and an expression
     (with the same concrete syntax appearance);
     the latter is an expression and not a statement because
     the statement in question is always an expression statement,
     and so it suffices to represent the expression.
     We attempt to disambiguate both the declaration and the expression,
     independently from each other.
     In valid code, one of them must succeed and the other one must fail:
     then we disambiguate in favor of the one that succeeded.
     If none or both succeed, the code must be invalid."))
  (b* (((reterr) (irr-decl/stmt) (irr-dimb-table))
       ((amb-decl/stmt decl/stmt) decl/stmt)
       ((mv erp-decl new-decl table-decl) (dimb-decl decl/stmt.decl table))
       ((mv erp-expr new-expr table-expr) (dimb-expr decl/stmt.stmt table)))
    (if erp-decl
        ;; decl fails:
        (if erp-expr
            ;; stmt fails:
            (reterr (msg "In the ambiguous declaration or statement ~x0, ~
                          neither the declaration nor the expression ~
                          can be successfully disambiguated ~
                          given the current table ~x1. ~
                          The code must be invalid, ~
                          because at least one must succeed.~%~%~
                          These are the failures for each:~%~%~
                          ~@2~%~%~@3"
                         (amb-decl/stmt-fix decl/stmt)
                         (dimb-table-fix table)
                         erp-decl
                         erp-expr))
          ;; stmt succeeds:
          (retok (decl/stmt-stmt new-expr) table-expr))
      ;; decl succeeds:
      (if erp-expr
          ;; stmt fails:
          (retok (decl/stmt-decl new-decl) table-decl)
        ;; stmt succeeds:
        (reterr (msg "In the ambiguous declaration or statement ~x0, ~
                      both the declaration and the statement ~
                      are successfully disambiguated ~
                      given the current table ~x1. ~
                      The code must be invalid, ~
                      because at most one must succeed."
                     (amb-decl/stmt-fix decl/stmt)
                     (dimb-table-fix table))))))
  :hooks (:fix)

  ///

  (defret decl/stmt-unambp-of-dimb-amb-decl/stmt
    (implies (not erp)
             (decl/stmt-unambp decl-or-stmt))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defines dimb-stmts/blocks
  :short "Disambiguate statements, blocks, and related entities."

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-stmt ((stmt stmtp) (table dimb-tablep))
    :returns (mv erp (new-stmt stmtp) (new-table dimb-tablep))
    :parents (disambiguator dimb-stmts/blocks)
    :short "Disambiguate a statement."
    :long
    (xdoc::topstring
     (xdoc::p
      "A compound statement form a new scope.
       Thus we push a new scope before the block,
       which we pop after the block.")
     (xdoc::p
      "A selection statement forms a new scope, as do its sub-statements
       [C:6.8.4/3].")
     (xdoc::p
      "An iteration statement forms a new scope, as do its sub-statements
       [C:6.8.5/5]."))
    (b* (((reterr) (irr-stmt) (irr-dimb-table)))
      (stmt-case
       stmt
       :labeled
       (b* (((erp new-label table) (dimb-label stmt.label table))
            ((erp new-stmt table) (dimb-stmt stmt.stmt table)))
         (retok (make-stmt-labeled :label new-label :stmt new-stmt)
                table))
       :compound
       (b* ((table (dimb-push-scope table))
            ((erp new-items table) (dimb-block-item-list stmt.items table))
            (table (dimb-pop-scope table)))
         (retok (stmt-compound new-items) table))
       :expr
       (b* (((erp new-expr? table) (dimb-expr-option stmt.expr? table)))
         (retok (stmt-expr new-expr?) table))
       :if
       (b* ((table (dimb-push-scope table))
            ((erp new-test table) (dimb-expr stmt.test table))
            (table (dimb-push-scope table))
            ((erp new-then table) (dimb-stmt stmt.then table))
            (table (dimb-pop-scope table))
            (table (dimb-pop-scope table)))
         (retok (make-stmt-if :test new-test :then new-then) table))
       :ifelse
       (b* ((table (dimb-push-scope table))
            ((erp new-test table) (dimb-expr stmt.test table))
            (table (dimb-push-scope table))
            ((erp new-then table) (dimb-stmt stmt.then table))
            (table (dimb-pop-scope table))
            (table (dimb-push-scope table))
            ((erp new-else table) (dimb-stmt stmt.else table))
            (table (dimb-pop-scope table))
            (table (dimb-pop-scope table)))
         (retok (make-stmt-ifelse :test new-test :then new-then :else new-else)
                table))
       :switch
       (b* ((table (dimb-push-scope table))
            ((erp new-target table) (dimb-expr stmt.target table))
            (table (dimb-push-scope table))
            ((erp new-body table) (dimb-stmt stmt.body table))
            (table (dimb-pop-scope table))
            (table (dimb-pop-scope table)))
         (retok (make-stmt-switch :target new-target :body new-body) table))
       :while
       (b* ((table (dimb-push-scope table))
            ((erp new-test table) (dimb-expr stmt.test table))
            (table (dimb-push-scope table))
            ((erp new-body table) (dimb-stmt stmt.body table))
            (table (dimb-pop-scope table))
            (table (dimb-pop-scope table)))
         (retok (make-stmt-while :test new-test :body new-body) table))
       :dowhile
       (b* ((table (dimb-push-scope table))
            (table (dimb-push-scope table))
            ((erp new-body table) (dimb-stmt stmt.body table))
            (table (dimb-pop-scope table))
            ((erp new-test table) (dimb-expr stmt.test table))
            (table (dimb-pop-scope table)))
         (retok (make-stmt-dowhile :body new-body :test new-test) table))
       :for-expr
       (b* ((table (dimb-push-scope table))
            ((erp new-init table) (dimb-expr-option stmt.init table))
            ((erp new-test table) (dimb-expr-option stmt.test table))
            ((erp new-next table) (dimb-expr-option stmt.next table))
            (table (dimb-push-scope table))
            ((erp new-body table) (dimb-stmt stmt.body table))
            (table (dimb-pop-scope table)))
         (retok (make-stmt-for-expr :init new-init
                                    :test new-test
                                    :next new-next
                                    :body new-body)
                table))
       :for-decl
       (b* ((table (dimb-push-scope table))
            ((erp new-init table) (dimb-decl stmt.init table))
            ((erp new-test table) (dimb-expr-option stmt.test table))
            ((erp new-next table) (dimb-expr-option stmt.next table))
            (table (dimb-push-scope table))
            ((erp new-body table) (dimb-stmt stmt.body table))
            (table (dimb-pop-scope table)))
         (retok (make-stmt-for-decl :init new-init
                                    :test new-test
                                    :next new-next
                                    :body new-body)
                table))
       :for-ambig
       (b* ((table (dimb-push-scope table))
            ((erp decl/expr table) (dimb-amb-decl/stmt stmt.init table))
            ((erp new-test table) (dimb-expr-option stmt.test table))
            ((erp new-next table) (dimb-expr-option stmt.next table))
            (table (dimb-push-scope table))
            ((erp new-body table) (dimb-stmt stmt.body table))
            (table (dimb-pop-scope table)))
         (decl/stmt-case
          decl/expr
          :decl (retok (make-stmt-for-decl :init decl/expr.unwrap
                                           :test new-test
                                           :next new-next
                                           :body new-body)
                       table)
          :stmt (retok (make-stmt-for-expr :init decl/expr.unwrap
                                           :test new-test
                                           :next new-next
                                           :body new-body)
                       table)))
       :goto
       (retok (stmt-fix stmt) (dimb-table-fix table))
       :continue
       (retok (stmt-fix stmt) (dimb-table-fix table))
       :break
       (retok (stmt-fix stmt) (dimb-table-fix table))
       :return
       (b* (((erp new-expr? table) (dimb-expr-option stmt.expr? table)))
         (retok (stmt-return new-expr?) table))))
    :measure (stmt-count stmt))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-block-item ((item block-itemp) (table dimb-tablep))
    :returns (mv erp (new-item block-itemp) (new-table dimb-tablep))
    :parents (disambiguator dimb-stmts/blocks)
    :short "Disambiguate a block item."
    :long
    (xdoc::topstring
     (xdoc::p
      "An ambiguous declaration or (expression) statement
       is disambiguated and re-classified."))
    (b* (((reterr) (irr-block-item) (irr-dimb-table)))
      (block-item-case
       item
       :decl
       (b* (((erp new-decl table) (dimb-decl item.unwrap table)))
         (retok (block-item-decl new-decl) table))
       :stmt
       (b* (((erp new-stmt table) (dimb-stmt item.unwrap table)))
         (retok (block-item-stmt new-stmt) table))
       :ambig
       (b* (((erp decl/stmt table) (dimb-amb-decl/stmt item.unwrap table)))
         (decl/stmt-case
          decl/stmt
          :decl (retok (block-item-decl decl/stmt.unwrap) table)
          :stmt (retok (block-item-stmt (stmt-expr decl/stmt.unwrap)) table)))))
    :measure (block-item-count item))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define dimb-block-item-list ((items block-item-listp) (table dimb-tablep))
    :returns (mv erp (new-items block-item-listp) (new-table dimb-tablep))
    :parents (disambiguator dimb-stmts/blocks)
    :short "Disambiguate a list of block items."
    (b* (((reterr) nil (irr-dimb-table))
         ((when (endp items)) (retok nil (dimb-table-fix table)))
         ((erp new-item table) (dimb-block-item (car items) table))
         ((erp new-items table) (dimb-block-item-list (cdr items) table)))
      (retok (cons new-item new-items) table))
    :measure (block-item-list-count items))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  :hints (("Goal" :in-theory (enable o< o-finp)))

  :verify-guards :after-returns

  ///

  (fty::deffixequiv-mutual dimb-stmts/blocks)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defret-mutual stmts/blocks-unambp-of-dimb-stmts/blocks
    (defret stmt-unambp-of-dimb-stmt
      (implies (not erp)
               (stmt-unambp new-stmt))
      :fn dimb-stmt)
    (defret block-item-unambp-of-dimb-block-item
      (implies (not erp)
               (block-item-unambp new-item))
      :fn dimb-block-item)
    (defret block-item-list-unambp-of-dimb-block-item-list
      (implies (not erp)
               (block-item-list-unambp new-items))
      :fn dimb-block-item-list)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-fundef ((fundef fundefp) (table dimb-tablep))
  :returns (mv erp (new-fundef fundefp) (new-table dimb-tablep))
  :short "Disambiguate a function definition."
  :long
  (xdoc::topstring
   (xdoc::p
    "We process the declaration specifiers,
     obtaining the kind of the identifier declared by the declarator,
     which in valid code must be @(':objfun'),
     but we do not check this explicitly.")
   (xdoc::p
    "Then we process the declarator, passing @('t') as the @('fundefp') flag,
     because we are processing the declarator of a defined function.
     In valid code, this declarator will include a function declarator
     with either parameter declarations or identifiers,
     after it has been processed.
     Because of the @('fundefp') flag set to @('t'),
     the disambiguation table returned from @(tsee dimb-declor)
     will contain a newly pushed scope for the function definition.
     If the (disambiguated) declarator has parameter declarations,
     those will have added the formal parameters of the function to that scope.
     If instead the (disambiguated) declarator has just identifiers,
     the new scope will be empty,
     but the declarator will be followed, in the function definition,
     by declarations for the identifiers (again, assuming the code is valid).")
   (xdoc::p
    "We process those declarations, which will add the function parameters
     to the scope that was added when processing the declarator.")
   (xdoc::p
    "Then we add the declared function to the disambiguation table,
     so that it can be referenced from the body, in a recursive call.")
   (xdoc::p
    "After all of that, we disambiguate the body of the function definition,
     which is a block (i.e. compound statement) in valid code.
     But we do not push a new scope for the block,
     because the scope pushed by @(tsee dimb-declor)
     is already the one for the function body.")
   (xdoc::p
    "At the end, we pop the scope for the function definition,
     and we add the function to the table,
     so that it is available in the rest of the translation unit."))
  (b* (((reterr) (irr-fundef) (irr-dimb-table))
       ((fundef fundef) fundef)
       ((erp new-spec & table)
        (dimb-declspec-list fundef.spec (dimb-kind-objfun) table))
       ((erp new-declor ident table) (dimb-declor fundef.declor t table))
       ((erp new-decls table) (dimb-decl-list fundef.decls table))
       (table (dimb-add-ident ident (dimb-kind-objfun) table))
       ((unless (stmt-case fundef.body :compound))
        (reterr (msg "The body of the function definition ~x0 ~
                      is not a compound statement; ~
                      the code is invalid."
                     (fundef-fix fundef))))
       ((erp new-items table)
        (dimb-block-item-list (stmt-compound->items fundef.body) table))
       (table (dimb-pop-scope table))
       (table (dimb-add-ident ident (dimb-kind-objfun) table)))
    (retok (make-fundef :extension fundef.extension
                        :spec new-spec
                        :declor new-declor
                        :decls new-decls
                        :body (stmt-compound new-items))
           table))
  :hooks (:fix)

  ///

  (defret fundef-unambp-of-dimb-fundef
    (implies (not erp)
             (fundef-unambp new-fundef))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-extdecl ((extdecl extdeclp) (table dimb-tablep))
  :returns (mv erp (new-extdecl extdeclp) (new-table dimb-tablep))
  :short "Disambiguate an external declaration."
  (b* (((reterr) (irr-extdecl) (irr-dimb-table)))
    (extdecl-case
     extdecl
     :fundef
     (b* (((erp new-fundef table) (dimb-fundef extdecl.unwrap table)))
       (retok (extdecl-fundef new-fundef) table))
     :decl
     (b* (((erp new-decl table) (dimb-decl extdecl.unwrap table)))
       (retok (extdecl-decl new-decl) table))))
  :hooks (:fix)

  ///

  (defret extdecl-unambp-of-dimb-extdecl
    (implies (not erp)
             (extdecl-unambp new-extdecl))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-extdecl-list ((edecls extdecl-listp) (table dimb-tablep))
  :returns (mv erp (new-edecls extdecl-listp) (new-table dimb-tablep))
  :short "Disambiguate a list of external declarations."
  (b* (((reterr) nil (irr-dimb-table))
       ((when (endp edecls)) (retok nil (dimb-table-fix table)))
       ((erp new-edecl table) (dimb-extdecl (car edecls) table))
       ((erp new-edecls table) (dimb-extdecl-list (cdr edecls) table)))
    (retok (cons new-edecl new-edecls) table))
  :hooks (:fix)

  ///

  (defret extdecl-list-unambp-of-dimb-extdecl-list
    (implies (not erp)
             (extdecl-list-unambp new-edecls))
    :hints (("Goal" :induct t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-transunit ((tunit transunitp) (gcc booleanp))
  :returns (mv erp (new-tunit transunitp))
  :short "Disambiguate a translation unit."
  :long
  (xdoc::topstring
   (xdoc::p
    "We initialize the disambiguation table,
     we disambiguate all the external declarations in order,
     and we discard the final disambiguation table.")
   (xdoc::p
    "If the GCC flag is @('nil') (i.e. no GCC extensions),
     the initial disambiguation table is empty.
     If the flag is @('t'), for now the only difference is that
     we initialize the disambiguation table with some GCC built-ins.
     For now we only add some built-ins
     that we have observed in some preprocessed files.
     We should revisit this, adding all the GCC built-ins,
     with clear and accurate references."))
  (b* (((reterr) (irr-transunit))
       (edecls (transunit->decls tunit))
       (table (dimb-init-table))
       (table
         (if gcc
             (b* ((table (dimb-add-ident (ident "__builtin_bswap16")
                                         (dimb-kind-objfun)
                                         table))
                  (table (dimb-add-ident (ident "__builtin_bswap32")
                                         (dimb-kind-objfun)
                                         table))
                  (table (dimb-add-ident (ident "__builtin_bswap64")
                                         (dimb-kind-objfun)
                                         table)))
               table)
           table))
       ((erp new-edecls &) (dimb-extdecl-list edecls table)))
    (retok (transunit new-edecls)))
  :hooks (:fix)

  ///

  (defret transunit-unambp-of-dimb-transunit
    (implies (not erp)
             (transunit-unambp new-tunit))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define dimb-transunit-ensemble ((tuens transunit-ensemblep) (gcc booleanp))
  :returns (mv erp (new-tuens transunit-ensemblep))
  :short "Disambiguate a translation unit ensembles."
  :long
  (xdoc::topstring
   (xdoc::p
    "We also pass a flag saying whether GCC extensions should be accepted.")
   (xdoc::p
    "We disambiguate all the translation units, independently.
     We leave the file path mapping unchanged."))
  (b* (((reterr) (irr-transunit-ensemble))
       (tumap (transunit-ensemble->unwrap tuens))
       ((erp new-tumap) (dimb-transunit-ensemble-loop tumap gcc)))
    (retok (transunit-ensemble new-tumap)))
  :hooks (:fix)

  :prepwork

  ((define dimb-transunit-ensemble-loop ((tumap filepath-transunit-mapp)
                                         (gcc booleanp))
     :returns (mv erp (new-tumap filepath-transunit-mapp
                                 :hyp (filepath-transunit-mapp tumap)))
     :parents nil
     (b* (((reterr) nil)
          ((when (omap::emptyp tumap)) (retok nil))
          ((mv path tunit) (omap::head tumap))
          ((erp new-tunit) (dimb-transunit tunit gcc))
          ((erp new-tumap)
           (dimb-transunit-ensemble-loop (omap::tail tumap) gcc)))
       (retok (omap::update path new-tunit new-tumap)))
     :verify-guards :after-returns

     ///

     (fty::deffixequiv dimb-transunit-ensemble-loop
       :args ((gcc booleanp)))

     (defret transunit-ensemble-unambp-loop-of-dimb-transunit-ensemble-loop
       (implies (not erp)
                (transunit-ensemble-unambp-loop new-tumap))
       :hints (("Goal" :induct t)))))

  ///

  (defret transunit-ensemble-unambp-of-dimb-transunit-ensemble
    (implies (not erp)
             (transunit-ensemble-unambp new-tuens))))
