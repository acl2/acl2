; C Library
;
; Copyright (C) 2025 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (www.alessandrocoglio.info)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Purpose

; This file contains an ABNF grammar for C
; that is based on the grammar in [C17]
; but is meant for use by tools that manipulate C code.
; See :doc c$::syntax-for-tools for more information.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Notation

; The ABNF notation can capture well the notation described in [C17:6.1].
; We write ABNF rules that are similar to the syntax rules in [C17],
; to the extent possible, but the ABNF rules are tailored to our purpose.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Structure

; This file is divided into sections, separated by lines of 80 semicolons.
; Each section starts with a title.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Levels

; [C17] presents a lexical grammar [C17:A.1] and a phrase structure grammar [C17:A.2].
; This is a typical two-level grammar structure for programming languages:
; the first grammar describes how a sequence of characters
; is organized into lexical units (identifiers, constants, etc.),
; and the second grammar describes how the sequence of those lexical units
; is organized into higher-level constructs (expressions, statements, etc.).

; In C, the lexical organization is a bit more complicated than other languages,
; because of preprocessing and other features.
; In fact, the complete syntactic (and semantic) processing of code
; is described as consisting of 8 translation phases [C17:5.1.1.2].

; Since our grammar formulation aims at capturing at the same time
; the phrase structure of the code and some preprocessing constructs,
; we regard our grammars as defining just two phases:
; one for the lexical organization
; (which therefore includes both tokens and some preprocessing tokens),
; and one for a phrase structure that may also include preprocessing constructs
; (which therefore is an extension of the phrase structure grammar in [C17]).

; Our ABNF grammar does not consider
; the trigraph sequences handled in the first phase in [C17:5.1.1.2]
; and the splicing of lines in the second phase in [C17:5.1.1.2].
; These are simple transformations that can be performed
; prior to the processing described by our ABNF grammar,
; along with UTF-8 decoding if we start with Unicode files.

; Our ABNF grammar does not capture the requirement that
; a non-empty file ends with a new-line character (see phase 3 in [C17:5.1.1.2]).
; This can be easily enforced outside the grammar as well.

; [C17:5.1.1.2/6] requires that adjacent string literals are concatenated.
; This does not affect the lexing of the code, since string literals are tokens,
; but the parser needs to accept adjacent string literals.
; In the (phrase structure) grammar, we accommodate this
; by allowing one or more string literals where the grammar in [C17] allows one
; (the phrase grammar in [C17] corresponds to translation phase 7,
; which comes after adjacent string literal concatenation in phase 6).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Preprocessing

; As mentioned above, our ABNF grammar aims at capturing code
; in a form that includes the phrase structure
; with at least some preprocessing constructs.
; Actually, right now we do not capture any preprocessing construct,
; but we plan to do that soon; this is just an initial version.

; However, C preprocessing operates at a low lexical level,
; so it may be difficult or impossible to capture
; all possible C code in this hybrid way.
; In that case, it is always possible to preprocess the code separately,
; and then use this grammar, without preprocessing constructs.
; This ABNF grammar covers at least all preprocessed code.

; In that case, the preprocessing may be done via an external tool,
; e.g. (a component of) some existing C compiler.
; We may also build our own preprocessor in ACL2 at some point.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Characters [C17:5.2.1]

; [C17:5.2.1] provides requirements on the source character set,
; i.e. the character set used to write the C code,
; but the details of this character set are implementation-dependent;
; see [books]/kestrel/c/language/character-sets.lisp
; for a formalization of the requirements in [C17:5.2.1].
; In particular, [C17:5.2.1] does not prescribe ASCII or Unicode.
; Our grammar assumes Unicode, which is a very general assumption these days.

; We define the source character set as the union of
; the basic character set (which has an obvious ASCII interpretation)
; and an initial set of extended characters, which we will extend as needed.
; As we define these basic and extended character sets,
; we also define subsets of them used in other parts of the grammar.

; The basic characters are defined based on [C17:5.2.1].
; The 'digit' rule name corresponds to
; the 'digit' nonterminal in [C17:A.1.3] [C17:6.4.2.1];
; all the other rule names do not directly correspond to nonterminals in [C17].

uppercase-letter = %x41-5a ; A-Z

lowercase-letter = %x61-7a ; a-z

letter = uppercase-letter / lowercase-letter

digit = %x30-39 ; 0-9 [C17:A.1.3] [C17:6.4.2.1]

double-quote = %x22 ; "

graphic-character = %x21-23 ; ! " #
                  / %x25-2f ; % & ' ( ) * + , - . /
                  / %x3a-3f ; : ; < = > ?
                  / %x5b-5f ; [ \ ] ^ _
                  / %x7b-7e ; { | } ~

space = %x20 ; SP

horizontal-tab = %x09 ; HT

vertical-tab = %x0B ; VT

form-feed = %x0C ; FF

control-character = horizontal-tab
                  / vertical-tab
                  / form-feed

basic-character = letter
                / digit
                / graphic-character
                / space
                / control-character

; We support almost all non-ASCII Unicode characters,
; except for the bidirectional formatting characters,
; which may lead to the Trojan Source vulnerability.
; These are the format characters in the ranges %x202A-202E and %x2066-2069.
; We also exclude high and low surrogates, which are in the range %xD800-DFFF:
; these never result from UTF-8 decoding,
; but are only used in UFT-16 encoding;
; they are Unicode code points, but not Unicode scalar values.
; So the following are the "safe" non-ASCII characters that we support.

safe-nonascii = %x80-2029
              ; omit format characters %x202A-202E
              / %x202F-2065
              ; omit format characters %x2066-2069
              / %x206A-D7FF
              ; omit high and low surrogates
              / %xE000-10FFFF

; We support the following extended characters:
; the printable ASCII characters that are not basic characters ($ @ `),
; line feed, carriage return, and the safe non-ASCII characters defined above.
; Line feed and carriage return are needed
; to express what [C17] regards as new-line characters,
; which are, in general, new-line indications that could potentially be
; different actual characters, or not even characters.
; The following rule names do not directly correspond to nonterminals in [C17].

line-feed = %x0a ; LF

carriage-return = %x0d ; CR

extended-character = %x24 ; $
                   / %x40 ; @
                   / %x60 ; `
                   / line-feed
                   / carriage-return
                   / safe-nonascii

; This is our initial (source) character set.
; This rule name has no direct corresponding nonterminal in [C17],
; and is not used in the rest of our ABNF grammar,
; but it serves to clarify the character set.

character = basic-character
          / extended-character

; ASCII control characters like backspace (%x08) are potentially dangerous
; because they may make code appear different from what it is,
; depending on where it is displayed (editor, shell, etc.).
; These dangers are similar to Trojan Source,
; which is based on Unicode bidirectional format characters,
; described above.
; [C17] is silent on the matter; it does not even prescribe ASCII or Unicode.
; For now we exclude all those characters, in the definition above;
; note that none of the characters defined above exhibits these dangers.

; [C17] does not prescribe how lines should be terminated,
; but assumes a new-line character [C17:5.2.1].
; Given that we commit to ASCII/Unicode,
; it seems reasonable to define a new-line character as
; line feed, or carriage return, or carriage return and line feed;
; this is the same definition as in Java.
; Note that this is not necessarily a single character,
; but it follows the nomenclature of 'new-line character' in [C17].

new-line = line-feed
         / carriage-return
         / carriage-return line-feed

; We introduce rules for the character set except certain characters.
; These are used in other rules in the grammar given later,
; but they are included here so they are close to
; the structurally similar rules above,
; all of which must be updated consistently if we add more extended characters.
; These rules have no direct counterpart in [C17].

extended-character-not-new-line = %x24 ; $
                                / %x40 ; @
                                / %x60 ; `
                                ; omit line-feed and carriage-return
                                / safe-nonascii
                                ; cf. extended-character

graphic-character-not-star = %x21-23 ; ! " #
                           / %x25-29 ; % & ' ( )
                           ; omit *
                           / %x2b-2f ; + , - . /
                           / %x3a-3f ; : ; < = > ?
                           / %x5b-5f ; [ \ ] ^ _
                           / %x7b-7e ; { | } ~
                           ; cf. graphic-character

graphic-character-not-star-or-slash = %x21-23 ; ! " #
                                    / %x25-29 ; % & ' ( )
                                    ; omit *
                                    / %x2b-2e ; + , - .
                                    ; omit /
                                    / %x3a-3f ; : ; < = > ?
                                    / %x5b-5f ; [ \ ] ^ _
                                    / %x7b-7e ; { | } ~
                                    ; cf. graphic-character

graphic-character-not-single-quote-or-backslash = %x21-23 ; ! " #
                                                / %x25-26 ; % &
                                                ; omit '
                                                / %x28-2f ; ( ) * + , - . /
                                                / %x3a-3f ; : ; < = > ?
                                                / %x5b    ; [
                                                ; omit \
                                                / %x5d-5f ; ] ^ _
                                                / %x7b-7e ; { | } ~

graphic-character-not-double-quote-or-backslash =
      %x21    ; !
    ; omit "
    / %x23    ; #
    / %x25-2f ; % & ' ( ) * + , - . /
    / %x3a-3f ; : ; < = > ?
    / %x5b    ; [
    ; omit \
    / %x5d-5f ; ] ^ _
    / %x7b-7e ; { | } ~

basic-character-not-star = letter
                         / digit
                         / graphic-character-not-star
                         / space
                         / control-character

basic-character-not-star-or-slash = letter
                                  / digit
                                  / graphic-character-not-star-or-slash
                                  / space
                                  / control-character

basic-character-not-single-quote-or-backslash =
      letter
    / digit
    / graphic-character-not-single-quote-or-backslash
    / space
    / control-character

basic-character-not-double-quote-or-backslash =
      letter
    / digit
    / graphic-character-not-double-quote-or-backslash
    / space
    / control-character

character-not-new-line = basic-character
                       / extended-character-not-new-line

character-not-star = basic-character-not-star
                   / extended-character

character-not-star-or-slash = basic-character-not-star-or-slash
                            / extended-character

character-not-single-quote-or-backslash-or-new-line =
      basic-character-not-single-quote-or-backslash
    / extended-character-not-new-line

character-not-double-quote-or-backslash-or-new-line =
      basic-character-not-double-quote-or-backslash
    / extended-character-not-new-line

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; White Space [C17:6.4/3]

; [C17] designates the following as white-space characters:
; space, horizontal tab, vertical tab, form feed, and new line.
; It designates white space as not only these characters, but also comments.
; We introduce an ABNF rule (which has no counterpart grammar rule in [C17])
; for white-space characters (not comments, which are defined separately).

white-space = space
            / horizontal-tab
            / vertical-tab
            / form-feed
            / new-line

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Comments [C17:6.4.9]

; [C17] does not provide grammar rules for comments;
; it describes them informally in [C17:6.4.9].
; Here we provide ABNF grammar rules that capture the syntax of comments.

comment = block-comment
        / line-comment

block-comment = "/*" rest-of-block-comment

rest-of-block-comment =
      "*" rest-of-block-comment-after-star
    / character-not-star rest-of-block-comment

rest-of-block-comment-after-star =
      "/"
    / "*" rest-of-block-comment-after-star
    / character-not-star-or-slash rest-of-block-comment

line-comment = "//" *character-not-new-line

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Lexical elements [C17:A.1.1] [C17:6.4]

; In the grammar in [C17], tokens and preprocessing tokens overlap,
; and are meant to describe the language in different translation phases.
; However, in this grammar, as explained in 'Purpose' above,
; we mix together preprocessing tokens and (non-preprocessing) tokens.
; Currently they are all (non-preprocessing) tokens,
; but will add some preprocessing tokens.

token = keyword
      / identifier
      / constant
      / string-literal
      / punctuator

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Keywords [C17:A.1.2] [C17:6.4.1]

keyword = %s"auto"
        / %s"break"
        / %s"case"
        / %s"char"
        / %s"const"
        / %s"continue"
        / %s"default"
        / %s"do"
        / %s"double"
        / %s"else"
        / %s"enum"
        / %s"extern"
        / %s"float"
        / %s"for"
        / %s"goto"
        / %s"if"
        / %s"inline"
        / %s"int"
        / %s"long"
        / %s"register"
        / %s"restrict"
        / %s"return"
        / %s"short"
        / %s"signed"
        / %s"sizeof"
        / %s"static"
        / %s"struct"
        / %s"switch"
        / %s"typedef"
        / %s"union"
        / %s"unsigned"
        / %s"void"
        / %s"volatile"
        / %s"while"
        / %s"_Alignas"
        / %s"_Alignof"
        / %s"_Atomic"
        / %s"_Bool"
        / %s"_Complex"
        / %s"_Generic"
        / %s"_Imaginary"
        / %s"_Noreturn"
        / %s"_Static_assert"
        / %s"_Thread_local"

; Keywords for GCC extensions
; (https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html)

; The following are valid identifiers in standard C,
; but they are recognized as keywords as part of GCC extensions.
; This is not an exhaustive list,
; also because the GCC documentation does not seem to
; explicitly and clearly list all of them.
; The ones that we include here are ones that we have seen in documentation,
; including the "GNU C Reference Manual"
; at https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.pdf,
; which can be found via a web search
; but does not seem linked from the GCC main web site
; (which suggests that that manual may not be up to date);
; we have also verified in at least one implementation of GCC on MacOS
; that all the keywords below are indeed accepted.

gcc-keyword = %s"__alignof"
            / %s"__alignof__"
            / %s"asm"
            / %s"__asm"
            / %s"__asm__"
            / %s"__attribute"
            / %s"__attribute__"
            / %s"__auto_type"
            / %s"__builtin_offsetof"
            / %s"__builtin_types_compatible_p"
            / %s"__builtin_va_list"
            / %s"__declspec"
            / %s"__extension__"
            / %s"_Float32"
            / %s"_Float32x"
            / %s"_Float64"
            / %s"_Float64x"
            / %s"_Float128"
            / %s"_Float128x"
            / %s"__inline"
            / %s"__inline__"
            / %s"__int128"
            / %s"__restrict"
            / %s"__restrict__"
            / %s"__signed"
            / %s"__signed__"
            / %s"__stdcall"
            / %s"typeof"
            / %s"__typeof"
            / %s"__typeof__"
            / %s"__volatile"
            / %s"__volatile__"

; Given that some GCC keyword variants are completely equivalent
; to each other and to some standard keywords,
; we introduce grammar rules for these equivalence classes,
; to make their use in other rules more compact.

alignof-keyword = %s"_Alignof" / %s"__alignof" / %s"__alignof__"

asm-keyword = %s"asm" / %s"__asm" / %s"__asm__"

attribute-keyword = %s"__attribute" / %s"__attribute__"

inline-keyword = %s"inline" / %s"__inline" / %s"__inline__"

restrict-keyword = %s"restrict" / %s"__restrict" / %s"__restrict__"

signed-keyword = %s"signed" / %s"__signed" / %s"__signed__"

typeof-keyword = %s"typeof" / %s"__typeof" / %s"__typeof__"

volatile-keyword = %s"volatile" / %s"__volatile" / %s"__volatile__"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Identifiers [C17:A.1.3] [C17:6.4.2.1]

; For now we omit universal character names in identifiers.
; These have requirements specified in [C17:D].
; We could add them in the future if needed.

; For now we omit other implementation-defined characters from identifiers.
; We could add them in the future if needed.

; Our ABNF rule for 'nondigit' is equivalent to the one in [C17],
; but we use our 'letter' (defined above) instead of listing the letters.

identifier = identifier-nondigit
           / identifier identifier-nondigit
           / identifier digit

identifier-nondigit = nondigit
                    ; omit universal-character-name
                    ; omit other implementation-defined character

nondigit = "_"
         / letter

; During preprocessing, ideniifiers include keywords:
; see rule for 'preprocessing-token' in [C17:A.1.1] [C17:6.4].
; After preprocessing, identifiers exclude keywords:
; see rule for 'token' in [C17:A.1.1] [C17:6.4],
; and the extra-grammatical requirement in [C17:6.4.2.1/4].
; However, in the rule for 'identifier' in [C17:A.1.3] [C17:6.4.2.1],
; grammatically identifiers include keywords, as does our ABNF grammar rule.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Universal Character Names [C17:A.1.4] [C17:6.4.3]

universal-character-name = %s"\u" hex-quad
                         / %s"\U" hex-quad hex-quad

hex-quad =
  hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit

; The rule name 'hexadecimal-digit' is defined below, as part of constants.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Constants [C17:A.1.5] [C17:6.4.4]

; As a GCC extension, we allow the '\%' escape.
; Although we did not find it documented in the GCC manual,
; we encountered it in practical code, and we found this web page:
; https://stackoverflow.com/questions/34142682/what-is-the-backslash-percent-escape-in-c.

constant = integer-constant
         / floating-constant
         / enumeration-constant
         / character-constant

integer-constant = decimal-constant [ integer-suffix ]
                 / octal-constant [ integer-suffix ]
                 / hexadecimal-constant [ integer-suffix ]

decimal-constant = nonzero-digit
                 / decimal-constant digit

octal-constant = "0"
               / octal-constant octal-digit

hexadecimal-constant = hexadecimal-prefix hexadecimal-digit
                     / hexadecimal-constant hexadecimal-digit

hexadecimal-prefix = %i"0x"

nonzero-digit = %x31-39 ; 1-9

octal-digit = %x30-37 ; 0-7

hexadecimal-digit = %x30-39 ; 0-9
                  / %x61-66 ; a-f
                  / %x41-46 ; A-F

integer-suffix = unsigned-suffix [ long-suffix ]
               / unsigned-suffix [ long-long-suffix ]
               / long-suffix [ unsigned-suffix ]
               / long-long-suffix [ unsigned-suffix ]

unsigned-suffix = %i"u"

long-suffix = %i"l"

long-long-suffix = %s"ll" / %s"LL" ; note that %i"ll" would include lL and Ll

floating-constant = decimal-floating-constant
                  / hexadecimal-floating-constant

decimal-floating-constant =
      fractional-constant [ exponent-part ] [ floating-suffix ]
    / digit-sequence exponent-part [ floating-suffix ]

hexadecimal-floating-constant =
      hexadecimal-prefix hexadecimal-fractional-constant
                         binary-exponent-part [floating-suffix ]
    / hexadecimal-prefix hexadecimal-digit-sequence
                         binary-exponent-part [ floating-suffix ]

fractional-constant = [ digit-sequence ] "." digit-sequence
                    / digit-sequence "."

exponent-part = %i"e" [ sign ] digit-sequence

sign = "+" / "-"

digit-sequence = digit
               / digit-sequence digit

hexadecimal-fractional-constant =
      [ hexadecimal-digit-sequence ] "." hexadecimal-digit-sequence
    / hexadecimal-digit-sequence "."

binary-exponent-part = %i"p" [ sign ] digit-sequence

hexadecimal-digit-sequence = hexadecimal-digit
                           / hexadecimal-digit-sequence hexadecimal-digit

floating-suffix = %i"f" / %i"l"

enumeration-constant = identifier

character-constant = "'" c-char-sequence "'"
                   / %s"L'" c-char-sequence "'"
                   / %i"u'" c-char-sequence "'"

c-char-sequence = c-char
                / c-char-sequence c-char

c-char = character-not-single-quote-or-backslash-or-new-line
       / escape-sequence

escape-sequence = simple-escape-sequence
                / octal-escape-sequence
                / hexadecimal-escape-sequence
                / universal-character-name

simple-escape-sequence = "\'"
                       / "\" double-quote
                       / "\?"
                       / "\\"
                       / %s"\a"
                       / %s"\b"
                       / %s"\f"
                       / %s"\n"
                       / %s"\r"
                       / %s"\t"
                       / %s"\v"
                       / "\%" ; GCC extension

octal-escape-sequence = "\" octal-digit
                      / "\" octal-digit octal-digit
                      / "\" octal-digit octal-digit octal-digit

hexadecimal-escape-sequence = %s"\x" hexadecimal-digit
                            / hexadecimal-escape-sequence hexadecimal-digit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; String literals [C17:A.1.6] [C17:6.4.5]

string-literal =
    [ encoding-prefix ] double-quote [ s-char-sequence ] double-quote

encoding-prefix = %s"u8"
                / %i"u"
                / %s"L"

s-char-sequence = s-char
                / s-char-sequence s-char

s-char = character-not-double-quote-or-backslash-or-new-line
       / escape-sequence

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Punctuators [C17:A.1.7] [C17:6.4.6]

punctuator = "["
           / "]"
           / "("
           / ")"
           / "{"
           / "}"
           / "."
           / "->"
           / "++"
           / "--"
           / "&"
           / "*"
           / "+"
           / "-"
           / "~"
           / "!"
           / "/"
           / "%"
           / "<<"
           / ">>"
           / "<"
           / ">"
           / "<="
           / ">="
           / "=="
           / "!="
           / "^"
           / "|"
           / "&&"
           / "||"
           / "?"
           / ":"
           / ";"
           / "..."
           / "="
           / "*="
           / "/="
           / "%="
           / "+="
           / "-="
           / "<<="
           / ">>="
           / "&="
           / "^="
           / "|="
           / ","
           / "#"
           / "##"
           / "<:"
           / ":>"
           / "<%"
           / "%>"
           / "%:"
           / "%:%:"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Header names [C17:A.1.8] [C17:6.4.7]

; We omit these for now, but we will add them to represent #include directives.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Preprocessing numbers [C17:A.1.9] [C17:6.4.8]

; We omit these, because, as explained in 'Purpose' above,
; the goal of this grammar is to represent C code in a form
; that includes constructs both before and after preprocessing,
; and in fact we assume that numbers (constants) are (non-preprocessing) tokens,
; as we plan to capture only limited preprocessing constructs, as practical.
; But should we find a need to include these, we will, of course
; (e.g. in order to represent some more elaborate preprocessing constructs).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Lexemes

; As explained earlier when talking about the two grammar levels,
; the purpose of the lexical part of this ABNF grammar
; is to describe a single lexing phase.
; Thus, we provide an ABNF grammar rule for lexemes,
; i.e. the lexical units that the code is organized into.
; This rule has no grammar rule counterpart in [C17].

lexeme = token
       / comment
       / white-space

; The intent of the lexical part of our ABNF grammar is that
; a finite sequence of Unicode characters
; is organized into a sequence of lexemes.
; The ABNF grammar rules express most of the requirements for this,
; but not all, such as the fact that an identifier cannot be a keyword.
; An important and general extra-grammatical requirement is that
; the longest match is always taken [C17:6.4/4],
; with the exception noted there.

; The rest of the ABNF grammar rules in this file
; describe how lexemes are organized into higher-level constructs,
; corresponding to the phase structure grammar in [C17:A.2].
; Currently we only use tokens,
; discarding comments and white-space characters,
; but in the future we may retain some information from comments,
; given the purpose of this ABNF grammar.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Expressions [C17:A.2.1]

; As a GCC extension, we include statement expressions,
; i.e. expressions that consists of a parenthesized compound statement
; (https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html).
; Since they are parenthesized, we classify them as primary expressions.

; As a GCC extension, we include calls of '__builtin_types_compatible_p'
; (https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html),
; which are not normal function calls, because the arguments are types names.
; Although function calls are postfix expressions in general,
; since here the called function is known,
; it makes more sense for these to be primary expressions.

; As a GCC extension, we include calls of '__builtin_offsetof'
; (https://gcc.gnu.org/onlinedocs/gcc/Offsetof.html),
; which are not normal function calls,
; because the first argument is a type name.
; The GCC documentation page linked just above
; provides a grammar for these calls.
; We render that as an extension of our ABNF grammar;
; note that the second argument is a restricted form of expressions.

; As a GCC extension, we include calls of '__builtin_va_arg',
; which are not normal function calls,
; because the second argument is a type name.
; We did not find this documented in the GCC manual,
; presumably because it is an internal function,
; used to implement the user-visible 'va_arg' macro,
; although we did not find the latter in the GCC manual either,
; but some web searches support the view explained just above.

; As a GCC extension, we allow empty compound literals.
; GCC extensions for compound literals are described in
; https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html,
; which does not actually mention empty compound literals,
; but we have encountered them in practical code.

; As a GCC extensions, we allow conditionals with omitted operands,
; documented at https://gcc.gnu.org/onlinedocs/gcc/Conditionals.html.

; As a GCC extension, we allow a primary expression
; to be preceded by '__extension__'.
; This is briefly mentioned in the GCC manual
; (https://gcc.gnu.org/onlinedocs/gcc/Alternate-Keywords.html);
; experiments suggest that this keyword only applies to
; the subsequent primary expression,
; and not to a larger expression,
; which makes syntactic sense.
; The keyword and the expression are juxtaposed,
; without required parentheses;
; if there are parentheses, they below to the expression,
; which is therefore a parenthesized expression.

primary-expression = identifier
                   / constant
                   / 1*string-literal
                   / "(" expression ")"
                   / generic-selection
                   ; GCC extensions:
                   / "(" compound-statement ")"
                   / types-compatible-call
                   / offsetof-call
                   / va-arg-call
                   / %s"__extension__" primary-expression

types-compatible-call =
    %s"__builtin_types_compatible_p" "(" type-name "," type-name ")"

offsetof-call =
    %s"__builtin_offsetof" "(" type-name "," offsetof-member-designator ")"

offsetof-member-designator = identifier
                           / offsetof-member-designator "." identifier
                           / offsetof-member-designator "[" expression "]"

va-arg-call =
    %s"__builtin_va_arg" "(" assignment-expression "," type-name ")"

generic-selection =
    %s"_Generic" "(" assignment-expression "," generic-assoc-list ")"

generic-assoc-list = generic-association
                   / generic-assoc-list "," generic-association

generic-association = type-name ":" assignment-expression
                    / %s"default" ":" assignment-expression

postfix-expression = primary-expression
                   / postfix-expression "[" expression "]"
                   / postfix-expression "(" [ argument-expression-list ] ")"
                   / postfix-expression "." identifier
                   / postfix-expression "->" identifier
                   / postfix-expression "++"
                   / postfix-expression "--"
                   / "(" type-name ")" "{" initializer-list "}"
                   / "(" type-name ")" "{" initializer-list "," "}"
                   / "(" type-name ")" "{" "}" ; GCC extension

argument-expression-list = assignment-expression
                         / argument-expression-list "," assignment-expression

unary-expression = postfix-expression
                 / "++" unary-expression
                 / "--" unary-expression
                 / unary-operator cast-expression
                 / %s"sizeof" unary-expression
                 / %s"sizeof" "(" type-name ")"
                 / alignof-keyword "(" type-name ")"

unary-operator = "&"
               / "*"
               / "+"
               / "-"
               / "~"
               / "!"

cast-expression = unary-expression
                / "(" type-name ")" cast-expression

multiplicative-expression = cast-expression
                          / multiplicative-expression "*" cast-expression
                          / multiplicative-expression "/" cast-expression
                          / multiplicative-expression "%" cast-expression

additive-expression = multiplicative-expression
                    / additive-expression "+" multiplicative-expression
                    / additive-expression "-" multiplicative-expression

shift-expression = additive-expression
                 / shift-expression "<<" additive-expression
                 / shift-expression ">>" additive-expression

relational-expression = shift-expression
                      / relational-expression "<" shift-expression
                      / relational-expression ">" shift-expression
                      / relational-expression "<=" shift-expression
                      / relational-expression ">=" shift-expression

equality-expression = relational-expression
                    / equality-expression "==" relational-expression
                    / equality-expression "!=" relational-expression

and-expression = equality-expression
               / and-expression "&" equality-expression

exclusive-or-expression = and-expression
                        / exclusive-or-expression "^" and-expression

inclusive-or-expression = exclusive-or-expression
                        / inclusive-or-expression "|" exclusive-or-expression

logical-and-expression = inclusive-or-expression
                       / logical-and-expression "&&" inclusive-or-expression

logical-or-expression = logical-and-expression
                      / logical-or-expression "||" logical-and-expression

conditional-expression =
      logical-or-expression
    / logical-or-expression "?" expression ":" conditional-expression
    / logical-or-expression "?" ":" conditional-expression ; GCC extension

assignment-expression =
      conditional-expression
    / unary-expression assignment-operator assignment-expression

assignment-operator = "="
                    / "*="
                    / "/="
                    / "%="
                    / "+="
                    / "-="
                    / "<<="
                    / ">>="
                    / "&="
                    / "^="
                    / "|="

expression = assignment-expression
           / expression "," assignment-expression

constant-expression = conditional-expression

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Attributes (https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html)

; These are a GCC extension (see motivation in :doc syntax-for-tools).
; The GCC documentation does not provide an explicit grammar,
; so our ABNF grammar rules are based on the informal description there.

; The GCC documentation mentions three kinds of attributes:
; empty, names, and names with parameters.
; For now we do not model empty ones.
; We model the other two as consistsing of an attribute name
; optionally followed by a parenthesized list of one or more parameters.
; An attribute name is an identifier or a keyword:
; the GCC documentation mentions
; identifiers and reserved words as attribute names,
; where 'reserved word' is presumably a synonym of 'keyword',
; according to the official nomenclature in [C17].

; The GCC documentation mentions three kinds of parameters,
; where each kind seems to refer to the whole list of parameters
; (not to individual parameters),
; because otherwise the grouping would be ambiguous.
; The three kinds are
; (i) a single identifier,
; (ii) an identifier followed by a comma
; and by a non-empty comma-separated sequence of expressions,
; and (iii) a possibly empty comma-separated sequence of expressions.
; These three alternatives overlap syntactically,
; because identifiers are expressions.
; Thus, in our grammar rules, we just say that
; attribute parameters are a parenthesized sequence of
; zero or more comma-separated assignment expressions.
; Note that we use assignment expressions, and not more general expressions,
; because otherwise the grouping would be ambiguous,
; if an expression included the comma operator.

attribute-name = identifier / keyword

attribute-parameters =
    "(" [ assignment-expression *( "," assignment-expression ) ] ")"

attribute = attribute-name [ attribute-parameters ]

; An attribute specifiers consists of
; the keyword '__attribute__' or '__attribute',
; followed by zero or more comma-separated attributes
; enclosed in double parentheses.
; We regard each double (open or closed) parenthesis
; as consisting of two separate tokens,
; so that we do not have to define a new kind of token.
; This means that our grammar allows white space and comments
; between the two open or closed parenthesis.
; It is not clear from the GCC documentation if this is allowed;
; perhaps we should run an experiment with GCC to see whether that is allowed.

attribute-list = attribute *( "," attribute )

attribute-specifier = attribute-keyword "(" "(" [ attribute-list ] ")" ")"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Assembler
; (https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html)

; This is a GCC extension,
; introduced by the keywords 'asm', '__asm', or '__asm__'.
; The GCC documentation describes three instances of this:
; 1. One to specify the assembler name of a function or variable
;    (https://gcc.gnu.org/onlinedocs/gcc/Asm-Labels.html).
;    We call this 'assembler name specifier', which seems fitting,
;    although the GCC documentation does not seem to use a precise term.
; 2. Basic assembler statements, i.e. instructions without operands
;    (https://gcc.gnu.org/onlinedocs/gcc/Basic-Asm.html).
; 3. Extended assembler statements, i.e. instructions with operands
;    (https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html).

; An assembler name specifier consists of an 'asm' or variant keyword
; followed by a parenthesized sequence of one or more string literals.
; Recall that our grammar captures juxtaposed string literals,
; not just their concatenation; this is why we allow one or more here.

asm-name-specifier = asm-keyword "(" 1*string-literal ")"

; We capture basic and extended assembler statements together,
; with the basic ones as a special case of the extended ones.
; We follow the grammar in the GCC documentation (see links above).
; Recall that we use ABNF repetitions of one or more string literals
; in order to capture the string juxtaposition prior to string concatenation.

asm-qualifier = volatile-keyword / inline-keyword / %s"goto"

asm-statement = asm-keyword
                *asm-qualifier
                "("
                1*string-literal
                [ ":" asm-output-operands
                [ ":" asm-input-operands
                [ ":" asm-clobbers
                [ ":" asm-goto-labels ] ] ] ]
                ")"
                ";"

asm-output-operands = [ asm-output-operand *( "," asm-output-operand ) ]

asm-output-operand = [ "[" identifier "]" ] 1*string-literal "(" expression ")"

asm-input-operands = [ asm-input-operand *( "," asm-input-operand ) ]

asm-input-operand = [ "[" identifier "]" ] 1*string-literal "(" expression ")"

asm-clobbers = [ asm-clobber *( "," asm-clobber ) ]

asm-clobber = 1*string-literal

asm-goto-labels = [ identifier *( "," identifier ) ]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Declarations [C17:A.2.2]

; As a GCC extension, we allow the GCC keyword '__extension__'
; to occur at the start of a (member) structure declaration
; and at the start of a (non-static-assertion) declaration.

; As a GCC extension,
; we allow declaration specifiers, as well as specifier and qualifier lists,
; to include attribute specifiers;
; these can be easily distinguished from other declaration specifiers
; by the starting '__attribute__' or '__attribute' GCC keyword.

; As a GCC extension,
; we allow the '__stdcall' keyword as a declaration specifier.
; The latter is documented as an attribute 'stdcall' in the GCC manual,
; which should therefore have the syntax '__attribute__((stdcall))',
; but apparently it is also accepted by itself, with two underscores in front,
; but only in certain places (not everywhere normal attributes are allowed).

; As a GCC extension,
; we allow the '__declspec' attribute syntax as a declaration specifier.

; As a GCC extension, allow a list of type qualifiers
; to also contains attribute specifiers.
; Thus we use type-qualifier-and-attribute-specifier-list
; instead of just type-qualifier-list.

; The above may not the only places where attribute specifiers may occur,
; in the full GCC extensions, but they are places that have been observed.
; Our purpose in supporting the GCC extensions, for now,
; is not to be exhaustive,
; but rather to be able to handle practical C code that
; does not quite comply with the standard due to the presence of GCC extensions.

; As a GCC extension, we allow an optional assembler name specifier
; just after top-level declarators in initializer declarators,
; and before the attributes (see below).

; As GCC extensions, we include
; the '__signed' and '__signed__' variants of 'signed' as type specifiers.

; As GCC extensions, we include the type specifiers
; '__int128',
; '_Float32',
; '_Float32x',
; '_Float64',
; '_Float64x',
; '_Float128',
; '_Float128x',
; and '__builtin_va_list'.

; We include the GCC extension for the 'typeof' operator,
; along with its '__typeof' and '__typeof__' variants.
; This is documented at https://gcc.gnu.org/onlinedocs/gcc/Typeof.html.
; This must fit into the grammar as a type specifier.

; As a GCC extension, we include the '__auto_type' abbreviation
; (see the end of https://gcc.gnu.org/onlinedocs/gcc/Typeof.html),
; which is a type specifier.

; As a GCC extension, we allow attribute specifiers
; at the end of a top-level declarator in an initialization declarator,
; just after the assembler name specifier if any.
; This extension,
; including the fact that it follows the assembler name specifier if any,
; is documented in https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html,
; under 'All other attributes', 5th paragraph
; (this reference might change as the GCC manual gets updated).

; As a GCC extension, we allow structures with no members:
; see https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html.

; We also allow a lone semicolon as a structure declaration.
; This is definitely not grammatical according to [C17],
; and we did not find it anywhere in the GCC documentation;
; nonetheless, we encountered it in practical code.
; Presumably, it may make it easier to write certain macros.
; Semantically, it amounts to nothing, i.e. it is ignored.

declaration = [ %s"__extension__" ] ; GCC extension
              declaration-specifiers
              [ init-declarator-list ]
              ";"
            / static-assert-declaration

declaration-specifiers =
      storage-class-specifier [ declaration-specifiers ]
    / type-specifier [ declaration-specifiers ]
    / type-qualifier [ declaration-specifiers ]
    / function-specifier [ declaration-specifiers ]
    / alignment-specifier [ declaration-specifiers ]
    ; GCC extensions:
    / attribute-specifier [ declaration-specifiers ]
    / %s"__stdcall" [ declaration-specifiers ]
    / %s"__declspec" "(" identifier ")" [ declaration-specifiers ]

init-declarator-list = init-declarator
                     / init-declarator-list "," init-declarator

init-declarator =
      declarator [ asm-name-specifier ] *attribute-specifier
    / declarator [ asm-name-specifier ] *attribute-specifier "=" initializer

storage-class-specifier = %s"typedef"
                        / %s"extern"
                        / %s"static"
                        / %s"_Thread_local"
                        / %s"auto"
                        / %s"register"

type-specifier = %s"void"
               / %s"char"
               / %s"short"
               / %s"int"
               / %s"long"
               / %s"float"
               / %s"double"
               / signed-keyword
               / %s"unsigned"
               / %s"_Bool"
               / %s"_Complex"
               / atomic-type-specifier
               / struct-or-union-specifier
               / enum-specifier
               / typedef-name
               ; GCC extensions:
               / %s"__int128"
               / %s"_Float32"
               / %s"_Float32x"
               / %s"_Float64"
               / %s"_Float64x"
               / %s"_Float128"
               / %s"_Float128x"
               / %s"__builtin_va_list"
               / typeof-keyword "(" expression ")"
               / typeof-keyword "(" type-name ")"
               / %s"__auto_type"

struct-or-union-specifier =
      struct-or-union [ identifier ] "{" struct-declaration-list "}"
    / struct-or-union identifier
    / %s"struct" [ identifier ] "{" "}" ; GCC extension

struct-or-union = %s"struct"
                / %s"union"

struct-declaration-list = struct-declaration
                        / struct-declaration-list struct-declaration

struct-declaration = [ %s"__extension__" ] ; GCC extension
                     specifier-qualifier-list
                     [ struct-declarator-list ]
                     *attribute-specifier ; GCC extension
                     ";"
                   / static-assert-declaration
                   / ";"

specifier-qualifier-list = type-specifier [ specifier-qualifier-list ]
                         / type-qualifier [ specifier-qualifier-list ]
                         / alignment-specifier [ specifier-qualifier-list ]
                         ; GCC extension:
                         / attribute-specifier [ specifier-qualifier-list ]

struct-declarator-list = struct-declarator
                       / struct-declarator-list "," struct-declarator

struct-declarator = declarator
                  / [ declarator ] ":" constant-expression

enum-specifier = %s"enum" [ identifier ] "{" enumerator-list "}"
               / %s"enum" [ identifier ] "{" enumerator-list "," "}"
               / %s"enum" identifier

enumerator-list = enumerator
                / enumerator-list "," enumerator

enumerator = enumeration-constant
           / enumeration-constant "=" constant-expression

atomic-type-specifier = %s"_Atomic" "(" type-name ")"

type-qualifier = %s"const"
               / restrict-keyword
               / volatile-keyword
               / %s"_Atomic"

function-specifier = inline-keyword
                   / %s"_Noreturn"

alignment-specifier = %s"_Alignas" "(" type-name ")"
                    / %s"_Alignas" "(" constant-expression ")"

declarator = [ pointer ] direct-declarator

direct-declarator =
      identifier
    / "(" declarator ")"
    / direct-declarator
      "[" [ type-qualifier-and-attribute-specifier-list ]
          [ assignment-expression ] "]"
    / direct-declarator
      "[" %s"static" [ type-qualifier-and-attribute-specifier-list ]
          assignment-expression "]"
    / direct-declarator
      "[" type-qualifier-and-attribute-specifier-list %s"static"
          assignment-expression "]"
    / direct-declarator
      "[" [ type-qualifier-and-attribute-specifier-list ] "*" "]"
    / direct-declarator "(" parameter-type-list ")"
    / direct-declarator "(" [ identifier-list ] ")"

pointer = "*" [ type-qualifier-and-attribute-specifier-list ]
        / "*" [ type-qualifier-and-attribute-specifier-list ] pointer

type-qualifier-or-attribute-specifier = type-qualifier / attribute-specifier

type-qualifier-and-attribute-specifier-list =
      type-qualifier-or-attribute-specifier
    / type-qualifier-and-attribute-specifier-list
      type-qualifier-or-attribute-specifier

parameter-type-list = parameter-list
                    / parameter-list "," "..."

parameter-list = parameter-declaration
               / parameter-list "," parameter-declaration

parameter-declaration = declaration-specifiers declarator
                      / declaration-specifiers [ abstract-declarator ]

identifier-list = identifier
                / identifier-list "," identifier

type-name = specifier-qualifier-list [ abstract-declarator ]

abstract-declarator = pointer
                    / [ pointer ] direct-abstract-declarator

direct-abstract-declarator =
      "(" abstract-declarator ")"
    / [ direct-abstract-declarator ]
      "[" [ type-qualifier-and-attribute-specifier-list ]
          [ assignment-expression ] "]"
    / [ direct-abstract-declarator ]
      "[" %s"static" [ type-qualifier-and-attribute-specifier-list ]
          assignment-expression "]"
    / [ direct-abstract-declarator ]
      "[" type-qualifier-and-attribute-specifier-list %s"static"
          assignment-expression "]"
    / [ direct-abstract-declarator ] "[" "*" "]"
    / [ direct-abstract-declarator ] "(" [ parameter-type-list ] ")"

typedef-name = identifier

initializer = assignment-expression
            / "{" initializer-list "}"
            / "{" initializer-list "," "}"

initializer-list = [ designation ] initializer
                 / initializer-list "," [ designation ] initializer

designation = designator-list "="

designator-list = designator
                / designator-list designator

designator = "[" constant-expression "]"
           / "." identifier

static-assert-declaration =
    %s"_Static_assert" "(" constant-expression "," 1*string-literal ")" ";"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Statements [C17:A.2.3]

; As a GCC extension, we allow case ranges
; (https://gcc.gnu.org/onlinedocs/gcc/Case-Ranges.html).
; That is, instead of a single constant expression just after 'case',
; we allow two, separated by the three-dot punctuator
; (this punctuator also exists in standard C, for a different purpose).

statement = labeled-statement
          / compound-statement
          / expression-statement
          / selection-statement
          / iteration-statement
          / jump-statement
          / asm-statement ; GCC extension

labeled-statement = identifier ":" statement
                  / %s"case" constant-expression
                    [ "..." constant-expression ] ; GCC extension
                    ":" statement
                  / %s"default" ":" statement

compound-statement = "{" [ block-item-list ] "}"

block-item-list = block-item
                / block-item-list block-item

block-item = declaration
           / statement

expression-statement = [ expression ] ";"

selection-statement = %s"if" "(" expression ")" statement
                    / %s"if" "(" expression ")" statement %s"else" statement
                    / %s"switch" "(" expression ")" statement

iteration-statement =
      %s"while" "(" expression ")" statement
    / %s"do" statement %s"while" "(" expression ")" ";"
    / %s"for" "(" [ expression ] ";" [ expression ] ";" [ expression ] ")"
      statement
    / %s"for" "(" declaration [ expression ] ";" [ expression ] ")"
      statement

jump-statement = %s"goto" identifier ";"
               / %s"continue" ";"
               / %s"break" ";"
               / %s"return" [ expression ] ";"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; External definitions [C17:A.2.4]

; As a GCC extension, we allow the GCC keyword '__extension__'
; to occur at the start of a function definition.
; We also allow an assembler name specifier
; just after the declarator of a function definition,
; possibly followed by zero or more attribute specifiers;
; this is similar to initializer declarators.

; We also allow a lone semicolon as an external declaration.
; This is definitely not grammatical according to [C17],
; and we did not find it anywhere in the GCC documentation;
; nonetheless, we encountered it in practical code.
; Presumably, it may make it easier to write certain macros.
; Semantically, it amounts to nothing, i.e. it is ignored.
; Note that this is not a null statement,
; because we are the top level.

; As a GCC extension, we allow assembler statements at the top level,
; i.e. as external declarations.
; We could not find a place in the GCC documentation saying that
; assembler statements can occur at the top level,
; but we encountered that in practical code.

translation-unit = external-declaration
                 / translation-unit external-declaration

external-declaration = function-definition
                     / declaration
                     ; GCC extensions:
                     / ";"
                     / asm-statement

function-definition = [ %s"__extension__" ] ; GCC extension
                      declaration-specifiers
                      declarator
                      [asm-name-specifier] ; GCC extension
                      *attribute-specifier ; GCC extension
                      [ declaration-list ]
                      compound-statement

declaration-list = declaration
                 / declaration-list declaration

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Preprocessing directives [C17:A.3]

; We will capture (some forms of) these in the future.
