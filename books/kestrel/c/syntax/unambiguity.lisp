; C Library
;
; Copyright (C) 2025 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (www.alessandrocoglio.info)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "C$")

(include-book "abstract-syntax-operations")
(include-book "code-ensembles")

(include-book "kestrel/fty/deffold-reduce" :dir :system)

(local (include-book "kestrel/built-ins/disable" :dir :system))
(local (acl2::disable-most-builtin-logic-defuns))
(local (acl2::disable-builtin-rewrite-rules-for-defaults))
(set-induction-depth-limit 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ unambiguity
  :parents (syntax-for-tools)
  :short "Unambiguity of the ASTs."
  :long
  (xdoc::topstring
   (xdoc::p
    "Our "
    (xdoc::seetopic "abstract-syntax" "abstract syntax")
    " includes ambiguous constructs,
     i.e. constructs that capture syntactically ambiguous constructs;
     see the documentation of the abstract syntax for details.
     The @(see disambiguator), if successful,
     removes those constructs, leaving only the unambiguous ones.")
   (xdoc::p
    "Here we define predicates over the abstract syntax
     that say whether the constructs are unambiguous,
     i.e. whether there are no ambiguous constructs.")
   (xdoc::p
    "For now we do not make any checks on GCC extensions,
     even though they may contain expressions.
     This mirrors the treatment in the @(see disambiguator):
     the reason for this (temporary) limitation is explained there."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::deffold-reduce unambp
  :short "Definition of the unambiguity predicates."
  :long
  (xdoc::topstring
   (xdoc::p
    "We use @(tsee fty::deffold-reduce) to define these predicates concisely.")
   (xdoc::p
    "The @(':default') value is @('t'),
     because constructs like identifiers and constants are unambiguous;
     ambiguities may only exist in expressions, type names, etc.")
   (xdoc::p
    "We override the boilerplate to return @('nil') on
     the fixtype cases with @('ambig') in their names,
     the fixtypes @('amb-...'),
     and the dummy base case of @(tsee dirabsdeclor);
     although the latter is not properly an ambiguous construct,
     we take the opportunity to exclude it here from consideration
     whenever unambiguous constructs are concerned
     (which is for most of the tools, except for parser and disambiguator).")
   (xdoc::p
    "We override the boilerplate to return @('t') on
     GCC attributes, attribute specifiers, and assembler constructs."))
  :types (exprs/decls/stmts
          type-spec-list
          expr/tyname
          declor/absdeclor
          decl/stmt
          fundef
          fundef-option
          extdecl
          extdecl-list
          transunit
          filepath-transunit-map
          transunit-ensemble)
  :result booleanp
  :default t
  :combine and
  :override
  ((expr :sizeof-ambig nil)
   (expr :cast/call-ambig nil)
   (expr :cast/mul-ambig nil)
   (expr :cast/add-ambig nil)
   (expr :cast/sub-ambig nil)
   (expr :cast/and-ambig nil)
   (type-spec :typeof-ambig nil)
   (align-spec :alignas-ambig nil)
   (dirabsdeclor :dummy-base nil)
   (attrib t)
   (attrib-spec t)
   (asm-output t)
   (asm-input t)
   (asm-stmt t)
   (stmt :for-ambig nil)
   (block-item :ambig nil)
   (amb-expr/tyname nil)
   (amb-declor/absdeclor nil)
   (amb-decl/stmt nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection abstract-syntax-unambp-additional-theorems
  :short "Additional theorems about the unambiguity predicates."
  :long
  (xdoc::topstring
   (xdoc::p
    "These are in addition to the ones generated by @(tsee fty::deffold-reduce).
     These additional ones seem necessary for actual proofs
     involving the unambiguity predicates,
     e.g. the proof that the @(see disambiguator)
     returns unambiguous ASTs.
     It may be possible to extend @(tsee fty::deffold-reduce)
     to generate at least some of these,
     by recognizing certain sufficiently general patterns.
     However, all in all these are not many compared to
     the number of theorems already generated by @(tsee fty::deffold-reduce)."))

  ;; The following theorems apply to non-nullary sum type constructors,
  ;; whose fields are never ambiguous.

  (defruled expr-unambp-when-ident
    (implies (expr-case expr :ident)
             (expr-unambp expr))
    :enable expr-unambp)

  (defruled expr-unambp-when-const
    (implies (expr-case expr :const)
             (expr-unambp expr))
    :enable expr-unambp)

  (defruled expr-unambp-when-string
    (implies (expr-case expr :string)
             (expr-unambp expr))
    :enable expr-unambp)

  (defruled member-designor-unambp-when-ident
    (implies (member-designor-case memdes :ident)
             (member-designor-unambp memdes))
    :enable member-designor-unambp)

  (defruled type-spec-unambp-when-signed
    (implies (type-spec-case type-spec :signed)
             (type-spec-unambp type-spec))
    :enable type-spec-unambp)

  (defruled type-spec-unambp-when-typedef
    (implies (type-spec-case type-spec :typedef)
             (type-spec-unambp type-spec))
    :enable type-spec-unambp)

  (defruled type-spec-unambp-when-int128
    (implies (type-spec-case type-spec :int128)
             (type-spec-unambp type-spec))
    :enable type-spec-unambp)

  (defruled type-spec-unambp-when-struct-empty
    (implies (type-spec-case type-spec :struct-empty)
             (type-spec-unambp type-spec))
    :enable type-spec-unambp)

  (defruled spec/qual-unambp-when-typequal
    (implies (spec/qual-case spec/qual :typequal)
             (spec/qual-unambp spec/qual))
    :enable spec/qual-unambp)

  (defruled spec/qual-unambp-when-attrib
    (implies (spec/qual-case spec/qual :attrib)
             (spec/qual-unambp spec/qual))
    :expand (spec/qual-unambp spec/qual))

  (defruled designor-unambp-when-dot
    (implies (designor-case designor :dot)
             (designor-unambp designor))
    :enable designor-unambp)

  (defruled dirdeclor-unambp-when-ident
    (implies (dirdeclor-case dirdeclor :ident)
             (dirdeclor-unambp dirdeclor))
    :enable dirdeclor-unambp)

  (defruled label-unambp-when-name
    (implies (label-case label :name)
             (label-unambp label))
    :enable label-unambp)

  (defruled stmt-unambp-of-when-goto
    (implies (stmt-case stmt :goto)
             (stmt-unambp stmt))
    :enable stmt-unambp)

  (defruled stmt-unambp-of-when-asm
    (implies (stmt-case stmt :asm)
             (stmt-unambp stmt))
    :expand (stmt-unambp stmt))

  ;; This are variants that negate the cases.
  ;; Attempting to replace these with theorems of the form above
  ;; causes some disambiguator proofs to fail.

  (defruled decl-spec-unambp-when-not-tyspec/align
    (implies (and (not (decl-spec-case decl-spec :typespec))
                  (not (decl-spec-case decl-spec :align)))
             (decl-spec-unambp decl-spec))
    :expand (decl-spec-unambp decl-spec))

  (defruled extdecl-unambp-when-not-fundef/decl
    (implies (and (not (extdecl-case extdecl :fundef))
                  (not (extdecl-case extdecl :decl)))
             (extdecl-unambp extdecl))
    :enable extdecl-unambp)

  ;; The following theorems exclude certain cases from consideration.

  (defruled expr-not-sizeof-when-unambp
    (implies (expr-unambp expr)
             (not (equal (expr-kind expr) :sizeof-ambig)))
    :rule-classes :forward-chaining
    :enable expr-unambp)

  (defruled expr-not-cast/call-ambig-when-unambp
    (implies (expr-unambp expr)
             (not (equal (expr-kind expr) :cast/call-ambig)))
    :rule-classes :forward-chaining
    :enable expr-unambp)

  (defruled expr-not-cast/mul-ambig-when-unambp
    (implies (expr-unambp expr)
             (not (equal (expr-kind expr) :cast/mul-ambig)))
    :rule-classes :forward-chaining
    :enable expr-unambp)

  (defruled expr-not-cast/add-ambig-when-unambp
    (implies (expr-unambp expr)
             (not (equal (expr-kind expr) :cast/add-ambig)))
    :rule-classes :forward-chaining
    :enable expr-unambp)

  (defruled expr-not-cast/sub-ambig-when-unambp
    (implies (expr-unambp expr)
             (not (equal (expr-kind expr) :cast/sub-ambig)))
    :rule-classes :forward-chaining
    :enable expr-unambp)

  (defruled expr-not-cast/and-ambig-when-unambp
    (implies (expr-unambp expr)
             (not (equal (expr-kind expr) :cast/and-ambig)))
    :rule-classes :forward-chaining
    :enable expr-unambp)

  (defruled type-spec-not-typeof-ambig-when-unambp
    (implies (type-spec-unambp tyspec)
             (not (equal (type-spec-kind tyspec) :typeof-ambig)))
    :rule-classes :forward-chaining
    :enable type-spec-unambp)

  (defruled align-spec-not-alignas-ambig-when-unambp
    (implies (align-spec-unambp alignspec)
             (not (equal (align-spec-kind alignspec) :alignas-ambig)))
    :rule-classes :forward-chaining
    :enable align-spec-unambp)

  (defruled param-declor-not-ambig-when-unambp
    (implies (param-declor-unambp param-declor)
             (not (equal (param-declor-kind param-declor) :ambig)))
    :rule-classes :forward-chaining
    :expand (param-declor-unambp param-declor))

  (defruled dirabsdeclor-not-dummy-base-when-unambp
    (implies (dirabsdeclor-unambp dirabsdeclor)
             (not (equal (dirabsdeclor-kind dirabsdeclor) :dummy-base)))
    :rule-classes :forward-chaining
    :enable dirabsdeclor-unambp)

  (defruled stmt-not-for-ambig-when-unambp
    (implies (stmt-unambp stmt)
             (not (equal (stmt-kind stmt) :for-ambig)))
    :rule-classes :forward-chaining
    :enable stmt-unambp)

  (defruled block-item-not-ambig-when-unambp
    (implies (block-item-unambp item)
             (not (equal (block-item-kind item) :ambig)))
    :rule-classes :forward-chaining
    :enable block-item-unambp)

  ;; These were found necessary at some point,
  ;; but they should be re-assessed.

  (defruled expr-unambp-of-type-spec-typeof-expr->expr
    (implies (and (type-spec-unambp tyspec)
                  (equal (type-spec-kind tyspec) :typeof-expr))
             (expr-unambp (type-spec-typeof-expr->expr tyspec)))
    :rule-classes :forward-chaining
    :enable type-spec-unambp)

  (defruled tyname-unambp-of-type-spec-typeof-type->type
    (implies (and (type-spec-unambp tyspec)
                  (equal (type-spec-kind tyspec) :typeof-type))
             (tyname-unambp (type-spec-typeof-type->type tyspec)))
    :rule-classes :forward-chaining
    :enable type-spec-unambp)

  ;; Add the above theorems to the rule set.

  (add-to-ruleset abstract-syntax-unambp-rules
                  '(expr-unambp-when-ident
                    expr-unambp-when-const
                    expr-unambp-when-string
                    member-designor-unambp-when-ident
                    type-spec-unambp-when-signed
                    type-spec-unambp-when-typedef
                    type-spec-unambp-when-int128
                    type-spec-unambp-when-struct-empty
                    spec/qual-unambp-when-typequal
                    spec/qual-unambp-when-attrib
                    decl-spec-unambp-when-not-tyspec/align
                    designor-unambp-when-dot
                    dirdeclor-unambp-when-ident
                    label-unambp-when-name
                    stmt-unambp-of-when-goto
                    stmt-unambp-of-when-asm
                    extdecl-unambp-when-not-fundef/decl
                    expr-not-sizeof-when-unambp
                    expr-not-cast/call-ambig-when-unambp
                    expr-not-cast/mul-ambig-when-unambp
                    expr-not-cast/add-ambig-when-unambp
                    expr-not-cast/sub-ambig-when-unambp
                    expr-not-cast/and-ambig-when-unambp
                    type-spec-not-typeof-ambig-when-unambp
                    align-spec-not-alignas-ambig-when-unambp
                    param-declor-not-ambig-when-unambp
                    dirabsdeclor-not-dummy-base-when-unambp
                    stmt-not-for-ambig-when-unambp
                    block-item-not-ambig-when-unambp
                    expr-unambp-of-type-spec-typeof-expr->expr
                    tyname-unambp-of-type-spec-typeof-type->type)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection type-spec-list-unambp-of-sublists
  :short "Theorems saying that the sublist of type specifiers
          extracted via some abstract syntax operations
          is unambiguous if the initial list is unambiguous."

  (defrule type-spec-list-unambp-of-check-spec/qual-list-all-typespec
    (b* (((mv okp tyspecs) (check-spec/qual-list-all-typespec specquals)))
      (implies (and (spec/qual-list-unambp specquals)
                    okp)
               (type-spec-list-unambp tyspecs)))
    :induct t
    :enable (check-spec/qual-list-all-typespec
             abstract-syntax-unambp-rules))

  (defrule type-spec-list-unambp-of-check-decl-spec-list-all-typespec
    (b* (((mv okp tyspecs) (check-decl-spec-list-all-typespec specquals)))
      (implies (and (decl-spec-list-unambp specquals)
                    okp)
               (type-spec-list-unambp tyspecs)))
    :induct t
    :enable (check-decl-spec-list-all-typespec
             abstract-syntax-unambp-rules))

  (defrule type-spec-list-unambp-of-check-decl-spec-list-all-typespec/stoclass
    (b* (((mv okp tyspecs &)
          (check-decl-spec-list-all-typespec/stoclass declspecs)))
      (implies (and (decl-spec-list-unambp declspecs)
                    okp)
               (type-spec-list-unambp tyspecs)))
    :induct t
    :enable (check-decl-spec-list-all-typespec/stoclass
             abstract-syntax-unambp-rules)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection expr-unambp-of-operation-on-expr-unambp
  :short "Preservation of unambiguity by certain operations on expressions."

  (defrule expr-unambp-of-apply-pre-inc/dec-ops
    (implies (expr-unambp expr)
             (expr-unambp (apply-pre-inc/dec-ops inc/dec expr)))
    :induct t
    :enable (apply-pre-inc/dec-ops
             expr-unambp-of-expr-unary))

  (defrule expr-unambp-of-apply-post-inc/dec-ops
    (implies (expr-unambp expr)
             (expr-unambp (apply-post-inc/dec-ops expr inc/dec)))
    :induct t
    :enable (apply-post-inc/dec-ops
             expr-unambp-of-expr-unary))

  (defrule expr-list-unambp-of-expr-to-asg-expr-list
    (implies (expr-unambp expr)
             (expr-list-unambp (expr-to-asg-expr-list expr)))
    :induct t
    :enable (expr-to-asg-expr-list
             abstract-syntax-unambp-rules))

  (defrule expr-unambp-of-check-expr-mul
    (b* (((mv yes/no arg1 arg2) (check-expr-mul expr)))
      (implies (and (expr-unambp expr)
                    yes/no)
               (and (expr-unambp arg1)
                    (expr-unambp arg2))))
    :enable check-expr-mul)

  (defrule expr-unambp-of-check-expr-binary
    (b* (((mv yes/no & arg1 arg2) (check-expr-binary expr)))
      (implies (and (expr-unambp expr)
                    yes/no)
               (and (expr-unambp arg1)
                    (expr-unambp arg2))))
    :enable check-expr-binary))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define code-ensemble-unambp ((code code-ensemblep))
  :returns (yes/no booleanp)
  :short "Check if a code ensemble is unambiguous."
  :long
  (xdoc::topstring
   (xdoc::p
    "That is, check whether the translation unit ensemble is unambiguous.
     The implementation environment is ignored for this,
     but it is convenient to lift the unambiguity predicate
     from translation unit ensembles to code ensembles."))
  (transunit-ensemble-unambp (code-ensemble->transunits code))
  :hooks (:fix)

  ///

  (defruled code-ensemble-unambp-of-code-ensemble
    (equal (code-ensemble-unambp (code-ensemble tunits ienv))
           (transunit-ensemble-unambp tunits)))

  (defruled transunit-ensemble-unambp-of-code-ensemble->transunits
    (implies (code-ensemble-unambp code)
             (transunit-ensemble-unambp (code-ensemble->transunits code)))))
