; C Library
;
; Copyright (C) 2021 Kestrel Institute (http://www.kestrel.edu)
; Copyright (C) 2021 Kestrel Technology LLC (http://kestreltechnology.com)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (coglio@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "C")

(include-book "dynamic-semantics")

(include-book "kestrel/utilities/defopeners" :dir :system)
(include-book "tools/rulesets" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ atc-proof-support
  :parents (atc-implementation)
  :short "Rules to support the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "Currently, the generated proofs of function correctness
     are carried out via symbolic execution of the C code.
     The C code is a constant value,
     because we are generating proofs over specific C functions.")
   (xdoc::p
    "In order to make these generated proofs more robust,
     we carry them out in a theory that consists exactly of
     (what we believe to be) all and only the needed rules.
     This file defines that theory, which consists of
     rules introduced elsewhere and rules introduced in this file.
     This set of rules has been defined by
     experimenting with several symbolic execution proofs,
     starting with the empty theory and adding rules
     as needed to advance the symbolic execution,
     and also by looking at the C dynamic semantics.
     There is no guarantee (meta proof) that
     these rules will suffice for every use of ATC;
     there is also no guarantee that
     the proof will not be defeated by some ACL2 heuristic in some cases.
     Nonetheless, the proof strategy seems sound and robust,
     and if a generated proof fails
     it should be possible to (prove and) use additional rules."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection atc-opener-rules
  :short "Opener rules for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "To symbolically execute  the generated C code,
     we need to unfold the recursive execution functions,
     as well as other recursive functions.")
   (xdoc::p
    "In general, just enabling recursive functions in ACL2
     does not guarantee that their calls will be expanded when desired:
     ACL2 has heuristics to inhibit the unfolding sometimes,
     to avoid infinite loops.
     When the values over which a recursive function recurses are constant,
     as it happens in our symbolic execution,
     then we know that the expansion is always safe,
     but experiments suggest that ACL2's heuristics
     sometimes block those expansions.
     For this reason, it is better to have opener rules,
     i.e. rules that expand function calls,
     according to the function definitions,
     under suitable conditions.")
   (xdoc::p
    "We use the @('defopeners') utility
     from @('[books]/kestrel/utilities/defopeners').
     Compared to the @(tsee defopener) utility,
     @('defopeners') generates multiple opener rules
     (note the plural vs. singular name),
     corresponding to the conditional structure of the function.
     In general, there will be some base cases and some step cases;
     the former have @('base') in the generated rule names,
     while the latter have @('unroll') in the generated rule names.
     The names of the generated rules are automatically obtained
     via the @('defopeners-names') companion tool of @('defopeners').
     While @(tsee defopener) simplifies the expansion, @('defopeners') does not;
     since we use the rules in a symbolic execution,
     we expect that the simplification will take place there.")
   (xdoc::p
    "We generate opener rules for
     all the (singly and mutually) recursive @('exec-...') functions
     except @(tsee exec-fun) (more on this below),
     as well as for some other recursive functions.
     The opener rules have hypotheses saying that
     certain arguments are (quoted) constants,
     which is what we expect in the symbolic execution.")
   (xdoc::p
    "We used to have opener rules for @(tsee read-var-aux),
     and to enable the @(tsee read-var) definition rule,
     but now we keep @(tsee read-var) disabled
     and we use rules about how it manipulates
     computation states of a certain form (see @(see atc-rewrite-rules)).
     We plan to do the same for @(tsee write-var),
     but for now instead we enable it
     and we introduce and use opener rules for @(tsee write-var-aux).
     These openers have @(tsee syntaxp) hypotheses saying that
     the list of scopes has the form @('(cons ...)'),
     because this is what happens during symbolic execution.")
   (xdoc::p
    "We avoid opener rules for @(tsee exec-fun) because
     we use the correctness theorems of callees
     in the correctness proofs of callers.
     Those correctness theorems are expressed in terms of @(tsee exec-fun),
     so we do not want to expand @(tsee exec-fun).
     See the proof generation code for more details.")
   (xdoc::p
    "We collect all the openers rules in a ruleset,
     to make it easier to collect them incrementally as they are introduced."))

  (def-ruleset atc-openers nil)

  (progn
    (defopeners exec-expr-pure
      :hyps ((syntaxp (quotep e)))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names exec-expr-pure)))

  (progn
    (defopeners exec-expr-pure-list
      :hyps ((syntaxp (quotep es)))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names exec-expr-pure-list)))

  (progn
    (defopeners exec-expr-call-or-pure
      :hyps ((syntaxp (quotep e)))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names exec-expr-call-or-pure)))

  (progn
    (defopeners exec-expr-asg
      :hyps ((syntaxp (quotep e)))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names exec-expr-asg)))

  (progn
    (defopeners exec-stmt
      :hyps ((syntaxp (quotep s)))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names exec-stmt)))

  (progn
    (defopeners exec-stmt-while
      :hyps ((syntaxp (quote test))
             (syntaxp (quote body)))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names exec-stmt-while)))

  (progn
    (defopeners exec-block-item
      :hyps ((syntaxp item))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names exec-block-item)))

  (progn
    (defopeners exec-block-item-list
      :hyps ((syntaxp (quotep items)))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names exec-block-item-list)))

  (progn
    (defopeners init-scope
      :hyps ((syntaxp formals))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names init-scope)))

  (progn
    (defopeners write-var-aux
      :hyps ((syntaxp (quotep var))
             (syntaxp (and (consp scopes)
                           (eq (car scopes) 'cons))))
      :disable t)
    (add-to-ruleset atc-openers (defopeners-names write-var-aux))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(make-event
 `(defval *atc-opener-rules*
    :short "List of opener rules for the proofs generated by ATC."
    ',(get-ruleset 'atc-openers (w state))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-executable-counterpart-rules*
  :short "List of executable counterpart rules for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "During symbolic execution, some data is constant,
     especially the C abstract sytactic entities being executed.
     In the course of the symbolic execution,
     terms appear with functions applied to quoted constants.
     Those can be simplified via the executable counterparts of such functions.
     We collect all such rules here.
     Many of them are fixtype deconstructors;
     there are also some fixers and some constructors.
     The one for @(tsee zp) serves when testing the limit value,
     which is a (large) constant.
     This list may not be exhaustive; we may add more as needed."))
  '((:e binop-fix)
    (:e binop-kind)
    (:e binop-purep)
    (:e binop-strictp)
    (:e block-item-declon->get)
    (:e block-item-kind)
    (:e block-item-stmt->get)
    (:e booleanp)
    (:e compustate)
    (:e compustate->frames)
    (:e compustate-fix)
    (:e const-int->get)
    (:e const-kind)
    (:e declon->init)
    (:e declon->declor)
    (:e declon->type)
    (:e declor->ident)
    (:e declor->pointerp)
    (:e expr-arrsub->arr)
    (:e expr-arrsub->sub)
    (:e expr-binary->arg1)
    (:e expr-binary->arg2)
    (:e expr-binary->op)
    (:e expr-call->args)
    (:e expr-call->fun)
    (:e expr-cast->type)
    (:e expr-cast->arg)
    (:e expr-cond->else)
    (:e expr-cond->test)
    (:e expr-cond->then)
    (:e expr-const->get)
    (:e expr-fix)
    (:e expr-ident->get)
    (:e expr-kind)
    (:e expr-unary->arg)
    (:e expr-unary->op)
    (:e exprp)
    (:e frame-list-fix)
    (:e fun-env-lookup)
    (:e fun-info->body)
    (:e fun-info->params)
    (:e fun-info->result)
    (:e iconst->base)
    (:e iconst->type)
    (:e iconst->unsignedp)
    (:e iconst->value)
    (:e iconst-fix)
    (:e iconst-tysuffix-kind)
    (:e ident)
    (:e ident-fix)
    (:e identp)
    (:e init-fun-env)
    (:e len)
    (:e natp)
    (:e omap::in)
    (:e param-declon->declor)
    (:e param-declon->type)
    (:e param-declon-list-fix)
    (:e scope-list-fix)
    (:e scope-listp)
    (:e scopep)
    (:e schar-integerp)
    (:e uchar-integerp)
    (:e sshort-integerp)
    (:e ushort-integerp)
    (:e sint-integerp)
    (:e uint-integerp)
    (:e slong-integerp)
    (:e ulong-integerp)
    (:e sllong-integerp)
    (:e ullong-integerp)
    (:e stmt-compound->items)
    (:e stmt-expr->get)
    (:e stmt-fix)
    (:e stmt-if->test)
    (:e stmt-if->then)
    (:e stmt-ifelse->else)
    (:e stmt-ifelse->test)
    (:e stmt-ifelse->then)
    (:e stmt-kind)
    (:e stmt-return->value)
    (:e stmt-while->test)
    (:e stmt-while->body)
    (:e tyname)
    (:e type-kind)
    (:e type-name-to-type)
    (:e type-pointer)
    (:e type-schar)
    (:e type-uchar)
    (:e type-sshort)
    (:e type-ushort)
    (:e type-sint)
    (:e type-uint)
    (:e type-slong)
    (:e type-ulong)
    (:e type-sllong)
    (:e type-ullong)
    (:e unop-fix)
    (:e unop-kind)
    (:e valuep)
    (:e value-list-fix)
    (:e value-listp)
    (:e zp)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-shift-definition-rules*
  :short "List of definition rules for shift operations
          for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "These are the ACL2 functions that model shift operations on C integers.
     They are expanded in proofs because they are defined in terms of
     the ACL2 functions that model shift operations
     on C integers (first argument) and ACL2 integers (second argument).
     We include in this list not only the function themselves,
     but also the ones expressing their guards."))
  (b* ((types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort)
                    (type-sint)
                    (type-uint)
                    (type-slong)
                    (type-ulong)
                    (type-sllong)
                    (type-ullong))))
    (atc-shl/shr-names-loop-left-types types types))

  :prepwork

  ((define atc-shl/shr-names-loop-right-types ((ltype typep) (rtypes type-listp))
     :guard (and (type-integerp ltype)
                 (type-integer-listp rtypes))
     :returns (names symbol-listp)
     (cond ((endp rtypes) nil)
           (t (b* ((lfixtype (atc-integer-type-fixtype ltype))
                   (rfixtype (atc-integer-type-fixtype (car rtypes)))
                   (shl (pack 'shl- lfixtype '- rfixtype))
                   (shr (pack 'shr- lfixtype '- rfixtype))
                   (shl-okp (pack shl '-okp))
                   (shr-okp (pack shr '-okp)))
                (list*
                 shl shr shl-okp shr-okp
                 (atc-shl/shr-names-loop-right-types ltype (cdr rtypes)))))))

   (define atc-shl/shr-names-loop-left-types ((ltypes type-listp)
                                              (rtypes type-listp))
     :guard (and (type-integer-listp ltypes)
                 (type-integer-listp rtypes))
     :returns (names symbol-listp)
     (cond ((endp ltypes) nil)
           (t (append
               (atc-shl/shr-names-loop-right-types (car ltypes) rtypes)
               (atc-shl/shr-names-loop-left-types (cdr ltypes) rtypes)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-integer-ops-1-conv-definition-rules*
  :short "List of definition rules for operations
          that involve one C integer type
          and that involve conversions."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is for operations on types of rank lower than @('int'):
     these involve conversions in the sense that
     the operand is promoted prior to being operated upon.
     We exclude logical negation from the operations here,
     because that operation does not promote the operand.
     We include the shift operations with ACL2 integers as second arguments.")
   (xdoc::p
    "These functions are all expanded in proofs because
     they are defined in terms of conversions and
     of operations on types of rank at least @('int'):
     this is what the dynamic semantics of C uses."))
  (b* ((types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort))))
    (atc-integer-ops-1-conv-names-loop-ops '(plus minus bitnot shl shr) types))

  :prepwork

  ((define atc-integer-ops-1-conv-names-loop-types ((op symbolp)
                                                    (types type-listp))
     :guard (and (member-eq op '(plus minus bitnot shl shr))
                 (type-integer-listp types))
     :returns (name symbol-listp)
     (cond ((endp types) nil)
           (t (b* ((type (car types))
                   (fixtype (atc-integer-type-fixtype type))
                   (names (if (and (eq op 'minus)
                                   (type-signed-integerp type))
                              (list (pack op '- fixtype)
                                    (pack op '- fixtype '-okp))
                            (list (pack op '- fixtype))))
                   (more-names
                    (atc-integer-ops-1-conv-names-loop-types op (cdr types))))
                (append names more-names)))))

   (define atc-integer-ops-1-conv-names-loop-ops ((ops symbol-listp)
                                                  (types type-listp))
     :guard (and (subsetp-eq ops '(plus minus bitnot shl shr))
                 (type-integer-listp types))
     :returns (names symbol-listp)
     (cond ((endp ops) nil)
           (t (append
               (atc-integer-ops-1-conv-names-loop-types (car ops) types)
               (atc-integer-ops-1-conv-names-loop-ops (cdr ops) types)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-integer-ops-2-conv-definition-rules*
  :short "List of definition rules for operations
          that involve two C integer types
          and that involve conversions."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is for operations on types that differ
     or that have rank lower than @('int'):
     these involve conversions in the sense that
     the operands are subjected to the usual arithmetic conversions
     prior to being operated upon.")
   (xdoc::p
    "These functions are all expanded in proofs because
     they are defined in terms of conversions and
     of operations on equal types of rank at least @('int'):
     this is what the dynamic semantics of C uses."))
  (b* ((ops (list 'add 'sub 'mul 'div 'rem
                  'lt 'gt 'le 'ge 'eq 'ne
                  'bitand 'bitxor 'bitior))
       (types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort)
                    (type-sint)
                    (type-uint)
                    (type-slong)
                    (type-ulong)
                    (type-sllong)
                    (type-ullong))))
    (atc-integer-ops-2-conv-names-loop-ops ops types types))

  :prepwork

  ((define atc-integer-ops-2-conv-names-loop-right-types ((op symbolp)
                                                          (ltype typep)
                                                          (rtypes type-listp))
     :guard (and (member-eq op (list 'add 'sub 'mul 'div 'rem
                                     'lt 'gt 'le 'ge 'eq 'ne
                                     'bitand 'bitxor 'bitior))
                 (type-integerp ltype)
                 (type-integer-listp rtypes))
     :returns (names symbol-listp)
     (cond
      ((endp rtypes) nil)
      (t (b* ((rtype (car rtypes))
              (type (if (member-eq op '(lt gt le ge eq ne))
                        (type-sint)
                      (uaconvert-types ltype rtype)))
              ((when (and (equal type ltype)
                          (equal type rtype)))
               (atc-integer-ops-2-conv-names-loop-right-types op
                                                              ltype
                                                              (cdr rtypes)))
              (lfixtype (atc-integer-type-fixtype ltype))
              (rfixtype (atc-integer-type-fixtype rtype))
              (names (if (or (member-eq op '(div rem))
                             (and (type-signed-integerp type)
                                  (member-eq op '(add sub mul))))
                         (list (pack op '- lfixtype '- rfixtype)
                               (pack op '- lfixtype '- rfixtype '-okp))
                       (list (pack op '- lfixtype '- rfixtype))))
              (more-names
               (atc-integer-ops-2-conv-names-loop-right-types
                op
                ltype
                (cdr rtypes))))
           (append names more-names))))
     :guard-hints (("Goal" :in-theory (enable type-arithmeticp type-realp))))

   (define atc-integer-ops-2-conv-names-loop-left-types ((op symbolp)
                                                         (ltypes type-listp)
                                                         (rtypes type-listp))
     :guard (and (member-eq op (list 'add 'sub 'mul 'div 'rem
                                     'lt 'gt 'le 'ge 'eq 'ne
                                     'bitand 'bitxor 'bitior))
                 (type-integer-listp ltypes)
                 (type-integer-listp rtypes))
     :returns (names symbol-listp)
     (cond ((endp ltypes) nil)
           (t (append
               (atc-integer-ops-2-conv-names-loop-right-types op
                                                              (car ltypes)
                                                              rtypes)
               (atc-integer-ops-2-conv-names-loop-left-types op
                                                             (cdr ltypes)
                                                             rtypes)))))

   (define atc-integer-ops-2-conv-names-loop-ops ((ops symbol-listp)
                                                  (ltypes type-listp)
                                                  (rtypes type-listp))
     :guard (and (subsetp-eq ops (list 'add 'sub 'mul 'div 'rem
                                       'lt 'gt 'le 'ge 'eq 'ne
                                       'bitand 'bitxor 'bitior))
                 (type-integer-listp ltypes)
                 (type-integer-listp rtypes))
     :returns (names symbol-listp)
     (cond ((endp ops) nil)
           (t (append
               (atc-integer-ops-2-conv-names-loop-left-types (car ops)
                                                             ltypes
                                                             rtypes)
               (atc-integer-ops-2-conv-names-loop-ops (cdr ops)
                                                      ltypes
                                                      rtypes)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-definition-rules*
  :short "List of definition rules for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "During symbolic execution, terms appear
     with certain non-recursive functions applied to
     terms that are not constant, but contain constant parts.
     These can be simplified by opening the function definition,
     which ACL2's heuristics (we believe) should never block,
     given that they are not recursive.
     Some are @('exec-...') functions,
     others are functions to manipulate the frame stack,
     etc.")
   (xdoc::p
    "We expand @(tsee condexpr) because it is just a wrapper
     that signifies a conditional expression instead of statement.")
   (xdoc::p
    "It may seem surprising that
     we expand functions like @(tsee sint-dec-const),
     since those correspond to C constructs;
     we certainly do not expand functions like @(tsee add-sint-sint).
     The reason is that functions like @(tsee sint-dec-const)
     are used to represent C constants in ACL2 functions,
     but in the dynamic semantics,
     @(tsee exec-iconst) (which we expand, obviously)
     produces terms of the form @('(sint <quoted-integer>)').
     By expanding @(tsee sint-dec-const) in the ACL2 functions,
     we produce terms of the form @('(sint <quoted-integer>)'),
     which therefore match the ones from @(tsee exec-iconst).")
   (xdoc::p
    "We do not expand any fixtype constructors.
     This is because such expansions would expose
     the internal representational details of the fixtype's values.
     Instead, we want to operate on those as more abstract entities,
     and use deconstructors to obtain their components.
     In fact, as explained elsewhere,
     we enable rules that simplify
     applications of deconstructors to constructors.")
   (xdoc::p
    "We expand @(tsee sint-from-boolean),
     because it is really just an abbreviation.
     In fact, we want to expose its @(tsee if) structure
     in the symbolic execution."))
  (append
   '(compustate-frames-number
     condexpr
     declar
     assign
     create-var
     endp
     exec-iconst
     exec-const
     exec-ident
     exec-plus
     exec-minus
     exec-bitnot
     exec-lognot
     exec-unary
     exec-mul
     exec-div
     exec-rem
     exec-add
     exec-sub
     exec-shl
     exec-shr
     exec-lt
     exec-gt
     exec-le
     exec-ge
     exec-eq
     exec-ne
     exec-bitand
     exec-bitxor
     exec-bitior
     exec-binary-strict-pure
     exec-test
     exec-integer
     exec-binary-logand
     exec-binary-logor
     exec-binary-pure
     exec-cast
     exec-arrsub
     promote-value
     mv-nth
     pop-frame
     push-frame
     sint-from-boolean
     sint-dec-const
     sint-oct-const
     sint-hex-const
     uint-dec-const
     uint-oct-const
     uint-hex-const
     slong-dec-const
     slong-oct-const
     slong-hex-const
     ulong-dec-const
     ulong-oct-const
     ulong-hex-const
     sllong-dec-const
     sllong-oct-const
     sllong-hex-const
     ullong-dec-const
     ullong-oct-const
     ullong-hex-const
     top-frame
     type-of-value
     uaconvert-values
     uchar-array-sint-index-okp
     uchar-array-read-sint
     uchar-array-write-sint
     value-unsigned-integerp
     value-signed-integerp
     value-integerp
     value-realp
     value-arithmeticp
     value-scalarp
     write-var)
   *atc-shift-definition-rules*
   *atc-integer-ops-1-conv-definition-rules*
   *atc-integer-ops-2-conv-definition-rules*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection atc-read-var-rewrite-rules
  :short "Rewrite rules for @(tsee read-var)."
  :long
  (xdoc::topstring
   (xdoc::p
    "During symbolic execution, the computation state
     always has a top frame with at least one scope,
     because an attempt to read a variable should not fail
     (as we are proving the correctness of the generated C code).
     The variable is searched in the innermost scope first,
     then in the surrounding scopes.")
   (xdoc::p
    "So we need a rule for the case in which the innermost scope is empty,
     which defers to the remaining scopes.
     And we need a rule for the case the innermost scope is not empty,
     in which case it has the form of a call of @(tsee omap::update);
     this rule involves a case split based on whether
     the variable is found in the @(tsee omap::update) call,
     or must be searched in the omap argument of that call.")
   (xdoc::p
    "Note that both rules construct new computation states
     that do not represent actual computation states of the C code,
     but rather artificial ones
     that include the recursed-upon scopes.
     This may incur additional @(tsee cons)ing cost during symbolic execution,
     but on the other hand keeping @(tsee read-var) disabled
     may avoid the application of certain rules,
     and so it may be worth overall.
     It certainly seems to help keep the symbolic execution simpler,
     so for now we go this route,
     and plan to do the same for other functions too."))

  (defruled read-var-of-compustate-empty-scope
    (implies (syntaxp (quotep var))
             (equal (read-var var
                              (compustate (cons (frame fun
                                                       (cons nil
                                                             scopes))
                                                frames)
                                          heap))
                    (read-var var
                              (compustate (cons (frame fun
                                                       scopes)
                                                frames)
                                          heap))))
    :enable (read-var
             read-var-aux
             compustate-frames-number
             top-frame))

  (defruled read-var-of-compustate-nonempty-scope
    (implies (and (syntaxp (quotep var))
                  (syntaxp (quotep var2))
                  (identp var2)
                  (valuep val)
                  (scopep scope))
             (equal (read-var var
                              (compustate
                               (cons (frame fun
                                            (cons (omap::update var2
                                                                val
                                                                scope)
                                                  scopes))
                                     frames)
                               heap))
                    (if (equal (ident-fix var)
                               (ident-fix var2))
                        val
                      (read-var var
                                (compustate (cons (frame fun
                                                         (cons scope
                                                               scopes))
                                                  frames)
                                            heap)))))
    :enable (read-var
             read-var-aux
             compustate-frames-number
             top-frame)
    :prep-lemmas
    ((defrule frame->scopes-of-top-grame-of-compustate-of-cons
       (equal (frame->scopes (top-frame (compustate (cons frame frames) heap)))
              (frame->scopes frame))
       :enable (top-frame)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-read-var-rewrite-rules*
  :short "List of rewrite rules for @(tsee read-var)."
  '(read-var-of-compustate-empty-scope
    read-var-of-compustate-nonempty-scope))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection atc-enter-scope-rewrite-rules
  :short "Rewrite rules for @(tsee enter-scope)."

  (defruled enter-scope-of-compustate
    (implies (consp scopes)
             (equal (enter-scope (compustate (cons (frame fun
                                                          scopes)
                                                   frames)
                                             heap))
                    (compustate (cons (frame fun
                                             (cons nil scopes))
                                      frames)
                                heap)))
    :enable (enter-scope
             push-frame
             top-frame
             pop-frame)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-enter-scope-rewrite-rules*
  :short "List of rewrite rules for @(tsee enter-scope)."
  '(enter-scope-of-compustate))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection atc-exit-scope-rewrite-rules
  :short "Rewrite rules for @(tsee exit-scope)."

  (defruled exit-scope-of-compustate
    (equal (exit-scope (compustate (cons (frame fun
                                                (cons scope scopes))
                                         frames)
                                   heap))
           (compustate (cons (frame fun
                                    scopes)
                             frames)
                       heap))
    :enable (exit-scope
             push-frame
             top-frame
             pop-frame)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-exit-scope-rewrite-rules*
  :short "List of rewrite rules for @(tsee exit-scope)."
  '(exit-scope-of-compustate))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection atc-distributivity-over-if-rewrite-rule
  :short "Rewrite rules about certain functions distributing over @(tsee if)."

  (defruled car-of-if
    (equal (car (if a b c))
           (if a (car b) (car c))))

  (defruled mv-nth-of-if
    (equal (mv-nth n (if a b c))
           (if a (mv-nth n b) (mv-nth n c))))

  (defruled len-of-if
    (equal (len (if a b c))
           (if a (len b) (len c))))

  (defruled errorp-of-if
    (equal (errorp (if a b c))
           (if a (errorp b) (errorp c))))

  (defruled valuep-of-if
    (equal (valuep (if a b c))
           (if a (valuep b) (valuep c))))

  (defruled scharp-of-if
    (equal (scharp (if a b c))
           (if a (scharp b) (scharp c))))

  (defruled ucharp-of-if
    (equal (ucharp (if a b c))
           (if a (ucharp b) (ucharp c))))

  (defruled sshortp-of-if
    (equal (sshortp (if a b c))
           (if a (sshortp b) (sshortp c))))

  (defruled ushortp-of-if
    (equal (ushortp (if a b c))
           (if a (ushortp b) (ushortp c))))

  (defruled sintp-of-if
    (equal (sintp (if a b c))
           (if a (sintp b) (sintp c))))

  (defruled uintp-of-if
    (equal (uintp (if a b c))
           (if a (uintp b) (uintp c))))

  (defruled slongp-of-if
    (equal (slongp (if a b c))
           (if a (slongp b) (slongp c))))

  (defruled ulongp-of-if
    (equal (ulongp (if a b c))
           (if a (ulongp b) (ulongp c))))

  (defruled sllongp-of-if
    (equal (sllongp (if a b c))
           (if a (sllongp b) (sllongp c))))

  (defruled ullongp-of-if
    (equal (ullongp (if a b c))
           (if a (ullongp b) (ullongp c))))

  (defruled pointerp-of-if
    (equal (pointerp (if a b c))
           (if a (pointerp b) (pointerp c))))

  (defruled compustate->frames-of-if
    (equal (compustate->frames (if a b c))
           (if a (compustate->frames b) (compustate->frames c))))

  (defruled scope-fix-of-if
    (equal (scope-fix (if a b c))
           (if a (scope-fix b) (scope-fix c))))

  (defruled value-result-fix-of-if
    (equal (value-result-fix (if a b c))
           (if a (value-result-fix b) (value-result-fix c)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-distributivity-over-if-rewrite-rules*
  :short "List of rewrite rules about
          certain functions distributing over @(tsee if)."
  '(car-of-if
    mv-nth-of-if
    len-of-if
    errorp-of-if
    valuep-of-if
    scharp-of-if
    ucharp-of-if
    sshortp-of-if
    ushortp-of-if
    sintp-of-if
    uintp-of-if
    slongp-of-if
    ulongp-of-if
    sllongp-of-if
    ullongp-of-if
    pointerp-of-if
    compustate->frames-of-if
    scope-fix-of-if
    value-result-fix-of-if))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection atc-rewrite-rules
  :short "Rewrite rules for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "During symbolic execution, certain term patterns appear,
     which are amenable to simplification via the following rewrite rules.
     These are non-opener rewrite rules; opener rules are considered separately
     (see @(tsee atc-opener-rules)).")
   (xdoc::p
    "The following rules are general
     and should be probably moved to a more general place.
     For now we put them here, disabled.")
   (xdoc::p
    "Some of the following rewrite rules, in combinations with external ones,
     may exhibit backchaining circularities.
     However, it looks like ACL2's ancestor checks
     should avoid actual circularities,
     in effect limiting the application of
     different partial ``arcs'' of the circles in different situations.
     Anyways, this is being flagged here as something to watch for.")
   (xdoc::p
    "The rule @('c::len-of-cons') below
     is a duplicate of @('acl2::len-of-cons')
     from at least two list libraries,
     but this way we avoid having this file depend on those list libraries;
     the theorem is very simple and small,
     so it is not a lot of duplication.")
   (xdoc::p
    "We also have two rules to simplify applications of
     @(tsee boolean-from-sint) to @('(sint 0)') and @('(sint 1)').
     These applications appear during symbolic execution,
     because in C certain ``boolean'' expressions produce those @('int') values,
     and @(tsee boolean-from-sint) is used to turn those into ACL2 booleans,
     which are uses in @(tsee if)s,
     and thus we clearly want to simplify those application
     to @('t') and @('nil'), which further simplifies the @(tsee if)s.")
   (xdoc::p
    "We also have two rules to simplify applications of
     @(tsee lognot-sint) to @('(sint 0)') and @('(sint 1)').
     Terms of this form may arise in the process of simplifying
     C non-strict expressions involving @('&&') and @('||').")
   (xdoc::p
    "We also found it necessary to include rules
     to distribute two specific functions over @(tsee if)s.
     It seems that, in the course of these symbolic execution proofs,
     we will always want to distribute functions over @(tsee if)s.
     This distribution happens at the goal level,
     but not in the rewriter by default.")
   (xdoc::p
    "The two @('not-zp-of-limit-...') rules
     serve to relieve the recurring hypothesis
     that the limit is never 0 during the symbolic execution.
     Initially the limit is a variable, and the first rule applies;
     the hypothesis of this rule is easily discharged by
     the inequality assumption over the initial limit
     in the symbolic execution theorem,
     via ACL2's linear arithmetic.
     The @(tsee syntaxp) hypothesis restricts the application of the rule
     to the case in which the limit is a variable (which is true initially).
     As the symbolic execution proceeds,
     1 gets repeatedly subtracted from the initial limit variable,
     and it appears that ACL2 automatically combines multiple 1s
     into constants larger than 1,
     giving the pattern @('(binary-+ \'<negative-integer> <limit-variable>)').
     This is the pattern in the second rule @('not-zp-of-limit-...'),
     whose hypothesis about the limit variable
     is easily discharged via linear arithmetic."))

  (defruled not-zp-of-limit-variable
    (implies (and (syntaxp (symbolp limit))
                  (integerp limit)
                  (> limit 0))
             (not (zp limit))))

  (defruled not-zp-of-limit-minus-const
    (implies (and (syntaxp (quotep -c))
                  (integerp -c)
                  (< -c 0)
                  (integerp limit)
                  (> limit (- -c)))
             (not (zp (binary-+ -c limit)))))

  (defruled value-result-fix-when-valuep
    (implies (valuep x)
             (equal (value-result-fix x)
                    x)))

  (defruled not-errorp-when-valuep
    (implies (valuep x)
             (not (errorp x)))
    :enable (errorp
             valuep
             ucharp
             scharp
             ushortp
             sshortp
             uintp
             sintp
             ulongp
             slongp
             ullongp
             sllongp
             pointerp))

  (defruled not-errorp-when-value-listp
    (implies (value-listp x)
             (not (errorp x)))
    :enable errorp)

  (defruled not-errorp-when-scopep
    (implies (scopep x)
             (not (errorp x)))
    :enable (errorp scopep))

  (defruled not-errorp-when-scope-listp
    (implies (scope-listp x)
             (not (errorp x)))
    :enable errorp)

  (defruled not-errorp-when-uchar-arrayp
    (implies (uchar-arrayp x)
             (not (errorp x)))
    :enable (errorp uchar-arrayp))

  (defruled not-errorp-when-booleanp
    (implies (booleanp x)
             (not (errorp x)))
    :enable errorp)

  (defruled len-of-cons
    (equal (len (cons x y))
           (1+ (len y)))
    :prep-books ((include-book "std/lists/len" :dir :system)))

  (defruled 1+len-greater-than-0
    (> (1+ (len x)) 0))

  (defruled boolean-from-sint-of-0
    (equal (boolean-from-sint (sint 0)) nil))

  (defruled boolean-from-sint-of-1
    (equal (boolean-from-sint (sint 1)) t))

  (defruled lognot-sint-of-0
    (equal (lognot-sint (sint 0))
           (sint 1)))

  (defruled lognot-sint-of-1
    (equal (lognot-sint (sint 1))
           (sint 0)))

  (defruled 1+nat-greater-than-0
    (implies (natp x)
             (< 0 (1+ x))))

  (defruled natp-of-1+
    (implies (natp x)
             (natp (1+ x))))

  (defruled natp-of-len
    (natp (len x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-integer-ops-1-return-rewrite-rules*
  :short "List of rewrite rules for the return types of
          models of C integer operations that involve one C integer type."
  (b* ((ops '(plus minus bitnot lognot shl shr))
       (types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort)
                    (type-sint)
                    (type-uint)
                    (type-slong)
                    (type-ulong)
                    (type-sllong)
                    (type-ullong))))
    (atc-integer-ops-1-return-names-loop-ops ops types))

  :prepwork

  ((define atc-integer-ops-1-return-names-loop-types ((op symbolp)
                                                      (types type-listp))
     :guard (and (member-eq op '(plus minus bitnot lognot shl shr))
                 (type-integer-listp types))
     :returns (names symbol-listp)
     (cond
      ((endp types) nil)
      (t (b* ((type (car types))
              (argfixtype (atc-integer-type-fixtype type))
              (restype (if (eq op 'lognot) (type-sint) (promote-type type)))
              (resfixtype (atc-integer-type-fixtype restype))
              (respred (pack resfixtype 'p)))
           (cons (pack respred '-of- op '- argfixtype)
                 (atc-integer-ops-1-return-names-loop-types op (cdr types)))))))

   (define atc-integer-ops-1-return-names-loop-ops ((ops symbol-listp)
                                                    (types type-listp))
     :guard (and (subsetp-eq ops '(plus minus bitnot lognot shl shr))
                 (type-integer-listp types))
     :returns (names symbol-listp)
     (cond ((endp ops) nil)
           (t (append
               (atc-integer-ops-1-return-names-loop-types (car ops) types)
               (atc-integer-ops-1-return-names-loop-ops (cdr ops) types)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-integer-ops-2-return-rewrite-rules*
  :short "List of rewrite rules for the return types of
          models of C integer operations that involve two C integer types."
  (b* ((ops (list 'add 'sub 'mul 'div 'rem
                  'lt 'gt 'le 'ge 'eq 'ne
                  'bitand 'bitxor 'bitior))
       (types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort)
                    (type-sint)
                    (type-uint)
                    (type-slong)
                    (type-ulong)
                    (type-sllong)
                    (type-ullong))))
    (atc-integer-ops-2-return-names-loop-ops ops types types))

  :prepwork

  ((define atc-integer-ops-2-return-names-loop-right-types ((op symbolp)
                                                            (ltype typep)
                                                            (rtypes type-listp))
     :guard (and (member-eq op (list 'add 'sub 'mul 'div 'rem
                                     'lt 'gt 'le 'ge 'eq 'ne
                                     'bitand 'bitxor 'bitior))
                 (type-integerp ltype)
                 (type-integer-listp rtypes))
     :returns (names symbol-listp)
     (cond
      ((endp rtypes) nil)
      (t (b* ((rtype (car rtypes))
              (type (if (member-eq op '(lt gt le ge eq ne))
                        (type-sint)
                      (uaconvert-types ltype rtype)))
              (lfixtype (atc-integer-type-fixtype ltype))
              (rfixtype (atc-integer-type-fixtype rtype))
              (fixtype (atc-integer-type-fixtype type))
              (pred (pack fixtype 'p)))
           (cons
            (pack pred '-of- op '- lfixtype '- rfixtype)
            (atc-integer-ops-2-return-names-loop-right-types op
                                                             ltype
                                                             (cdr rtypes))))))
     :guard-hints (("Goal" :in-theory (enable type-arithmeticp type-realp))))

   (define atc-integer-ops-2-return-names-loop-left-types ((op symbolp)
                                                           (ltypes type-listp)
                                                           (rtypes type-listp))
     :guard (and (member-eq op (list 'add 'sub 'mul 'div 'rem
                                     'lt 'gt 'le 'ge 'eq 'ne
                                     'bitand 'bitxor 'bitior))
                 (type-integer-listp ltypes)
                 (type-integer-listp rtypes))
     :returns (names symbol-listp)
     (cond ((endp ltypes) nil)
           (t (append
               (atc-integer-ops-2-return-names-loop-right-types op
                                                                (car ltypes)
                                                                rtypes)
               (atc-integer-ops-2-return-names-loop-left-types op
                                                               (cdr ltypes)
                                                               rtypes)))))

   (define atc-integer-ops-2-return-names-loop-ops ((ops symbol-listp)
                                                    (ltypes type-listp)
                                                    (rtypes type-listp))
     :guard (and (subsetp-eq ops (list 'add 'sub 'mul 'div 'rem
                                       'lt 'gt 'le 'ge 'eq 'ne
                                       'bitand 'bitxor 'bitior))
                 (type-integer-listp ltypes)
                 (type-integer-listp rtypes))
     :returns (names symbol-listp)
     (cond ((endp ops) nil)
           (t (append
               (atc-integer-ops-2-return-names-loop-left-types (car ops)
                                                               ltypes
                                                               rtypes)
               (atc-integer-ops-2-return-names-loop-ops (cdr ops)
                                                        ltypes
                                                        rtypes)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-integer-convs-return-rewrite-rules*
  :short "List of rewrite rules for the return types of
          models of C integer conversions."
  (b* ((types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort)
                    (type-sint)
                    (type-uint)
                    (type-slong)
                    (type-ulong)
                    (type-sllong)
                    (type-ullong))))
    (atc-integer-convs-return-names-loop-src-types types types))

  :prepwork

  ((define atc-integer-convs-return-names-loop-dst-types ((stype typep)
                                                          (dtypes type-listp))
     :guard (and (type-integerp stype)
                 (type-integer-listp dtypes))
     :returns (names symbol-listp)
     (cond
      ((endp dtypes) nil)
      ((equal stype (car dtypes))
       (atc-integer-convs-return-names-loop-dst-types stype
                                                      (cdr dtypes)))
      (t (b* ((sfixtype (atc-integer-type-fixtype stype))
              (dfixtype (atc-integer-type-fixtype (car dtypes)))
              (pred (pack dfixtype 'p)))
           (cons
            (pack pred '-of- dfixtype '-from- sfixtype)
            (atc-integer-convs-return-names-loop-dst-types stype
                                                           (cdr dtypes)))))))

   (define atc-integer-convs-return-names-loop-src-types ((stypes type-listp)
                                                          (dtypes type-listp))
     :guard (and (type-integer-listp stypes)
                 (type-integer-listp dtypes))
     :returns (names symbol-listp)
     (cond ((endp stypes) nil)
           (t (append
               (atc-integer-convs-return-names-loop-dst-types (car stypes)
                                                              dtypes)
               (atc-integer-convs-return-names-loop-src-types (cdr stypes)
                                                              dtypes)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-rewrite-rules*
  :short "List of rewrite rules for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "These exlude the openers (see @(tsee *atc-opener-rules*)),
     and include not only the rules defined in @(see atc-rewrite-rules),
     but also other existing rewrite rules.
     Note that some of them serve to
     simplify fixtype deconstructors applied to constructors.")
   (xdoc::p
    "We take the opportunity here to discuss the general shape
     of the computation state terms during the symbolic execution.
     They have the form @('(compustate <frames>)'),
     where @('<frames>') is a @(tsee cons) nest of frames
     (possibly @('nil'), when there are no frames).
     Each frame has the form @('(frame <fun-id> <scopes>)'),
     where @('<fun-id>') is a quoted constant with the function identifier
     (the quoted constant being produced by
     the rules enabled in symbolic execution),
     and where @('<scopes>') is a @(tsee cons) nest of scopes,
     never @('nil') due to the invariant on the @(tsee scope) fixtype.
     Each scope is an @(tsee omap::update) nest, possibly @('nil'):
     note that @(tsee omap::update) is a constructor of non-empty omaps,
     @('nil') being the one for empty omaps.
     In this nest,
     the keys of the map are quoted constants for C variable identifiers,
     while the values are shallowly embedded C expressions,
     which depend on the ACL2 variables in the formulation of
     each functional correctness theorem,
     which are also the formal parameters of the ACL2 function
     that the functional correctness theorem pertains to.")
   (xdoc::p
    "Given the above, it should not be surprising to see
     rules like @('omap::in-of-update'),
     which serves to simplify, during symbolic execution,
     the finding of a variable in a scope."))
  (append
   ;; introduced in this file:
   *atc-read-var-rewrite-rules*
   *atc-enter-scope-rewrite-rules*
   *atc-exit-scope-rewrite-rules*
   *atc-distributivity-over-if-rewrite-rules*
   '(not-zp-of-limit-variable
     not-zp-of-limit-minus-const
     value-result-fix-when-valuep
     not-errorp-when-valuep
     not-errorp-when-value-listp
     not-errorp-when-scopep
     not-errorp-when-scope-listp
     not-errorp-when-uchar-arrayp
     not-errorp-when-booleanp
     len-of-cons
     1+len-greater-than-0
     boolean-from-sint-of-0
     boolean-from-sint-of-1
     lognot-sint-of-0
     lognot-sint-of-1
     1+nat-greater-than-0
     natp-of-1+
     natp-of-len)
   ;; introduced elsewhere:
   '(booleanp-of-boolean-from-uchar
     booleanp-of-boolean-from-schar
     booleanp-of-boolean-from-ushort
     booleanp-of-boolean-from-sshort
     booleanp-of-boolean-from-uint
     booleanp-of-boolean-from-sint
     booleanp-of-boolean-from-ulong
     booleanp-of-boolean-from-slong
     booleanp-of-boolean-from-ullong
     booleanp-of-boolean-from-sllong
     car-cons
     cdr-cons
     compustate-of-fields
     compustate->frames-of-compustate
     compustate->heap-of-compustate
     compustate-fix-when-compustatep
     compustatep-of-compustate
     frame->function-of-frame
     frame->scopes-of-frame
     frame-fix-when-framep
     frame-list-fix-of-cons
     frame-list-fix-when-frame-listp
     frame-listp-of-compustate->frames
     framep-of-frame
     heap-fix-when-heapp
     heapp-of-compustate->heap
     not-errorp-when-compustatep
     omap::in-of-update
     pop-frame-of-push-frame
     scope-fix-when-scopep
     scope-list-fix-of-cons
     scope-listp-of-cons
     scopep-of-update
     schar-fix-when-scharp
     uchar-fix-when-ucharp
     sshort-fix-when-sshortp
     ushort-fix-when-ushortp
     sint-fix-when-sintp
     uint-fix-when-uintp
     slong-fix-when-slongp
     ulong-fix-when-ulongp
     sllong-fix-when-sllongp
     ullong-fix-when-ullongp
     scharp-of-schar
     ucharp-of-uchar
     sshortp-of-sshort
     ushortp-of-ushort
     sintp-of-sint
     uintp-of-uint
     slongp-of-slong
     ulongp-of-ulong
     sllongp-of-sllong
     ullongp-of-ullong
     ucharp-of-uchar-array-read-sint
     ucharp-of-uchar-array-read
     top-frame-of-push-frame
     valuep-when-pointerp
     valuep-when-scharp
     valuep-when-ucharp
     valuep-when-sshortp
     valuep-when-ushortp
     valuep-when-sintp
     valuep-when-uintp
     valuep-when-slongp
     valuep-when-ulongp
     valuep-when-sllongp
     valuep-when-ullongp
     value-fix-when-valuep
     value-listp-of-cons
     value-list-fix-of-cons
     value-optionp-when-valuep)
   *value-disjoint-rules*
   *atc-integer-ops-1-return-rewrite-rules*
   *atc-integer-ops-2-return-rewrite-rules*
   *atc-integer-convs-return-rewrite-rules*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-integer-ops-1-type-prescription-rules*
  :short "List of type prescription rules for the
          models of C integer operations that involve one C integer type."
  (b* ((ops '(plus minus bitnot lognot shl shr))
       (types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort)
                    (type-sint)
                    (type-uint)
                    (type-slong)
                    (type-ulong)
                    (type-sllong)
                    (type-ullong))))
    (atc-integer-ops-1-type-presc-rules-loop-ops ops types))

  :prepwork

  ((define atc-integer-ops-1-type-presc-rules-loop-types ((op symbolp)
                                                          (types type-listp))
     :guard (and (member-eq op '(plus minus bitnot lognot shl shr))
                 (type-integer-listp types))
     :returns (rules true-list-listp)
     (cond
      ((endp types) nil)
      (t (b* ((type (car types))
              (fixtype (atc-integer-type-fixtype type)))
           (cons
            (list :t (pack op '- fixtype))
            (atc-integer-ops-1-type-presc-rules-loop-types op (cdr types)))))))

   (define atc-integer-ops-1-type-presc-rules-loop-ops ((ops symbol-listp)
                                                        (types type-listp))
     :guard (and (subsetp-eq ops '(plus minus bitnot lognot shl shr))
                 (type-integer-listp types))
     :returns (rule true-list-listp)
     (cond
      ((endp ops) nil)
      (t (append
          (atc-integer-ops-1-type-presc-rules-loop-types (car ops) types)
          (atc-integer-ops-1-type-presc-rules-loop-ops (cdr ops) types)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-integer-ops-2-type-prescription-rules*
  :short "List of type prescription rules for the
          models of C integer operations that involve two C integer types."
  (b* ((ops (list 'add 'sub 'mul 'div 'rem
                  'lt 'gt 'le 'ge 'eq 'ne
                  'bitand 'bitxor 'bitior))
       (types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort)
                    (type-sint)
                    (type-uint)
                    (type-slong)
                    (type-ulong)
                    (type-sllong)
                    (type-ullong))))
    (atc-integer-ops-2-type-presc-rules-loop-ops ops types types))

  :prepwork

  ((define atc-integer-ops-2-type-presc-rules-loop-right-types
     ((op symbolp)
      (ltype typep)
      (rtypes type-listp))
     :guard (and (member-eq op (list 'add 'sub 'mul 'div 'rem
                                     'lt 'gt 'le 'ge 'eq 'ne
                                     'bitand 'bitxor 'bitior))
                 (type-integerp ltype)
                 (type-integer-listp rtypes))
     :returns (rules true-list-listp)
     (cond
      ((endp rtypes) nil)
      (t (b* ((rtype (car rtypes))
              (lfixtype (atc-integer-type-fixtype ltype))
              (rfixtype (atc-integer-type-fixtype rtype)))
           (cons
            (list :t (pack op '- lfixtype '- rfixtype))
            (atc-integer-ops-2-type-presc-rules-loop-right-types
             op
             ltype
             (cdr rtypes))))))
     :guard-hints (("Goal" :in-theory (enable type-arithmeticp type-realp))))

   (define atc-integer-ops-2-type-presc-rules-loop-left-types
     ((op symbolp)
      (ltypes type-listp)
      (rtypes type-listp))
     :guard (and (member-eq op (list 'add 'sub 'mul 'div 'rem
                                     'lt 'gt 'le 'ge 'eq 'ne
                                     'bitand 'bitxor 'bitior))
                 (type-integer-listp ltypes)
                 (type-integer-listp rtypes))
     :returns (rules true-list-listp)
     (cond ((endp ltypes) nil)
           (t (append
               (atc-integer-ops-2-type-presc-rules-loop-right-types op
                                                                    (car ltypes)
                                                                    rtypes)
               (atc-integer-ops-2-type-presc-rules-loop-left-types op
                                                                   (cdr ltypes)
                                                                   rtypes)))))

   (define atc-integer-ops-2-type-presc-rules-loop-ops ((ops symbol-listp)
                                                        (ltypes type-listp)
                                                        (rtypes type-listp))
     :guard (and (subsetp-eq ops (list 'add 'sub 'mul 'div 'rem
                                       'lt 'gt 'le 'ge 'eq 'ne
                                       'bitand 'bitxor 'bitior))
                 (type-integer-listp ltypes)
                 (type-integer-listp rtypes))
     :returns (rules true-list-listp)
     (cond ((endp ops) nil)
           (t (append
               (atc-integer-ops-2-type-presc-rules-loop-left-types (car ops)
                                                                   ltypes
                                                                   rtypes)
               (atc-integer-ops-2-type-presc-rules-loop-ops (cdr ops)
                                                            ltypes
                                                            rtypes)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-integer-convs-type-prescription-rules*
  :short "List of type prescription rules for the
          models of C integer conversions."
  (b* ((types (list (type-schar)
                    (type-uchar)
                    (type-sshort)
                    (type-ushort)
                    (type-sint)
                    (type-uint)
                    (type-slong)
                    (type-ulong)
                    (type-sllong)
                    (type-ullong))))
    (atc-integer-convs-type-presc-rules-loop-src-types types types))

  :prepwork

  ((define atc-integer-convs-type-presc-rules-loop-dst-types
     ((stype typep)
      (dtypes type-listp))
     :guard (and (type-integerp stype)
                 (type-integer-listp dtypes))
     :returns (rules true-list-listp)
     (cond
      ((endp dtypes) nil)
      ((equal stype (car dtypes))
       (atc-integer-convs-type-presc-rules-loop-dst-types stype
                                                          (cdr dtypes)))
      (t (b* ((sfixtype (atc-integer-type-fixtype stype))
              (dfixtype (atc-integer-type-fixtype (car dtypes))))
           (cons
            (list :t (pack dfixtype '-from- sfixtype))
            (atc-integer-convs-type-presc-rules-loop-dst-types
             stype
             (cdr dtypes)))))))

   (define atc-integer-convs-type-presc-rules-loop-src-types
     ((stypes type-listp)
      (dtypes type-listp))
     :guard (and (type-integer-listp stypes)
                 (type-integer-listp dtypes))
     :returns (rules true-list-listp)
     (cond ((endp stypes) nil)
           (t (append
               (atc-integer-convs-type-presc-rules-loop-dst-types (car stypes)
                                                                  dtypes)
               (atc-integer-convs-type-presc-rules-loop-src-types (cdr stypes)
                                                                  dtypes)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-type-prescription-rules*
  :short "List of type prescription rules for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "In the dynamic semantics, the execution of statements and other entities
     returns @(tsee mv) values, which logically satisfy @(tsee consp);
     the negated application of @(tsee consp) to those execution functions
     comes up in certain subgoals,
     so a simple way to discharge those subgoals
     is to use the type prescription rules for those execution functions.")
   (xdoc::p
    "We also need rules about the constructors of C integer values
     and the C functions that represent C operations and conversions,
     including array read operations."))
  (append
   '((:t exec-expr-call-or-pure)
     (:t exec-fun)
     (:t exec-stmt)
     (:t exec-block-item)
     (:t exec-block-item-list)
     (:t schar)
     (:t uchar)
     (:t sshort)
     (:t ushort)
     (:t sint)
     (:t uint)
     (:t slong)
     (:t ulong)
     (:t sllong)
     (:t ullong)
     (:t uchar-array-read-sint)
     (:t uchar-array-read))
   *atc-integer-ops-1-type-prescription-rules*
   *atc-integer-ops-2-type-prescription-rules*
   *atc-integer-convs-type-prescription-rules*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-compound-recognizer-rules*
  :short "List of compound recognizer rules for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "The type prescription rules in @(tsee *atc-type-prescription-rules*)
     cover all the shallowly embedded C expressions except for variables.
     In the scenarios explained in @(tsee *atc-type-prescription-rules*),
     we may need to establish that a variable is not @('nil'),
     which must follow from the guard hypotheses.
     For this, we use the compound recognizer rule below.
     The fact that the type is @(tsee consp) is actually not important;
     what is important is that it does not include @('nil'),
     i.e. it is logically true."))
  '(consp-when-scharp
    consp-when-ucharp
    consp-when-sshortp
    consp-when-ushortp
    consp-when-sintp
    consp-when-uintp
    consp-when-slongp
    consp-when-ulongp
    consp-when-sllongp
    consp-when-ullongp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *atc-all-rules*
  :short "List of all the (generic) rules for the proofs generated by ATC."
  :long
  (xdoc::topstring
   (xdoc::p
    "These are the ones used in all the generated proofs.
     In addition, each proof includes a few additional rules
     that depend on the specific C-representing ACL2 functions involved.
     See @(see atc-implementation)."))
  (append *atc-opener-rules*
          *atc-executable-counterpart-rules*
          *atc-definition-rules*
          *atc-rewrite-rules*
          *atc-type-prescription-rules*
          *atc-compound-recognizer-rules*))
