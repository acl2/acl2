; C Library
;
; Copyright (C) 2025 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (www.alessandrocoglio.info)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "C2C")

(include-book "../syntax/abstract-syntax-operations")
(include-book "../syntax/unambiguity")
(include-book "../syntax/validation-information")
(include-book "../syntax/langdef-mapping")
(include-book "../atc/symbolic-execution-rules/top")

(include-book "kestrel/fty/pseudo-event-form-list" :dir :system)
(include-book "std/lists/index-of" :dir :system)
(include-book "std/system/constant-value" :dir :system)
(include-book "std/system/pseudo-event-form-listp" :dir :system)

(local (include-book "std/system/w" :dir :system))
(local (include-book "std/typed-lists/atom-listp" :dir :system))
(local (include-book "std/typed-lists/character-listp" :dir :system))
(local (include-book "std/typed-lists/symbol-listp" :dir :system))

(local (include-book "kestrel/built-ins/disable" :dir :system))
(local (acl2::disable-most-builtin-logic-defuns))
(local (acl2::disable-builtin-rewrite-rules-for-defaults))
(set-induction-depth-limit 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-implementation

 simpadd0

 :items

 ((xdoc::evmac-topic-implementation-item-input "const-old")

  (xdoc::evmac-topic-implementation-item-input "const-new")

  (xdoc::evmac-topic-implementation-item-input "proofs"))

 :additional

 ("This transformation is implemented as a collection of ACL2 functions
   that operate on the abstract syntax,
   following the recursive structure of the abstract syntax.
   This is a typical pattern for C-to-C transformations,
   which we may want to partially automate,
   via things like generalized `folds' over the abstract syntax."

  "We are extending these functions
   to also return correctness theorems in a bottom-up fashion.
   We will eventually replace the top-level theorems,
   which are currently very specific and brittle,
   with robust ones that emerge from the bottom-up generation.
   This is one of a few different or slightly different approaches
   to proof generation, which we are exploring."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defruled simpadd-exec-binary-strict-pure-when-add-alt
  :parents (simpadd0-implementation)
  :short "Alternative symbolic execution theorem."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is used in the function equivalence proofs.")
   (xdoc::p
    "It is a temporary rule, just like the current function equivalence proofs,
     which we are in the process of replacing with
     more robust proofs generated bottom-up."))
  (implies (and (equal c::op (c::binop-add))
                (equal c::y (c::expr-value->value eval))
                (equal c::objdes-y (c::expr-value->object eval))
                (not (equal (c::value-kind c::x) :array))
                (not (equal (c::value-kind c::y) :array))
                (equal c::val (c::add-values c::x c::y))
                (c::valuep c::val))
           (equal (c::exec-binary-strict-pure
                   c::op
                   (c::expr-value c::x c::objdes-x)
                   eval)
                  (c::expr-value c::val nil)))
  :use c::exec-binary-strict-pure-when-add)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection simpadd0-supporting-lemma
  :parents (simpadd0-implementation)
  :short "Supporting lemma for @(tsee simpadd0)."
  :long
  (xdoc::topstring
   (xdoc::p
    "We prove a lemma that is relied on
     by the proofs generated by the transformation.
     The lemma justifies the correctness of the transformation.
     The lemma is proved by first proving a few local theorems;
     only the lemma is exported.")
   (xdoc::p
    "First, we show that an expression satisfying @(tsee c$::expr-zerop)
     successfully translates via the language definition mapping.
     This is the expression recognized as ``zero'' by this transformation.
     This is not actually needed to prove the supporting lemma,
     but it provides validation.")
   (xdoc::p
    "Then we prove, via a few theorems that build on each other,
     that executing an expression of the form @('x + 0'),
     where the @('0') part is characterized by @(tsee c$::expr-zerop),
     is like executing just @('x'),
     under the assumption that @('x') is accessible in the computation state
     and contains a value of type @('int').
     We use @(tsee c::valuep) and @(tsee c::value-case)
     to express that the value has type @('int');
     since we have available a number of theorems,
     used in the proofs generated by @(tsee c::atc),
     that involve the predicate @(tsee c::sintp) from the "
    (xdoc::seetopic "c::representation" "shallow embedding")
    ", we show that @(tsee c::sintp) is equivalent to
     the use of @(tsee c::valuep) and @(tsee c::value-case),
     so we can relieve the hypotheses of
     those theorems from the shallow embedding,
     and prove the theorems below more succinctly.")
   (xdoc::p
    "A subtlety of the theorem about
     the equivalence of executing @('x + 0') and @('x')
     is that expression execution, in our formal semantics,
     returns an expression value of type @(tsee c::expr-value),
     which consists of a value and an optional object designator.
     The latter is non-@('nil') for lvalues,
     i.e. expressions that designate an object.
     While @('x + 0') is not an lvalue, @('x') is;
     so, strictly speaking, their execution is not quite equivalent,
     but the value part of their expression values are the same.
     This should suffice to generate proofs for this transformation:
     in valid code, @('x + 0') is never treated as an lvalue,
     and so if we replace it with @('x'),
     the surrounding code, which does not change,
     just needs the value of @('x'),
     via the usual lvalue conversion."))

  (defruledl ldm-expr-when-expr-zerop
    (implies (c$::expr-zerop expr)
             (equal (c$::ldm-expr expr)
                    (mv nil
                        (c::expr-const
                         (c::const-int
                          (c::make-iconst
                           :value 0
                           :base (c::iconst-base-oct)
                           :unsignedp nil
                           :length (c::iconst-length-none)))))))
    :enable (c$::expr-zerop
             c$::ldm-expr
             c$::ldm-const
             c$::ldm-iconst
             c$::ldm-dec/oct/hex-const))

  (defruledl c::sintp-alt-def
    (equal (c::sintp x)
           (and (c::valuep x)
                (c::value-case x :sint)))
    :enable (c::sintp
             c::valuep
             c::value-kind))

  (defruledl c::add-integer-values-of-sint-and-sint0
    (implies (and (c::valuep val)
                  (c::value-case val :sint)
                  (equal sint0 (c::value-sint 0)))
             (equal (c::add-integer-values val sint0)
                    val))
    :enable (c::add-integer-values
             c::result-integer-value
             c::sintp-alt-def
             c::type-of-value-when-sintp
             c::value-integerp-when-sintp
             c::integer-type-rangep
             ifix
             fix))

  (defruledl c::uaconvert-values-of-sint-and-sint0
    (implies (and (c::valuep val)
                  (c::value-case val :sint)
                  (equal sint0 (c::value-sint 0)))
             (equal (c::uaconvert-values val sint0)
                    (mv val sint0)))
    :enable (c::sintp-alt-def
             c::uaconvert-values-when-sintp-and-sintp))

  (defruledl c::add-arithmetic-values-of-sint-and-sint0
    (implies (and (c::valuep val)
                  (c::value-case val :sint)
                  (equal sint0 (c::value-sint 0)))
             (equal (c::add-arithmetic-values val sint0)
                    val))
    :enable (c::add-arithmetic-values
             c::uaconvert-values-of-sint-and-sint0
             c::add-integer-values-of-sint-and-sint0))

  (defruledl c::add-values-of-sint-and-sint0
    (implies (and (c::valuep val)
                  (c::value-case val :sint)
                  (equal sint0 (c::value-sint 0)))
             (equal (c::add-values val sint0)
                    val))
    :enable (c::add-values
             c::value-arithmeticp-when-sintp
             c::sintp-alt-def
             c::add-arithmetic-values-of-sint-and-sint0))

  (defruled simpadd0-supporting-lemma
    (implies (and (c::objdesign-of-var var compst)
                  (c$::expr-zerop zero))
             (b* ((val (c::read-object
                        (c::objdesign-of-var var compst) compst)))
               (implies (and (c::valuep val)
                             (c::value-case val :sint))
                        (b* ((var+zero-result
                              (c::exec-expr-pure
                               (c::expr-binary
                                (c::binop-add)
                                (c::expr-ident var)
                                (mv-nth 1 (c$::ldm-expr zero)))
                               compst))
                             (var-result
                              (c::exec-expr-pure
                               (c::expr-ident var)
                               compst)))
                          (and (not (c::errorp var-result))
                               (equal (c::expr-value->value var+zero-result)
                                      (c::expr-value->value var-result)))))))
    :enable (c::exec-expr-pure
             c::exec-binary-strict-pure
             c::eval-binary-strict-pure
             c::exec-ident
             c::apconvert-expr-value
             c::add-values-of-sint-and-sint0
             ldm-expr-when-expr-zerop)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-input-processing simpadd0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-process-inputs (const-old const-new proofs (wrld plist-worldp))
  :returns (mv erp
               (tunits-old transunit-ensemblep)
               (const-old$ symbolp)
               (const-new$ symbolp)
               (proofs$ booleanp))
  :short "Process all the inputs."
  (b* (((reterr) (c$::irr-transunit-ensemble) nil nil nil)
       ((unless (symbolp const-old))
        (reterr (msg "The first input must be a symbol, ~
                      but it is ~x0 instead."
                     const-old)))
       ((unless (symbolp const-new))
        (reterr (msg "The second input must be a symbol, ~
                      but it is ~x0 instead."
                     const-new)))
       ((unless (booleanp proofs))
        (reterr (msg "The :PROOFS input must be a boolean, ~
                      but it is ~x0 instead."
                     proofs)))
       ((unless (constant-symbolp const-old wrld))
        (reterr (msg "The first input, ~x0, must be a named constant, ~
                      but it is not."
                     const-old)))
       (tunits-old (constant-value const-old wrld))
       ((unless (transunit-ensemblep tunits-old))
        (reterr (msg "The value of the constant ~x0 ~
                      must be a translation unit ensemble, ~
                      but it is ~x1 instead."
                     const-old tunits-old)))
       ((unless (transunit-ensemble-unambp tunits-old))
        (reterr (msg "The translation unit ensemble ~x0 ~
                      that is the value of the constant ~x1 ~
                      must be unambiguous, ~
                      but it is not."
                     tunits-old const-old)))
       ((unless (transunit-ensemble-annop tunits-old))
        (reterr (msg "The translation unit ensemble ~x0 ~
                      that is the value of the constant ~x1 ~
                      must contains validation information, ~
                      but it does not."
                     tunits-old const-old))))
    (retok tunits-old const-old const-new proofs))

  ///

  (defret transunit-ensemble-unambp-of-simpadd0-process-inputs
    (implies (not erp)
             (transunit-ensemble-unambp tunits-old)))

  (defret transunit-ensemble-annop-of-simpadd0-process-inputs
    (implies (not erp)
             (transunit-ensemble-annop tunits-old))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-event-generation simpadd0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fty::defprod simpadd0-gin
  :short "General inputs for transformation functions."
  :long
  (xdoc::topstring
   (xdoc::p
    "The transformation functions take as input the construct to transform,
     which has a different type for each transformation function.
     But each function also takes certain common inputs,
     which we put into this data structure
     for modularity and to facilitate extension.
     Additionally, the transformation take the ACL2 state as input,
     but this is not part of this structure for obvious reasons."))
  ((const-new symbolp
              "The @(':const-new') input of the transformation.")
   (thm-index pos
              "Index used to generate unique theorem names
               that include increasing numeric indices.")
   (names-to-avoid symbol-list
                   "List of event names to avoid,
                    for the generated theorems."))
  :pred simpadd0-ginp)

;;;;;;;;;;;;;;;;;;;;

(fty::defprod simpadd0-gout
  :short "General outputs for transformation functions."
  :long
  (xdoc::topstring
   (xdoc::p
    "The transformation functions return as output the transformed construct,
     which has a different type for each transformation function.
     But each function also returns certain common outputs,
     which we put into this data structure
     for modularity and to facility extension."))
  ((events pseudo-event-form-list
           "Cumulative list of generated theorems.")
   (thm-name symbol
             "Name of the theorem generated by the transformation function.
              The theorem concerns the transformation of the C construct
              that the transformation function operates on.
              This is @('nil') if no theorem is generated.")
   (thm-index pos
              "Updated numeric index to generate unique theorem names;
               this is updated from
               the homonymous component of @(tsee simpadd0-gin).")
   (names-to-avoid symbol-list
                   "Updated list of event names to avoid;
                    this is updated from
                    the homonymous component of @(tsee simpadd0-gin).")
   (vars ident-set
         "Set of simplified variables.
          This consists of the variables @('x') such that
          an expression of the form @('x + 0')
          occurs in the C construct transformed by the transformation function
          (which is returning a value of this fixtype)
          and was transformed into @('x').
          This set will be soon used to generate hypotheses, in the theorems,
          about those functions being in the computation state
          and containing @('int') values.")
   (diffp bool
          "Flag saying whether the C construct was transformed
           into something different by the transformation function.")
   (falliblep bool
              "Flag saying whether the execution of the C construct
               may return an error, under certain given hypotheses."))
  :pred simpadd0-goutp)

;;;;;;;;;;

(defirrelevant irr-simpadd0-gout
  :short "Irrelevant general outputs for transformation functions."
  :type simpadd0-goutp
  :body (make-simpadd0-gout :events nil
                            :thm-name nil
                            :thm-index 1
                            :names-to-avoid nil
                            :vars nil
                            :diffp nil
                            :falliblep nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-gen-var-hyps ((vars ident-setp))
  :returns (hyps true-listp)
  :short "Generate variable hypotheses for certain theorems."
  :long
  (xdoc::topstring
   (xdoc::p
    "The input of this function comes from
     the @('vars') component of @(tsee simpadd0-gout).
     For each such variable, we add a hypothesis about it saying that
     the variable can be read from the computation state
     and it contains an @('int') value."))
  (b* (((when (set::emptyp (ident-set-fix vars))) nil)
       (var (set::head vars))
       (hyp `(b* ((var (mv-nth 1 (c$::ldm-ident
                                  (ident ,(ident->unwrap var)))))
                  (objdes (c::objdesign-of-var var compst))
                  (val (c::read-object objdes compst)))
               (and objdes
                    (c::valuep val)
                    (c::value-case val :sint))))
       (hyps (simpadd0-gen-var-hyps (set::tail vars))))
    (cons hyp hyps))
  :prepwork ((local (in-theory (enable c$::emptyp-of-ident-set-fix))))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-gen-expr-pure-thm ((old exprp)
                                    (new exprp)
                                    (falliblep booleanp)
                                    (vars ident-setp)
                                    (const-new symbolp)
                                    (thm-index posp)
                                    (hints true-listp))
  :guard (and (expr-unambp old)
              (expr-unambp new))
  :returns (mv (thm-event pseudo-event-formp)
               (thm-name symbolp)
               (updated-thm-index posp))
  :short "Generate a theorem for the transformation of a pure expression."
  :long
  (xdoc::topstring
   (xdoc::p
    "This function takes the old and new expressions as inputs,
     which must always satisfy @(tsee c$::expr-pure-formalp).
     If the two expressions are syntactically equal,
     the generated theorem just says that the expressions have type @('int').
     If they are not syntactically equal,
     the theorem also says that the execution of the two expressions
     yields the same result,
     assuming that the old expression's result is not an error.
     More precisely, the theorem equates the value components of
     the expression values returned by expression execution;
     for our current purposes this is adequate,
     but we may generalize this in the future.")
   (xdoc::p
    "Note that the calls of @(tsee c$::ldm-expr) in the theorem
     are known to succeed (i.e. not return any error),
     given that @(tsee c$::expr-pure-formalp) holds.")
   (xdoc::p
    "This function also takes as input a set of identifiers,
     which are the variables in scope of type @('int').
     The theorem includes a hypothesis for each of these variables,
     saying that they are in the computation state
     and that they contain @('int') values.")
   (xdoc::p
    "The hypothesis that the old expression does not return an error
     is generated only if the old expression may actually return an error,
     which is indicated by the boolean flag passed as input.
     This possbility of returning an error or not
     is with respect to the hypotheses about the variables in @('vars')
     mentioned above.")
   (xdoc::p
    "The hints to prove the theorem are passed as input too,
     since the proof generally varies depending on the kind of expression."))
  (b* ((old (expr-fix old))
       (new (expr-fix new))
       ((unless (c$::expr-pure-formalp old))
        (raise "Internal error: ~x0 is not in the formalized subset." old)
        (mv '(_) nil 1))
       (equalp (equal old new))
       ((unless (or equalp (c$::expr-pure-formalp new)))
        (raise "Internal error: ~x0 is not in the formalized subset." new)
        (mv '(_) nil 1))
       (hyps (simpadd0-gen-var-hyps vars))
       (formula
        (if equalp
            `(b* ((expr (mv-nth 1 (c$::ldm-expr ',old)))
                  (expr-result (c::exec-expr-pure expr compst))
                  (expr-value (c::expr-value->value expr-result)))
               (implies (and ,@hyps
                             ,@(and falliblep
                                    '((not (c::errorp expr-result)))))
                        (equal (c::value-kind expr-value) :sint)))
          `(b* ((old-expr (mv-nth 1 (c$::ldm-expr ',old)))
                (new-expr (mv-nth 1 (c$::ldm-expr ',new)))
                (old-result (c::exec-expr-pure old-expr compst))
                (new-result (c::exec-expr-pure new-expr compst))
                (old-value (c::expr-value->value old-result))
                (new-value (c::expr-value->value new-result)))
             (implies (and ,@hyps
                           ,@(and falliblep
                                  '((not (c::errorp old-result)))))
                      (and (equal old-value new-value)
                           (equal (c::value-kind old-value) :sint))))))
       (thm-name
        (packn-pos (list const-new '-thm- thm-index) const-new))
       (thm-index (1+ (pos-fix thm-index)))
       (thm-event
        `(defthmd ,thm-name
           ,formula
           :hints ,hints)))
    (mv thm-event thm-name thm-index))
  ///
  (fty::deffixequiv simpadd0-gen-expr-pure-thm
    :args ((old exprp) (new exprp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-expr-ident ((ident identp)
                             (info c$::var-infop)
                             (gin simpadd0-ginp))
  :returns (mv (new-ident identp)
               (new-info c$::var-infop)
               (gout simpadd0-goutp))
  :short "Transform an identifier expression (i.e. a variable)."
  :long
  (xdoc::topstring
   (xdoc::p
    "This undergoes no actual transformation,
     but we introduce it for uniformity,
     also because we may eventually evolve the @(tsee simpadd0) implementation
     into a much more general transformation.
     Thus, the output identifier and validation information
     are always the same as the input ones.")
   (xdoc::p
    "If the variable has type @('int'),
     which we check in the validation information,
     then we generate a theorem saying that the expression,
     when executed, yields a value of type @('int').")
   (xdoc::p
    "Under the assumption that the variable is in scope,
     which is included in the generated theorem,
     the execution of a variable never results in an error,
     so we pass @('nil') as the @('falliblep') flag
     to the theorem generation function,
     and we set to @('nil') the @('falliblep') component
     of @(tsee simpadd0-gout).")
   (xdoc::p
    "The generated theorem is proved via a general supporting lemma,
     which is proved below."))
  (b* ((ident (ident-fix ident))
       (info (c$::var-info-fix info))
       ((simpadd0-gin gin) gin)
       ((c$::var-info info) info)
       ((unless (c$::type-case info.type :sint))
        (mv ident
            info
            (make-simpadd0-gout :events nil
                                :thm-name nil
                                :thm-index gin.thm-index
                                :names-to-avoid gin.names-to-avoid
                                :vars nil
                                :diffp nil
                                :falliblep nil)))
       (vars (set::insert ident nil))
       (expr (c$::expr-ident ident info))
       (hints `(("Goal"
                 :in-theory '((:e c$::expr-ident)
                              (:e c$::expr-pure-formalp)
                              (:e c$::ident))
                 :use (:instance simpadd0-expr-ident-support-lemma
                                 (ident ',ident)
                                 (info ',info)))))
       (falliblep nil)
       ((mv thm-event thm-name thm-index)
        (simpadd0-gen-expr-pure-thm expr
                                    expr
                                    falliblep
                                    vars
                                    gin.const-new
                                    gin.thm-index
                                    hints)))
    (mv ident
        info
        (make-simpadd0-gout :events (list thm-event)
                            :thm-name thm-name
                            :thm-index thm-index
                            :names-to-avoid (list thm-name)
                            :vars vars
                            :diffp nil
                            :falliblep falliblep)))
  :prepwork ((local (in-theory (enable identity))))
  :hooks (:fix)

  ///

  (defruled simpadd0-expr-ident-support-lemma
    (b* ((expr (mv-nth 1 (c$::ldm-expr (c$::expr-ident ident info))))
         (expr-result (c::exec-expr-pure expr compst))
         (expr-value (c::expr-value->value expr-result)))
      (implies (and (c$::expr-pure-formalp (c$::expr-ident ident info))
                    (b* ((var (mv-nth 1 (c$::ldm-ident ident)))
                         (objdes (c::objdesign-of-var var compst))
                         (val (c::read-object objdes compst)))
                      (and objdes
                           (c::valuep val)
                           (c::value-case val :sint))))
               (equal (c::value-kind expr-value) :sint)))
    :enable (c::exec-expr-pure
             c::exec-ident
             c$::ldm-expr
             c$::expr-pure-formalp)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-expr-const ((const constp) (gin simpadd0-ginp))
  :returns (mv (new-const constp) (gout simpadd0-goutp))
  :short "Transform a constant."
  :long
  (xdoc::topstring
   (xdoc::p
    "This undergoes no actual transformation,
     but we introduce it for uniformity,
     also because we may eventually evolve the @(tsee simpadd0) implementation
     into a much more general transformation.
     Thus, the output constant is always the same as the input one.")
   (xdoc::p
    "If the constant is an integer one and has type @('int'),
     and under the additional condition described shortly,
     we generate a theorem saying that the exprssion,
     when executed, yields a value of type @('int').
     The additional condition is that
     the value of the constant fits in 32 bits.
     The reason is that
     our current dynamic semantics assumes that @('int') has 32 bits,
     while our validator is more general
     (@(tsee valid-iconst) takes an implementation environment as input,
     which specifies, among other things, the size of @('int')).
     Until we extend our dynamic semantics to be more general,
     we need this additional condition for proof generation."))
  (b* (((simpadd0-gin gin) gin)
       (no-thm-gout (make-simpadd0-gout :events nil
                                        :thm-name nil
                                        :thm-index gin.thm-index
                                        :names-to-avoid gin.names-to-avoid
                                        :vars nil
                                        :diffp nil
                                        :falliblep nil))
       ((unless (const-case const :int)) (mv (const-fix const) no-thm-gout))
       ((iconst iconst) (const-int->unwrap const))
       ((c$::iconst-info info) (c$::coerce-iconst-info iconst.info))
       ((unless (and (c$::type-case info.type :sint)
                     (<= info.value (c::sint-max))))
        (mv (const-fix const) no-thm-gout))
       (expr (c$::expr-const const))
       (hints `(("Goal" :in-theory '(c::exec-expr-pure
                                     (:e c$::ldm-expr)
                                     (:e c::expr-const)
                                     (:e c::expr-fix)
                                     (:e c::expr-kind)
                                     (:e c::expr-const->get)
                                     (:e c::exec-const)
                                     (:e c::expr-value->value)
                                     (:e c::value-kind)))))
       (vars nil)
       (falliblep nil)
       ((mv thm-event thm-name thm-index)
        (simpadd0-gen-expr-pure-thm expr
                                    expr
                                    falliblep
                                    vars
                                    gin.const-new
                                    gin.thm-index
                                    hints)))
    (mv (const-fix const)
        (make-simpadd0-gout :events (list thm-event)
                            :thm-name thm-name
                            :thm-index thm-index
                            :names-to-avoid (list thm-name)
                            :vars vars
                            :diffp nil
                            :falliblep falliblep)))
  :hooks (:fix))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defines simpadd0-exprs/decls/stmts
  :short "Transform expressions, declarations, statements,
          and related entities."
  :long
  (xdoc::topstring
   (xdoc::p
    "For now we only generate theorems for certain kinds of expressions.
     We are in the process of extending the implementation to generate theorems
     for additional kinds of expressions and for other constructs."))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-expr ((expr exprp) (gin simpadd0-ginp) state)
    :guard (expr-unambp expr)
    :returns (mv (new-expr exprp) (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an expression."
    :long
    (xdoc::topstring
     (xdoc::p
      "Variables (i.e. identifier expressions) and constants
       are handled by separate functions.")
     (xdoc::p
      "String literals undergo no transformation.
       No theorems are generated for them,
       since our formal dynamic semantics does not cover them yet.")
     (xdoc::p
      "When we encounter constructs unsupported in the formal dynamic semnatics,
       we do not generate a theorem.
       Currently we also do not generate a theorem also for supported constructs
       for which we have not implemented theorem generation yet:
       we are in the process of extending the implementation.")
     (xdoc::p
      "When we encounter a parenthesized expression,
       we recursively transform the inner expression,
       we parenthesize the transformed inner expression,
       and we return that.
       We generate a theorem if the two inner expressions differ
       (in which case the parenthesized expressions differ as well)
       and a theorem for the inner expressions' transformation was generated
       (which we can tell based on whether
       there is a theorem name for the inner expressions).
       Since @(tsee c$::ldm-expr) maps parenthesized expressions
       to the same as what the inner expressions are mapped to,
       the proof of the generated theorem is straightforward,
       but we supply the executable counterpart of @(tsee c$::ldm-expr)
       so that they can be applied to the parenthesized expressions.")
     (xdoc::p
      "When we encounter an expression @('x + 0') that we transform into @('x'),
       we also generate a theorem saying that
       executing the two expressions give equivalent results.
       This is proved by essentially just instantiating
       @(tsee simpadd0-supporting-lemma)
       (see its documentation, also in regard to the exact way in which
       we express the equivalence).
       This is a very preliminary theorem generation capability,
       which we plan to extend soon."))
    (b* (((simpadd0-gin gin) gin))
      (expr-case
       expr
       :ident (b* (((mv ident info gout)
                    (simpadd0-expr-ident expr.ident
                                         (c$::coerce-var-info expr.info)
                                         gin)))
                (mv (make-expr-ident :ident ident :info info) gout))
       :const (b* (((mv const gout) (simpadd0-expr-const expr.const gin)))
                (mv (expr-const const) gout))
       :string (mv (expr-fix expr)
                   (make-simpadd0-gout :events nil
                                       :thm-name nil
                                       :thm-index gin.thm-index
                                       :names-to-avoid gin.names-to-avoid
                                       :vars nil
                                       :diffp nil
                                       :falliblep nil))
       :paren
       (b* (((mv new-inner (simpadd0-gout gout-inner))
             (simpadd0-expr expr.inner gin state))
            ((unless (mbt (expr-unambp new-inner)))
             (mv (irr-expr) (irr-simpadd0-gout)))
            (new-expr (expr-paren new-inner)))
         (if (and gout-inner.diffp
                  gout-inner.thm-name)
             (b* ((hints
                   `(("Goal"
                      :in-theory '((:e c$::ldm-expr))
                      :use ,gout-inner.thm-name)))
                  ((mv thm-event thm-name thm-index)
                   (simpadd0-gen-expr-pure-thm expr
                                               new-expr
                                               t
                                               gout-inner.vars
                                               gin.const-new
                                               gout-inner.thm-index
                                               hints)))
               (mv new-expr
                   (make-simpadd0-gout
                    :events (append gout-inner.events
                                    (list thm-event))
                    :thm-name thm-name
                    :thm-index thm-index
                    :names-to-avoid (append gout-inner.names-to-avoid
                                            (list thm-name))
                    :vars gout-inner.vars
                    :diffp t
                    :falliblep gout-inner.falliblep)))
           (mv new-expr
               (make-simpadd0-gout :events gout-inner.events
                                   :thm-name nil
                                   :thm-index gout-inner.thm-index
                                   :names-to-avoid gout-inner.names-to-avoid
                                   :vars gout-inner.vars
                                   :diffp gout-inner.diffp
                                   :falliblep gout-inner.falliblep))))
       :gensel
       (b* (((mv new-control (simpadd0-gout gout-control))
             (simpadd0-expr expr.control gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-control.thm-index
                  :names-to-avoid gout-control.names-to-avoid))
            ((mv new-assocs (simpadd0-gout gout-assocs))
             (simpadd0-genassoc-list expr.assocs gin state)))
         (mv (make-expr-gensel :control new-control
                               :assocs new-assocs)
             (make-simpadd0-gout
              :events (append gout-control.events gout-assocs.events)
              :thm-name nil
              :thm-index gout-assocs.thm-index
              :names-to-avoid gout-assocs.names-to-avoid
              :vars (set::union gout-control.vars gout-assocs.vars)
              :diffp (or gout-control.diffp gout-assocs.diffp)
              :falliblep t)))
       :arrsub
       (b* (((mv new-arg1 (simpadd0-gout gout-arg1))
             (simpadd0-expr expr.arg1 gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-arg1.thm-index
                  :names-to-avoid gout-arg1.names-to-avoid))
            ((mv new-arg2 (simpadd0-gout gout-arg2))
             (simpadd0-expr expr.arg2 gin state))
            (new-expr (make-expr-arrsub :arg1 new-arg1
                                        :arg2 new-arg2)))
         (mv new-expr
             (make-simpadd0-gout
              :events (append gout-arg1.events gout-arg2.events)
              :thm-name nil
              :thm-index gout-arg2.thm-index
              :names-to-avoid gout-arg2.names-to-avoid
              :vars (set::union gout-arg1.vars gout-arg2.vars)
              :diffp (or gout-arg1.diffp gout-arg2.diffp)
              :falliblep t)))
       :funcall
       (b* (((mv new-fun (simpadd0-gout gout-fun))
             (simpadd0-expr expr.fun gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-fun.thm-index
                  :names-to-avoid gout-fun.names-to-avoid))
            ((mv new-args (simpadd0-gout gout-args))
             (simpadd0-expr-list expr.args gin state)))
         (mv (make-expr-funcall :fun new-fun
                                :args new-args)
             (make-simpadd0-gout
              :events (append gout-fun.events gout-args.events)
              :thm-name nil
              :thm-index gout-args.thm-index
              :names-to-avoid gout-args.names-to-avoid
              :vars (set::union gout-fun.vars gout-args.vars)
              :diffp (or gout-fun.diffp gout-args.diffp)
              :falliblep t)))
       :member
       (b* (((mv new-arg (simpadd0-gout gout-arg))
             (simpadd0-expr expr.arg gin state)))
         (mv (make-expr-member :arg new-arg
                               :name expr.name)
             (make-simpadd0-gout
              :events gout-arg.events
              :thm-name nil
              :thm-index gout-arg.thm-index
              :names-to-avoid gout-arg.names-to-avoid
              :vars gout-arg.vars
              :diffp gout-arg.diffp
              :falliblep t)))
       :memberp
       (b* (((mv new-arg (simpadd0-gout gout-arg))
             (simpadd0-expr expr.arg gin state)))
         (mv (make-expr-memberp :arg new-arg
                                :name expr.name)
             (make-simpadd0-gout
              :events gout-arg.events
              :thm-name nil
              :thm-index gout-arg.thm-index
              :names-to-avoid gout-arg.names-to-avoid
              :vars gout-arg.vars
              :diffp gout-arg.diffp
              :falliblep t)))
       :complit
       (b* (((mv new-type (simpadd0-gout gout-type))
             (simpadd0-tyname expr.type gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-type.thm-index
                  :names-to-avoid gout-type.names-to-avoid))
            ((mv new-elems (simpadd0-gout gout-elems))
             (simpadd0-desiniter-list expr.elems gin state)))
         (mv (make-expr-complit :type new-type
                                :elems new-elems
                                :final-comma expr.final-comma)
             (make-simpadd0-gout
              :events (append gout-type.events gout-elems.events)
              :thm-name nil
              :thm-index gout-elems.thm-index
              :names-to-avoid gout-elems.names-to-avoid
              :vars (set::union gout-type.vars gout-elems.vars)
              :diffp (or gout-type.diffp gout-elems.diffp)
              :falliblep t)))
       :unary
       (b* (((mv new-arg (simpadd0-gout gout-arg))
             (simpadd0-expr expr.arg gin state)))
         (mv (make-expr-unary :op expr.op
                              :arg new-arg)
             (make-simpadd0-gout
              :events gout-arg.events
              :thm-name nil
              :thm-index gout-arg.thm-index
              :names-to-avoid gout-arg.names-to-avoid
              :vars gout-arg.vars
              :diffp gout-arg.diffp
              :falliblep t)))
       :sizeof
       (b* (((mv new-type (simpadd0-gout gout-type))
             (simpadd0-tyname expr.type gin state)))
         (mv (expr-sizeof new-type)
             (make-simpadd0-gout
              :events gout-type.events
              :thm-name nil
              :thm-index gout-type.thm-index
              :names-to-avoid gout-type.names-to-avoid
              :vars gout-type.vars
              :diffp gout-type.diffp
              :falliblep t)))
       :alignof
       (b* (((mv new-type (simpadd0-gout gout-type))
             (simpadd0-tyname expr.type gin state)))
         (mv (make-expr-alignof :type new-type
                                :uscores expr.uscores)
             (make-simpadd0-gout
              :events gout-type.events
              :thm-name nil
              :thm-index gout-type.thm-index
              :names-to-avoid gout-type.names-to-avoid
              :vars gout-type.vars
              :diffp gout-type.diffp
              :falliblep t)))
       :cast
       (b* (((mv new-type (simpadd0-gout gout-type))
             (simpadd0-tyname expr.type gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-type.thm-index
                  :names-to-avoid gout-type.names-to-avoid))
            ((mv new-arg (simpadd0-gout gout-arg))
             (simpadd0-expr expr.arg gin state)))
         (mv (make-expr-cast :type new-type
                             :arg new-arg)
             (make-simpadd0-gout
              :events (append gout-type.events gout-arg.events)
              :thm-name nil
              :thm-index gout-arg.thm-index
              :names-to-avoid gout-arg.names-to-avoid
              :vars (set::union gout-type.vars gout-arg.vars)
              :diffp (or gout-type.diffp gout-arg.diffp)
              :falliblep t)))
       :binary
       (b* (((mv new-arg1 (simpadd0-gout gout-arg1))
             (simpadd0-expr expr.arg1 gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-arg1.thm-index
                  :names-to-avoid gout-arg1.names-to-avoid))
            ((mv new-arg2 (simpadd0-gout gout-arg2))
             (simpadd0-expr expr.arg2 gin state)))
         (if (and (c$::expr-zerop new-arg2)
                  (expr-case new-arg1 :ident)
                  (b* (((c$::var-info info)
                        (c$::coerce-var-info
                         (c$::expr-ident->info new-arg1))))
                    (c$::type-case info.type :sint))
                  (equal new-arg1 expr.arg1)
                  (equal new-arg2 expr.arg2))
             ;; Transform the expression and generate a theorem.
             (b* ((var (expr-ident->ident new-arg1))
                  (vars (set::insert var (set::union gout-arg1.vars
                                                     gout-arg2.vars)))
                  (info (c$::expr-ident->info new-arg1))
                  (hints
                   `(("Goal"
                      :in-theory '((:e c::expr-binary)
                                   (:e c::expr-ident)
                                   (:e c::binop-add)
                                   (:e c$::binop-add)
                                   (:e c$::const-int)
                                   (:e c$::dec/oct/hex-const-oct)
                                   (:e c$::expr-binary)
                                   (:e c$::expr-const)
                                   (:e c$::expr-ident)
                                   (:e c$::expr-zerop)
                                   (:e c$::iconst)
                                   (:e c$::ident)
                                   (:e c$::ldm-expr)
                                   (:e c$::ldm-ident)
                                   (:e c$::expr-pure-formalp))
                      :use ((:instance simpadd0-supporting-lemma
                                       (var (mv-nth 1 (c$::ldm-ident
                                                       (c$::ident
                                                        ,(ident->unwrap var)))))
                                       (zero (c$::expr-const
                                              (c$::const-int
                                               (c$::make-iconst
                                                :core
                                                (c$::make-dec/oct/hex-const-oct
                                                 :leading-zeros 1
                                                 :value 0)
                                                :suffix? nil)))))
                            (:instance simpadd0-expr-ident-support-lemma
                                       (ident ',var)
                                       (info ',info))))))
                  ((mv thm-event thm-name thm-index)
                   (simpadd0-gen-expr-pure-thm expr
                                               new-arg1
                                               nil
                                               vars
                                               gin.const-new
                                               gout-arg2.thm-index
                                               hints)))
               (mv new-arg1
                   (make-simpadd0-gout
                    :events (append gout-arg1.events
                                    gout-arg2.events
                                    (list thm-event))
                    :thm-name thm-name
                    :thm-index thm-index
                    :names-to-avoid (append gout-arg2.names-to-avoid
                                            (list thm-name))
                    :vars vars
                    :diffp t
                    :falliblep t)))
           ;; Do not transform the expression.
           (mv (make-expr-binary :op expr.op :arg1 new-arg1 :arg2 new-arg2)
               (make-simpadd0-gout
                :events (append gout-arg1.events gout-arg2.events)
                :thm-name nil
                :thm-index gout-arg2.thm-index
                :names-to-avoid gout-arg2.names-to-avoid
                :vars (set::union gout-arg1.vars gout-arg2.vars)
                :diffp (or gout-arg1.diffp gout-arg2.diffp)
                :falliblep t))))
       :cond
       (b* (((mv new-test (simpadd0-gout gout-test))
             (simpadd0-expr expr.test gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-test.thm-index
                  :names-to-avoid gout-test.names-to-avoid))
            ((mv new-then (simpadd0-gout gout-then))
             (simpadd0-expr-option expr.then gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-then.thm-index
                  :names-to-avoid gout-then.names-to-avoid))
            ((mv new-else (simpadd0-gout gout-else))
             (simpadd0-expr expr.else gin state)))
         (mv (make-expr-cond :test new-test
                             :then new-then
                             :else new-else)
             (make-simpadd0-gout
              :events (append gout-test.events
                              gout-then.events
                              gout-else.events)
              :thm-name nil
              :thm-index gout-else.thm-index
              :names-to-avoid gout-else.names-to-avoid
              :vars (set::union gout-test.vars
                                (set::union gout-then.vars
                                            gout-else.vars))
              :diffp (or gout-test.diffp gout-then.diffp gout-else.diffp)
              :falliblep t)))
       :comma
       (b* (((mv new-first (simpadd0-gout gout-first))
             (simpadd0-expr expr.first gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-first.thm-index
                  :names-to-avoid gout-first.names-to-avoid))
            ((mv new-next (simpadd0-gout gout-next))
             (simpadd0-expr expr.next gin state)))
         (mv (make-expr-comma :first new-first
                              :next new-next)
             (make-simpadd0-gout
              :events (append gout-first.events gout-next.events)
              :thm-name nil
              :thm-index gout-next.thm-index
              :names-to-avoid gout-next.names-to-avoid
              :vars (set::union gout-first.vars gout-next.vars)
              :diffp (or gout-first.diffp gout-next.diffp)
              :falliblep t)))
       :stmt
       (b* (((mv new-items (simpadd0-gout gout-items))
             (simpadd0-block-item-list expr.items gin state)))
         (mv (expr-stmt new-items)
             (make-simpadd0-gout
              :events gout-items.events
              :thm-name nil
              :thm-index gout-items.thm-index
              :names-to-avoid gout-items.names-to-avoid
              :vars gout-items.vars
              :diffp gout-items.diffp
              :falliblep t)))
       :tycompat
       (b* (((mv new-type1 (simpadd0-gout gout-type1))
             (simpadd0-tyname expr.type1 gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-type1.thm-index
                  :names-to-avoid gout-type1.names-to-avoid))
            ((mv new-type2 (simpadd0-gout gout-type2))
             (simpadd0-tyname expr.type2 gin state)))
         (mv (make-expr-tycompat :type1 new-type1
                                 :type2 new-type2)
             (make-simpadd0-gout
              :events (append gout-type1.events gout-type2.events)
              :thm-name nil
              :thm-index gout-type2.thm-index
              :names-to-avoid gout-type2.names-to-avoid
              :vars (set::union gout-type1.vars gout-type2.vars)
              :diffp (or gout-type1.diffp gout-type1.diffp)
              :falliblep t)))
       :offsetof
       (b* (((mv new-type (simpadd0-gout gout-type))
             (simpadd0-tyname expr.type gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-type.thm-index
                  :names-to-avoid gout-type.names-to-avoid))
            ((mv new-member (simpadd0-gout gout-member))
             (simpadd0-member-designor expr.member gin state)))
         (mv (make-expr-offsetof :type new-type
                                 :member new-member)
             (make-simpadd0-gout
              :events (append gout-type.events gout-member.events)
              :thm-name nil
              :thm-index gout-member.thm-index
              :names-to-avoid gout-member.names-to-avoid
              :vars (set::union gout-type.vars gout-member.vars)
              :diffp (or gout-type.diffp gout-member.diffp)
              :falliblep t)))
       :va-arg
       (b* (((mv new-list (simpadd0-gout gout-list))
             (simpadd0-expr expr.list gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-list.thm-index
                  :names-to-avoid gout-list.names-to-avoid))
            ((mv new-type (simpadd0-gout gout-type))
             (simpadd0-tyname expr.type gin state)))
         (mv (make-expr-va-arg :list new-list
                               :type new-type)
             (make-simpadd0-gout
              :events (append gout-list.events gout-type.events)
              :thm-name nil
              :thm-index gout-type.thm-index
              :names-to-avoid gout-type.names-to-avoid
              :vars (set::union gout-list.vars gout-type.vars)
              :diffp (or gout-list.diffp gout-type.diffp)
              :falliblep t)))
       :extension
       (b* (((mv new-expr (simpadd0-gout gout-expr))
             (simpadd0-expr expr.expr gin state)))
         (mv (expr-extension new-expr)
             (make-simpadd0-gout
              :events gout-expr.events
              :thm-name nil
              :thm-index gout-expr.thm-index
              :names-to-avoid gout-expr.names-to-avoid
              :vars gout-expr.vars
              :diffp gout-expr.diffp
              :falliblep t)))
       :otherwise (prog2$ (impossible) (mv (irr-expr) (irr-simpadd0-gout)))))
    :measure (expr-count expr))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-expr-list ((exprs expr-listp) (gin simpadd0-ginp) state)
    :guard (expr-list-unambp exprs)
    :returns (mv (new-exprs expr-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of expressions."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp exprs))
          (mv nil
              (make-simpadd0-gout :events nil
                                  :thm-name nil
                                  :thm-index gin.thm-index
                                  :names-to-avoid gin.names-to-avoid
                                  :vars nil
                                  :diffp nil
                                  :falliblep t)))
         ((mv new-expr (simpadd0-gout gout-expr))
          (simpadd0-expr (car exprs) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-expr.thm-index
               :names-to-avoid gout-expr.names-to-avoid))
         ((mv new-exprs (simpadd0-gout gout-exprs))
          (simpadd0-expr-list (cdr exprs) gin state)))
      (mv (cons new-expr new-exprs)
          (make-simpadd0-gout
           :events (append gout-expr.events gout-exprs.events)
           :thm-name nil
           :thm-index gout-exprs.thm-index
           :names-to-avoid gout-exprs.names-to-avoid
           :vars (set::union gout-expr.vars gout-exprs.vars)
           :diffp (or gout-expr.diffp gout-exprs.diffp)
           :falliblep t)))
    :measure (expr-list-count exprs))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-expr-option ((expr? expr-optionp) (gin simpadd0-ginp) state)
    :guard (expr-option-unambp expr?)
    :returns (mv (new-expr? expr-optionp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an optional expression."
    (b* (((simpadd0-gin gin) gin))
      (expr-option-case
       expr?
       :some (simpadd0-expr expr?.val gin state)
       :none (mv nil
                 (make-simpadd0-gout :events nil
                                     :thm-name nil
                                     :thm-index gin.thm-index
                                     :names-to-avoid gin.names-to-avoid
                                     :vars nil
                                     :diffp nil
                                     :falliblep t))))
    :measure (expr-option-count expr?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-const-expr ((cexpr const-exprp) (gin simpadd0-ginp) state)
    :guard (const-expr-unambp cexpr)
    :returns (mv (new-cexpr const-exprp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a constant expression."
    (b* (((simpadd0-gin gin) gin)
         ((mv new-expr (simpadd0-gout gout-expr))
          (simpadd0-expr (const-expr->expr cexpr) gin state)))
      (mv (const-expr new-expr)
          (make-simpadd0-gout :events gout-expr.events
                              :thm-name nil
                              :thm-index gout-expr.thm-index
                              :names-to-avoid gout-expr.names-to-avoid
                              :vars gout-expr.vars
                              :diffp gout-expr.diffp
                              :falliblep t)))
    :measure (const-expr-count cexpr))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-const-expr-option ((cexpr? const-expr-optionp)
                                      (gin simpadd0-ginp)
                                      state)
    :guard (const-expr-option-unambp cexpr?)
    :returns (mv (new-cexpr? const-expr-optionp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an optional constant expression."
    (b* (((simpadd0-gin gin) gin))
      (const-expr-option-case
       cexpr?
       :some (simpadd0-const-expr cexpr?.val gin state)
       :none (mv nil
                 (make-simpadd0-gout :events nil
                                     :thm-name nil
                                     :thm-index gin.thm-index
                                     :names-to-avoid gin.names-to-avoid
                                     :vars nil
                                     :diffp nil
                                     :falliblep t))))
    :measure (const-expr-option-count cexpr?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-genassoc ((genassoc genassocp) (gin simpadd0-ginp) state)
    :guard (genassoc-unambp genassoc)
    :returns (mv (new-genassoc genassocp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a generic association."
    (b* (((simpadd0-gin gin) gin))
      (genassoc-case
       genassoc
       :type
       (b* (((mv new-type (simpadd0-gout gout-type))
             (simpadd0-tyname genassoc.type gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-type.thm-index
                  :names-to-avoid gout-type.names-to-avoid))
            ((mv new-expr (simpadd0-gout gout-expr))
             (simpadd0-expr genassoc.expr gin state)))
         (mv (make-genassoc-type :type new-type
                                 :expr new-expr)
             (make-simpadd0-gout
              :events (append gout-type.events gout-expr.events)
              :thm-name nil
              :thm-index gout-expr.thm-index
              :names-to-avoid gout-expr.names-to-avoid
              :vars (set::union gout-type.vars gout-expr.vars)
              :diffp (or gout-type.diffp gout-expr.diffp)
              :falliblep t)))
       :default
       (b* (((mv new-expr (simpadd0-gout gout-expr))
             (simpadd0-expr genassoc.expr gin state)))
         (mv (genassoc-default new-expr)
             (make-simpadd0-gout
              :events gout-expr.events
              :thm-name nil
              :thm-index gout-expr.thm-index
              :names-to-avoid gout-expr.names-to-avoid
              :vars gout-expr.vars
              :diffp gout-expr.diffp
              :falliblep t)))))
    :measure (genassoc-count genassoc))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-genassoc-list ((genassocs genassoc-listp)
                                  (gin simpadd0-ginp)
                                  state)
    :guard (genassoc-list-unambp genassocs)
    :returns (mv (new-genassocs genassoc-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of generic associations."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp genassocs))
          (mv nil
              (make-simpadd0-gout :events nil
                                  :thm-name nil
                                  :thm-index gin.thm-index
                                  :names-to-avoid gin.names-to-avoid
                                  :vars nil
                                  :diffp nil
                                  :falliblep t)))
         ((mv new-assoc (simpadd0-gout gout-assoc))
          (simpadd0-genassoc (car genassocs) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-assoc.thm-index
               :names-to-avoid gout-assoc.names-to-avoid))
         ((mv new-assocs (simpadd0-gout gout-assocs))
          (simpadd0-genassoc-list (cdr genassocs) gin state)))
      (mv (cons new-assoc new-assocs)
          (make-simpadd0-gout
           :events (append gout-assoc.events gout-assocs.events)
           :thm-name nil
           :thm-index gout-assocs.thm-index
           :names-to-avoid gout-assocs.names-to-avoid
           :vars (set::union gout-assoc.vars gout-assocs.vars)
           :diffp (or gout-assoc.diffp gout-assocs.diffp)
           :falliblep t)))
    :measure (genassoc-list-count genassocs))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-member-designor ((memdes member-designorp)
                                    (gin simpadd0-ginp)
                                    state)
    :guard (member-designor-unambp memdes)
    :returns (mv (new-memdes member-designorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a member designator."
    (b* (((simpadd0-gin gin) gin))
      (member-designor-case
       memdes
       :ident (mv (member-designor-fix memdes)
                  (make-simpadd0-gout :events nil
                                      :thm-name nil
                                      :thm-index gin.thm-index
                                      :names-to-avoid gin.names-to-avoid
                                      :vars nil
                                      :diffp nil
                                      :falliblep t))
       :dot
       (b* (((mv new-member (simpadd0-gout gout-member))
             (simpadd0-member-designor memdes.member gin state)))
         (mv (make-member-designor-dot :member new-member
                                       :name memdes.name)
             (make-simpadd0-gout
              :events gout-member.events
              :thm-name nil
              :thm-index gout-member.thm-index
              :names-to-avoid gout-member.names-to-avoid
              :vars gout-member.vars
              :diffp gout-member.diffp
              :falliblep t)))
       :sub
       (b* (((mv new-member (simpadd0-gout gout-member))
             (simpadd0-member-designor memdes.member gin state))
            (gin (change-simpadd0-gin
                  gin
                  :thm-index gout-member.thm-index
                  :names-to-avoid gout-member.names-to-avoid))
            ((mv new-index (simpadd0-gout gout-index))
             (simpadd0-expr memdes.index gin state)))
         (mv (make-member-designor-sub :member new-member
                                       :index new-index)
             (make-simpadd0-gout
              :events (append gout-member.events gout-index.events)
              :thm-name nil
              :thm-index gout-index.thm-index
              :names-to-avoid gout-index.names-to-avoid
              :vars (set::union gout-member.vars gout-index.vars)
              :diffp (or gout-member.diffp gout-index.diffp)
              :falliblep t)))))
    :measure (member-designor-count memdes))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-type-spec ((tyspec type-specp) (gin simpadd0-ginp) state)
    :guard (type-spec-unambp tyspec)
    :returns (mv (new-tyspec type-specp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a type specifier."
    (b* (((simpadd0-gin gin) gin)
         (gout0 (make-simpadd0-gout :events nil
                                    :thm-name nil
                                    :thm-index gin.thm-index
                                    :names-to-avoid gin.names-to-avoid
                                    :vars nil
                                    :diffp nil
                                    :falliblep t)))
      (type-spec-case
       tyspec
       :void (mv (type-spec-fix tyspec) gout0)
       :char (mv (type-spec-fix tyspec) gout0)
       :short (mv (type-spec-fix tyspec) gout0)
       :int (mv (type-spec-fix tyspec) gout0)
       :long (mv (type-spec-fix tyspec) gout0)
       :float (mv (type-spec-fix tyspec) gout0)
       :double (mv (type-spec-fix tyspec) gout0)
       :signed (mv (type-spec-fix tyspec) gout0)
       :unsigned (mv (type-spec-fix tyspec) gout0)
       :bool (mv (type-spec-fix tyspec) gout0)
       :complex (mv (type-spec-fix tyspec) gout0)
       :atomic (b* (((mv new-type (simpadd0-gout gout-type))
                     (simpadd0-tyname tyspec.type gin state)))
                 (mv (type-spec-atomic new-type)
                     (make-simpadd0-gout
                      :events gout-type.events
                      :thm-name nil
                      :thm-index gout-type.thm-index
                      :names-to-avoid gout-type.names-to-avoid
                      :vars gout-type.vars
                      :diffp gout-type.diffp
                      :falliblep t)))
       :struct (b* (((mv new-spec (simpadd0-gout gout-spec))
                     (simpadd0-strunispec tyspec.spec gin state)))
                 (mv (type-spec-struct new-spec)
                     (make-simpadd0-gout
                      :events gout-spec.events
                      :thm-name nil
                      :thm-index gout-spec.thm-index
                      :names-to-avoid gout-spec.names-to-avoid
                      :vars gout-spec.vars
                      :diffp gout-spec.diffp
                      :falliblep t)))
       :union (b* (((mv new-spec (simpadd0-gout gout-spec))
                    (simpadd0-strunispec tyspec.spec gin state)))
                (mv (type-spec-union new-spec)
                    (make-simpadd0-gout
                     :events gout-spec.events
                     :thm-name nil
                     :thm-index gout-spec.thm-index
                     :names-to-avoid gout-spec.names-to-avoid
                     :vars gout-spec.vars
                     :diffp gout-spec.diffp
                     :falliblep t)))
       :enum (b* (((mv new-spec (simpadd0-gout gout-spec))
                   (simpadd0-enumspec tyspec.spec gin state)))
               (mv (type-spec-enum new-spec)
                   (make-simpadd0-gout
                    :events gout-spec.events
                    :thm-name nil
                    :thm-index gout-spec.thm-index
                    :names-to-avoid gout-spec.names-to-avoid
                    :vars gout-spec.vars
                    :diffp gout-spec.diffp
                    :falliblep t)))
       :typedef (mv (type-spec-fix tyspec) gout0)
       :int128 (mv (type-spec-fix tyspec) gout0)
       :float32 (mv (type-spec-fix tyspec) gout0)
       :float32x (mv (type-spec-fix tyspec) gout0)
       :float64 (mv (type-spec-fix tyspec) gout0)
       :float64x (mv (type-spec-fix tyspec) gout0)
       :float128 (mv (type-spec-fix tyspec) gout0)
       :float128x (mv (type-spec-fix tyspec) gout0)
       :builtin-va-list (mv (type-spec-fix tyspec) gout0)
       :struct-empty (mv (type-spec-fix tyspec) gout0)
       :typeof-expr (b* (((mv new-expr (simpadd0-gout gout-expr))
                          (simpadd0-expr tyspec.expr gin state)))
                      (mv (make-type-spec-typeof-expr :expr new-expr
                                                      :uscores tyspec.uscores)
                          (make-simpadd0-gout
                           :events gout-expr.events
                           :thm-name nil
                           :thm-index gout-expr.thm-index
                           :names-to-avoid gout-expr.names-to-avoid
                           :vars gout-expr.vars
                           :diffp gout-expr.diffp
                           :falliblep t)))
       :typeof-type (b* (((mv new-type (simpadd0-gout gout-type))
                          (simpadd0-tyname tyspec.type gin state)))
                      (mv (make-type-spec-typeof-type :type new-type
                                                      :uscores tyspec.uscores)
                          (make-simpadd0-gout
                           :events gout-type.events
                           :thm-name nil
                           :thm-index gout-type.thm-index
                           :names-to-avoid gout-type.names-to-avoid
                           :vars gout-type.vars
                           :diffp gout-type.diffp
                           :falliblep t)))
       :typeof-ambig (prog2$ (impossible)
                             (mv (irr-type-spec) (irr-simpadd0-gout)))
       :auto-type (mv (type-spec-fix tyspec) gout0)))
    :measure (type-spec-count tyspec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-spec/qual ((specqual spec/qual-p)
                              (gin simpadd0-ginp)
                              state)
    :guard (spec/qual-unambp specqual)
    :returns (mv (new-specqual spec/qual-p)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a type specifier or qualifier."
    (b* (((simpadd0-gin gin) gin))
      (spec/qual-case
       specqual
       :typespec (b* (((mv new-spec (simpadd0-gout gout-spec))
                       (simpadd0-type-spec specqual.spec gin state)))
                   (mv (spec/qual-typespec new-spec)
                       (make-simpadd0-gout
                        :events gout-spec.events
                        :thm-name nil
                        :thm-index gout-spec.thm-index
                        :names-to-avoid gout-spec.names-to-avoid
                        :vars gout-spec.vars
                        :diffp gout-spec.diffp
                        :falliblep t)))
       :typequal (mv (spec/qual-fix specqual)
                     (make-simpadd0-gout
                      :events nil
                      :thm-name nil
                      :thm-index gin.thm-index
                      :names-to-avoid gin.names-to-avoid
                      :vars nil
                      :diffp nil
                      :falliblep t))
       :align (b* (((mv new-spec (simpadd0-gout gout-spec))
                    (simpadd0-align-spec specqual.spec gin state)))
                (mv (spec/qual-align new-spec)
                    (make-simpadd0-gout
                     :events gout-spec.events
                     :thm-name nil
                     :thm-index gout-spec.thm-index
                     :names-to-avoid gout-spec.names-to-avoid
                     :vars gout-spec.vars
                     :diffp gout-spec.diffp
                     :falliblep t)))
       :attrib (mv (spec/qual-fix specqual)
                   (make-simpadd0-gout
                    :events nil
                    :thm-name nil
                    :thm-index gin.thm-index
                    :names-to-avoid gin.names-to-avoid
                    :vars nil
                    :diffp nil
                    :falliblep t))))
    :measure (spec/qual-count specqual))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-spec/qual-list ((specquals spec/qual-listp)
                                   (gin simpadd0-ginp)
                                   state)
    :guard (spec/qual-list-unambp specquals)
    :returns (mv (new-specquals spec/qual-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of type specifiers and qualifiers."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp specquals))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-specqual (simpadd0-gout gout-specqual))
          (simpadd0-spec/qual (car specquals) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-specqual.thm-index
               :names-to-avoid gout-specqual.names-to-avoid))
         ((mv new-specquals (simpadd0-gout gout-specquals))
          (simpadd0-spec/qual-list (cdr specquals) gin state)))
      (mv (cons new-specqual new-specquals)
          (make-simpadd0-gout
           :events (append gout-specqual.events gout-specquals.events)
           :thm-name nil
           :thm-index gout-specquals.thm-index
           :names-to-avoid gout-specquals.names-to-avoid
           :vars (set::union gout-specqual.vars gout-specquals.vars)
           :diffp (or gout-specqual.diffp gout-specquals.diffp)
           :falliblep t)))
    :measure (spec/qual-list-count specquals))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-align-spec ((alignspec align-specp)
                               (gin simpadd0-ginp)
                               state)
    :guard (align-spec-unambp alignspec)
    :returns (mv (new-alignspec align-specp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an alignment specifier."
    (b* (((simpadd0-gin gin) gin))
      (align-spec-case
       alignspec
       :alignas-type (b* (((mv new-type (simpadd0-gout gout-type))
                           (simpadd0-tyname alignspec.type gin state)))
                       (mv (align-spec-alignas-type new-type)
                           (make-simpadd0-gout
                            :events gout-type.events
                            :thm-name nil
                            :thm-index gout-type.thm-index
                            :names-to-avoid gout-type.names-to-avoid
                            :vars gout-type.vars
                            :diffp gout-type.diffp
                            :falliblep t)))
       :alignas-expr (b* (((mv new-expr (simpadd0-gout gout-expr))
                           (simpadd0-const-expr alignspec.expr gin state)))
                       (mv (align-spec-alignas-expr new-expr)
                           (make-simpadd0-gout
                            :events gout-expr.events
                            :thm-name nil
                            :thm-index gout-expr.thm-index
                            :names-to-avoid gout-expr.names-to-avoid
                            :vars gout-expr.vars
                            :diffp gout-expr.diffp
                            :falliblep t)))
       :alignas-ambig (prog2$ (impossible)
                              (mv (irr-align-spec) (irr-simpadd0-gout)))))
    :measure (align-spec-count alignspec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-decl-spec ((declspec decl-specp) (gin simpadd0-ginp) state)
    :guard (decl-spec-unambp declspec)
    :returns (mv (new-declspec decl-specp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a declaration specifier."
    (b* (((simpadd0-gin gin) gin))
      (decl-spec-case
       declspec
       :stoclass (mv (decl-spec-fix declspec)
                     (make-simpadd0-gout
                      :events nil
                      :thm-name nil
                      :thm-index gin.thm-index
                      :names-to-avoid gin.names-to-avoid
                      :vars nil
                      :diffp nil
                      :falliblep t))
       :typespec (b* (((mv new-spec (simpadd0-gout gout-spec))
                       (simpadd0-type-spec declspec.spec gin state)))
                   (mv (decl-spec-typespec new-spec)
                       (make-simpadd0-gout
                        :events gout-spec.events
                        :thm-name nil
                        :thm-index gout-spec.thm-index
                        :names-to-avoid gout-spec.names-to-avoid
                        :vars gout-spec.vars
                        :diffp gout-spec.diffp
                        :falliblep t)))
       :typequal (mv (decl-spec-fix declspec)
                     (make-simpadd0-gout
                      :events nil
                      :thm-name nil
                      :thm-index gin.thm-index
                      :names-to-avoid gin.names-to-avoid
                      :vars nil
                      :diffp nil
                      :falliblep t))
       :function (mv (decl-spec-fix declspec)
                     (make-simpadd0-gout
                      :events nil
                      :thm-name nil
                      :thm-index gin.thm-index
                      :names-to-avoid gin.names-to-avoid
                      :vars nil
                      :diffp nil
                      :falliblep t))
       :align (b* (((mv new-spec (simpadd0-gout gout-spec))
                    (simpadd0-align-spec declspec.spec gin state)))
                (mv (decl-spec-align new-spec)
                    (make-simpadd0-gout
                     :events gout-spec.events
                     :thm-name nil
                     :thm-index gout-spec.thm-index
                     :names-to-avoid gout-spec.names-to-avoid
                     :vars gout-spec.vars
                     :diffp gout-spec.diffp
                     :falliblep t)))
       :attrib (mv (decl-spec-fix declspec)
                   (make-simpadd0-gout
                    :events nil
                    :thm-name nil
                    :thm-index gin.thm-index
                    :names-to-avoid gin.names-to-avoid
                    :vars nil
                    :diffp nil
                    :falliblep t))
       :stdcall (mv (decl-spec-fix declspec)
                    (make-simpadd0-gout
                     :events nil
                     :thm-name nil
                     :thm-index gin.thm-index
                     :names-to-avoid gin.names-to-avoid
                     :vars nil
                     :diffp nil
                     :falliblep t))
       :declspec (mv (decl-spec-fix declspec)
                     (make-simpadd0-gout
                      :events nil
                      :thm-name nil
                      :thm-index gin.thm-index
                      :names-to-avoid gin.names-to-avoid
                      :vars nil
                      :diffp nil
                      :falliblep t))))
    :measure (decl-spec-count declspec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-decl-spec-list ((declspecs decl-spec-listp)
                                   (gin simpadd0-ginp)
                                   state)
    :guard (decl-spec-list-unambp declspecs)
    :returns (mv (new-declspecs decl-spec-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of declaration specifiers."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp declspecs))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-declspec (simpadd0-gout gout-declspec))
          (simpadd0-decl-spec (car declspecs) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-declspec.thm-index
               :names-to-avoid gout-declspec.names-to-avoid))
         ((mv new-declspecs (simpadd0-gout gout-declspecs))
          (simpadd0-decl-spec-list (cdr declspecs) gin state)))
      (mv (cons new-declspec new-declspecs)
          (make-simpadd0-gout
           :events (append gout-declspec.events gout-declspecs.events)
           :thm-name nil
           :thm-index gout-declspecs.thm-index
           :names-to-avoid gout-declspecs.names-to-avoid
           :vars (set::union gout-declspec.vars gout-declspecs.vars)
           :diffp (or gout-declspec.diffp gout-declspecs.diffp)
           :falliblep t)))
    :measure (decl-spec-list-count declspecs))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-initer ((initer initerp) (gin simpadd0-ginp) state)
    :guard (initer-unambp initer)
    :returns (mv (new-initer initerp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an initializer."
    (b* (((simpadd0-gin gin) gin))
      (initer-case
       initer
       :single (b* (((mv new-expr (simpadd0-gout gout-expr))
                     (simpadd0-expr initer.expr gin state)))
                 (mv (initer-single new-expr)
                     (make-simpadd0-gout
                      :events gout-expr.events
                      :thm-name nil
                      :thm-index gout-expr.thm-index
                      :names-to-avoid gout-expr.names-to-avoid
                      :vars gout-expr.vars
                      :diffp gout-expr.diffp
                      :falliblep t)))
       :list (b* (((mv new-elems (simpadd0-gout gout-elems))
                   (simpadd0-desiniter-list initer.elems gin state)))
               (mv (make-initer-list :elems new-elems
                                     :final-comma initer.final-comma)
                   (make-simpadd0-gout
                    :events gout-elems.events
                    :thm-name nil
                    :thm-index gout-elems.thm-index
                    :names-to-avoid gout-elems.names-to-avoid
                    :vars gout-elems.vars
                    :diffp gout-elems.diffp
                    :falliblep t)))))
    :measure (initer-count initer))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-initer-option ((initer? initer-optionp)
                                  (gin simpadd0-ginp)
                                  state)
    :guard (initer-option-unambp initer?)
    :returns (mv (new-initer? initer-optionp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an optional initializer."
    (b* (((simpadd0-gin gin) gin))
      (initer-option-case
       initer?
       :some (simpadd0-initer initer?.val gin state)
       :none (mv nil
                 (make-simpadd0-gout
                  :events nil
                  :thm-name nil
                  :thm-index gin.thm-index
                  :names-to-avoid gin.names-to-avoid
                  :vars nil
                  :diffp nil
                  :falliblep t))))
    :measure (initer-option-count initer?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-desiniter ((desiniter desiniterp)
                              (gin simpadd0-ginp)
                              state)
    :guard (desiniter-unambp desiniter)
    :returns (mv (new-desiniter desiniterp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an initializer with optional designations."
    (b* (((desiniter desiniter) desiniter)
         ((mv new-designors (simpadd0-gout gout-designors))
          (simpadd0-designor-list desiniter.designors gin state))
         ((mv new-initer (simpadd0-gout gout-initer))
          (simpadd0-initer desiniter.initer gin state)))
      (mv (make-desiniter :designors new-designors
                          :initer new-initer)
          (make-simpadd0-gout
           :events (append gout-designors.events gout-initer.events)
           :thm-name nil
           :thm-index gout-initer.thm-index
           :names-to-avoid gout-initer.names-to-avoid
           :vars (set::union gout-designors.vars gout-initer.vars)
           :diffp (or gout-designors.diffp gout-initer.diffp)
           :falliblep t)))
    :measure (desiniter-count desiniter))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-desiniter-list ((desiniters desiniter-listp)
                                   (gin simpadd0-ginp)
                                   state)
    :guard (desiniter-list-unambp desiniters)
    :returns (mv (new-desiniters desiniter-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of initializers with optional designations."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp desiniters))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-desiniter (simpadd0-gout gout-desiniter))
          (simpadd0-desiniter (car desiniters) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-desiniter.thm-index
               :names-to-avoid gout-desiniter.names-to-avoid))
         ((mv new-desiniters (simpadd0-gout gout-desiniters))
          (simpadd0-desiniter-list (cdr desiniters) gin state)))
      (mv (cons new-desiniter new-desiniters)
          (make-simpadd0-gout
           :events (append gout-desiniter.events gout-desiniters.events)
           :thm-name nil
           :thm-index gout-desiniters.thm-index
           :names-to-avoid gout-desiniters.names-to-avoid
           :vars (set::union gout-desiniter.vars gout-desiniters.vars)
           :diffp (or gout-desiniter.diffp gout-desiniters.diffp)
           :falliblep t)))
    :measure (desiniter-list-count desiniters))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-designor ((designor designorp) (gin simpadd0-ginp) state)
    :guard (designor-unambp designor)
    :returns (mv (new-designor designorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a designator."
    (b* (((simpadd0-gin gin) gin))
      (designor-case
       designor
       :sub (b* (((mv new-index (simpadd0-gout gout-index))
                  (simpadd0-const-expr designor.index gin state)))
              (mv (designor-sub new-index)
                  (make-simpadd0-gout
                   :events gout-index.events
                   :thm-name nil
                   :thm-index gout-index.thm-index
                   :names-to-avoid gout-index.names-to-avoid
                   :vars gout-index.vars
                   :diffp gout-index.diffp
                   :falliblep t)))
       :dot (mv (designor-fix designor)
                (make-simpadd0-gout
                 :events nil
                 :thm-name nil
                 :thm-index gin.thm-index
                 :names-to-avoid gin.names-to-avoid
                 :vars nil
                 :diffp nil
                 :falliblep t))))
    :measure (designor-count designor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-designor-list ((designors designor-listp)
                                  (gin simpadd0-ginp)
                                  state)
    :guard (designor-list-unambp designors)
    :returns (mv (new-designors designor-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of designators."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp designors))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-designor (simpadd0-gout gout-designor))
          (simpadd0-designor (car designors) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-designor.thm-index
               :names-to-avoid gout-designor.names-to-avoid))
         ((mv new-designors (simpadd0-gout gout-designors))
          (simpadd0-designor-list (cdr designors) gin state)))
      (mv (cons new-designor new-designors)
          (make-simpadd0-gout
           :events (append gout-designor.events gout-designors.events)
           :thm-name nil
           :thm-index gout-designors.thm-index
           :names-to-avoid gout-designors.names-to-avoid
           :vars (set::union gout-designor.vars gout-designors.vars)
           :diffp (or gout-designor.diffp gout-designors.diffp)
           :falliblep t)))
    :measure (designor-list-count designors))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-declor ((declor declorp) (gin simpadd0-ginp) state)
    :guard (declor-unambp declor)
    :returns (mv (new-declor declorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a declarator."
    (b* (((simpadd0-gin gin) gin)
         ((declor declor) declor)
         ((mv new-direct (simpadd0-gout gout-direct))
          (simpadd0-dirdeclor declor.direct gin state)))
      (mv (make-declor :pointers declor.pointers
                       :direct new-direct)
          (make-simpadd0-gout
           :events gout-direct.events
           :thm-name nil
           :thm-index gout-direct.thm-index
           :names-to-avoid gout-direct.names-to-avoid
           :vars gout-direct.vars
           :diffp gout-direct.diffp
           :falliblep t)))
    :measure (declor-count declor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-declor-option ((declor? declor-optionp)
                                  (gin simpadd0-ginp)
                                  state)
    :guard (declor-option-unambp declor?)
    :returns (mv (new-declor? declor-optionp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an optional declarator."
    (b* (((simpadd0-gin gin) gin))
      (declor-option-case
       declor?
       :some (simpadd0-declor declor?.val gin state)
       :none (mv nil
                 (make-simpadd0-gout
                  :events nil
                  :thm-name nil
                  :thm-index gin.thm-index
                  :names-to-avoid gin.names-to-avoid
                  :vars nil
                  :diffp nil
                  :falliblep t))))
    :measure (declor-option-count declor?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-dirdeclor ((dirdeclor dirdeclorp) (gin simpadd0-ginp) state)
    :guard (dirdeclor-unambp dirdeclor)
    :returns (mv (new-dirdeclor dirdeclorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a direct declarator."
    (b* (((simpadd0-gin gin) gin))
      (dirdeclor-case
       dirdeclor
       :ident (mv (dirdeclor-fix dirdeclor)
                  (make-simpadd0-gout
                   :events nil
                   :thm-name nil
                   :thm-index gin.thm-index
                   :names-to-avoid gin.names-to-avoid
                   :vars nil
                   :diffp nil
                   :falliblep t))
       :paren (b* (((mv new-declor (simpadd0-gout gout-declor))
                    (simpadd0-declor dirdeclor.unwrap gin state)))
                (mv (dirdeclor-paren new-declor)
                    (make-simpadd0-gout
                     :events gout-declor.events
                     :thm-name nil
                     :thm-index gout-declor.thm-index
                     :names-to-avoid gout-declor.names-to-avoid
                     :vars gout-declor.vars
                     :diffp gout-declor.diffp
                     :falliblep t)))
       :array (b* (((mv new-decl (simpadd0-gout gout-decl))
                    (simpadd0-dirdeclor dirdeclor.decl gin state))
                   (gin (change-simpadd0-gin
                         gin
                         :thm-index gout-decl.thm-index
                         :names-to-avoid gout-decl.names-to-avoid))
                   ((mv new-expr? (simpadd0-gout gout-expr?))
                    (simpadd0-expr-option dirdeclor.expr? gin state)))
                (mv (make-dirdeclor-array :decl new-decl
                                          :tyquals dirdeclor.tyquals
                                          :expr? new-expr?)
                    (make-simpadd0-gout
                     :events (append gout-decl.events gout-expr?.events)
                     :thm-name nil
                     :thm-index gout-expr?.thm-index
                     :names-to-avoid gout-expr?.names-to-avoid
                     :vars (set::union gout-decl.vars gout-expr?.vars)
                     :diffp (or gout-decl.diffp gout-expr?.diffp)
                     :falliblep t)))
       :array-static1 (b* (((mv new-decl (simpadd0-gout gout-decl))
                            (simpadd0-dirdeclor dirdeclor.decl gin state))
                           (gin (change-simpadd0-gin
                                 gin
                                 :thm-index gout-decl.thm-index
                                 :names-to-avoid gout-decl.names-to-avoid))
                           ((mv new-expr (simpadd0-gout gout-expr))
                            (simpadd0-expr dirdeclor.expr gin state)))
                        (mv (make-dirdeclor-array-static1
                             :decl new-decl
                             :tyquals dirdeclor.tyquals
                             :expr new-expr)
                            (make-simpadd0-gout
                             :events (append gout-decl.events gout-expr.events)
                             :thm-name nil
                             :thm-index gout-expr.thm-index
                             :names-to-avoid gout-expr.names-to-avoid
                             :vars (set::union gout-decl.vars gout-expr.vars)
                             :diffp (or gout-decl.diffp gout-expr.diffp)
                             :falliblep t)))
       :array-static2 (b* (((mv new-decl (simpadd0-gout gout-decl))
                            (simpadd0-dirdeclor dirdeclor.decl gin state))
                           (gin (change-simpadd0-gin
                                 gin
                                 :thm-index gout-decl.thm-index
                                 :names-to-avoid gout-decl.names-to-avoid))
                           ((mv new-expr (simpadd0-gout gout-expr))
                            (simpadd0-expr dirdeclor.expr gin state)))
                        (mv (make-dirdeclor-array-static2
                             :decl new-decl
                             :tyquals dirdeclor.tyquals
                             :expr new-expr)
                            (make-simpadd0-gout
                             :events (append gout-decl.events gout-expr.events)
                             :thm-name nil
                             :thm-index gout-expr.thm-index
                             :names-to-avoid gout-expr.names-to-avoid
                             :vars (set::union gout-decl.vars gout-expr.vars)
                             :diffp (or gout-decl.diffp gout-expr.diffp)
                             :falliblep t)))
       :array-star (b* (((mv new-decl (simpadd0-gout gout-decl))
                         (simpadd0-dirdeclor dirdeclor.decl gin state)))
                     (mv (make-dirdeclor-array-star :decl new-decl
                                                    :tyquals dirdeclor.tyquals)
                         (make-simpadd0-gout
                          :events gout-decl.events
                          :thm-name nil
                          :thm-index gout-decl.thm-index
                          :names-to-avoid gout-decl.names-to-avoid
                          :vars gout-decl.vars
                          :diffp gout-decl.diffp
                          :falliblep t)))
       :function-params (b* (((mv new-decl (simpadd0-gout gout-decl))
                              (simpadd0-dirdeclor dirdeclor.decl gin state))
                             (gin (change-simpadd0-gin
                                   gin
                                   :thm-index gout-decl.thm-index
                                   :names-to-avoid gout-decl.names-to-avoid))
                             ((mv new-params (simpadd0-gout gout-params))
                              (simpadd0-paramdecl-list dirdeclor.params
                                                       gin
                                                       state)))
                          (mv (make-dirdeclor-function-params
                               :decl new-decl
                               :params new-params
                               :ellipsis dirdeclor.ellipsis)
                              (make-simpadd0-gout
                               :events (append gout-decl.events
                                               gout-params.events)
                               :thm-name nil
                               :thm-index gout-params.thm-index
                               :names-to-avoid gout-params.names-to-avoid
                               :vars (set::union gout-decl.vars
                                                 gout-params.vars)
                               :diffp (or gout-decl.diffp gout-params.diffp)
                               :falliblep t)))
       :function-names (b* (((mv new-decl (simpadd0-gout gout-decl))
                             (simpadd0-dirdeclor dirdeclor.decl gin state)))
                         (mv (make-dirdeclor-function-names
                              :decl new-decl
                              :names dirdeclor.names)
                             (make-simpadd0-gout
                              :events gout-decl.events
                              :thm-name nil
                              :thm-index gout-decl.thm-index
                              :names-to-avoid gout-decl.names-to-avoid
                              :vars gout-decl.vars
                              :diffp gout-decl.diffp
                              :falliblep t)))))
    :measure (dirdeclor-count dirdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-absdeclor ((absdeclor absdeclorp) (gin simpadd0-ginp) state)
    :guard (absdeclor-unambp absdeclor)
    :returns (mv (new-absdeclor absdeclorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an abstract declarator."
    (b* (((simpadd0-gin gin) gin)
         ((absdeclor absdeclor) absdeclor)
         ((mv new-decl? (simpadd0-gout gout-decl?))
          (simpadd0-dirabsdeclor-option absdeclor.decl? gin state)))
      (mv (make-absdeclor :pointers absdeclor.pointers
                          :decl? new-decl?)
          (make-simpadd0-gout
           :events gout-decl?.events
           :thm-name nil
           :thm-index gout-decl?.thm-index
           :names-to-avoid gout-decl?.names-to-avoid
           :vars gout-decl?.vars
           :diffp gout-decl?.diffp
           :falliblep t)))
    :measure (absdeclor-count absdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-absdeclor-option ((absdeclor? absdeclor-optionp)
                                     (gin simpadd0-ginp)
                                     state)
    :guard (absdeclor-option-unambp absdeclor?)
    :returns (mv (new-absdeclor? absdeclor-optionp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an optional abstract declarator."
    (b* (((simpadd0-gin gin) gin))
      (absdeclor-option-case
       absdeclor?
       :some (simpadd0-absdeclor absdeclor?.val gin state)
       :none (mv nil
                 (make-simpadd0-gout
                  :events nil
                  :thm-name nil
                  :thm-index gin.thm-index
                  :names-to-avoid gin.names-to-avoid
                  :vars nil
                  :diffp nil
                  :falliblep t))))
    :measure (absdeclor-option-count absdeclor?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-dirabsdeclor ((dirabsdeclor dirabsdeclorp)
                                 (gin simpadd0-ginp)
                                 state)
    :guard (dirabsdeclor-unambp dirabsdeclor)
    :returns (mv (new-dirabsdeclor dirabsdeclorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a direct abstract declarator."
    (b* (((simpadd0-gin gin) gin))
      (dirabsdeclor-case
       dirabsdeclor
       :dummy-base (prog2$
                    (raise "Misusage error: ~x0."
                           (dirabsdeclor-fix dirabsdeclor))
                    (mv (irr-dirabsdeclor) (irr-simpadd0-gout)))
       :paren (b* (((mv new-inner (simpadd0-gout gout-inner))
                    (simpadd0-absdeclor dirabsdeclor.unwrap gin state)))
                (mv (dirabsdeclor-paren new-inner)
                    (make-simpadd0-gout
                     :events gout-inner.events
                     :thm-name nil
                     :thm-index gout-inner.thm-index
                     :names-to-avoid gout-inner.names-to-avoid
                     :vars gout-inner.vars
                     :diffp gout-inner.diffp
                     :falliblep t)))
       :array (b* (((mv new-decl? (simpadd0-gout gout-decl?))
                    (simpadd0-dirabsdeclor-option dirabsdeclor.decl? gin state))
                   (gin (change-simpadd0-gin
                         gin
                         :thm-index gout-decl?.thm-index
                         :names-to-avoid gout-decl?.names-to-avoid))
                   ((mv new-expr? (simpadd0-gout gout-expr?))
                    (simpadd0-expr-option dirabsdeclor.expr? gin state)))
                (mv (make-dirabsdeclor-array :decl? new-decl?
                                             :tyquals dirabsdeclor.tyquals
                                             :expr? new-expr?)
                    (make-simpadd0-gout
                     :events (append gout-decl?.events gout-expr?.events)
                     :thm-name nil
                     :thm-index gout-expr?.thm-index
                     :names-to-avoid gout-expr?.names-to-avoid
                     :vars (set::union gout-decl?.vars gout-expr?.vars)
                     :diffp (or gout-decl?.diffp gout-expr?.diffp)
                     :falliblep t)))
       :array-static1 (b* (((mv new-decl? (simpadd0-gout gout-decl?))
                            (simpadd0-dirabsdeclor-option dirabsdeclor.decl?
                                                          gin
                                                          state))
                           (gin (change-simpadd0-gin
                                 gin
                                 :thm-index gout-decl?.thm-index
                                 :names-to-avoid gout-decl?.names-to-avoid))
                           ((mv new-expr (simpadd0-gout gout-expr))
                            (simpadd0-expr dirabsdeclor.expr gin state)))
                        (mv (make-dirabsdeclor-array-static1
                             :decl? new-decl?
                             :tyquals dirabsdeclor.tyquals
                             :expr new-expr)
                            (make-simpadd0-gout
                             :events (append gout-decl?.events
                                             gout-expr.events)
                             :thm-name nil
                             :thm-index gout-expr.thm-index
                             :names-to-avoid gout-expr.names-to-avoid
                             :vars (set::union gout-decl?.vars
                                               gout-expr.vars)
                             :diffp (or gout-decl?.diffp gout-expr.diffp)
                             :falliblep t)))
       :array-static2 (b* (((mv new-decl? (simpadd0-gout gout-decl?))
                            (simpadd0-dirabsdeclor-option dirabsdeclor.decl?
                                                          gin state))
                           (gin (change-simpadd0-gin
                                 gin
                                 :thm-index gout-decl?.thm-index
                                 :names-to-avoid gout-decl?.names-to-avoid))
                           ((mv new-expr (simpadd0-gout gout-expr))
                            (simpadd0-expr dirabsdeclor.expr gin state)))
                        (mv (make-dirabsdeclor-array-static2
                             :decl? new-decl?
                             :tyquals dirabsdeclor.tyquals
                             :expr new-expr)
                            (make-simpadd0-gout
                             :events (append gout-decl?.events
                                             gout-expr.events)
                             :thm-name nil
                             :thm-index gout-expr.thm-index
                             :names-to-avoid gout-expr.names-to-avoid
                             :vars (set::union gout-decl?.vars
                                               gout-expr.vars)
                             :diffp (or gout-decl?.diffp gout-expr.diffp)
                             :falliblep t)))
       :array-star (b* (((mv new-decl? (simpadd0-gout gout-decl?))
                         (simpadd0-dirabsdeclor-option dirabsdeclor.decl?
                                                       gin
                                                       state)))
                     (mv (dirabsdeclor-array-star new-decl?)
                         (make-simpadd0-gout
                          :events gout-decl?.events
                          :thm-name nil
                          :thm-index gout-decl?.thm-index
                          :names-to-avoid gout-decl?.names-to-avoid
                          :vars gout-decl?.vars
                          :diffp gout-decl?.diffp
                          :falliblep t)))
       :function (b* (((mv new-decl? (simpadd0-gout gout-decl?))
                       (simpadd0-dirabsdeclor-option dirabsdeclor.decl?
                                                     gin
                                                     state))
                      (gin (change-simpadd0-gin
                            gin
                            :thm-index gout-decl?.thm-index
                            :names-to-avoid gout-decl?.names-to-avoid))
                      ((mv new-params (simpadd0-gout gout-params))
                       (simpadd0-paramdecl-list dirabsdeclor.params gin state)))
                   (mv (make-dirabsdeclor-function
                        :decl? new-decl?
                        :params new-params
                        :ellipsis dirabsdeclor.ellipsis)
                       (make-simpadd0-gout
                        :events (append gout-decl?.events gout-params.events)
                        :thm-name nil
                        :thm-index gout-params.thm-index
                        :names-to-avoid gout-params.names-to-avoid
                        :vars (set::union gout-decl?.vars
                                          gout-params.vars)
                        :diffp (or gout-decl?.diffp gout-params.diffp)
                        :falliblep t)))))
    :measure (dirabsdeclor-count dirabsdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-dirabsdeclor-option ((dirabsdeclor? dirabsdeclor-optionp)
                                        (gin simpadd0-ginp)
                                        state)
    :guard (dirabsdeclor-option-unambp dirabsdeclor?)
    :returns (mv (new-dirabsdeclor? dirabsdeclor-optionp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an optional direct abstract declarator."
    (b* (((simpadd0-gin gin) gin))
      (dirabsdeclor-option-case
       dirabsdeclor?
       :some (simpadd0-dirabsdeclor dirabsdeclor?.val gin state)
       :none (mv nil
                 (make-simpadd0-gout
                  :events nil
                  :thm-name nil
                  :thm-index gin.thm-index
                  :names-to-avoid gin.names-to-avoid
                  :vars nil
                  :diffp nil
                  :falliblep t))))
    :measure (dirabsdeclor-option-count dirabsdeclor?))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-paramdecl ((paramdecl paramdeclp) (gin simpadd0-ginp) state)
    :guard (paramdecl-unambp paramdecl)
    :returns (mv (new-paramdecl paramdeclp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a parameter declaration."
    (b* (((simpadd0-gin gin) gin)
         ((paramdecl paramdecl) paramdecl)
         ((mv new-spec (simpadd0-gout gout-spec))
          (simpadd0-decl-spec-list paramdecl.spec gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-spec.thm-index
               :names-to-avoid gout-spec.names-to-avoid))
         ((mv new-decl (simpadd0-gout gout-decl))
          (simpadd0-paramdeclor paramdecl.decl gin state)))
      (mv (make-paramdecl :spec new-spec
                          :decl new-decl)
          (make-simpadd0-gout
           :events (append gout-spec.events gout-decl.events)
           :thm-name nil
           :thm-index gout-decl.thm-index
           :names-to-avoid gout-decl.names-to-avoid
           :vars (set::union gout-spec.vars gout-decl.vars)
           :diffp (or gout-spec.diffp gout-decl.diffp)
           :falliblep t)))
    :measure (paramdecl-count paramdecl))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-paramdecl-list ((paramdecls paramdecl-listp)
                                   (gin simpadd0-ginp)
                                   state)
    :guard (paramdecl-list-unambp paramdecls)
    :returns (mv (new-paramdecls paramdecl-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of parameter declarations."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp paramdecls))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-paramdecl (simpadd0-gout gout-paramdecl))
          (simpadd0-paramdecl (car paramdecls) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-paramdecl.thm-index
               :names-to-avoid gout-paramdecl.names-to-avoid))
         ((mv new-paramdecls (simpadd0-gout gout-paramdecls))
          (simpadd0-paramdecl-list (cdr paramdecls) gin state)))
      (mv (cons new-paramdecl new-paramdecls)
          (make-simpadd0-gout
           :events (append gout-paramdecl.events gout-paramdecls.events)
           :thm-name nil
           :thm-index gout-paramdecls.thm-index
           :names-to-avoid gout-paramdecls.names-to-avoid
           :vars (set::union gout-paramdecl.vars gout-paramdecls.vars)
           :diffp (or gout-paramdecl.diffp gout-paramdecls.diffp)
           :falliblep t)))
    :measure (paramdecl-list-count paramdecls))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-paramdeclor ((paramdeclor paramdeclorp)
                                (gin simpadd0-ginp)
                                state)
    :guard (paramdeclor-unambp paramdeclor)
    :returns (mv (new-paramdeclor paramdeclorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a parameter declarator."
    (b* (((simpadd0-gin gin) gin))
      (paramdeclor-case
       paramdeclor
       :declor (b* (((mv new-declor (simpadd0-gout gout-declor))
                     (simpadd0-declor paramdeclor.unwrap gin state)))
                 (mv (paramdeclor-declor new-declor)
                     (make-simpadd0-gout
                      :events gout-declor.events
                      :thm-name nil
                      :thm-index gout-declor.thm-index
                      :names-to-avoid gout-declor.names-to-avoid
                      :vars gout-declor.vars
                      :diffp gout-declor.diffp
                      :falliblep t)))
       :absdeclor (b* (((mv new-absdeclor (simpadd0-gout gout-absdeclor))
                        (simpadd0-absdeclor paramdeclor.unwrap gin state)))
                    (mv (paramdeclor-absdeclor new-absdeclor)
                        (make-simpadd0-gout
                         :events gout-absdeclor.events
                         :thm-name nil
                         :thm-index gout-absdeclor.thm-index
                         :names-to-avoid gout-absdeclor.names-to-avoid
                         :vars gout-absdeclor.vars
                         :diffp gout-absdeclor.diffp
                         :falliblep t)))
       :none (mv (paramdeclor-none)
                 (make-simpadd0-gout
                  :events nil
                  :thm-name nil
                  :thm-index gin.thm-index
                  :names-to-avoid gin.names-to-avoid
                  :vars nil
                  :diffp nil
                  :falliblep t))
       :ambig (prog2$ (impossible) (mv (irr-paramdeclor) (irr-simpadd0-gout)))))
    :measure (paramdeclor-count paramdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-tyname ((tyname tynamep) (gin simpadd0-ginp) state)
    :guard (tyname-unambp tyname)
    :returns (mv (new-tyname tynamep)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a type name."
    (b* (((simpadd0-gin gin) gin)
         ((tyname tyname) tyname)
         ((mv new-specqual (simpadd0-gout gout-specqual))
          (simpadd0-spec/qual-list tyname.specqual gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-specqual.thm-index
               :names-to-avoid gout-specqual.names-to-avoid))
         ((mv new-decl? (simpadd0-gout gout-decl?))
          (simpadd0-absdeclor-option tyname.decl? gin state)))
      (mv (make-tyname :specqual new-specqual
                       :decl? new-decl?)
          (make-simpadd0-gout
           :events (append gout-specqual.events gout-decl?.events)
           :thm-name nil
           :thm-index gout-decl?.thm-index
           :names-to-avoid gout-decl?.names-to-avoid
           :vars (set::union gout-specqual.vars gout-decl?.vars)
           :diffp (or gout-specqual.diffp gout-decl?.diffp)
           :falliblep t)))
    :measure (tyname-count tyname))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-strunispec ((strunispec strunispecp)
                               (gin simpadd0-ginp)
                               state)
    :guard (strunispec-unambp strunispec)
    :returns (mv (new-strunispec strunispecp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a structure or union specifier."
    (b* (((simpadd0-gin gin) gin)
         ((strunispec strunispec) strunispec)
         ((mv new-members (simpadd0-gout gout-members))
          (simpadd0-structdecl-list strunispec.members gin state)))
      (mv (make-strunispec :name strunispec.name
                           :members new-members)
          (make-simpadd0-gout
           :events gout-members.events
           :thm-name nil
           :thm-index gout-members.thm-index
           :names-to-avoid gout-members.names-to-avoid
           :vars gout-members.vars
           :diffp gout-members.diffp
           :falliblep t)))
    :measure (strunispec-count strunispec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-structdecl ((structdecl structdeclp)
                               (gin simpadd0-ginp)
                               state)
    :guard (structdecl-unambp structdecl)
    :returns (mv (new-structdecl structdeclp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a structure declaration."
    (b* (((simpadd0-gin gin) gin))
      (structdecl-case
       structdecl
       :member (b* (((mv new-specqual (simpadd0-gout gout-specqual))
                     (simpadd0-spec/qual-list structdecl.specqual gin state))
                    (gin (change-simpadd0-gin
                          gin
                          :thm-index gout-specqual.thm-index
                          :names-to-avoid gout-specqual.names-to-avoid))
                    ((mv new-declor (simpadd0-gout gout-declor))
                     (simpadd0-structdeclor-list structdecl.declor gin state)))
                 (mv (make-structdecl-member
                      :extension structdecl.extension
                      :specqual new-specqual
                      :declor new-declor
                      :attrib structdecl.attrib)
                     (make-simpadd0-gout
                      :events (append gout-specqual.events
                                      gout-declor.events)
                      :thm-name nil
                      :thm-index gout-declor.thm-index
                      :names-to-avoid gout-declor.names-to-avoid
                      :vars (set::union gout-specqual.vars gout-declor.vars)
                      :diffp (or gout-specqual.diffp gout-declor.diffp)
                      :falliblep t)))
       :statassert (b* (((mv new-structdecl (simpadd0-gout gout-structdecl))
                         (simpadd0-statassert structdecl.unwrap gin state)))
                     (mv (structdecl-statassert new-structdecl)
                         (make-simpadd0-gout
                          :events gout-structdecl.events
                          :thm-name nil
                          :thm-index gout-structdecl.thm-index
                          :names-to-avoid gout-structdecl.names-to-avoid
                          :vars gout-structdecl.vars
                          :diffp gout-structdecl.diffp
                          :falliblep t)))
       :empty (mv (structdecl-empty)
                  (make-simpadd0-gout
                   :events nil
                   :thm-name nil
                   :thm-index gin.thm-index
                   :names-to-avoid gin.names-to-avoid
                   :vars nil
                   :diffp nil
                   :falliblep t))))
    :measure (structdecl-count structdecl))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-structdecl-list ((structdecls structdecl-listp)
                                    (gin simpadd0-ginp)
                                    state)
    :guard (structdecl-list-unambp structdecls)
    :returns (mv (new-structdecls structdecl-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of structure declarations."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp structdecls))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-structdecl (simpadd0-gout gout-structdecl))
          (simpadd0-structdecl (car structdecls) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-structdecl.thm-index
               :names-to-avoid gout-structdecl.names-to-avoid))
         ((mv new-structdecls (simpadd0-gout gout-structdecls))
          (simpadd0-structdecl-list (cdr structdecls) gin state)))
      (mv (cons new-structdecl new-structdecls)
          (make-simpadd0-gout
           :events (append gout-structdecl.events gout-structdecls.events)
           :thm-name nil
           :thm-index gout-structdecls.thm-index
           :names-to-avoid gout-structdecls.names-to-avoid
           :vars (set::union gout-structdecl.vars gout-structdecls.vars)
           :diffp (or gout-structdecl.diffp gout-structdecls.diffp)
           :falliblep t)))
    :measure (structdecl-list-count structdecls))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-structdeclor ((structdeclor structdeclorp)
                                 (gin simpadd0-ginp)
                                 state)
    :guard (structdeclor-unambp structdeclor)
    :returns (mv (new-structdeclor structdeclorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a structure declarator."
    (b* (((simpadd0-gin gin) gin)
         ((structdeclor structdeclor) structdeclor)
         ((mv new-declor? (simpadd0-gout gout-declor?))
          (simpadd0-declor-option structdeclor.declor? gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-declor?.thm-index
               :names-to-avoid gout-declor?.names-to-avoid))
         ((mv new-expr? (simpadd0-gout gout-expr?))
          (simpadd0-const-expr-option structdeclor.expr? gin state)))
      (mv (make-structdeclor :declor? new-declor?
                             :expr? new-expr?)
          (make-simpadd0-gout
           :events (append gout-declor?.events gout-expr?.events)
           :thm-name nil
           :thm-index gout-expr?.thm-index
           :names-to-avoid gout-expr?.names-to-avoid
           :vars (set::union gout-declor?.vars gout-expr?.vars)
           :diffp (or gout-declor?.diffp gout-expr?.diffp)
           :falliblep t)))
    :measure (structdeclor-count structdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-structdeclor-list ((structdeclors structdeclor-listp)
                                      (gin simpadd0-ginp)
                                      state)
    :guard (structdeclor-list-unambp structdeclors)
    :returns (mv (new-structdeclors structdeclor-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of structure declarators."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp structdeclors))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-structdeclor (simpadd0-gout gout-structdeclor))
          (simpadd0-structdeclor (car structdeclors) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-structdeclor.thm-index
               :names-to-avoid gout-structdeclor.names-to-avoid))
         ((mv new-structdeclors (simpadd0-gout gout-structdeclors))
          (simpadd0-structdeclor-list (cdr structdeclors) gin state)))
      (mv (cons new-structdeclor new-structdeclors)
          (make-simpadd0-gout
           :events (append gout-structdeclor.events
                           gout-structdeclors.events)
           :thm-name nil
           :thm-index gout-structdeclors.thm-index
           :names-to-avoid gout-structdeclors.names-to-avoid
           :vars (set::union gout-structdeclor.vars gout-structdeclors.vars)
           :diffp (or gout-structdeclor.diffp gout-structdeclors.diffp)
           :falliblep t)))
    :measure (structdeclor-list-count structdeclors))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-enumspec ((enumspec enumspecp) (gin simpadd0-ginp) state)
    :guard (enumspec-unambp enumspec)
    :returns (mv (new-enumspec enumspecp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an enumeration specifier."
    (b* (((simpadd0-gin gin) gin)
         ((enumspec enumspec) enumspec)
         ((mv new-list (simpadd0-gout gout-list))
          (simpadd0-enumer-list enumspec.list gin state)))
      (mv (make-enumspec :name enumspec.name
                         :list new-list
                         :final-comma enumspec.final-comma)
          (make-simpadd0-gout
           :events gout-list.events
           :thm-name nil
           :thm-index gout-list.thm-index
           :names-to-avoid gout-list.names-to-avoid
           :vars gout-list.vars
           :diffp gout-list.diffp
           :falliblep t)))
    :measure (enumspec-count enumspec))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-enumer ((enumer enumerp) (gin simpadd0-ginp) state)
    :guard (enumer-unambp enumer)
    :returns (mv (new-enumer enumerp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an enumerator."
    (b* (((simpadd0-gin gin) gin)
         ((enumer enumer) enumer)
         ((mv new-value (simpadd0-gout gout-value))
          (simpadd0-const-expr-option enumer.value gin state)))
      (mv (make-enumer :name enumer.name
                       :value new-value)
          (make-simpadd0-gout
           :events gout-value.events
           :thm-name nil
           :thm-index gout-value.thm-index
           :names-to-avoid gout-value.names-to-avoid
           :vars gout-value.vars
           :diffp gout-value.diffp
           :falliblep t)))
    :measure (enumer-count enumer))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-enumer-list ((enumers enumer-listp)
                                (gin simpadd0-ginp)
                                state)
    :guard (enumer-list-unambp enumers)
    :returns (mv (new-enumers enumer-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of enumerators."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp enumers))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-enumer (simpadd0-gout gout-enumer))
          (simpadd0-enumer (car enumers) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-enumer.thm-index
               :names-to-avoid gout-enumer.names-to-avoid))
         ((mv new-enumers (simpadd0-gout gout-enumers))
          (simpadd0-enumer-list (cdr enumers) gin state)))
      (mv (cons new-enumer new-enumers)
          (make-simpadd0-gout
           :events (append gout-enumer.events gout-enumers.events)
           :thm-name nil
           :thm-index gout-enumers.thm-index
           :names-to-avoid gout-enumers.names-to-avoid
           :vars (set::union gout-enumer.vars gout-enumers.vars)
           :diffp (or gout-enumer.diffp gout-enumers.diffp)
           :falliblep t)))
    :measure (enumer-list-count enumers))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-statassert ((statassert statassertp)
                               (gin simpadd0-ginp)
                               state)
    :guard (statassert-unambp statassert)
    :returns (mv (new-statassert statassertp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an static assertion declaration."
    (b* (((simpadd0-gin gin) gin)
         ((statassert statassert) statassert)
         ((mv new-test (simpadd0-gout gout-test))
          (simpadd0-const-expr statassert.test gin state)))
      (mv (make-statassert :test new-test
                           :message statassert.message)
          (make-simpadd0-gout
           :events gout-test.events
           :thm-name nil
           :thm-index gout-test.thm-index
           :names-to-avoid gout-test.names-to-avoid
           :vars gout-test.vars
           :diffp gout-test.diffp
           :falliblep t)))
    :measure (statassert-count statassert))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-initdeclor ((initdeclor initdeclorp)
                               (gin simpadd0-ginp)
                               state)
    :guard (initdeclor-unambp initdeclor)
    :returns (mv (new-initdeclor initdeclorp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform an initializer declarator."
    (b* (((simpadd0-gin gin) gin)
         ((initdeclor initdeclor) initdeclor)
         ((mv new-declor (simpadd0-gout gout-declor))
          (simpadd0-declor initdeclor.declor gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-declor.thm-index
               :names-to-avoid gout-declor.names-to-avoid))
         ((mv new-init? (simpadd0-gout gout-init?))
          (simpadd0-initer-option initdeclor.init? gin state)))
      (mv (make-initdeclor :declor new-declor
                           :asm? initdeclor.asm?
                           :attribs initdeclor.attribs
                           :init? new-init?)
          (make-simpadd0-gout
           :events (append gout-declor.events gout-init?.events)
           :thm-name nil
           :thm-index gout-init?.thm-index
           :names-to-avoid gout-init?.names-to-avoid
           :vars (set::union gout-declor.vars gout-init?.vars)
           :diffp (or gout-declor.diffp gout-init?.diffp)
           :falliblep t)))
    :measure (initdeclor-count initdeclor))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-initdeclor-list ((initdeclors initdeclor-listp)
                                    (gin simpadd0-ginp)
                                    state)
    :guard (initdeclor-list-unambp initdeclors)
    :returns (mv (new-initdeclors initdeclor-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of initializer declarators."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp initdeclors))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-initdeclor (simpadd0-gout gout-initdeclor))
          (simpadd0-initdeclor (car initdeclors) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-initdeclor.thm-index
               :names-to-avoid gout-initdeclor.names-to-avoid))
         ((mv new-initdeclors (simpadd0-gout gout-initdeclors))
          (simpadd0-initdeclor-list (cdr initdeclors) gin state)))
      (mv (cons new-initdeclor new-initdeclors)
          (make-simpadd0-gout
           :events (append gout-initdeclor.events
                           gout-initdeclors.events)
           :thm-name nil
           :thm-index gout-initdeclors.thm-index
           :names-to-avoid gout-initdeclors.names-to-avoid
           :vars (set::union gout-initdeclor.vars gout-initdeclors.vars)
           :diffp (or gout-initdeclor.diffp gout-initdeclors.diffp)
           :falliblep t)))
    :measure (initdeclor-list-count initdeclors))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-decl ((decl declp) (gin simpadd0-ginp) state)
    :guard (decl-unambp decl)
    :returns (mv (new-decl declp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a declaration."
    (b* (((simpadd0-gin gin) gin))
      (decl-case
       decl
       :decl (b* (((mv new-specs (simpadd0-gout gout-specs))
                   (simpadd0-decl-spec-list decl.specs gin state))
                  (gin (change-simpadd0-gin
                        gin
                        :thm-index gout-specs.thm-index
                        :names-to-avoid gout-specs.names-to-avoid))
                  ((mv new-init (simpadd0-gout gout-init))
                   (simpadd0-initdeclor-list decl.init gin state)))
               (mv (make-decl-decl :extension decl.extension
                                   :specs new-specs
                                   :init new-init)
                   (make-simpadd0-gout
                    :events (append gout-specs.events
                                    gout-init.events)
                    :thm-name nil
                    :thm-index gout-init.thm-index
                    :names-to-avoid gout-init.names-to-avoid
                    :vars (set::union gout-specs.vars gout-init.vars)
                    :diffp (or gout-specs.diffp gout-init.diffp)
                    :falliblep t)))
       :statassert (b* (((mv new-decl (simpadd0-gout gout-decl))
                         (simpadd0-statassert decl.unwrap gin state)))
                     (mv (decl-statassert new-decl)
                         (make-simpadd0-gout
                          :events gout-decl.events
                          :thm-name nil
                          :thm-index gout-decl.thm-index
                          :names-to-avoid gout-decl.names-to-avoid
                          :vars gout-decl.vars
                          :diffp gout-decl.diffp
                          :falliblep t)))))
    :measure (decl-count decl))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-decl-list ((decls decl-listp) (gin simpadd0-ginp) state)
    :guard (decl-list-unambp decls)
    :returns (mv (new-decls decl-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of declarations."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp decls))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-decl (simpadd0-gout gout-decl))
          (simpadd0-decl (car decls) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-decl.thm-index
               :names-to-avoid gout-decl.names-to-avoid))
         ((mv new-decls (simpadd0-gout gout-decls))
          (simpadd0-decl-list (cdr decls) gin state)))
      (mv (cons new-decl new-decls)
          (make-simpadd0-gout
           :events (append gout-decl.events gout-decls.events)
           :thm-name nil
           :thm-index gout-decls.thm-index
           :names-to-avoid gout-decls.names-to-avoid
           :vars (set::union gout-decl.vars gout-decls.vars)
           :diffp (or gout-decl.diffp gout-decls.diffp)
           :falliblep t)))
    :measure (decl-list-count decls))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-label ((label labelp) (gin simpadd0-ginp) state)
    :guard (label-unambp label)
    :returns (mv (new-label labelp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a label."
    (b* (((simpadd0-gin gin) gin))
      (label-case
       label
       :name (mv (label-fix label)
                 (make-simpadd0-gout
                  :events nil
                  :thm-name nil
                  :thm-index gin.thm-index
                  :names-to-avoid gin.names-to-avoid
                  :vars nil
                  :diffp nil
                  :falliblep t))
       :casexpr (b* (((mv new-expr (simpadd0-gout gout-expr))
                      (simpadd0-const-expr label.expr gin state))
                     (gin (change-simpadd0-gin
                           gin
                           :thm-index gout-expr.thm-index
                           :names-to-avoid gout-expr.names-to-avoid))
                     ((mv new-range? (simpadd0-gout gout-range?))
                      (simpadd0-const-expr-option label.range? gin state)))
                  (mv (make-label-casexpr :expr new-expr
                                          :range? new-range?)
                      (make-simpadd0-gout
                       :events (append gout-expr.events gout-range?.events)
                       :thm-name nil
                       :thm-index gout-range?.thm-index
                       :names-to-avoid gout-range?.names-to-avoid
                       :vars (set::union gout-expr.vars gout-range?.vars)
                       :diffp (or gout-expr.diffp gout-range?.diffp)
                       :falliblep t)))
       :default (mv (label-fix label)
                    (make-simpadd0-gout
                     :events nil
                     :thm-name nil
                     :thm-index gin.thm-index
                     :names-to-avoid gin.names-to-avoid
                     :vars nil
                     :diffp nil
                     :falliblep t))))
    :measure (label-count label))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-stmt ((stmt stmtp) (gin simpadd0-ginp) state)
    :guard (stmt-unambp stmt)
    :returns (mv (new-stmt stmtp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a statement."
    (b* (((simpadd0-gin gin) gin))
      (stmt-case
       stmt
       :labeled (b* (((mv new-label (simpadd0-gout gout-label))
                      (simpadd0-label stmt.label gin state))
                     (gin (change-simpadd0-gin
                           gin
                           :thm-index gout-label.thm-index
                           :names-to-avoid gout-label.names-to-avoid))
                     ((mv new-stmt (simpadd0-gout gout-stmt))
                      (simpadd0-stmt stmt.stmt gin state)))
                  (mv (make-stmt-labeled :label new-label
                                         :stmt new-stmt)
                      (make-simpadd0-gout
                       :events (append gout-label.events
                                       gout-stmt.events)
                       :thm-name nil
                       :thm-index gout-stmt.thm-index
                       :names-to-avoid gout-stmt.names-to-avoid
                       :vars (set::union gout-label.vars gout-stmt.vars)
                       :diffp (or gout-label.diffp gout-stmt.diffp)
                       :falliblep t)))
       :compound (b* (((mv new-items (simpadd0-gout gout-items))
                       (simpadd0-block-item-list stmt.items gin state)))
                   (mv (stmt-compound new-items)
                       (make-simpadd0-gout
                        :events gout-items.events
                        :thm-name nil
                        :thm-index gout-items.thm-index
                        :names-to-avoid gout-items.names-to-avoid
                        :vars gout-items.vars
                        :diffp gout-items.diffp
                        :falliblep t)))
       :expr (b* (((mv new-expr? (simpadd0-gout gout-expr?))
                   (simpadd0-expr-option stmt.expr? gin state)))
               (mv (stmt-expr new-expr?)
                   (make-simpadd0-gout
                    :events gout-expr?.events
                    :thm-name nil
                    :thm-index gout-expr?.thm-index
                    :names-to-avoid gout-expr?.names-to-avoid
                    :vars gout-expr?.vars
                    :diffp gout-expr?.diffp
                    :falliblep t)))
       :if (b* (((mv new-test (simpadd0-gout gout-test))
                 (simpadd0-expr stmt.test gin state))
                (gin (change-simpadd0-gin
                      gin
                      :thm-index gout-test.thm-index
                      :names-to-avoid gout-test.names-to-avoid))
                ((mv new-then (simpadd0-gout gout-then))
                 (simpadd0-stmt stmt.then gin state)))
             (mv (make-stmt-if :test new-test
                               :then new-then)
                 (make-simpadd0-gout
                  :events (append gout-test.events gout-then.events)
                  :thm-name nil
                  :thm-index gout-then.thm-index
                  :names-to-avoid gout-then.names-to-avoid
                  :vars (set::union gout-test.vars gout-then.vars)
                  :diffp (or gout-test.diffp gout-then.diffp)
                  :falliblep t)))
       :ifelse (b* (((mv new-test (simpadd0-gout gout-test))
                     (simpadd0-expr stmt.test gin state))
                    (gin (change-simpadd0-gin
                          gin
                          :thm-index gout-test.thm-index
                          :names-to-avoid gout-test.names-to-avoid))
                    ((mv new-then (simpadd0-gout gout-then))
                     (simpadd0-stmt stmt.then gin state))
                    (gin (change-simpadd0-gin
                          gin
                          :thm-index gout-then.thm-index
                          :names-to-avoid gout-then.names-to-avoid))
                    ((mv new-else (simpadd0-gout gout-else))
                     (simpadd0-stmt stmt.else gin state)))
                 (mv (make-stmt-ifelse :test new-test
                                       :then new-then
                                       :else new-else)
                     (make-simpadd0-gout
                      :events (append gout-test.events
                                      gout-then.events
                                      gout-else.events)
                      :thm-name nil
                      :thm-index gout-else.thm-index
                      :names-to-avoid gout-else.names-to-avoid
                      :vars (set::union gout-test.vars
                                        (set::union gout-then.vars
                                                    gout-else.vars))
                      :diffp (or gout-test.diffp
                                 gout-then.diffp
                                 gout-else.diffp)
                      :falliblep t)))
       :switch (b* (((mv new-target (simpadd0-gout gout-target))
                     (simpadd0-expr stmt.target gin state))
                    (gin (change-simpadd0-gin
                          gin
                          :thm-index gout-target.thm-index
                          :names-to-avoid gout-target.names-to-avoid))
                    ((mv new-body (simpadd0-gout gout-body))
                     (simpadd0-stmt stmt.body gin state)))
                 (mv (make-stmt-switch :target new-target
                                       :body new-body)
                     (make-simpadd0-gout
                      :events (append gout-target.events gout-body.events)
                      :thm-name nil
                      :thm-index gout-body.thm-index
                      :names-to-avoid gout-body.names-to-avoid
                      :vars (set::union gout-target.vars gout-body.vars)
                      :diffp (or gout-target.diffp gout-body.diffp)
                      :falliblep t)))
       :while (b* (((mv new-test (simpadd0-gout gout-test))
                    (simpadd0-expr stmt.test gin state))
                   (gin (change-simpadd0-gin
                         gin
                         :thm-index gout-test.thm-index
                         :names-to-avoid gout-test.names-to-avoid))
                   ((mv new-body (simpadd0-gout gout-body))
                    (simpadd0-stmt stmt.body gin state)))
                (mv (make-stmt-while :test new-test
                                     :body new-body)
                    (make-simpadd0-gout
                     :events (append gout-test.events gout-body.events)
                     :thm-name nil
                     :thm-index gout-body.thm-index
                     :names-to-avoid gout-body.names-to-avoid
                     :vars (set::union gout-test.vars gout-body.vars)
                     :diffp (or gout-test.diffp gout-body.diffp)
                     :falliblep t)))
       :dowhile (b* (((mv new-body (simpadd0-gout gout-body))
                      (simpadd0-stmt stmt.body gin state))
                     (gin (change-simpadd0-gin
                           gin
                           :thm-index gout-body.thm-index
                           :names-to-avoid gout-body.names-to-avoid))
                     ((mv new-test (simpadd0-gout gout-test))
                      (simpadd0-expr stmt.test gin state)))
                  (mv (make-stmt-dowhile :body new-body
                                         :test new-test)
                      (make-simpadd0-gout
                       :events (append gout-body.events gout-test.events)
                       :thm-name nil
                       :thm-index gout-test.thm-index
                       :names-to-avoid gout-test.names-to-avoid
                       :vars (set::union gout-body.vars gout-test.vars)
                       :diffp (or gout-body.diffp gout-test.diffp)
                       :falliblep t)))
       :for-expr (b* (((mv new-init (simpadd0-gout gout-init))
                       (simpadd0-expr-option stmt.init gin state))
                      (gin (change-simpadd0-gin
                            gin
                            :thm-index gout-init.thm-index
                            :names-to-avoid gout-init.names-to-avoid))
                      ((mv new-test (simpadd0-gout gout-test))
                       (simpadd0-expr-option stmt.test gin state))
                      (gin (change-simpadd0-gin
                            gin
                            :thm-index gout-test.thm-index
                            :names-to-avoid gout-test.names-to-avoid))
                      ((mv new-next (simpadd0-gout gout-next))
                       (simpadd0-expr-option stmt.next gin state))
                      (gin (change-simpadd0-gin
                            gin
                            :thm-index gout-next.thm-index
                            :names-to-avoid gout-next.names-to-avoid))
                      ((mv new-body (simpadd0-gout gout-body))
                       (simpadd0-stmt stmt.body gin state)))
                   (mv (make-stmt-for-expr :init new-init
                                           :test new-test
                                           :next new-next
                                           :body new-body)
                       (make-simpadd0-gout
                        :events (append gout-init.events
                                        gout-test.events
                                        gout-next.events
                                        gout-body.events)
                        :thm-name nil
                        :thm-index gout-body.thm-index
                        :names-to-avoid gout-body.names-to-avoid
                        :vars (set::union gout-init.vars
                                          (set::union gout-test.vars
                                                      (set::union
                                                       gout-next.vars
                                                       gout-body.vars)))
                        :diffp (or gout-init.diffp
                                   gout-test.diffp
                                   gout-next.diffp
                                   gout-body.diffp)
                        :falliblep t)))
       :for-decl (b* (((mv new-init (simpadd0-gout gout-init))
                       (simpadd0-decl stmt.init gin state))
                      (gin (change-simpadd0-gin
                            gin
                            :thm-index gout-init.thm-index
                            :names-to-avoid gout-init.names-to-avoid))
                      ((mv new-test (simpadd0-gout gout-test))
                       (simpadd0-expr-option stmt.test gin state))
                      (gin (change-simpadd0-gin
                            gin
                            :thm-index gout-test.thm-index
                            :names-to-avoid gout-test.names-to-avoid))
                      ((mv new-next (simpadd0-gout gout-next))
                       (simpadd0-expr-option stmt.next gin state))
                      (gin (change-simpadd0-gin
                            gin
                            :thm-index gout-next.thm-index
                            :names-to-avoid gout-next.names-to-avoid))
                      ((mv new-body (simpadd0-gout gout-body))
                       (simpadd0-stmt stmt.body gin state)))
                   (mv (make-stmt-for-decl :init new-init
                                           :test new-test
                                           :next new-next
                                           :body new-body)
                       (make-simpadd0-gout
                        :events (append gout-init.events
                                        gout-test.events
                                        gout-next.events
                                        gout-body.events)
                        :thm-name nil
                        :thm-index gout-body.thm-index
                        :names-to-avoid gout-body.names-to-avoid
                        :vars (set::union gout-init.vars
                                          (set::union gout-test.vars
                                                      (set::union
                                                       gout-next.vars
                                                       gout-body.vars)))
                        :diffp (or gout-init.diffp
                                   gout-test.diffp
                                   gout-next.diffp
                                   gout-body.diffp)
                        :falliblep t)))
       :for-ambig (prog2$ (impossible) (mv (irr-stmt) (irr-simpadd0-gout)))
       :goto (mv (stmt-fix stmt)
                 (make-simpadd0-gout
                  :events nil
                  :thm-name nil
                  :thm-index gin.thm-index
                  :names-to-avoid gin.names-to-avoid
                  :vars nil
                  :diffp nil
                  :falliblep t))
       :continue (mv (stmt-fix stmt)
                     (make-simpadd0-gout
                      :events nil
                      :thm-name nil
                      :thm-index gin.thm-index
                      :names-to-avoid gin.names-to-avoid
                      :vars nil
                      :diffp nil
                      :falliblep t))
       :break (mv (stmt-fix stmt)
                  (make-simpadd0-gout
                   :events nil
                   :thm-name nil
                   :thm-index gin.thm-index
                   :names-to-avoid gin.names-to-avoid
                   :vars nil
                   :diffp nil
                   :falliblep t))
       :return (b* (((mv new-expr? (simpadd0-gout gout-expr?))
                     (simpadd0-expr-option stmt.expr? gin state)))
                 (mv (stmt-return new-expr?)
                     (make-simpadd0-gout
                      :events gout-expr?.events
                      :thm-name nil
                      :thm-index gout-expr?.thm-index
                      :names-to-avoid gout-expr?.names-to-avoid
                      :vars gout-expr?.vars
                      :diffp gout-expr?.diffp
                      :falliblep t)))
       :asm (mv (stmt-fix stmt)
                (make-simpadd0-gout
                 :events nil
                 :thm-name nil
                 :thm-index gin.thm-index
                 :names-to-avoid gin.names-to-avoid
                 :vars nil
                 :diffp nil
                 :falliblep t))))
    :measure (stmt-count stmt))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-block-item ((item block-itemp) (gin simpadd0-ginp) state)
    :guard (block-item-unambp item)
    :returns (mv (new-item block-itemp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a block item."
    (b* (((simpadd0-gin gin) gin))
      (block-item-case
       item
       :decl (b* (((mv new-item (simpadd0-gout gout-item))
                   (simpadd0-decl item.unwrap gin state)))
               (mv (block-item-decl new-item)
                   (make-simpadd0-gout
                    :events gout-item.events
                    :thm-name nil
                    :thm-index gout-item.thm-index
                    :names-to-avoid gout-item.names-to-avoid
                    :vars gout-item.vars
                    :diffp gout-item.diffp
                    :falliblep t)))
       :stmt (b* (((mv new-item (simpadd0-gout gout-item))
                   (simpadd0-stmt item.unwrap gin state)))
               (mv (block-item-stmt new-item)
                   (make-simpadd0-gout
                    :events gout-item.events
                    :thm-name nil
                    :thm-index gout-item.thm-index
                    :names-to-avoid gout-item.names-to-avoid
                    :vars gout-item.vars
                    :diffp gout-item.diffp
                    :falliblep t)))
       :ambig (prog2$ (impossible) (mv (irr-block-item) (irr-simpadd0-gout)))))
    :measure (block-item-count item))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define simpadd0-block-item-list ((items block-item-listp)
                                    (gin simpadd0-ginp)
                                    state)
    :guard (block-item-list-unambp items)
    :returns (mv (new-items block-item-listp)
                 (gout simpadd0-goutp))
    :parents (simpadd0 simpadd0-exprs/decls/stmts)
    :short "Transform a list of block items."
    (b* (((simpadd0-gin gin) gin)
         ((when (endp items))
          (mv nil
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t)))
         ((mv new-item (simpadd0-gout gout-item))
          (simpadd0-block-item (car items) gin state))
         (gin (change-simpadd0-gin
               gin
               :thm-index gout-item.thm-index
               :names-to-avoid gout-item.names-to-avoid))
         ((mv new-items (simpadd0-gout gout-items))
          (simpadd0-block-item-list (cdr items) gin state)))
      (mv (cons new-item new-items)
          (make-simpadd0-gout
           :events (append gout-item.events gout-items.events)
           :thm-name nil
           :thm-index gout-items.thm-index
           :names-to-avoid gout-items.names-to-avoid
           :vars (set::union gout-item.vars gout-items.vars)
           :diffp (or gout-item.diffp gout-items.diffp)
           :falliblep t)))
    :measure (block-item-list-count items))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  :hints (("Goal" :in-theory (enable o< o-finp)))

  :verify-guards nil ; done after the unambiguity proofs

  ///

  (local (in-theory (enable irr-absdeclor
                            irr-dirabsdeclor)))

  (fty::deffixequiv-mutual simpadd0-exprs/decls/stmts)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defret-mutual exprs/decls-unambp-of-simpadd0-exprs/decls
    (defret expr-unambp-of-simpadd0-expr
      (expr-unambp new-expr)
      :fn simpadd0-expr)
    (defret expr-list-unambp-of-simpadd0-expr-list
      (expr-list-unambp new-exprs)
      :fn simpadd0-expr-list)
    (defret expr-option-unambp-of-simpadd0-expr-option
      (expr-option-unambp new-expr?)
      :fn simpadd0-expr-option)
    (defret const-expr-unambp-of-simpadd0-const-expr
      (const-expr-unambp new-cexpr)
      :fn simpadd0-const-expr)
    (defret const-expr-option-unambp-of-simpadd0-const-expr-option
      (const-expr-option-unambp new-cexpr?)
      :fn simpadd0-const-expr-option)
    (defret genassoc-unambp-of-simpadd0-genassoc
      (genassoc-unambp new-genassoc)
      :fn simpadd0-genassoc)
    (defret genassoc-list-unambp-of-simpadd0-genassoc-list
      (genassoc-list-unambp new-genassocs)
      :fn simpadd0-genassoc-list)
    (defret member-designor-unambp-of-simpadd0-member-designor
      (member-designor-unambp new-memdes)
      :fn simpadd0-member-designor)
    (defret type-spec-unambp-of-simpadd0-type-spec
      (type-spec-unambp new-tyspec)
      :fn simpadd0-type-spec)
    (defret spec/qual-unambp-of-simpadd0-spec/qual
      (spec/qual-unambp new-specqual)
      :fn simpadd0-spec/qual)
    (defret spec/qual-list-unambp-of-simpadd0-spec/qual-list
      (spec/qual-list-unambp new-specquals)
      :fn simpadd0-spec/qual-list)
    (defret align-spec-unambp-of-simpadd0-align-spec
      (align-spec-unambp new-alignspec)
      :fn simpadd0-align-spec)
    (defret decl-spec-unambp-of-simpadd0-decl-spec
      (decl-spec-unambp new-declspec)
      :fn simpadd0-decl-spec)
    (defret decl-spec-list-unambp-of-simpadd0-decl-spec-list
      (decl-spec-list-unambp new-declspecs)
      :fn simpadd0-decl-spec-list)
    (defret initer-unambp-of-simpadd0-initer
      (initer-unambp new-initer)
      :fn simpadd0-initer)
    (defret initer-option-unambp-of-simpadd0-initer-option
      (initer-option-unambp new-initer?)
      :fn simpadd0-initer-option)
    (defret desiniter-unambp-of-simpadd0-desiniter
      (desiniter-unambp new-desiniter)
      :fn simpadd0-desiniter)
    (defret desiniter-list-unambp-of-simpadd0-desiniter-list
      (desiniter-list-unambp new-desiniters)
      :fn simpadd0-desiniter-list)
    (defret designor-unambp-of-simpadd0-designor
      (designor-unambp new-designor)
      :fn simpadd0-designor)
    (defret designor-list-unambp-of-simpadd0-designor-list
      (designor-list-unambp new-designors)
      :fn simpadd0-designor-list)
    (defret declor-unambp-of-simpadd0-declor
      (declor-unambp new-declor)
      :fn simpadd0-declor)
    (defret declor-option-unambp-of-simpadd0-declor-option
      (declor-option-unambp new-declor?)
      :fn simpadd0-declor-option)
    (defret dirdeclor-unambp-of-simpadd0-dirdeclor
      (dirdeclor-unambp new-dirdeclor)
      :fn simpadd0-dirdeclor)
    (defret absdeclor-unambp-of-simpadd0-absdeclor
      (absdeclor-unambp new-absdeclor)
      :fn simpadd0-absdeclor)
    (defret absdeclor-option-unambp-of-simpadd0-absdeclor-option
      (absdeclor-option-unambp new-absdeclor?)
      :fn simpadd0-absdeclor-option)
    (defret dirabsdeclor-unambp-of-simpadd0-dirabsdeclor
      (dirabsdeclor-unambp new-dirabsdeclor)
      :fn simpadd0-dirabsdeclor)
    (defret dirabsdeclor-option-unambp-of-simpadd0-dirabsdeclor-option
      (dirabsdeclor-option-unambp new-dirabsdeclor?)
      :fn simpadd0-dirabsdeclor-option)
    (defret paramdecl-unambp-of-simpadd0-paramdecl
      (paramdecl-unambp new-paramdecl)
      :fn simpadd0-paramdecl)
    (defret paramdecl-list-unambp-of-simpadd0-paramdecl-list
      (paramdecl-list-unambp new-paramdecls)
      :fn simpadd0-paramdecl-list)
    (defret paramdeclor-unambp-of-simpadd0-paramdeclor
      (paramdeclor-unambp new-paramdeclor)
      :fn simpadd0-paramdeclor)
    (defret tyname-unambp-of-simpadd0-tyname
      (tyname-unambp new-tyname)
      :fn simpadd0-tyname)
    (defret strunispec-unambp-of-simpadd0-strunispec
      (strunispec-unambp new-strunispec)
      :fn simpadd0-strunispec)
    (defret structdecl-unambp-of-simpadd0-structdecl
      (structdecl-unambp new-structdecl)
      :fn simpadd0-structdecl)
    (defret structdecl-list-unambp-of-simpadd0-structdecl-list
      (structdecl-list-unambp new-structdecls)
      :fn simpadd0-structdecl-list)
    (defret structdeclor-unambp-of-simpadd0-structdeclor
      (structdeclor-unambp new-structdeclor)
      :fn simpadd0-structdeclor)
    (defret structdeclor-list-unambp-of-simpadd0-structdeclor-list
      (structdeclor-list-unambp new-structdeclors)
      :fn simpadd0-structdeclor-list)
    (defret enumspec-unambp-of-simpadd0-enumspec
      (enumspec-unambp new-enumspec)
      :fn simpadd0-enumspec)
    (defret enumer-unambp-of-simpadd0-enumer
      (enumer-unambp new-enumer)
      :fn simpadd0-enumer)
    (defret enumer-list-unambp-of-simpadd0-enumer-list
      (enumer-list-unambp new-enumers)
      :fn simpadd0-enumer-list)
    (defret statassert-unambp-of-simpadd0-statassert
      (statassert-unambp new-statassert)
      :fn simpadd0-statassert)
    (defret initdeclor-unambp-of-simpadd0-initdeclor
      (initdeclor-unambp new-initdeclor)
      :fn simpadd0-initdeclor)
    (defret initdeclor-list-unambp-of-simpadd0-initdeclor-list
      (initdeclor-list-unambp new-initdeclors)
      :fn simpadd0-initdeclor-list)
    (defret decl-unambp-of-simpadd0-decl
      (decl-unambp new-decl)
      :fn simpadd0-decl)
    (defret decl-list-unambp-of-simpadd0-decl-list
      (decl-list-unambp new-decls)
      :fn simpadd0-decl-list)
    (defret label-unambp-of-simpadd0-label
      (label-unambp new-label)
      :fn simpadd0-label)
    (defret stmt-unambp-of-simpadd0-stmt
      (stmt-unambp new-stmt)
      :fn simpadd0-stmt)
    (defret block-item-unambp-of-simpadd0-block-item
      (block-item-unambp new-item)
      :fn simpadd0-block-item)
    (defret block-item-list-unambp-of-simpadd0-block-item-list
      (block-item-list-unambp new-items)
      :fn simpadd0-block-item-list)
    :hints (("Goal" :in-theory (enable simpadd0-expr
                                       simpadd0-expr-list
                                       simpadd0-expr-option
                                       simpadd0-const-expr
                                       simpadd0-const-expr-option
                                       simpadd0-genassoc
                                       simpadd0-genassoc-list
                                       simpadd0-type-spec
                                       simpadd0-spec/qual
                                       simpadd0-spec/qual-list
                                       simpadd0-align-spec
                                       simpadd0-decl-spec
                                       simpadd0-decl-spec-list
                                       simpadd0-initer
                                       simpadd0-initer-option
                                       simpadd0-desiniter
                                       simpadd0-desiniter-list
                                       simpadd0-designor
                                       simpadd0-designor-list
                                       simpadd0-declor
                                       simpadd0-declor-option
                                       simpadd0-dirdeclor
                                       simpadd0-absdeclor
                                       simpadd0-absdeclor-option
                                       simpadd0-dirabsdeclor
                                       simpadd0-dirabsdeclor-option
                                       simpadd0-paramdecl
                                       simpadd0-paramdecl-list
                                       simpadd0-paramdeclor
                                       simpadd0-tyname
                                       simpadd0-strunispec
                                       simpadd0-structdecl
                                       simpadd0-structdecl-list
                                       simpadd0-structdeclor
                                       simpadd0-structdeclor-list
                                       simpadd0-enumspec
                                       simpadd0-enumer
                                       simpadd0-enumer-list
                                       simpadd0-statassert
                                       simpadd0-initdeclor
                                       simpadd0-initdeclor-list
                                       simpadd0-decl
                                       simpadd0-decl-list
                                       simpadd0-label
                                       simpadd0-stmt
                                       simpadd0-block-item
                                       simpadd0-block-item-list
                                       irr-expr
                                       irr-const-expr
                                       irr-align-spec
                                       irr-dirabsdeclor
                                       irr-paramdeclor
                                       irr-type-spec
                                       irr-stmt
                                       irr-block-item))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (verify-guards simpadd0-expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-fundef ((fundef fundefp) (gin simpadd0-ginp) state)
  :guard (fundef-unambp fundef)
  :returns (mv (new-fundef fundefp)
               (gout simpadd0-goutp))
  :short "Transform a function definition."
  (b* (((simpadd0-gin gin) gin)
       ((fundef fundef) fundef)
       ((mv new-spec (simpadd0-gout gout-spec))
        (simpadd0-decl-spec-list fundef.spec gin state))
       (gin (change-simpadd0-gin
             gin
             :thm-index gout-spec.thm-index
             :names-to-avoid gout-spec.names-to-avoid))
       ((mv new-declor (simpadd0-gout gout-declor))
        (simpadd0-declor fundef.declor gin state))
       (gin (change-simpadd0-gin
             gin
             :thm-index gout-declor.thm-index
             :names-to-avoid gout-declor.names-to-avoid))
       ((mv new-decls (simpadd0-gout gout-decls))
        (simpadd0-decl-list fundef.decls gin state))
       (gin (change-simpadd0-gin
             gin
             :thm-index gout-decls.thm-index
             :names-to-avoid gout-decls.names-to-avoid))
       ((mv new-body (simpadd0-gout gout-body))
        (simpadd0-stmt fundef.body gin state)))
    (mv (make-fundef :extension fundef.extension
                     :spec new-spec
                     :declor new-declor
                     :asm? fundef.asm?
                     :attribs fundef.attribs
                     :decls new-decls
                     :body new-body)
        (make-simpadd0-gout
         :events (append gout-spec.events
                         gout-declor.events
                         gout-decls.events
                         gout-body.events)
         :thm-name nil
         :thm-index gout-body.thm-index
         :names-to-avoid gout-body.names-to-avoid
         :vars (set::union gout-spec.vars
                           (set::union gout-declor.vars
                                       (set::union gout-decls.vars
                                                   gout-body.vars)))
         :diffp (or gout-spec.diffp
                    gout-declor.diffp
                    gout-decls.diffp
                    gout-body.diffp)
         :falliblep t)))
  :hooks (:fix)

  ///

  (defret fundef-unambp-of-simpadd0-fundef
    (fundef-unambp new-fundef)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-extdecl ((extdecl extdeclp) (gin simpadd0-ginp) state)
  :guard (extdecl-unambp extdecl)
  :returns (mv (new-extdecl extdeclp)
               (gout simpadd0-goutp))
  :short "Transform an external declaration."
  (b* (((simpadd0-gin gin) gin))
    (extdecl-case
     extdecl
     :fundef (b* (((mv new-fundef (simpadd0-gout gout-fundef))
                   (simpadd0-fundef extdecl.unwrap gin state)))
               (mv (extdecl-fundef new-fundef)
                   (make-simpadd0-gout
                    :events gout-fundef.events
                    :thm-name nil
                    :thm-index gout-fundef.thm-index
                    :names-to-avoid gout-fundef.names-to-avoid
                    :vars gout-fundef.vars
                    :diffp gout-fundef.diffp
                    :falliblep t)))
     :decl (b* (((mv new-decl (simpadd0-gout gout-decl))
                 (simpadd0-decl extdecl.unwrap gin state)))
             (mv (extdecl-decl new-decl)
                 (make-simpadd0-gout
                  :events gout-decl.events
                  :thm-name nil
                  :thm-index gout-decl.thm-index
                  :names-to-avoid gout-decl.names-to-avoid
                  :vars gout-decl.vars
                  :diffp gout-decl.diffp
                  :falliblep t)))
     :empty (mv (extdecl-empty)
                (make-simpadd0-gout
                 :events nil
                 :thm-name nil
                 :thm-index gin.thm-index
                 :names-to-avoid gin.names-to-avoid
                 :vars nil
                 :diffp nil
                 :falliblep t))
     :asm (mv (extdecl-fix extdecl)
              (make-simpadd0-gout
               :events nil
               :thm-name nil
               :thm-index gin.thm-index
               :names-to-avoid gin.names-to-avoid
               :vars nil
               :diffp nil
               :falliblep t))))
  :hooks (:fix)

  ///

  (defret extdecl-unambp-of-simpadd0-extdecl
    (extdecl-unambp new-extdecl)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-extdecl-list ((extdecls extdecl-listp)
                               (gin simpadd0-ginp)
                               state)
  :guard (extdecl-list-unambp extdecls)
  :returns (mv (new-extdecls extdecl-listp)
               (gout simpadd0-goutp))
  :short "Transform a list of external declarations."
  (b* (((simpadd0-gin gin) gin)
       ((when (endp extdecls))
        (mv nil
            (make-simpadd0-gout
             :events nil
             :thm-name nil
             :thm-index gin.thm-index
             :names-to-avoid gin.names-to-avoid
             :vars nil
             :diffp nil
             :falliblep t)))
       ((mv new-edecl (simpadd0-gout gout-edecl))
        (simpadd0-extdecl (car extdecls) gin state))
       (gin (change-simpadd0-gin
             gin
             :thm-index gout-edecl.thm-index
             :names-to-avoid gout-edecl.names-to-avoid))
       ((mv new-edecls (simpadd0-gout gout-edecls))
        (simpadd0-extdecl-list (cdr extdecls) gin state)))
    (mv (cons new-edecl new-edecls)
        (make-simpadd0-gout
         :events (append gout-edecl.events gout-edecls.events)
         :thm-name nil
         :thm-index gout-edecls.thm-index
         :names-to-avoid gout-edecls.names-to-avoid
         :vars (set::union gout-edecl.vars gout-edecls.vars)
         :diffp (or gout-edecl.diffp gout-edecls.diffp)
         :falliblep t)))
  :verify-guards :after-returns
  :hooks (:fix)

  ///

  (defret extdecl-list-unambp-of-simpadd0-extdecl-list
    (extdecl-list-unambp new-extdecls)
    :hints (("Goal" :induct t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-transunit ((tunit transunitp) (gin simpadd0-ginp) state)
  :guard (transunit-unambp tunit)
  :returns (mv (new-tunit transunitp)
               (gout simpadd0-goutp))
  :short "Transform a translation unit."
  (b* (((simpadd0-gin gin) gin)
       ((transunit tunit) tunit)
       ((mv new-decls (simpadd0-gout gout-decls))
        (simpadd0-extdecl-list tunit.decls gin state)))
    (mv  (make-transunit :decls new-decls
                         :info tunit.info)
         (make-simpadd0-gout
          :events gout-decls.events
          :thm-name nil
          :thm-index gout-decls.thm-index
          :names-to-avoid gout-decls.names-to-avoid
          :vars gout-decls.vars
          :diffp gout-decls.diffp
          :falliblep t)))
  :hooks (:fix)

  ///

  (defret transunit-unambp-of-simpadd0-transunit
    (transunit-unambp new-tunit)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-filepath ((path filepathp))
  :returns (new-path filepathp)
  :short "Transform a file path."
  :long
  (xdoc::topstring
   (xdoc::p
    "We only support file paths that consist of strings.
     We transform the path by interposing @('.simpadd0')
     just before the rightmost dot of the file extension, if any;
     if there is no file extension, we just add @('.simpadd0') at the end.
     So for instance a path @('path/to/file.c')
     becomes @('path/to/file.simpadd0.c').")
   (xdoc::p
    "Note that this kind of file path transformations
     supports chaining of transformations,
     e.g. @('path/to/file.xform1.xform2.xform3.c')."))
  (b* ((string (filepath->unwrap path))
       ((unless (stringp string))
        (raise "Misusage error: file path ~x0 is not a string." string)
        (filepath "irrelevant"))
       (chars (str::explode string))
       (dot-pos-in-rev (index-of #\. (rev chars)))
       ((when (not dot-pos-in-rev))
        (filepath (str::implode (append chars
                                        (str::explode ".simpadd0")))))
       (last-dot-pos (- (len chars) dot-pos-in-rev))
       (new-chars (append (take last-dot-pos chars)
                          (str::explode "simpadd0.")
                          (nthcdr last-dot-pos chars)))
       (new-string (str::implode new-chars)))
    (filepath new-string))
  :guard-hints
  (("Goal"
    :use (:instance acl2::index-of-<-len
                    (k #\.)
                    (x (rev (str::explode (filepath->unwrap path)))))
    :in-theory (e/d (nfix) (acl2::index-of-<-len))))
  :hooks (:fix)
  :prepwork ((local (include-book "arithmetic-3/top" :dir :system))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-filepath-transunit-map ((map filepath-transunit-mapp)
                                         (gin simpadd0-ginp)
                                         state)
  :guard (filepath-transunit-map-unambp map)
  :returns (mv (new-map filepath-transunit-mapp
                        :hyp (filepath-transunit-mapp map))
               (gout simpadd0-goutp))
  :short "Transform a map from file paths to translation units."
  :long
  (xdoc::topstring
   (xdoc::p
    "We transform both the file paths and the translation units."))
  (b* (((simpadd0-gin gin) gin)
       ((when (omap::emptyp map))
        (mv nil
            (make-simpadd0-gout
             :events nil
             :thm-name nil
             :thm-index gin.thm-index
             :names-to-avoid gin.names-to-avoid
             :vars nil
             :diffp nil
             :falliblep t)))
       ((mv path tunit) (omap::head map))
       (new-path (simpadd0-filepath path))
       ((mv new-tunit (simpadd0-gout gout-tunit))
        (simpadd0-transunit tunit gin state))
       (gin (change-simpadd0-gin
             gin
             :thm-index gout-tunit.thm-index
             :names-to-avoid gout-tunit.names-to-avoid))
       ((mv new-map (simpadd0-gout gout-map))
        (simpadd0-filepath-transunit-map (omap::tail map) gin state)))
    (mv (omap::update new-path new-tunit new-map)
        (make-simpadd0-gout
         :events (append gout-tunit.events gout-map.events)
         :thm-name nil
         :thm-index gout-map.thm-index
         :names-to-avoid gout-map.names-to-avoid
         :vars (set::union gout-tunit.vars gout-map.vars)
         :diffp (or gout-tunit.diffp gout-map.diffp)
         :falliblep t)))
  :verify-guards :after-returns

  ///

  (fty::deffixequiv simpadd0-filepath-transunit-map
    :args ((gin simpadd0-ginp)))

  (defret filepath-transunit-map-unambp-of-simpadd-filepath-transunit-map
    (filepath-transunit-map-unambp new-map)
    :hyp (filepath-transunit-mapp map)
    :hints (("Goal" :induct t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-transunit-ensemble ((tunits transunit-ensemblep)
                                     (gin simpadd0-ginp)
                                     state)
  :guard (transunit-ensemble-unambp tunits)
  :returns (mv (new-tunits transunit-ensemblep)
               (gout simpadd0-goutp))
  :short "Transform a translation unit ensemble."
  (b* (((simpadd0-gin gin) gin)
       ((transunit-ensemble tunits) tunits)
       ((mv new-map (simpadd0-gout gout-map))
        (simpadd0-filepath-transunit-map tunits.unwrap gin state)))
    (mv (transunit-ensemble new-map)
        (make-simpadd0-gout
         :events gout-map.events
         :thm-name nil
         :thm-index gout-map.thm-index
         :names-to-avoid gout-map.names-to-avoid
         :vars gout-map.vars
         :diffp gout-map.diffp
         :falliblep t)))
  :hooks (:fix)

  ///

  (defret transunit-ensemble-unambp-of-simpadd0-transunit-ensemble
    (transunit-ensemble-unambp new-tunits)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-gen-proof-for-fun ((term-old "A term.")
                                    (term-new "A term.")
                                    (fun identp))
  :returns (event pseudo-event-formp)
  :short "Generate equivalence theorem for a function."
  :long
  (xdoc::topstring
   (xdoc::p
    "The theorem just says that executing the the function,
     in the old and new translation unit,
     returns the same result.
     We use an arbitrary 1000 as the limit value.
     Clearly, all of this is very simple and ad hoc."))
  (b* ((string (ident->unwrap fun))
       ((unless (stringp string))
        (raise "Misusage error: function name ~x0 is not a string." string)
        '(_))
       (thm-name (packn-pos (list string '-equivalence) 'c2c))
       (event
        `(defruled ,thm-name
           (equal (c::exec-fun (c::ident ,string)
                               nil
                               compst
                               (c::init-fun-env
                                (mv-nth 1 (c$::ldm-transunit ,term-old)))
                               1000)
                  (c::exec-fun (c::ident ,string)
                               nil
                               compst
                               (c::init-fun-env
                                (mv-nth 1 (c$::ldm-transunit ,term-new)))
                               1000))
           :enable (c::atc-all-rules
                    c::fun-env-lookup
                    omap::assoc
                    simpadd-exec-binary-strict-pure-when-add-alt)
           :disable ((:e c::ident)))))
    event)
  :guard-hints (("Goal" :in-theory (enable atom-listp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-gen-proofs-for-transunit ((term-old "A term.")
                                           (term-new "A term.")
                                           (tunit transunitp))
  :returns (events pseudo-event-form-listp)
  :short "Generate equivalence theorems
          for all the functions in a translation unit."
  (simpadd0-gen-proofs-for-transunit-loop term-old
                                          term-new
                                          (transunit->decls tunit))
  :prepwork
  ((define simpadd0-gen-proofs-for-transunit-loop ((term-old "A term.")
                                                   (term-new "A term.")
                                                   (extdecls extdecl-listp))
     :returns (events pseudo-event-form-listp)
     :parents nil
     (b* (((when (endp extdecls)) nil)
          (extdecl (car extdecls))
          ((unless (extdecl-case extdecl :fundef))
           (simpadd0-gen-proofs-for-transunit-loop term-old
                                                   term-new
                                                   (cdr extdecls)))
          (fundef (extdecl-fundef->unwrap extdecl))
          (declor (fundef->declor fundef))
          (dirdeclor (declor->direct declor))
          ((unless (member-eq (dirdeclor-kind dirdeclor)
                              '(:function-params :function-names)))
           (raise "Internal error: ~
                   direct declarator of function definition ~x0 ~
                   is not a function declarator."
                  fundef))
          ((unless (cond
                    ((dirdeclor-case dirdeclor :function-params)
                     (endp (dirdeclor-function-params->params dirdeclor)))
                    ((dirdeclor-case dirdeclor :function-names)
                     (endp (dirdeclor-function-names->names dirdeclor)))))
           (raise "Proof generation is currently supported ~
                   only for functions with no parameters, ~
                   but the function definition ~x0 has parameters."
                  fundef))
          (fun (declor->ident declor))
          (event (simpadd0-gen-proof-for-fun term-old
                                             term-new
                                             fun))
          (events (simpadd0-gen-proofs-for-transunit-loop term-old
                                                          term-new
                                                          (cdr extdecls))))
       (cons event events)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-gen-proofs-for-transunit-ensemble
  ((const-old symbolp)
   (const-new symbolp)
   (tunits-old transunit-ensemblep)
   (tunits-new transunit-ensemblep))
  :returns (events pseudo-event-form-listp)
  :short "Generate equivalence theorems for all functions in
          a translation unit ensemble."
  (simpadd0-gen-proofs-for-transunit-ensemble-loop
   const-old
   const-new
   (transunit-ensemble->unwrap tunits-old)
   (transunit-ensemble->unwrap tunits-new))
  :prepwork
  ((define simpadd0-gen-proofs-for-transunit-ensemble-loop
     ((const-old symbolp)
      (const-new symbolp)
      (tunitmap-old filepath-transunit-mapp)
      (tunitmap-new filepath-transunit-mapp))
     :returns (events pseudo-event-form-listp)
     :parents nil
     (b* (((when (omap::emptyp tunitmap-old)) nil)
          ((when (omap::emptyp tunitmap-new))
           (raise "Internal error: extra translation units ~x0." tunitmap-new))
          ((mv path-old tunit) (omap::head tunitmap-old))
          ((mv path-new &) (omap::head tunitmap-new))
          (term-old `(omap::lookup
                      ',path-old
                      (transunit-ensemble->unwrap ,const-old)))
          (term-new `(omap::lookup
                      ',path-new
                      (transunit-ensemble->unwrap ,const-new)))
          (events (simpadd0-gen-proofs-for-transunit term-old
                                                     term-new
                                                     tunit))
          (more-events (simpadd0-gen-proofs-for-transunit-ensemble-loop
                        const-old
                        const-new
                        (omap::tail tunitmap-old)
                        (omap::tail tunitmap-new))))
       (append events more-events)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-gen-everything ((tunits-old transunit-ensemblep)
                                 (const-old symbolp)
                                 (const-new symbolp)
                                 (proofs booleanp)
                                 state)
  :guard (and (transunit-ensemble-unambp tunits-old)
              (transunit-ensemble-annop tunits-old))
  :returns (mv erp (event pseudo-event-formp))
  :short "Event expansion of the transformation."
  :long
  (xdoc::topstring
   (xdoc::p
    "The modular bottom-up theorems in @(tsee simpadd0-gout)
     are always generated, because they are never expected to fail.
     The function equivalence theorems, which are brittle,
     are generated only if @(':proofs') is @('t')."))
  (b* (((reterr) '(_))
       (gin (make-simpadd0-gin :const-new const-new
                               :thm-index 1
                               :names-to-avoid nil))
       ((mv tunits-new (simpadd0-gout gout))
        (simpadd0-transunit-ensemble tunits-old gin state))
       ((mv erp &) (if (not proofs)
                       (retok :irrelevant)
                     (c$::ldm-transunit-ensemble tunits-old)))
       ((when erp)
        (reterr (msg "The old translation unit ensemble ~x0 ~
                      is not within the subset of C ~
                      covered by our formal semantics. ~
                      ~@1 ~
                      Thus, proofs cannot be generated: ~
                      re-run the transformation with :PROOFS NIL."
                     tunits-old erp)))
       ((mv erp &) (if (not proofs)
                       (retok :irrelevant)
                     (c$::ldm-transunit-ensemble tunits-new)))
       ((when erp)
        (reterr (msg "The new translation unit ensemble ~x0 ~
                      is not within the subset of C ~
                      covered by our formal semantics. ~
                      ~@1 ~
                      Thus, proofs cannot be generated: ~
                      re-run the transformation with :PROOFS NIL."
                     tunits-new erp)))
       (thm-events (append gout.events
                           (and proofs
                                (simpadd0-gen-proofs-for-transunit-ensemble
                                 const-old const-new tunits-old tunits-new))))
       (const-event `(defconst ,const-new ',tunits-new)))
    (retok `(encapsulate () ,const-event ,@thm-events))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-process-inputs-and-gen-everything (const-old
                                                    const-new
                                                    proofs
                                                    state)
  :returns (mv erp (event pseudo-event-formp))
  :parents (simpadd0-implementation)
  :short "Process the inputs and generate the events."
  (b* (((reterr) '(_))
       ((erp tunits-old const-old const-new proofs)
        (simpadd0-process-inputs const-old const-new proofs (w state))))
    (simpadd0-gen-everything tunits-old const-old const-new proofs state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define simpadd0-fn (const-old const-new proofs (ctx ctxp) state)
  :returns (mv erp (event pseudo-event-formp) state)
  :parents (simpadd0-implementation)
  :short "Event expansion of @(tsee simpadd0)."
  (b* (((mv erp event)
        (simpadd0-process-inputs-and-gen-everything const-old
                                                    const-new
                                                    proofs
                                                    state))
       ((when erp) (er-soft+ ctx t '(_) "~@0" erp)))
    (value event)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection simpadd0-macro-definition
  :parents (simpadd0-implementation)
  :short "Definition of the @(tsee simpadd0) macro."
  (defmacro simpadd0 (const-old const-new &key proofs)
    `(make-event
      (simpadd0-fn ',const-old ',const-new ,proofs 'simpadd0 state))))
