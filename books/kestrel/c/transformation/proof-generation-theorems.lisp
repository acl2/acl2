; C Library
;
; Copyright (C) 2025 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (www.alessandrocoglio.info)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "C2C")

(include-book "proof-generation")

(include-book "std/util/defund-sk" :dir :system)

(local (include-book "kestrel/built-ins/disable" :dir :system))
(local (acl2::disable-most-builtin-logic-defuns))
(local (acl2::disable-builtin-rewrite-rules-for-defaults))
(set-induction-depth-limit 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ proof-generation-theorems
  :parents (transformation-tools)
  :short "Theorems supporting proof generation."
  :long
  (xdoc::topstring
   (xdoc::p
    "The proof hints generated by transformations
     reference the general theorems that we collect here."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection exec-congruence-theorems
  :short "Congruence theorems about execution."
  :long
  (xdoc::topstring
   (xdoc::p
    "These are not congruence rules in the ACL2 technical sense,
     but they are theorems expressing congruence-like properties:
     given two constructs (before and after a transformation, i.e. old and new),
     if the executions of their sub-constucts are equivalent,
     then the executions of the super-constructa are equivalent.
     Here `equivalent' means the following:
     if the execution of the old construct does not yield an error,
     neither does the execution of the new construct,
     and the two return the same results.")
   (xdoc::p
    "The theorems make use of @(tsee b*) bindings
     to keep them more readable.
     The theorems include additional hypotheses, in some cases,
     to ensure that the constructs in question are amenable to
     our formal dynamic semantics of C, which currently only covers a subset.")
   (xdoc::p
    "The theorems include hypotheses about
     the execution of the old construct not yielding an error,
     and in some cases about
     the execution of the sub-constructs of the new construct
     (not the new construct itself) not yielding an error);
     they also include hypotheses about
     the sub-constructs yielding the same results.
     While in some cases the equality of the results of the sub-constructs
     and the hypotheses that the old construct does not yield an error
     imply already that the sub-constructs do not yield an error
     (also see @(see exec-error-theorems)),
     this is not quite the case for (pure) expressions,
     which return expression values of type @(tsee c::expr-value).
     For flexibility, the theorems require the equality, for sub-expressions,
     not of their full expression values,
     but just for the values of those expression values
     (i.e. @(tsee c::expr-value->value)).
     Thus, we need explicit hypotheses that
     the expression values are not errors,
     because they are not readily implied by the equality of
     the values alone of the expression values.
     The flexibility is important, for instance,
     to handle the semantic equality of @('x + 0') and @('x'),
     which return different expression values (but the same values),
     because @('x') is an lvalue while @('x + 0') is not.")
   (xdoc::p
    "The theorems conclude that the new construct's execution
     does not yield an error either,
     and that its results are the same as the old construct's execution's.
     When these theorems are used in proof generation,
     the hypotheses about the new sub-constructs not yielding errors
     and about them returning the same results as the old ones
     are established via the proofs generated for the sub-constructs;
     and the conclusions serve for larger constructs, compositionally.")
   (xdoc::p
    "For non-strict constructs,
     we have multiple theorems,
     corresponding to which sub-constructs are actually executed.")
   (xdoc::p
    "For the C dynamic semantics execution functions
     that depend on function environments,
     we use potentially different function environments
     for the old vs. new constructs.
     We always use the same initial computation state
     for old and new constructs."))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-unary-congruence
    (b* ((old (c::expr-unary op old-arg))
         (new (c::expr-unary op new-arg))
         (old-arg-result (c::exec-expr-pure old-arg compst))
         (new-arg-result (c::exec-expr-pure new-arg compst))
         (old-arg-value (c::expr-value->value old-arg-result))
         (new-arg-value (c::expr-value->value new-arg-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type (c::type-of-value old-arg-value)))
      (implies (and (c::unop-nonpointerp op)
                    (not (c::errorp old-result))
                    (not (c::errorp new-arg-result))
                    (equal old-arg-value new-arg-value)
                    (c::type-nonchar-integerp type))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value)
                           (if (equal (c::unop-kind op) :lognot)
                               (c::type-sint)
                             (c::promote-type type))))))
    :expand ((c::exec-expr-pure (c::expr-unary op old-arg) compst)
             (c::exec-expr-pure (c::expr-unary op new-arg) compst))
    :disable ((:e c::type-sint))
    :enable (c::unop-nonpointerp
             c::exec-unary
             c::eval-unary
             c::apconvert-expr-value-when-not-array
             c::value-arithmeticp
             c::value-realp
             c::value-integerp
             c::value-signed-integerp
             c::value-unsigned-integerp
             c::value-kind-not-array-when-value-integerp)
    :prep-lemmas
    ((defrule c::lognot-value-lemma
       (implies (and (c::valuep val)
                     (member-equal (c::value-kind val)
                                   '(:uchar :schar
                                     :ushort :sshort
                                     :uint :sint
                                     :ulong :slong
                                     :ullong :sllong)))
                (equal (c::value-kind (c::lognot-value val)) :sint))
       :enable (c::lognot-value
                c::lognot-scalar-value
                c::lognot-integer-value
                c::value-scalarp
                c::value-arithmeticp
                c::value-realp
                c::value-integerp
                c::value-signed-integerp
                c::value-unsigned-integerp))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cast-congruence
    (b* ((old (c::expr-cast tyname old-arg))
         (new (c::expr-cast tyname new-arg))
         (old-arg-result (c::exec-expr-pure old-arg compst))
         (new-arg-result (c::exec-expr-pure new-arg compst))
         (old-arg-value (c::expr-value->value old-arg-result))
         (new-arg-value (c::expr-value->value new-arg-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type (c::type-of-value old-arg-value))
         (type1 (c::tyname-to-type tyname)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg-result))
                    (equal old-arg-value new-arg-value)
                    (c::type-nonchar-integerp type)
                    (c::type-nonchar-integerp type1))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value)
                           type1))))
    :expand ((c::exec-expr-pure (c::expr-cast tyname old-arg) compst)
             (c::exec-expr-pure (c::expr-cast tyname new-arg) compst))
    :enable (c::exec-cast
             c::eval-cast
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-pure-strict-congruence
    (b* ((old (c::expr-binary op old-arg1 old-arg2))
         (new (c::expr-binary op new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (old-arg2-result (c::exec-expr-pure old-arg2 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (new-arg2-result (c::exec-expr-pure new-arg2 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (old-arg2-value (c::expr-value->value old-arg2-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (new-arg2-value (c::expr-value->value new-arg2-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value))
         (type2 (c::type-of-value old-arg2-value)))
      (implies (and (c::binop-purep op)
                    (c::binop-strictp op)
                    (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (not (c::errorp new-arg2-result))
                    (equal old-arg1-value new-arg1-value)
                    (equal old-arg2-value new-arg2-value)
                    (c::type-nonchar-integerp type1)
                    (c::type-nonchar-integerp type2))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value)
                           (cond ((member-equal (c::binop-kind op)
                                                '(:mul :div :rem :add :sub
                                                  :bitand :bitxor :bitior))
                                  (c::uaconvert-types type1 type2))
                                 ((member-equal (c::binop-kind op)
                                                '(:shl :shr))
                                  (c::promote-type type1))
                                 (t (c::type-sint)))))))
    :expand ((c::exec-expr-pure (c::expr-binary op old-arg1 old-arg2) compst)
             (c::exec-expr-pure (c::expr-binary op new-arg1 new-arg2) compst))
    :disable ((:e c::type-sint))
    :enable (c::binop-purep
             c::binop-strictp
             c::exec-binary-strict-pure
             c::eval-binary-strict-pure
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logand-first-congruence
    (b* ((old (c::expr-binary (c::binop-logand) old-arg1 old-arg2))
         (new (c::expr-binary (c::binop-logand) new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (equal old-arg1-value new-arg1-value)
                    (c::type-nonchar-integerp type1)
                    (not (c::test-value old-arg1-value)))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) (c::type-sint)))))
    :expand ((c::exec-expr-pure (c::expr-binary '(:logand) old-arg1 old-arg2)
                                compst)
             (c::exec-expr-pure (c::expr-binary '(:logand) new-arg1 new-arg2)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logand-second-congruence
    (b* ((old (c::expr-binary (c::binop-logand) old-arg1 old-arg2))
         (new (c::expr-binary (c::binop-logand) new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (old-arg2-result (c::exec-expr-pure old-arg2 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (new-arg2-result (c::exec-expr-pure new-arg2 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (old-arg2-value (c::expr-value->value old-arg2-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (new-arg2-value (c::expr-value->value new-arg2-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value))
         (type2 (c::type-of-value old-arg2-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (not (c::errorp new-arg2-result))
                    (equal old-arg1-value new-arg1-value)
                    (equal old-arg2-value new-arg2-value)
                    (c::type-nonchar-integerp type1)
                    (c::type-nonchar-integerp type2)
                    (c::test-value old-arg1-value))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) (c::type-sint)))))
    :expand ((c::exec-expr-pure (c::expr-binary '(:logand) old-arg1 old-arg2)
                                compst)
             (c::exec-expr-pure (c::expr-binary '(:logand) new-arg1 new-arg2)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logor-first-congruence
    (b* ((old (c::expr-binary (c::binop-logor) old-arg1 old-arg2))
         (new (c::expr-binary (c::binop-logor) new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (equal old-arg1-value new-arg1-value)
                    (c::type-nonchar-integerp type1)
                    (c::test-value old-arg1-value))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) (c::type-sint)))))
    :expand ((c::exec-expr-pure (c::expr-binary '(:logor) old-arg1 old-arg2)
                                compst)
             (c::exec-expr-pure (c::expr-binary '(:logor) new-arg1 new-arg2)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logor-second-congruence
    (b* ((old (c::expr-binary (c::binop-logor) old-arg1 old-arg2))
         (new (c::expr-binary (c::binop-logor) new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (old-arg2-result (c::exec-expr-pure old-arg2 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (new-arg2-result (c::exec-expr-pure new-arg2 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (old-arg2-value (c::expr-value->value old-arg2-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (new-arg2-value (c::expr-value->value new-arg2-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value))
         (type2 (c::type-of-value old-arg2-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (not (c::errorp new-arg2-result))
                    (equal old-arg1-value new-arg1-value)
                    (equal old-arg2-value new-arg2-value)
                    (c::type-nonchar-integerp type1)
                    (c::type-nonchar-integerp type2)
                    (not (c::test-value old-arg1-value)))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) (c::type-sint)))))
    :expand ((c::exec-expr-pure (c::expr-binary '(:logor) old-arg1 old-arg2)
                                compst)
             (c::exec-expr-pure (c::expr-binary '(:logor) new-arg1 new-arg2)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-asg-congruence
    (b* ((old (c::expr-binary (c::binop-asg) (c::expr-ident var) old-arg))
         (new (c::expr-binary (c::binop-asg) (c::expr-ident var) new-arg))
         (old-arg-result (c::exec-expr-pure old-arg compst))
         (new-arg-result (c::exec-expr-pure new-arg compst))
         (old-arg-value (c::expr-value->value old-arg-result))
         (new-arg-value (c::expr-value->value new-arg-result))
         ((mv old-result old-compst) (c::exec-expr old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-expr new compst new-fenv limit))
         (val (c::read-object (c::objdesign-of-var var compst) compst))
         (type (c::type-of-value val)))
      (implies (and (not (equal (c::expr-kind old-arg) :call))
                    (not (equal (c::expr-kind new-arg) :call))
                    (not (and (equal (c::expr-kind old-arg) :binary)
                              (equal (c::binop-kind
                                      (c::expr-binary->op old-arg))
                                     :asg)))
                    (not (and (equal (c::expr-kind new-arg) :binary)
                              (equal (c::binop-kind
                                      (c::expr-binary->op new-arg))
                                     :asg)))
                    (not (c::errorp val))
                    (c::type-nonchar-integerp type)
                    (not (c::errorp old-result))
                    (not (c::errorp new-arg-result))
                    (equal old-arg-value new-arg-value)
                    (equal (c::type-of-value old-arg-value) type))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst))))
    :expand ((c::exec-expr
              (c::expr-binary '(:asg) (c::expr-ident var) old-arg)
              compst old-fenv limit)
             (c::exec-expr
              (c::expr-binary '(:asg) (c::expr-ident var) new-arg)
              compst old-fenv limit)
             (c::exec-expr-asg (c::expr-ident var)
                               old-arg
                               compst old-fenv (+ -1 limit))
             (c::exec-expr-asg (c::expr-ident var)
                               new-arg
                               compst new-fenv (+ -1 limit)))
    :enable (c::exec-expr
             c::exec-expr-asg
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp)
    :use (:instance
          lemma
          (val1 (c::read-object (c::objdesign-of-var var compst) compst))
          (val2 (c::expr-value->value (c::exec-expr-pure old-arg compst))))
    :prep-lemmas
    ((defruled lemma
       (implies (equal (c::type-of-value val1)
                       (c::type-of-value val2))
                (equal (c::value-integerp val1)
                       (c::value-integerp val2)))
       :enable (c::type-of-value
                c::value-integerp
                c::value-unsigned-integerp
                c::value-signed-integerp))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-true-congruence
    (b* ((old (c::expr-cond old-test old-then old-else))
         (new (c::expr-cond new-test new-then new-else))
         (old-test-result (c::exec-expr-pure old-test compst))
         (old-then-result (c::exec-expr-pure old-then compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (new-then-result (c::exec-expr-pure new-then compst))
         (old-test-value (c::expr-value->value old-test-result))
         (old-then-value (c::expr-value->value old-then-result))
         (new-test-value (c::expr-value->value new-test-result))
         (new-then-value (c::expr-value->value new-then-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type-test (c::type-of-value old-test-value))
         (type-then (c::type-of-value old-then-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-then-result))
                    (equal old-test-value new-test-value)
                    (equal old-then-value new-then-value)
                    (c::type-nonchar-integerp type-test)
                    (c::type-nonchar-integerp type-then)
                    (c::test-value old-test-value))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) type-then))))
    :expand ((c::exec-expr-pure (c::expr-cond old-test old-then old-else)
                                compst)
             (c::exec-expr-pure (c::expr-cond new-test new-then new-else)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-false-congruence
    (b* ((old (c::expr-cond old-test old-then old-else))
         (new (c::expr-cond new-test new-then new-else))
         (old-test-result (c::exec-expr-pure old-test compst))
         (old-else-result (c::exec-expr-pure old-else compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (new-else-result (c::exec-expr-pure new-else compst))
         (old-test-value (c::expr-value->value old-test-result))
         (old-else-value (c::expr-value->value old-else-result))
         (new-test-value (c::expr-value->value new-test-result))
         (new-else-value (c::expr-value->value new-else-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type-test (c::type-of-value old-test-value))
         (type-else (c::type-of-value old-else-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-else-result))
                    (equal old-test-value new-test-value)
                    (equal old-else-value new-else-value)
                    (c::type-nonchar-integerp type-test)
                    (c::type-nonchar-integerp type-else)
                    (not (c::test-value old-test-value)))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) type-else))))
    :expand ((c::exec-expr-pure (c::expr-cond old-test old-then old-else)
                                compst)
             (c::exec-expr-pure (c::expr-cond new-test new-then new-else)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled initer-single-pure-congruence
    (b* ((old (c::initer-single old-expr))
         (new (c::initer-single new-expr))
         (old-expr-result (c::exec-expr-pure old-expr compst))
         (new-expr-result (c::exec-expr-pure new-expr compst))
         (old-expr-value (c::expr-value->value old-expr-result))
         (new-expr-value (c::expr-value->value new-expr-result))
         ((mv old-result old-compst)
          (c::exec-initer old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-initer new compst new-fenv limit))
         (type (c::type-of-value old-expr-value)))
      (implies (and (not (equal (c::expr-kind old-expr) :call))
                    (not (equal (c::expr-kind new-expr) :call))
                    (not (and (equal (c::expr-kind old-expr) :binary)
                              (equal (c::binop-kind
                                      (c::expr-binary->op old-expr))
                                     :asg)))
                    (not (and (equal (c::expr-kind new-expr) :binary)
                              (equal (c::binop-kind
                                      (c::expr-binary->op new-expr))
                                     :asg)))
                    (not (c::errorp old-result))
                    (not (c::errorp new-expr-result))
                    (equal old-expr-value new-expr-value)
                    (c::type-nonchar-integerp type))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (equal (c::init-type-of-init-value old-result)
                           (c::init-type-single type)))))
    :expand ((c::exec-initer (c::initer-single old-expr) compst old-fenv limit)
             (c::exec-initer (c::initer-single new-expr) compst new-fenv limit))
    :enable (c::exec-expr
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp
             c::init-type-of-init-value))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-null-congruence
    (b* ((old (c::stmt-null))
         (new (c::stmt-null))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit)))
      (implies (not (c::errorp old-result))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :enable c::exec-stmt)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-expr-congruence
    (b* ((old (c::stmt-expr old-expr))
         (new (c::stmt-expr new-expr))
         ((mv old-expr-result old-expr-compst)
          (c::exec-expr old-expr compst old-fenv (- limit 1)))
         ((mv new-expr-result new-expr-compst)
          (c::exec-expr new-expr compst new-fenv (- limit 1)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-expr-result new-expr-result)
                    (equal old-expr-compst new-expr-compst))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :expand ((c::exec-stmt (c::stmt-expr old-expr) compst old-fenv limit)
             (c::exec-stmt (c::stmt-expr new-expr) compst new-fenv limit)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-return-value-congruence
    (b* ((old (c::stmt-return old-expr))
         (new (c::stmt-return new-expr))
         (old-expr-result (c::exec-expr-pure old-expr compst))
         (new-expr-result (c::exec-expr-pure new-expr compst))
         (old-expr-value (c::expr-value->value old-expr-result))
         (new-expr-value (c::expr-value->value new-expr-result))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-expr-value)))
      (implies (and old-expr
                    new-expr
                    (not (equal (c::expr-kind old-expr) :call))
                    (not (equal (c::expr-kind new-expr) :call))
                    (not (and (equal (c::expr-kind old-expr) :binary)
                              (equal (c::binop-kind
                                      (c::expr-binary->op old-expr))
                                     :asg)))
                    (not (and (equal (c::expr-kind new-expr) :binary)
                              (equal (c::binop-kind
                                      (c::expr-binary->op new-expr))
                                     :asg)))
                    (not (c::errorp old-result))
                    (not (c::errorp new-expr-result))
                    (equal old-expr-value new-expr-value)
                    (c::type-nonchar-integerp type))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (equal (c::stmt-value-kind old-result) :return)
                    (c::stmt-value-return->value? old-result)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert type nil)))))
    :expand ((c::exec-stmt (c::stmt-return old-expr) compst old-fenv limit)
             (c::exec-stmt (c::stmt-return new-expr) compst new-fenv limit))
    :enable (c::exec-expr
             c::type-of-value
             c::apconvert-expr-value-when-not-array
             c::type-nonchar-integerp
             c::type-option-of-stmt-value
             c::type-of-value-option
             c::value-option-some->val))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-return-novalue-congruence
    (b* ((old (c::stmt-return nil))
         (new (c::stmt-return nil))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit)))
      (implies (not (c::errorp old-result))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (equal (c::stmt-value-kind old-result) :return)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert (c::type-void) nil)))))
    :enable c::exec-stmt)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-true-congruence
    (b* ((old (c::stmt-if old-test old-then))
         (new (c::stmt-if new-test new-then))
         (old-test-result (c::exec-expr-pure old-test compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (old-test-value (c::expr-value->value old-test-result))
         (new-test-value (c::expr-value->value new-test-result))
         ((mv old-then-result old-then-compst)
          (c::exec-stmt old-then compst old-fenv (1- limit)))
         ((mv new-then-result new-then-compst)
          (c::exec-stmt new-then compst new-fenv (1- limit)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-test-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-then-result))
                    (equal old-test-value new-test-value)
                    (equal old-then-result new-then-result)
                    (equal old-then-compst new-then-compst)
                    (c::test-value old-test-value)
                    (c::type-nonchar-integerp type)
                    (set::in (c::type-option-of-stmt-value old-then-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand ((c::exec-stmt
              (c::stmt-if old-test old-then) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-if new-test new-then) compst new-fenv limit))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-false-congruence
    (b* ((old (c::stmt-if old-test old-then))
         (new (c::stmt-if new-test new-then))
         (old-test-result (c::exec-expr-pure old-test compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (old-test-value (c::expr-value->value old-test-result))
         (new-test-value (c::expr-value->value new-test-result))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-test-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (equal old-test-value new-test-value)
                    (not (c::test-value old-test-value))
                    (c::type-nonchar-integerp type))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :expand ((c::exec-stmt
              (c::stmt-if old-test old-then) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-if new-test new-then) compst new-fenv limit))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-true-congruence
    (b* ((old (c::stmt-ifelse old-test old-then old-else))
         (new (c::stmt-ifelse new-test new-then new-else))
         (old-test-result (c::exec-expr-pure old-test compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (old-test-value (c::expr-value->value old-test-result))
         (new-test-value (c::expr-value->value new-test-result))
         ((mv old-then-result old-then-compst)
          (c::exec-stmt old-then compst old-fenv (1- limit)))
         ((mv new-then-result new-then-compst)
          (c::exec-stmt new-then compst new-fenv (1- limit)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-test-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-then-result))
                    (equal old-test-value new-test-value)
                    (equal old-then-result new-then-result)
                    (equal old-then-compst new-then-compst)
                    (c::test-value old-test-value)
                    (c::type-nonchar-integerp type)
                    (set::in (c::type-option-of-stmt-value old-then-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand ((c::exec-stmt
              (c::stmt-ifelse old-test old-then old-else) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-ifelse new-test new-then new-else) compst new-fenv limit))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-false-congruence
    (b* ((old (c::stmt-ifelse old-test old-then old-else))
         (new (c::stmt-ifelse new-test new-then new-else))
         (old-test-result (c::exec-expr-pure old-test compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (old-test-value (c::expr-value->value old-test-result))
         (new-test-value (c::expr-value->value new-test-result))
         ((mv old-else-result old-else-compst)
          (c::exec-stmt old-else compst old-fenv (1- limit)))
         ((mv new-else-result new-else-compst)
          (c::exec-stmt new-else compst new-fenv (1- limit)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-test-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-else-result))
                    (equal old-test-value new-test-value)
                    (equal old-else-result new-else-result)
                    (equal old-else-compst new-else-compst)
                    (not (c::test-value old-test-value))
                    (c::type-nonchar-integerp type)
                    (set::in (c::type-option-of-stmt-value old-else-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand ((c::exec-stmt
              (c::stmt-ifelse old-test old-then old-else) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-ifelse new-test new-then new-else) compst new-fenv limit))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-compound-congruence
    (b* ((old (c::stmt-compound old-items))
         (new (c::stmt-compound new-items))
         (compst1 (c::enter-scope compst))
         ((mv old-items-result old-items-compst)
          (c::exec-block-item-list old-items compst1 old-fenv (1- limit)))
         ((mv new-items-result new-items-compst)
          (c::exec-block-item-list new-items compst1 new-fenv (1- limit)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-items-result new-items-result)
                    (equal old-items-compst new-items-compst)
                    (set::in (c::type-option-of-stmt-value old-items-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand ((c::exec-stmt (c::stmt-compound old-items) compst old-fenv limit)
             (c::exec-stmt (c::stmt-compound new-items) compst new-fenv limit)))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled decl-decl-congruence
    (b* ((declor (c::obj-declor-ident var))
         (old (c::obj-declon (c::scspecseq-none) tyspecs declor old-initer))
         (new (c::obj-declon (c::scspecseq-none) tyspecs declor new-initer))
         ((mv old-init-value old-init-compst)
          (c::exec-initer old-initer compst old-fenv (1- limit)))
         ((mv new-init-value new-init-compst)
          (c::exec-initer new-initer compst new-fenv (1- limit)))
         (old-compst (c::exec-obj-declon old compst old-fenv limit))
         (new-compst (c::exec-obj-declon new compst new-fenv limit)))
      (implies (and old-initer
                    new-initer
                    (not (c::errorp old-compst))
                    (equal old-init-value new-init-value)
                    (equal old-init-compst new-init-compst))
               (and (not (c::errorp new-compst))
                    (equal old-compst new-compst))))
    :expand ((c::exec-obj-declon
              (c::obj-declon
               '(:none) tyspecs (c::obj-declor-ident var) old-initer)
              compst old-fenv limit)
             (c::exec-obj-declon
              (c::obj-declon
               '(:none) tyspecs (c::obj-declor-ident var) new-initer)
              compst new-fenv limit))
    :enable (c::obj-declon-to-ident+scspec+tyname+init))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-stmt-congruence
    (b* ((old (c::block-item-stmt old-stmt))
         (new (c::block-item-stmt new-stmt))
         ((mv old-stmt-result old-stmt-compst)
          (c::exec-stmt old-stmt compst old-fenv (1- limit)))
         ((mv new-stmt-result new-stmt-compst)
          (c::exec-stmt new-stmt compst new-fenv (1- limit)))
         ((mv old-result old-compst)
          (c::exec-block-item old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-stmt-result new-stmt-result)
                    (equal old-stmt-compst new-stmt-compst)
                    (set::in (c::type-option-of-stmt-value old-stmt-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand
    ((c::exec-block-item (c::block-item-stmt old-stmt) compst old-fenv limit)
     (c::exec-block-item (c::block-item-stmt new-stmt) compst new-fenv limit)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-decl-congruence
    (b* ((old (c::block-item-declon old-declon))
         (new (c::block-item-declon new-declon))
         (old-declon-compst
          (c::exec-obj-declon old-declon compst old-fenv (1- limit)))
         (new-declon-compst
          (c::exec-obj-declon new-declon compst new-fenv (1- limit)))
         ((mv old-result old-compst)
          (c::exec-block-item old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-declon-compst new-declon-compst))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :expand ((c::exec-block-item
              (c::block-item-declon old-declon) compst old-fenv limit)
             (c::exec-block-item
              (c::block-item-declon new-declon) compst new-fenv limit)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-empty-congruence
    (b* ((old nil)
         (new nil)
         ((mv old-result old-compst)
          (c::exec-block-item-list old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item-list new compst new-fenv limit)))
      (implies (not (c::errorp old-result))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :enable c::exec-block-item-list)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-first-congruence
    (b* ((old (cons old-item old-items))
         (new (cons new-item new-items))
         ((mv old-item-result old-item-compst)
          (c::exec-block-item old-item compst old-fenv (1- limit)))
         ((mv new-item-result new-item-compst)
          (c::exec-block-item new-item compst new-fenv (1- limit)))
         ((mv old-result old-compst)
          (c::exec-block-item-list old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item-list new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-item-result new-item-result)
                    (equal old-item-compst new-item-compst)
                    (equal (c::stmt-value-kind old-item-result) :return)
                    (set::in (c::type-option-of-stmt-value old-item-result)
                             first-types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::union (set::delete nil first-types)
                                         rest-types)))))
    :expand ((c::exec-block-item-list
              (cons old-item old-items) compst old-fenv limit)
             (c::exec-block-item-list
              (cons new-item new-items) compst new-fenv limit))
    :enable c::type-option-of-stmt-value)

  ;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-rest-congruence
    (b* ((old (cons old-item old-items))
         (new (cons new-item new-items))
         ((mv old-item-result old-item-compst)
          (c::exec-block-item old-item compst old-fenv (1- limit)))
         ((mv new-item-result new-item-compst)
          (c::exec-block-item new-item compst new-fenv (1- limit)))
         ((mv old-items-result old-items-compst)
          (c::exec-block-item-list
           old-items old-item-compst old-fenv (1- limit)))
         ((mv new-items-result new-items-compst)
          (c::exec-block-item-list
           new-items new-item-compst new-fenv (1- limit)))
         ((mv old-result old-compst)
          (c::exec-block-item-list old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item-list new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-item-result new-item-result)
                    (equal old-items-result new-items-result)
                    (equal old-item-compst new-item-compst)
                    (equal old-items-compst new-items-compst)
                    (equal (c::stmt-value-kind old-item-result) :none)
                    (set::in (c::type-option-of-stmt-value old-item-result)
                             first-types)
                    (set::in (c::type-option-of-stmt-value old-items-result)
                             rest-types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::union (set::delete nil first-types)
                                         rest-types)))))
    :expand ((c::exec-block-item-list
              (cons old-item old-items) compst old-fenv limit)
             (c::exec-block-item-list
              (cons new-item new-items) compst new-fenv limit))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection exec-error-theorems
  :short "Error theorems about execution."
  :long
  (xdoc::topstring
   (xdoc::p
    "These theorems say that
     if the execution of a sub-construct yields an error,
     so does the execution of the super-construct.")
   (xdoc::p
    "Transformations use these theorems in proof generation
     to actually show that if the super-construct does not yield an error,
     neither do its sub-constructs."))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-unary-errors
    (implies (c::errorp (c::exec-expr-pure arg compst))
             (c::errorp (c::exec-expr-pure (c::expr-unary op arg) compst)))
    :expand (c::exec-expr-pure (c::expr-unary op arg) compst))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cast-errors
    (implies (c::errorp (c::exec-expr-pure arg compst))
             (c::errorp (c::exec-expr-pure (c::expr-cast tyname arg) compst)))
    :expand ((c::exec-expr-pure (c::expr-cast tyname arg) compst)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-pure-strict-errors
    (implies (and (c::binop-strictp op)
                  (or (c::errorp (c::exec-expr-pure arg1 compst))
                      (c::errorp (c::exec-expr-pure arg2 compst))))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary op arg1 arg2) compst)))
    :expand (c::exec-expr-pure (c::expr-binary op arg1 arg2) compst)
    :enable c::binop-strictp)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logand-first-errors
    (implies (c::errorp (c::exec-expr-pure arg1 compst))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary (c::binop-logand) arg1 arg2)
                                 compst)))
    :expand (c::exec-expr-pure (c::expr-binary '(:logand) arg1 arg2) compst))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logand-second-errors
    (implies (and (not (c::errorp (c::exec-expr-pure arg1 compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure arg1 compst))))
                  (c::test-value
                   (c::expr-value->value (c::exec-expr-pure arg1 compst)))
                  (c::errorp (c::exec-expr-pure arg2 compst)))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary (c::binop-logand) arg1 arg2)
                                 compst)))
    :expand (c::exec-expr-pure (c::expr-binary '(:logand) arg1 arg2) compst)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logor-first-errors
    (implies (c::errorp (c::exec-expr-pure arg1 compst))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary (c::binop-logor) arg1 arg2)
                                 compst)))
    :expand (c::exec-expr-pure (c::expr-binary '(:logor) arg1 arg2) compst))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logor-second-errors
    (implies (and (not (c::errorp (c::exec-expr-pure arg1 compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure arg1 compst))))
                  (not (c::test-value
                        (c::expr-value->value (c::exec-expr-pure arg1 compst))))
                  (c::errorp (c::exec-expr-pure arg2 compst)))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary (c::binop-logor) arg1 arg2)
                                 compst)))
    :expand (c::exec-expr-pure (c::expr-binary '(:logor) arg1 arg2) compst)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-asg-errors
    (implies (and (not (equal (c::expr-kind expr) :call))
                  (not (and (equal (c::expr-kind expr) :binary)
                            (equal (c::binop-kind (c::expr-binary->op expr))
                                   :asg)))
                  (or (c::errorp (c::exec-expr-pure (c::expr-ident var) compst))
                      (c::errorp (c::exec-expr-pure expr compst))))
             (c::errorp
              (mv-nth 0 (c::exec-expr
                         (c::expr-binary
                          (c::binop-asg) (c::expr-ident var) expr)
                         compst fenv limit))))
    :expand ((c::exec-expr (c::expr-binary '(:asg) (c::expr-ident var) expr)
                           compst fenv limit)
             (c::exec-expr-asg (c::expr-ident var) expr compst fenv (1- limit)))
    :enable c::exec-expr)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-test-errors
    (implies (c::errorp (c::exec-expr-pure test compst))
             (c::errorp
              (c::exec-expr-pure (c::expr-cond test then else) compst)))
    :expand (c::exec-expr-pure (c::expr-cond test then else) compst))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-then-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::test-value
                   (c::expr-value->value (c::exec-expr-pure test compst)))
                  (c::errorp (c::exec-expr-pure then compst)))
             (c::errorp
              (c::exec-expr-pure (c::expr-cond test then else) compst)))
    :expand (c::exec-expr-pure (c::expr-cond test then else) compst)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-else-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (not (c::test-value
                        (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::errorp (c::exec-expr-pure else compst)))
             (c::errorp
              (c::exec-expr-pure (c::expr-cond test then else) compst)))
    :expand (c::exec-expr-pure (c::expr-cond test then else) compst)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled initer-single-pure-errors
    (implies (and (not (equal (c::expr-kind expr) :call))
                  (not (and (equal (c::expr-kind expr) :binary)
                            (equal (c::binop-kind (c::expr-binary->op expr))
                                   :asg)))
                  (c::errorp (c::exec-expr-pure expr compst)))
             (c::errorp
              (mv-nth 0 (c::exec-initer
                         (c::initer-single expr) compst fenv limit))))
    :expand (c::exec-initer (c::initer-single expr) compst fenv limit)
    :enable c::exec-expr)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-expr-errors
    (implies (c::errorp
              (mv-nth 0 (c::exec-expr expr compst fenv (- limit 1))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt (c::stmt-expr expr) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-expr expr) compst fenv limit)
    :enable c::exec-expr)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-return-errors
    (implies (and expr
                  (not (equal (c::expr-kind expr) :call))
                  (not (and (equal (c::expr-kind expr) :binary)
                            (equal (c::binop-kind (c::expr-binary->op expr))
                                   :asg)))
                  (c::errorp (c::exec-expr-pure expr compst)))
             (c::errorp
              (mv-nth 0 (c::exec-stmt (c::stmt-return expr)
                                      compst
                                      fenv
                                      limit))))
    :expand (c::exec-stmt (c::stmt-return expr) compst fenv limit)
    :enable c::exec-expr)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-test-errors
    (implies (c::errorp (c::exec-expr-pure test compst))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-if test then) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-if test then) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-then-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::test-value
                   (c::expr-value->value (c::exec-expr-pure test compst)))
                  (c::errorp
                   (mv-nth 0 (c::exec-stmt then compst fenv (1- limit)))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-if test then) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-if test then) compst fenv limit)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-test-errors
    (implies (c::errorp (c::exec-expr-pure test compst))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-ifelse test then else) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-ifelse test then else) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-then-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::test-value
                   (c::expr-value->value (c::exec-expr-pure test compst)))
                  (c::errorp
                   (mv-nth 0 (c::exec-stmt then compst fenv (1- limit)))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-ifelse test then else) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-ifelse test then else) compst fenv limit)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-else-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (not
                   (c::test-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::errorp
                   (mv-nth 0 (c::exec-stmt else compst fenv (1- limit)))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-ifelse test then else) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-ifelse test then else) compst fenv limit)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-compound-errors
    (implies (c::errorp
              (mv-nth 0 (c::exec-block-item-list
                         items (c::enter-scope compst) fenv (1- limit))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-compound items) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-compound items) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled decl-decl-errors
    (b* ((declor (c::obj-declor-ident var))
         (declon (c::obj-declon (c::scspecseq-none) tyspecs declor initer)))
      (implies (and initer
                    (c::errorp
                     (mv-nth 0 (c::exec-initer
                                initer compst fenv (1- limit)))))
               (c::errorp (c::exec-obj-declon declon compst fenv limit))))
    :expand (c::exec-obj-declon
             (c::obj-declon
              '(:none) tyspecs (c::obj-declor-ident var) initer)
             compst fenv limit)
    :enable c::obj-declon-to-ident+scspec+tyname+init)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-stmt-errors
    (implies (c::errorp (mv-nth 0 (c::exec-stmt stmt compst fenv (1- limit))))
             (c::errorp
              (mv-nth 0 (c::exec-block-item
                         (c::block-item-stmt stmt) compst fenv limit))))
    :expand (c::exec-block-item (c::block-item-stmt stmt) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-decl-errors
    (implies (c::errorp (c::exec-obj-declon declon compst fenv (1- limit)))
             (c::errorp (mv-nth 0 (c::exec-block-item
                                   (c::block-item-declon declon)
                                   compst fenv limit))))
    :expand (c::exec-block-item
             (c::block-item-declon declon) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-first-errors
    (implies (c::errorp
              (mv-nth 0 (c::exec-block-item item compst fenv (1- limit))))
             (c::errorp
              (mv-nth 0 (c::exec-block-item-list
                         (cons item items) compst fenv limit))))
    :expand (c::exec-block-item-list (cons item items) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-rest-errors
    (b* (((mv result compst1) (c::exec-block-item item compst fenv (1- limit))))
      (implies (and (not (c::errorp result))
                    (equal (c::stmt-value-kind result) :none)
                    (c::errorp (mv-nth 0 (c::exec-block-item-list
                                          items compst1 fenv (1- limit)))))
               (c::errorp
                (mv-nth 0 (c::exec-block-item-list
                           (cons item items) compst fenv limit)))))
    :expand (c::exec-block-item-list (cons item items) compst fenv limit)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection exec-loop-theorems
  :short "Theorems about loop execution."
  :long
  (xdoc::topstring
   (xdoc::p
    "Loops need theorems similar to
     the congruence theorems in @(see exec-congruence-theorems),
     but since they involve proofs by induction,
     those theorems also combine the equivalent of
     the errors theorems in @(see exec-error-theorems)
     and the variable theorems in @(see exec-compustate-vars-theorems),
     because those facts participate in the induction.
     This is why we use the generic term @('exec-loop-theorems') here.")
   (xdoc::p
    "For now we only support @('while') loops,
     but other kinds of loops should be analogous.")
   (xdoc::p
    "The starting point to understand these theorems and their proofs
     is that we want something like the aforementioned congruence theorems:
     if the execution of the old test and new test are equivalent,
     and the execution of the old body and new body are equivalent,
     then the execution of the old loop and new loop are equivalent.
     But the execution of the loop may take zero or more iterations,
     so the proof is by induction.")
   (xdoc::p
    "Although @(tsee c::exec-stmt-while) has a recursive structure,
     it is mutually recursive with the other execution functions.
     Additionally, @(tsee c::exec-stmt-while) operates
     on a single test and body of a single loop,
     while here we have two loops (and tests and bodies).
     So we need a custom induction induction scheme,
     captured by the function @('while-induct') below,
     which has a singly recursive structure
     similar to @(tsee c::exec-stmt-while),
     but involving two tests and bodies,
     and also two function environments.
     But it has only one computation state,
     because the idea behind the congruence is that
     the two loops start in the same computation states,
     and stay in the same computation states.
     We ``force'' this equality, as well as the equality of the tests,
     by stopping the recursion in @('while-induct')
     if those are not equal.
     We also need a single limit,
     because the two executions are synchronized.
     The recursion of @('while-induct') stops as soon as
     some of the early-exit tests in @(tsee c::exec-stmt-while) fails.
     The only difference with @(tsee c::exec-stmt-while) is that
     we avoid the array-to-pointer conversion and its check
     by checking that the test yields an integer value.")
   (xdoc::p
    "The congruence theorems in @(see exec-congruence-theorems)
     have hypotheses about the execution of
     the sub-constructs of the construct of interest,
     starting with the same computation state @('compst'),
     and possibly involving a second computation state
     between the execution of a sub-construct
     and the execution of another sub-construct
     (e.g. see @('block-item-list-cons-rest-congruence')).
     If we attempted to do the same for loops,
     with test and body as the sub-constructs,
     we would run into trouble with the induction hypothesis,
     which would involve different computation states.
     Intuitively, the issue is that we want to show that
     the executions of the two loops remain ``synchronized''
     for a variable number of iterations,
     i.e. not just starting from the @('compst') computation state
     at the beginning of the loop.
     What we need is the fact that the executions of the tests and bodies
     are equivalent for every possible starting computation state,
     not just the specific @('compst') used in the theorem we want to prove.
     Indeed, in the bottom-up proof of theorems in our transformations,
     the equivalence theorems proved for tests and bodies
     are implicitly universally quantified.
     But we need to explicate the universal quantification
     in the hypotheses of the theorem we want to prove here.")
   (xdoc::p
    "This justifies the universally quantified predicate @('while-hyp')
     defined below, whose name indicates that it is used as hypothesis,
     in the theorem we want to prove about loops.
     The predicate states, for all possible computation states and limits,
     the equivalence of the test and of the bodies.
     Since, in general, our generated theorems include hypotheses
     about certain variables in the computation state with certain types,
     we parameterize the predicate over a map from identifiers to types,
     to capture such variables and their types.
     We use @(tsee c::compustate-has-vars-with-types-p),
     with that variable-type map,
     as both a hypothesis and a conclusion of the quantified predicate:
     the hypothesis is needed to show the satisfaction of the predicate
     (in the theorems generated by the transformation),
     and the conclusion is needed to support the induction.
     The quantified predicate is also parameterized by
     the set of optional types that can be returned by the loop bodies.")
   (xdoc::p
    "With @('while-hyp') as hypothesis,
     we can prove, by induction,
     the desired theorem about @(tsee c::exec-stmt-while).
     We need a few rules to handle the array-to-pointer conversion,
     but the proof hints are otherwise unremarkable.
     The @('while-hyp-necc') theorem is instantiated
     for the induction hypothesis.
     Note that the theorem has @(tsee c::compustate-has-vars-with-types-p)
     as both hypothesis and conclusion, matching @('while-hyp').")
   (xdoc::p
    "From the theorem about @(tsee c::exec-stmt-while),
     we prove the desired one, about @(tsee c::exec-stmt)
     applied to a @('while') loop.
     This already includes the conclusion about
     the variables in the computation state with certain types,
     and it also handles the errors.
     This is why, we noted earlier,
     it is more than the congruence theorems for non-loop constructs,
     which have separate theorems for handling errors and variables.")
   (xdoc::p
    "The theorems proved here make no claims about the loop terminating.
     The theorems say that, if the loop terminates,
     then it yields equivalent results for old and new code.
     If the loop fails to terminate,
     @(tsee c::exec-stmt-while), and thus @(tsee c::exec-stmt)
     returns an error due to the limit being exhausted,
     but the theorems deny that as hypothesis."))

  (defund while-induct (old-test
                        new-test
                        old-body
                        new-body
                        old-fenv
                        new-fenv
                        compst
                        limit)
    (declare (xargs :measure (nfix limit)
                    :hints (("Goal" :in-theory (enable nfix o< o-finp)))))
    (b* (((when (zp limit)) nil)
         (old-test-eval (c::exec-expr-pure old-test compst))
         ((when (c::errorp old-test-eval)) nil)
         (new-test-eval (c::exec-expr-pure new-test compst))
         ((when (c::errorp new-test-eval)) nil)
         (old-test-val (c::expr-value->value old-test-eval))
         ((unless (c::type-nonchar-integerp (c::type-of-value old-test-val)))
          nil)
         (new-test-val (c::expr-value->value new-test-eval))
         ((unless (c::type-nonchar-integerp (c::type-of-value new-test-val)))
          nil)
         ((unless (equal old-test-val new-test-val)) nil)
         (old-continuep (c::test-value old-test-val))
         ((when (c::errorp old-continuep)) nil)
         (new-continuep (c::test-value new-test-val))
         ((when (c::errorp new-continuep)) nil)
         ((when (not old-continuep)) nil)
         ((when (not new-continuep)) nil)
         ((mv old-sval old-compst)
          (c::exec-stmt old-body compst old-fenv (1- limit)))
         ((when (c::errorp old-sval)) nil)
         ((mv new-sval new-compst)
          (c::exec-stmt new-body compst new-fenv (1- limit)))
         ((when (c::errorp new-sval)) nil)
         ((when (c::stmt-value-case old-sval :return)) nil)
         ((when (c::stmt-value-case new-sval :return)) nil)
         ((unless (equal old-compst new-compst)) nil))
      (while-induct old-test
                    new-test
                    old-body
                    new-body
                    old-fenv
                    new-fenv
                    old-compst
                    (1- limit))))

  (defund-sk while-hyp (old-test
                        new-test
                        old-body
                        new-body
                        old-fenv
                        new-fenv
                        types
                        vartys)
    (forall
     (compst limit)
     (b* ((old-test-result (c::exec-expr-pure old-test compst))
          (new-test-result (c::exec-expr-pure new-test compst))
          (old-test-value (c::expr-value->value old-test-result))
          (new-test-value (c::expr-value->value new-test-result))
          ((mv old-body-result old-body-compst)
           (c::exec-stmt old-body compst old-fenv limit))
          ((mv new-body-result new-body-compst)
           (c::exec-stmt new-body compst new-fenv limit)))
       (implies (and (> (c::compustate-frames-number compst) 0)
                     (c::compustate-has-vars-with-types-p vartys compst))
                (and (implies (not (c::errorp old-test-result))
                              (and (not (c::errorp new-test-result))
                                   (equal old-test-value new-test-value)
                                   (c::type-nonchar-integerp
                                    (c::type-of-value old-test-value))))
                     (implies (not (c::errorp old-body-result))
                              (and (not (c::errorp new-body-result))
                                   (equal old-body-result new-body-result)
                                   (equal old-body-compst new-body-compst)
                                   (set::in
                                    (c::type-option-of-stmt-value
                                     old-body-result)
                                    types)
                                   (c::compustate-has-vars-with-types-p
                                    vartys old-body-compst))))))))

  (defruled stmt-while-loop-theorem
    (b* (((mv old-result old-compst)
          (c::exec-stmt-while old-test old-body compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-stmt-while new-test new-body compst new-fenv limit)))
      (implies (and (> (c::compustate-frames-number compst) 0)
                    (c::compustate-has-vars-with-types-p vartys compst)
                    (while-hyp old-test
                               new-test
                               old-body
                               new-body
                               old-fenv
                               new-fenv
                               types
                               vartys)
                    (not (c::errorp old-result)))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil types))
                    (c::compustate-has-vars-with-types-p vartys old-compst))))
    :induct (while-induct old-test
                          new-test
                          old-body
                          new-body
                          old-fenv
                          new-fenv
                          compst
                          limit)
    :enable (while-induct
             c::exec-stmt-while
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp)
    :hints ('(:use (:instance while-hyp-necc (limit (1- limit))))))

  (defruled stmt-while-theorem
    (b* ((old (c::stmt-while old-test old-body))
         (new (c::stmt-while new-test new-body))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit)))
      (implies (and (> (c::compustate-frames-number compst) 0)
                    (c::compustate-has-vars-with-types-p vartys compst)
                    (while-hyp old-test
                               new-test
                               old-body
                               new-body
                               old-fenv
                               new-fenv
                               types
                               vartys)
                    (not (c::errorp old-result)))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil types))
                    (c::compustate-has-vars-with-types-p vartys old-compst))))
    :expand ((c::exec-stmt
              (c::stmt-while old-test old-body) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-while new-test new-body) compst new-fenv limit))
    :use (:instance stmt-while-loop-theorem (limit (1- limit)))))
