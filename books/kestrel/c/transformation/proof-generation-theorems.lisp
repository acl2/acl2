; C Library
;
; Copyright (C) 2025 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Alessandro Coglio (www.alessandrocoglio.info)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "C2C")

(include-book "proof-generation")

(local (include-book "kestrel/built-ins/disable" :dir :system))
(local (acl2::disable-most-builtin-logic-defuns))
(local (acl2::disable-builtin-rewrite-rules-for-defaults))
(set-induction-depth-limit 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ proof-generation-theorems
  :parents (transformation-tools)
  :short "Theorems supporting proof generation."
  :long
  (xdoc::topstring
   (xdoc::p
    "The proof hints generated by transformations
     reference the general theorems that we collect here."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection exec-congruence-theorems
  :short "Congruence theorems about execution."
  :long
  (xdoc::topstring
   (xdoc::p
    "These are not congruence rules in the ACL2 technical sense,
     but they are theorems expressing congruence-like properties:
     given two constructs (before and after a transformation, i.e. old and new),
     if the executions of their sub-constucts are equivalent,
     then the executions of the super-constructa are equivalent.
     Here `equivalent' means the following:
     if the execution of the old construct does not yield an error,
     neither does the execution of the new construct,
     and the two return the same results.")
   (xdoc::p
    "The theorems make use of @(tsee b*) bindings
     to keep them more readable.
     The theorems include additional hypotheses, in some cases,
     to ensure that the constructs in question are amenable to
     our formal dynamic semantics of C, which currently only covers a subset.")
   (xdoc::p
    "The theorems include hypotheses about
     the execution of the old construct not yielding an error,
     and in some cases about
     the execution of the sub-constructs of the new construct
     (not the new construct itself) not yielding an error);
     they also include hypotheses about
     the sub-constructs yielding the same results.
     While in some cases the equality of the results of the sub-constructs
     and the hypotheses that the old construct does not yield an error
     imply already that the sub-constructs do not yield an error
     (also see @(see exec-error-theorems)),
     this is not quite the case for (pure) expressions,
     which return expression values of type @(tsee c::expr-value).
     For flexibility, the theorems require the equality, for sub-expressions,
     not of their full expression values,
     but just for the values of those expression values
     (i.e. @(tsee expr-value->value)).
     Thus, we need explicit hypotheses that
     the expression values are not errors,
     because they are not readily implied by the equality of
     the values alone of the expression values.
     The flexibility is important, for instance,
     to handle the semantic equality of @('x + 0') and @('x'),
     which return different expression values (but the same values),
     because @('x') is an lvalue while @('x + 0') is not.")
   (xdoc::p
    "The theorems conclude that the new construct's execution
     does not yield an error either,
     and that its results are the same as the old construct's execution's.
     When these theorems are used in proof generation,
     the hypotheses about the new sub-constructs not yielding errors
     and about them returning the same results as the old ones
     are established via the proofs generated for the sub-constructs;
     and the conclusions serve for larger constructs, compositionally.")
   (xdoc::p
    "For non-strict constructs,
     we have multiple theorems,
     corresponding to which sub-constructs are actually executed.")
   (xdoc::p
    "For the C dynamic semantics execution functions
     that depend on function environments,
     we use potentially different function environments
     for the old vs. new constructs.
     We always use the same initial computation state
     for old and new constructs."))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-unary-congruence
    (b* ((old (c::expr-unary op old-arg))
         (new (c::expr-unary op new-arg))
         (old-arg-result (c::exec-expr-pure old-arg compst))
         (new-arg-result (c::exec-expr-pure new-arg compst))
         (old-arg-value (c::expr-value->value old-arg-result))
         (new-arg-value (c::expr-value->value new-arg-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type (c::type-of-value old-arg-value)))
      (implies (and (c::unop-nonpointerp op)
                    (not (c::errorp old-result))
                    (not (c::errorp new-arg-result))
                    (equal old-arg-value new-arg-value)
                    (c::type-nonchar-integerp type))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value)
                           (if (equal (c::unop-kind op) :lognot)
                               (c::type-sint)
                             (c::promote-type type))))))
    :expand ((c::exec-expr-pure (c::expr-unary op old-arg) compst)
             (c::exec-expr-pure (c::expr-unary op new-arg) compst))
    :disable ((:e c::type-sint))
    :enable (c::unop-nonpointerp
             c::exec-unary
             c::eval-unary
             c::apconvert-expr-value-when-not-array
             c::value-arithmeticp
             c::value-realp
             c::value-integerp
             c::value-signed-integerp
             c::value-unsigned-integerp
             c::value-kind-not-array-when-value-integerp)
    :prep-lemmas
    ((defrule c::lognot-value-lemma
       (implies (and (c::valuep val)
                     (member-equal (c::value-kind val)
                                   '(:uchar :schar
                                     :ushort :sshort
                                     :uint :sint
                                     :ulong :slong
                                     :ullong :sllong)))
                (equal (c::value-kind (c::lognot-value val)) :sint))
       :enable (c::lognot-value
                c::lognot-scalar-value
                c::lognot-integer-value
                c::value-scalarp
                c::value-arithmeticp
                c::value-realp
                c::value-integerp
                c::value-signed-integerp
                c::value-unsigned-integerp))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cast-congruence
    (b* ((old (c::expr-cast tyname old-arg))
         (new (c::expr-cast tyname new-arg))
         (old-arg-result (c::exec-expr-pure old-arg compst))
         (new-arg-result (c::exec-expr-pure new-arg compst))
         (old-arg-value (c::expr-value->value old-arg-result))
         (new-arg-value (c::expr-value->value new-arg-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type (c::type-of-value old-arg-value))
         (type1 (c::tyname-to-type tyname)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg-result))
                    (equal old-arg-value new-arg-value)
                    (c::type-nonchar-integerp type)
                    (c::type-nonchar-integerp type1))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value)
                           type1))))
    :expand ((c::exec-expr-pure (c::expr-cast tyname old-arg) compst)
             (c::exec-expr-pure (c::expr-cast tyname new-arg) compst))
    :enable (c::exec-cast
             c::eval-cast
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-pure-strict-congruence
    (b* ((old (c::expr-binary op old-arg1 old-arg2))
         (new (c::expr-binary op new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (old-arg2-result (c::exec-expr-pure old-arg2 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (new-arg2-result (c::exec-expr-pure new-arg2 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (old-arg2-value (c::expr-value->value old-arg2-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (new-arg2-value (c::expr-value->value new-arg2-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value))
         (type2 (c::type-of-value old-arg2-value)))
      (implies (and (c::binop-purep op)
                    (c::binop-strictp op)
                    (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (not (c::errorp new-arg2-result))
                    (equal old-arg1-value new-arg1-value)
                    (equal old-arg2-value new-arg2-value)
                    (c::type-nonchar-integerp type1)
                    (c::type-nonchar-integerp type2))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value)
                           (cond ((member-equal (c::binop-kind op)
                                                '(:mul :div :rem :add :sub
                                                  :bitand :bitxor :bitior))
                                  (c::uaconvert-types type1 type2))
                                 ((member-equal (c::binop-kind op)
                                                '(:shl :shr))
                                  (c::promote-type type1))
                                 (t (c::type-sint)))))))
    :expand ((c::exec-expr-pure (c::expr-binary op old-arg1 old-arg2) compst)
             (c::exec-expr-pure (c::expr-binary op new-arg1 new-arg2) compst))
    :disable ((:e c::type-sint))
    :enable (c::binop-purep
             c::binop-strictp
             c::exec-binary-strict-pure
             c::eval-binary-strict-pure
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logand-first-congruence
    (b* ((old (c::expr-binary (c::binop-logand) old-arg1 old-arg2))
         (new (c::expr-binary (c::binop-logand) new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (equal old-arg1-value new-arg1-value)
                    (c::type-nonchar-integerp type1)
                    (not (c::test-value old-arg1-value)))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) (c::type-sint)))))
    :expand ((c::exec-expr-pure (c::expr-binary '(:logand) old-arg1 old-arg2)
                                compst)
             (c::exec-expr-pure (c::expr-binary '(:logand) new-arg1 new-arg2)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logand-second-congruence
    (b* ((old (c::expr-binary (c::binop-logand) old-arg1 old-arg2))
         (new (c::expr-binary (c::binop-logand) new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (old-arg2-result (c::exec-expr-pure old-arg2 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (new-arg2-result (c::exec-expr-pure new-arg2 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (old-arg2-value (c::expr-value->value old-arg2-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (new-arg2-value (c::expr-value->value new-arg2-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value))
         (type2 (c::type-of-value old-arg2-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (not (c::errorp new-arg2-result))
                    (equal old-arg1-value new-arg1-value)
                    (equal old-arg2-value new-arg2-value)
                    (c::type-nonchar-integerp type1)
                    (c::type-nonchar-integerp type2)
                    (c::test-value old-arg1-value))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) (c::type-sint)))))
    :expand ((c::exec-expr-pure (c::expr-binary '(:logand) old-arg1 old-arg2)
                                compst)
             (c::exec-expr-pure (c::expr-binary '(:logand) new-arg1 new-arg2)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logor-first-congruence
    (b* ((old (c::expr-binary (c::binop-logor) old-arg1 old-arg2))
         (new (c::expr-binary (c::binop-logor) new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (equal old-arg1-value new-arg1-value)
                    (c::type-nonchar-integerp type1)
                    (c::test-value old-arg1-value))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) (c::type-sint)))))
    :expand ((c::exec-expr-pure (c::expr-binary '(:logor) old-arg1 old-arg2)
                                compst)
             (c::exec-expr-pure (c::expr-binary '(:logor) new-arg1 new-arg2)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logor-second-congruence
    (b* ((old (c::expr-binary (c::binop-logor) old-arg1 old-arg2))
         (new (c::expr-binary (c::binop-logor) new-arg1 new-arg2))
         (old-arg1-result (c::exec-expr-pure old-arg1 compst))
         (old-arg2-result (c::exec-expr-pure old-arg2 compst))
         (new-arg1-result (c::exec-expr-pure new-arg1 compst))
         (new-arg2-result (c::exec-expr-pure new-arg2 compst))
         (old-arg1-value (c::expr-value->value old-arg1-result))
         (old-arg2-value (c::expr-value->value old-arg2-result))
         (new-arg1-value (c::expr-value->value new-arg1-result))
         (new-arg2-value (c::expr-value->value new-arg2-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type1 (c::type-of-value old-arg1-value))
         (type2 (c::type-of-value old-arg2-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-arg1-result))
                    (not (c::errorp new-arg2-result))
                    (equal old-arg1-value new-arg1-value)
                    (equal old-arg2-value new-arg2-value)
                    (c::type-nonchar-integerp type1)
                    (c::type-nonchar-integerp type2)
                    (not (c::test-value old-arg1-value)))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) (c::type-sint)))))
    :expand ((c::exec-expr-pure (c::expr-binary '(:logor) old-arg1 old-arg2)
                                compst)
             (c::exec-expr-pure (c::expr-binary '(:logor) new-arg1 new-arg2)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-asg-congruence
    (b* ((old (c::expr-binary (c::binop-asg) (c::expr-ident var) old-arg))
         (new (c::expr-binary (c::binop-asg) (c::expr-ident var) new-arg))
         (old-arg-result (c::exec-expr-pure old-arg compst))
         (new-arg-result (c::exec-expr-pure new-arg compst))
         (old-arg-value (c::expr-value->value old-arg-result))
         (new-arg-value (c::expr-value->value new-arg-result))
         (old-compst (c::exec-expr-asg old compst old-fenv limit))
         (new-compst (c::exec-expr-asg new compst new-fenv limit))
         (val (c::read-object (c::objdesign-of-var var compst) compst))
         (type (c::type-of-value val)))
      (implies (and (not (equal (c::expr-kind old-arg) :call))
                    (not (equal (c::expr-kind new-arg) :call))
                    (not (c::errorp val))
                    (c::type-nonchar-integerp type)
                    (not (c::errorp old-compst))
                    (not (c::errorp new-arg-result))
                    (equal old-arg-value new-arg-value)
                    (equal (c::type-of-value old-arg-value) type))
               (and (not (c::errorp new-compst))
                    (equal old-compst new-compst))))
    :expand ((c::exec-expr-asg
              (c::expr-binary '(:asg) (c::expr-ident var) old-arg)
              compst old-fenv limit)
             (c::exec-expr-asg
              (c::expr-binary '(:asg) (c::expr-ident var) new-arg)
              compst new-fenv limit))
    :enable (c::exec-expr-call-or-pure
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp)
    :use (:instance
          lemma
          (val1 (c::read-object (c::objdesign-of-var var compst) compst))
          (val2 (c::expr-value->value (c::exec-expr-pure old-arg compst))))
    :prep-lemmas
    ((defruled lemma
       (implies (equal (c::type-of-value val1)
                       (c::type-of-value val2))
                (equal (c::value-integerp val1)
                       (c::value-integerp val2)))
       :enable (c::type-of-value
                c::value-integerp
                c::value-unsigned-integerp
                c::value-signed-integerp))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-true-congruence
    (b* ((old (c::expr-cond old-test old-then old-else))
         (new (c::expr-cond new-test new-then new-else))
         (old-test-result (c::exec-expr-pure old-test compst))
         (old-then-result (c::exec-expr-pure old-then compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (new-then-result (c::exec-expr-pure new-then compst))
         (old-test-value (c::expr-value->value old-test-result))
         (old-then-value (c::expr-value->value old-then-result))
         (new-test-value (c::expr-value->value new-test-result))
         (new-then-value (c::expr-value->value new-then-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type-test (c::type-of-value old-test-value))
         (type-then (c::type-of-value old-then-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-then-result))
                    (equal old-test-value new-test-value)
                    (equal old-then-value new-then-value)
                    (c::type-nonchar-integerp type-test)
                    (c::type-nonchar-integerp type-then)
                    (c::test-value old-test-value))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) type-then))))
    :expand ((c::exec-expr-pure (c::expr-cond old-test old-then old-else)
                                compst)
             (c::exec-expr-pure (c::expr-cond new-test new-then new-else)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-false-congruence
    (b* ((old (c::expr-cond old-test old-then old-else))
         (new (c::expr-cond new-test new-then new-else))
         (old-test-result (c::exec-expr-pure old-test compst))
         (old-else-result (c::exec-expr-pure old-else compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (new-else-result (c::exec-expr-pure new-else compst))
         (old-test-value (c::expr-value->value old-test-result))
         (old-else-value (c::expr-value->value old-else-result))
         (new-test-value (c::expr-value->value new-test-result))
         (new-else-value (c::expr-value->value new-else-result))
         (old-result (c::exec-expr-pure old compst))
         (new-result (c::exec-expr-pure new compst))
         (old-value (c::expr-value->value old-result))
         (new-value (c::expr-value->value new-result))
         (type-test (c::type-of-value old-test-value))
         (type-else (c::type-of-value old-else-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-else-result))
                    (equal old-test-value new-test-value)
                    (equal old-else-value new-else-value)
                    (c::type-nonchar-integerp type-test)
                    (c::type-nonchar-integerp type-else)
                    (not (c::test-value old-test-value)))
               (and (not (c::errorp new-result))
                    (equal old-value new-value)
                    (equal (c::type-of-value old-value) type-else))))
    :expand ((c::exec-expr-pure (c::expr-cond old-test old-then old-else)
                                compst)
             (c::exec-expr-pure (c::expr-cond new-test new-then new-else)
                                compst))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled initer-single-pure-congruence
    (b* ((old (c::initer-single old-expr))
         (new (c::initer-single new-expr))
         (old-expr-result (c::exec-expr-pure old-expr compst))
         (new-expr-result (c::exec-expr-pure new-expr compst))
         (old-expr-value (c::expr-value->value old-expr-result))
         (new-expr-value (c::expr-value->value new-expr-result))
         ((mv old-result old-compst)
          (c::exec-initer old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-initer new compst new-fenv limit))
         (type (c::type-of-value old-expr-value)))
      (implies (and (not (equal (c::expr-kind old-expr) :call))
                    (not (equal (c::expr-kind new-expr) :call))
                    (not (c::errorp old-result))
                    (not (c::errorp new-expr-result))
                    (equal old-expr-value new-expr-value)
                    (c::type-nonchar-integerp type))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (equal (c::init-type-of-init-value old-result)
                           (c::init-type-single type)))))
    :expand ((c::exec-initer (c::initer-single old-expr) compst old-fenv limit)
             (c::exec-initer (c::initer-single new-expr) compst new-fenv limit))
    :enable (c::exec-expr-call-or-pure
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp
             c::init-type-of-init-value))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-null-congruence
    (b* ((old (c::stmt-null))
         (new (c::stmt-null))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit)))
      (implies (not (c::errorp old-result))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :enable c::exec-stmt)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-expr-asg-congruence
    (b* ((old (c::stmt-expr old-expr))
         (new (c::stmt-expr new-expr))
         (old-expr-compst (c::exec-expr-asg
                           old-expr compst old-fenv (- limit 2)))
         (new-expr-compst (c::exec-expr-asg
                           new-expr compst new-fenv (- limit 2)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit)))
      (implies (and (not (equal (c::expr-kind old-expr) :call))
                    (not (equal (c::expr-kind new-expr) :call))
                    (not (c::errorp old-result))
                    (equal old-expr-compst new-expr-compst))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :expand ((c::exec-stmt (c::stmt-expr old-expr) compst old-fenv limit)
             (c::exec-stmt (c::stmt-expr new-expr) compst new-fenv limit))
    :enable (c::exec-expr-call-or-asg))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-return-value-congruence
    (b* ((old (c::stmt-return old-expr))
         (new (c::stmt-return new-expr))
         (old-expr-result (c::exec-expr-pure old-expr compst))
         (new-expr-result (c::exec-expr-pure new-expr compst))
         (old-expr-value (c::expr-value->value old-expr-result))
         (new-expr-value (c::expr-value->value new-expr-result))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-expr-value)))
      (implies (and old-expr
                    new-expr
                    (not (equal (c::expr-kind old-expr) :call))
                    (not (equal (c::expr-kind new-expr) :call))
                    (not (c::errorp old-result))
                    (not (c::errorp new-expr-result))
                    (equal old-expr-value new-expr-value)
                    (c::type-nonchar-integerp type))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (equal (c::stmt-value-kind old-result) :return)
                    (c::stmt-value-return->value? old-result)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert type nil)))))
    :expand ((c::exec-stmt (c::stmt-return old-expr) compst old-fenv limit)
             (c::exec-stmt (c::stmt-return new-expr) compst new-fenv limit))
    :enable (c::exec-expr-call-or-pure
             c::type-of-value
             c::apconvert-expr-value-when-not-array
             c::type-nonchar-integerp
             c::type-option-of-stmt-value
             c::type-of-value-option
             c::value-option-some->val))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-return-novalue-congruence
    (b* ((old (c::stmt-return nil))
         (new (c::stmt-return nil))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit)))
      (implies (not (c::errorp old-result))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (equal (c::stmt-value-kind old-result) :return)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert (c::type-void) nil)))))
    :enable c::exec-stmt)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-true-congruence
    (b* ((old (c::stmt-if old-test old-then))
         (new (c::stmt-if new-test new-then))
         (old-test-result (c::exec-expr-pure old-test compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (old-test-value (c::expr-value->value old-test-result))
         (new-test-value (c::expr-value->value new-test-result))
         ((mv old-then-result old-then-compst)
          (c::exec-stmt old-then compst old-fenv (1- limit)))
         ((mv new-then-result new-then-compst)
          (c::exec-stmt new-then compst new-fenv (1- limit)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-test-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-then-result))
                    (equal old-test-value new-test-value)
                    (equal old-then-result new-then-result)
                    (equal old-then-compst new-then-compst)
                    (c::test-value old-test-value)
                    (c::type-nonchar-integerp type)
                    (set::in (c::type-option-of-stmt-value old-then-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand ((c::exec-stmt
              (c::stmt-if old-test old-then) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-if new-test new-then) compst new-fenv limit))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-false-congruence
    (b* ((old (c::stmt-if old-test old-then))
         (new (c::stmt-if new-test new-then))
         (old-test-result (c::exec-expr-pure old-test compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (old-test-value (c::expr-value->value old-test-result))
         (new-test-value (c::expr-value->value new-test-result))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-test-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (equal old-test-value new-test-value)
                    (not (c::test-value old-test-value))
                    (c::type-nonchar-integerp type))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :expand ((c::exec-stmt
              (c::stmt-if old-test old-then) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-if new-test new-then) compst new-fenv limit))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-true-congruence
    (b* ((old (c::stmt-ifelse old-test old-then old-else))
         (new (c::stmt-ifelse new-test new-then new-else))
         (old-test-result (c::exec-expr-pure old-test compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (old-test-value (c::expr-value->value old-test-result))
         (new-test-value (c::expr-value->value new-test-result))
         ((mv old-then-result old-then-compst)
          (c::exec-stmt old-then compst old-fenv (1- limit)))
         ((mv new-then-result new-then-compst)
          (c::exec-stmt new-then compst new-fenv (1- limit)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-test-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-then-result))
                    (equal old-test-value new-test-value)
                    (equal old-then-result new-then-result)
                    (equal old-then-compst new-then-compst)
                    (c::test-value old-test-value)
                    (c::type-nonchar-integerp type)
                    (set::in (c::type-option-of-stmt-value old-then-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand ((c::exec-stmt
              (c::stmt-ifelse old-test old-then old-else) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-ifelse new-test new-then new-else) compst new-fenv limit))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-false-congruence
    (b* ((old (c::stmt-ifelse old-test old-then old-else))
         (new (c::stmt-ifelse new-test new-then new-else))
         (old-test-result (c::exec-expr-pure old-test compst))
         (new-test-result (c::exec-expr-pure new-test compst))
         (old-test-value (c::expr-value->value old-test-result))
         (new-test-value (c::expr-value->value new-test-result))
         ((mv old-else-result old-else-compst)
          (c::exec-stmt old-else compst old-fenv (1- limit)))
         ((mv new-else-result new-else-compst)
          (c::exec-stmt new-else compst new-fenv (1- limit)))
         ((mv old-result old-compst) (c::exec-stmt old compst old-fenv limit))
         ((mv new-result new-compst) (c::exec-stmt new compst new-fenv limit))
         (type (c::type-of-value old-test-value)))
      (implies (and (not (c::errorp old-result))
                    (not (c::errorp new-test-result))
                    (not (c::errorp new-else-result))
                    (equal old-test-value new-test-value)
                    (equal old-else-result new-else-result)
                    (equal old-else-compst new-else-compst)
                    (not (c::test-value old-test-value))
                    (c::type-nonchar-integerp type)
                    (set::in (c::type-option-of-stmt-value old-else-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand ((c::exec-stmt
              (c::stmt-ifelse old-test old-then old-else) compst old-fenv limit)
             (c::exec-stmt
              (c::stmt-ifelse new-test new-then new-else) compst new-fenv limit))
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled decl-decl-congruence
    (b* ((declor (c::obj-declor-ident var))
         (old (c::obj-declon (c::scspecseq-none) tyspecs declor old-initer))
         (new (c::obj-declon (c::scspecseq-none) tyspecs declor new-initer))
         ((mv old-init-value old-init-compst)
          (c::exec-initer old-initer compst old-fenv (1- limit)))
         ((mv new-init-value new-init-compst)
          (c::exec-initer new-initer compst new-fenv (1- limit)))
         (old-compst (c::exec-obj-declon old compst old-fenv limit))
         (new-compst (c::exec-obj-declon new compst new-fenv limit)))
      (implies (and old-initer
                    new-initer
                    (not (c::errorp old-compst))
                    (equal old-init-value new-init-value)
                    (equal old-init-compst new-init-compst))
               (and (not (c::errorp new-compst))
                    (equal old-compst new-compst))))
    :expand ((c::exec-obj-declon
              (c::obj-declon
               '(:none) tyspecs (c::obj-declor-ident var) old-initer)
              compst old-fenv limit)
             (c::exec-obj-declon
              (c::obj-declon
               '(:none) tyspecs (c::obj-declor-ident var) new-initer)
              compst new-fenv limit))
    :enable (c::obj-declon-to-ident+scspec+tyname+init))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-stmt-congruence
    (b* ((old (c::block-item-stmt old-stmt))
         (new (c::block-item-stmt new-stmt))
         ((mv old-stmt-result old-stmt-compst)
          (c::exec-stmt old-stmt compst old-fenv (1- limit)))
         ((mv new-stmt-result new-stmt-compst)
          (c::exec-stmt new-stmt compst new-fenv (1- limit)))
         ((mv old-result old-compst)
          (c::exec-block-item old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-stmt-result new-stmt-result)
                    (equal old-stmt-compst new-stmt-compst)
                    (set::in (c::type-option-of-stmt-value old-stmt-result)
                             types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             types))))
    :expand
    ((c::exec-block-item (c::block-item-stmt old-stmt) compst old-fenv limit)
     (c::exec-block-item (c::block-item-stmt new-stmt) compst new-fenv limit)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-decl-congruence
    (b* ((old (c::block-item-declon old-declon))
         (new (c::block-item-declon new-declon))
         (old-declon-compst
          (c::exec-obj-declon old-declon compst old-fenv (1- limit)))
         (new-declon-compst
          (c::exec-obj-declon new-declon compst new-fenv (1- limit)))
         ((mv old-result old-compst)
          (c::exec-block-item old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-declon-compst new-declon-compst))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :expand ((c::exec-block-item
              (c::block-item-declon old-declon) compst old-fenv limit)
             (c::exec-block-item
              (c::block-item-declon new-declon) compst new-fenv limit)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-empty-congruence
    (b* ((old nil)
         (new nil)
         ((mv old-result old-compst)
          (c::exec-block-item-list old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item-list new compst new-fenv limit)))
      (implies (not (c::errorp old-result))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::insert nil nil)))))
    :enable c::exec-block-item-list)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-first-congruence
    (b* ((old (cons old-item old-items))
         (new (cons new-item new-items))
         ((mv old-item-result old-item-compst)
          (c::exec-block-item old-item compst old-fenv (1- limit)))
         ((mv new-item-result new-item-compst)
          (c::exec-block-item new-item compst new-fenv (1- limit)))
         ((mv old-result old-compst)
          (c::exec-block-item-list old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item-list new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-item-result new-item-result)
                    (equal old-item-compst new-item-compst)
                    (equal (c::stmt-value-kind old-item-result) :return)
                    (set::in (c::type-option-of-stmt-value old-item-result)
                             first-types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::union (set::delete nil first-types)
                                         rest-types)))))
    :expand ((c::exec-block-item-list
              (cons old-item old-items) compst old-fenv limit)
             (c::exec-block-item-list
              (cons new-item new-items) compst new-fenv limit))
    :enable c::type-option-of-stmt-value)

  ;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-rest-congruence
    (b* ((old (cons old-item old-items))
         (new (cons new-item new-items))
         ((mv old-item-result old-item-compst)
          (c::exec-block-item old-item compst old-fenv (1- limit)))
         ((mv new-item-result new-item-compst)
          (c::exec-block-item new-item compst new-fenv (1- limit)))
         ((mv old-items-result old-items-compst)
          (c::exec-block-item-list
           old-items old-item-compst old-fenv (1- limit)))
         ((mv new-items-result new-items-compst)
          (c::exec-block-item-list
           new-items new-item-compst new-fenv (1- limit)))
         ((mv old-result old-compst)
          (c::exec-block-item-list old compst old-fenv limit))
         ((mv new-result new-compst)
          (c::exec-block-item-list new compst new-fenv limit)))
      (implies (and (not (c::errorp old-result))
                    (equal old-item-result new-item-result)
                    (equal old-items-result new-items-result)
                    (equal old-item-compst new-item-compst)
                    (equal old-items-compst new-items-compst)
                    (equal (c::stmt-value-kind old-item-result) :none)
                    (set::in (c::type-option-of-stmt-value old-item-result)
                             first-types)
                    (set::in (c::type-option-of-stmt-value old-items-result)
                             rest-types))
               (and (not (c::errorp new-result))
                    (equal old-result new-result)
                    (equal old-compst new-compst)
                    (set::in (c::type-option-of-stmt-value old-result)
                             (set::union (set::delete nil first-types)
                                         rest-types)))))
    :expand ((c::exec-block-item-list
              (cons old-item old-items) compst old-fenv limit)
             (c::exec-block-item-list
              (cons new-item new-items) compst new-fenv limit))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection exec-error-theorems
  :short "Error theorems about execution."
  :long
  (xdoc::topstring
   (xdoc::p
    "These theorems say that
     if the execution of a sub-construct yields an error,
     so does the execution of the super-construct.")
   (xdoc::p
    "Transformations use these theorems in proof generation
     to actually show that if the super-construct does not yield an error,
     neither do its sub-constructs."))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-unary-errors
    (implies (c::errorp (c::exec-expr-pure arg compst))
             (c::errorp (c::exec-expr-pure (c::expr-unary op arg) compst)))
    :expand (c::exec-expr-pure (c::expr-unary op arg) compst))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cast-errors
    (implies (c::errorp (c::exec-expr-pure arg compst))
             (c::errorp (c::exec-expr-pure (c::expr-cast tyname arg) compst)))
    :expand ((c::exec-expr-pure (c::expr-cast tyname arg) compst)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-pure-strict-errors
    (implies (and (c::binop-strictp op)
                  (or (c::errorp (c::exec-expr-pure arg1 compst))
                      (c::errorp (c::exec-expr-pure arg2 compst))))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary op arg1 arg2) compst)))
    :expand (c::exec-expr-pure (c::expr-binary op arg1 arg2) compst)
    :enable c::binop-strictp)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logand-first-errors
    (implies (c::errorp (c::exec-expr-pure arg1 compst))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary (c::binop-logand) arg1 arg2)
                                 compst)))
    :expand (c::exec-expr-pure (c::expr-binary '(:logand) arg1 arg2) compst))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logand-second-errors
    (implies (and (not (c::errorp (c::exec-expr-pure arg1 compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure arg1 compst))))
                  (c::test-value
                   (c::expr-value->value (c::exec-expr-pure arg1 compst)))
                  (c::errorp (c::exec-expr-pure arg2 compst)))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary (c::binop-logand) arg1 arg2)
                                 compst)))
    :expand (c::exec-expr-pure (c::expr-binary '(:logand) arg1 arg2) compst)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logor-first-errors
    (implies (c::errorp (c::exec-expr-pure arg1 compst))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary (c::binop-logor) arg1 arg2)
                                 compst)))
    :expand (c::exec-expr-pure (c::expr-binary '(:logor) arg1 arg2) compst))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-logor-second-errors
    (implies (and (not (c::errorp (c::exec-expr-pure arg1 compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure arg1 compst))))
                  (not (c::test-value
                        (c::expr-value->value (c::exec-expr-pure arg1 compst))))
                  (c::errorp (c::exec-expr-pure arg2 compst)))
             (c::errorp
              (c::exec-expr-pure (c::expr-binary (c::binop-logor) arg1 arg2)
                                 compst)))
    :expand (c::exec-expr-pure (c::expr-binary '(:logor) arg1 arg2) compst)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-asg-errors
    (implies (and (not (equal (c::expr-kind expr) :call))
                  (or (c::errorp (c::exec-expr-pure (c::expr-ident var) compst))
                      (c::errorp (c::exec-expr-pure expr compst))))
             (c::errorp
              (c::exec-expr-asg (c::expr-binary (c::binop-asg)
                                                (c::expr-ident var)
                                                expr)
                                compst fenv limit)))
    :expand (c::exec-expr-asg (c::expr-binary '(:asg) (c::expr-ident var) expr)
                              compst fenv limit)
    :enable c::exec-expr-call-or-pure)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-test-errors
    (implies (c::errorp (c::exec-expr-pure test compst))
             (c::errorp
              (c::exec-expr-pure (c::expr-cond test then else) compst)))
    :expand (c::exec-expr-pure (c::expr-cond test then else) compst))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-then-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::test-value
                   (c::expr-value->value (c::exec-expr-pure test compst)))
                  (c::errorp (c::exec-expr-pure then compst)))
             (c::errorp
              (c::exec-expr-pure (c::expr-cond test then else) compst)))
    :expand (c::exec-expr-pure (c::expr-cond test then else) compst)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled expr-cond-else-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (not (c::test-value
                        (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::errorp (c::exec-expr-pure else compst)))
             (c::errorp
              (c::exec-expr-pure (c::expr-cond test then else) compst)))
    :expand (c::exec-expr-pure (c::expr-cond test then else) compst)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled initer-single-pure-errors
    (implies (and (not (equal (c::expr-kind expr) :call))
                  (c::errorp (c::exec-expr-pure expr compst)))
             (c::errorp
              (mv-nth 0 (c::exec-initer
                         (c::initer-single expr) compst fenv limit))))
    :expand (c::exec-initer (c::initer-single expr) compst fenv limit)
    :enable c::exec-expr-call-or-pure)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-expr-asg-errors
    (implies (and (not (equal (c::expr-kind expr) :call))
                  (c::errorp (c::exec-expr-asg expr compst fenv (- limit 2))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt (c::stmt-expr expr) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-expr expr) compst fenv limit)
    :enable c::exec-expr-call-or-asg)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-return-errors
    (implies (and expr
                  (not (equal (c::expr-kind expr) :call))
                  (c::errorp (c::exec-expr-pure expr compst)))
             (c::errorp
              (mv-nth 0 (c::exec-stmt (c::stmt-return expr)
                                      compst
                                      fenv
                                      limit))))
    :expand (c::exec-stmt (c::stmt-return expr) compst fenv limit)
    :enable c::exec-expr-call-or-pure)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-test-errors
    (implies (c::errorp (c::exec-expr-pure test compst))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-if test then) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-if test then) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-then-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::test-value
                   (c::expr-value->value (c::exec-expr-pure test compst)))
                  (c::errorp
                   (mv-nth 0 (c::exec-stmt then compst fenv (1- limit)))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-if test then) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-if test then) compst fenv limit)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-test-errors
    (implies (c::errorp (c::exec-expr-pure test compst))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-ifelse test then else) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-ifelse test then else) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-then-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::test-value
                   (c::expr-value->value (c::exec-expr-pure test compst)))
                  (c::errorp
                   (mv-nth 0 (c::exec-stmt then compst fenv (1- limit)))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-ifelse test then else) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-ifelse test then else) compst fenv limit)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-else-errors
    (implies (and (not (c::errorp (c::exec-expr-pure test compst)))
                  (c::type-nonchar-integerp
                   (c::type-of-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (not
                   (c::test-value
                    (c::expr-value->value (c::exec-expr-pure test compst))))
                  (c::errorp
                   (mv-nth 0 (c::exec-stmt else compst fenv (1- limit)))))
             (c::errorp
              (mv-nth 0 (c::exec-stmt
                         (c::stmt-ifelse test then else) compst fenv limit))))
    :expand (c::exec-stmt (c::stmt-ifelse test then else) compst fenv limit)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled decl-decl-errors
    (b* ((declor (c::obj-declor-ident var))
         (declon (c::obj-declon (c::scspecseq-none) tyspecs declor initer)))
      (implies (and initer
                    (c::errorp
                     (mv-nth 0 (c::exec-initer
                                initer compst fenv (1- limit)))))
               (c::errorp (c::exec-obj-declon declon compst fenv limit))))
    :expand (c::exec-obj-declon
             (c::obj-declon
              '(:none) tyspecs (c::obj-declor-ident var) initer)
             compst fenv limit)
    :enable c::obj-declon-to-ident+scspec+tyname+init)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-stmt-errors
    (implies (c::errorp (mv-nth 0 (c::exec-stmt stmt compst fenv (1- limit))))
             (c::errorp
              (mv-nth 0 (c::exec-block-item
                         (c::block-item-stmt stmt) compst fenv limit))))
    :expand (c::exec-block-item (c::block-item-stmt stmt) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-decl-errors
    (implies (c::errorp (c::exec-obj-declon declon compst fenv (1- limit)))
             (c::errorp (mv-nth 0 (c::exec-block-item
                                   (c::block-item-declon declon)
                                   compst fenv limit))))
    :expand (c::exec-block-item
             (c::block-item-declon declon) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-first-errors
    (implies (c::errorp
              (mv-nth 0 (c::exec-block-item item compst fenv (1- limit))))
             (c::errorp
              (mv-nth 0 (c::exec-block-item-list
                         (cons item items) compst fenv limit))))
    :expand (c::exec-block-item-list (cons item items) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-rest-errors
    (b* (((mv result compst1) (c::exec-block-item item compst fenv (1- limit))))
      (implies (and (not (c::errorp result))
                    (equal (c::stmt-value-kind result) :none)
                    (c::errorp (mv-nth 0 (c::exec-block-item-list
                                          items compst1 fenv (1- limit)))))
               (c::errorp
                (mv-nth 0 (c::exec-block-item-list
                           (cons item items) compst fenv limit)))))
    :expand (c::exec-block-item-list (cons item items) compst fenv limit)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection exec-compustate-vars-theorems
  :short "Theorems about variables in computation states w.r.t. execution."
  :long
  (xdoc::topstring
   (xdoc::p
    "These theorems are about @(tsee c::compustate-has-var-with-type-p),
     and how the execution of constructs preserve and/or modify it."))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-ident-compustate-vars
    (b* ((expr (c::expr-ident var))
         (result (c::exec-expr-pure expr compst))
         (value (c::expr-value->value result)))
      (implies (c::compustate-has-var-with-type-p var type compst)
               (equal (c::type-of-value value) (c::type-fix type))))
    :enable (c::exec-expr-pure
             c::exec-ident
             c::compustate-has-var-with-type-p))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled expr-binary-asg-compustate-vars
    (implies (not (equal (c::expr-kind expr) :call))
             (b* ((asg (c::expr-binary (c::binop-asg) (c::expr-ident var) expr))
                  (compst1 (c::exec-expr-asg asg compst fenv limit)))
               (implies (and (not (c::errorp compst1))
                             (equal (c::type-of-value
                                     (c::read-object
                                      (c::objdesign-of-var var compst)
                                      compst))
                                    (c::type-of-value
                                     (c::expr-value->value
                                      (c::exec-expr-pure expr compst))))
                             (c::type-nonchar-integerp
                              (c::type-of-value
                               (c::expr-value->value
                                (c::exec-expr-pure expr compst))))
                             (c::compustate-has-var-with-type-p var1 type compst))
                        (c::compustate-has-var-with-type-p var1 type compst1))))
    :expand (c::exec-expr-asg (c::expr-binary '(:asg) (c::expr-ident var) expr)
                              compst fenv limit)
    :enable (c::compustate-has-var-with-type-p
             c::exec-expr-call-or-pure
             c::exec-expr-pure
             c::exec-ident
             c::objdesign-of-var-of-write-object
             c::read-object-of-write-object-when-auto-or-static
             c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled initer-single-pure-compustate-vars
    (implies (not (equal (c::expr-kind expr) :call))
             (b* ((initer (c::initer-single expr))
                  ((mv result compst1)
                   (c::exec-initer initer compst fenv limit)))
               (implies (and (not (c::errorp result))
                             (c::type-nonchar-integerp
                              (c::type-of-value
                               (c::expr-value->value
                                (c::exec-expr-pure expr compst))))
                             (c::compustate-has-var-with-type-p var type compst))
                        (c::compustate-has-var-with-type-p var type compst1))))
    :expand (c::exec-initer (c::initer-single expr) compst fenv limit)
    :enable (c::exec-expr-call-or-pure
             c::compustate-has-var-with-type-p))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-null-compustate-vars
    (b* ((stmt (c::stmt-null))
         ((mv result compst1) (c::exec-stmt stmt compst fenv limit)))
      (implies (and (not (c::errorp result))
                    (c::compustate-has-var-with-type-p var type compst))
               (c::compustate-has-var-with-type-p var type compst1)))
    :enable (c::exec-stmt
             c::compustate-has-var-with-type-p))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-expr-asg-compustate-vars
    (b* ((stmt (c::stmt-expr expr))
         (expr-compst1 (c::exec-expr-asg expr compst fenv (- limit 2)))
         ((mv result compst1) (c::exec-stmt stmt compst fenv limit)))
      (implies (and (not (equal (c::expr-kind expr) :call))
                    (not (c::errorp result))
                    (c::compustate-has-var-with-type-p var type expr-compst1))
               (c::compustate-has-var-with-type-p var type compst1)))
    :expand (c::exec-stmt (c::stmt-expr expr) compst fenv limit)
    :enable c::exec-expr-call-or-asg)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-return-compustate-vars
    (implies (or (not expr?)
                 (not (equal (c::expr-kind expr?) :call)))
             (b* ((stmt (c::stmt-return expr?))
                  ((mv result compst1) (c::exec-stmt stmt compst fenv limit)))
               (implies (and (not (c::errorp result))
                             (c::compustate-has-var-with-type-p var type compst))
                        (c::compustate-has-var-with-type-p var type compst1))))
    :expand ((c::exec-stmt (c::stmt-return expr?) compst fenv limit)
             (c::exec-stmt '(:return nil) compst fenv limit))
    :enable (c::compustate-has-var-with-type-p
             c::exec-expr-call-or-pure))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-if-compustate-vars
    (b* ((stmt (c::stmt-if test then))
         (test-result (c::exec-expr-pure test compst))
         (test-value (c::expr-value->value test-result))
         ((mv & compst0) (c::exec-stmt then compst fenv (1- limit)))
         ((mv result compst1) (c::exec-stmt stmt compst fenv limit)))
      (implies (and (not (c::errorp result))
                    (c::type-nonchar-integerp (c::type-of-value test-value))
                    (or (and (c::test-value test-value)
                             (c::compustate-has-var-with-type-p var
                                                                type
                                                                compst0))
                        (and (not (c::test-value test-value))
                             (c::compustate-has-var-with-type-p var
                                                                type
                                                                compst))))
               (c::compustate-has-var-with-type-p var type compst1)))
    :expand (c::exec-stmt (c::stmt-if test then) compst fenv limit)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled stmt-ifelse-compustate-vars
    (b* ((stmt (c::stmt-ifelse test then else))
         (test-result (c::exec-expr-pure test compst))
         (test-value (c::expr-value->value test-result))
         ((mv & then-compst) (c::exec-stmt then compst fenv (1- limit)))
         ((mv & else-compst) (c::exec-stmt else compst fenv (1- limit)))
         ((mv result compst1) (c::exec-stmt stmt compst fenv limit)))
      (implies (and (not (c::errorp result))
                    (c::type-nonchar-integerp (c::type-of-value test-value))
                    (or (and (c::test-value test-value)
                             (c::compustate-has-var-with-type-p var
                                                                type
                                                                then-compst))
                        (and (not (c::test-value test-value))
                             (c::compustate-has-var-with-type-p var
                                                                type
                                                                else-compst))))
               (c::compustate-has-var-with-type-p var type compst1)))
    :expand (c::exec-stmt (c::stmt-ifelse test then else) compst fenv limit)
    :enable (c::apconvert-expr-value-when-not-array
             c::value-kind-not-array-when-value-integerp))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled decl-decl-compustate-vars-old
    (b* ((declor (c::obj-declor-ident var))
         (declon (c::obj-declon (c::scspecseq-none) tyspecs declor initer))
         ((mv & compst0) (c::exec-initer initer compst fenv (1- limit)))
         (compst1 (c::exec-obj-declon declon compst fenv limit)))
      (implies (and (not (c::errorp compst1))
                    (c::identp var)
                    (c::identp var1)
                    (not (equal var var1))
                    (c::compustate-has-var-with-type-p var1 type compst0))
               (c::compustate-has-var-with-type-p var1 type compst1)))
    :expand (c::exec-obj-declon
             (c::obj-declon
              '(:none) tyspecs (c::obj-declor-ident var) initer)
             compst fenv limit)
    :enable (c::obj-declon-to-ident+scspec+tyname+init
             c::tyspec+declor-to-ident+tyname
             c::obj-declor-to-ident+adeclor
             c::compustate-has-var-with-type-p-of-create-other-var))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled decl-decl-compustate-vars-new
    (b* ((declor (c::obj-declor-ident var))
         (declon (c::obj-declon (c::scspecseq-none) tyspecs declor initer))
         (compst1 (c::exec-obj-declon declon compst fenv limit))
         (type (c::tyspecseq-to-type tyspecs)))
      (implies (and (not (c::errorp compst1))
                    (c::identp var))
               (c::compustate-has-var-with-type-p var type compst1)))
    :expand (c::exec-obj-declon
             (c::obj-declon
              '(:none) tyspecs (c::obj-declor-ident var) initer)
             compst fenv limit)
    :enable (c::compustate-has-var-with-type-p-of-create-same-var
             c::obj-declon-to-ident+scspec+tyname+init
             c::tyspec+declor-to-ident+tyname
             c::obj-declor-to-ident+adeclor
             c::tyname-to-type
             c::tyname-to-type-aux
             c::init-value-to-value))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-stmt-compustate-vars
    (b* ((item (c::block-item-stmt stmt))
         ((mv & stmt-compst1) (c::exec-stmt stmt compst fenv (1- limit)))
         ((mv result compst1) (c::exec-block-item item compst fenv limit)))
      (implies (and (not (c::errorp result))
                    (c::compustate-has-var-with-type-p var type stmt-compst1))
               (c::compustate-has-var-with-type-p var type compst1)))
    :expand (c::exec-block-item (c::block-item-stmt stmt) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-decl-compustate-vars
    (b* ((item (c::block-item-declon declon))
         (declon-compst (c::exec-obj-declon declon compst fenv (1- limit)))
         ((mv result compst1) (c::exec-block-item item compst fenv limit)))
      (implies (and (not (c::errorp result))
                    (c::compustate-has-var-with-type-p var type declon-compst))
               (c::compustate-has-var-with-type-p var type compst1)))
    :expand (c::exec-block-item
             (c::block-item-declon declon) compst fenv limit))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-empty-compustate-vars
    (b* ((items nil)
         ((mv result compst1)
          (c::exec-block-item-list items compst fenv limit)))
      (implies (and (not (c::errorp result))
                    (c::compustate-has-var-with-type-p var type compst))
               (c::compustate-has-var-with-type-p var type compst1)))
    :enable (c::exec-block-item-list
             c::compustate-has-var-with-type-p))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defruled block-item-list-cons-compustate-vars
    (b* ((item+items (cons item items))
         ((mv result0 compst0)
          (c::exec-block-item item compst fenv (1- limit)))
         ((mv & compst1)
          (c::exec-block-item-list items compst0 fenv (1- limit)))
         ((mv result2 compst2)
          (c::exec-block-item-list item+items compst fenv limit)))
      (implies (and (not (c::errorp result2))
                    (or (and (equal (c::stmt-value-kind result0) :return)
                             (c::compustate-has-var-with-type-p var type compst0))
                        (and (equal (c::stmt-value-kind result0) :none)
                             (c::compustate-has-var-with-type-p var type compst1))))
               (c::compustate-has-var-with-type-p var type compst2)))
    :enable c::exec-block-item-list))
