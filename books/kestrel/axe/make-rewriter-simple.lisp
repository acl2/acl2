; A tool to make an Axe Rewriter for a given application
;
; Copyright (C) 2008-2011 Eric Smith and Stanford University
; Copyright (C) 2013-2025 Kestrel Institute
; Copyright (C) 2016-2020 Kestrel Technology, LLC
;
; License: A 3-clause BSD license. See the file books/3BSD-mod.txt.
;
; Author: Eric Smith (eric.smith@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "ACL2")

;; This book contains the tool make-rewriter-simple, which creates custom
;; Axe Rewriters.  When calling it, the user indicates an evaluator to use for
;; ground terms, an evaluator to use for syntaxp functions, and an evaluator to
;; use for bind-free functions.

;; The generated rewriter is a simple variant of the Axe Rewriter (no
;; "work-hard", no calling the Axe Prover or STP).  It does support normalizing
;; XORs.

;; The main functions provided are:
;;   simplify-dag-XXX
;;   simplify-term-XXX
;;   simplify-term-to-term-XXX
;;   simplify-terms-to-terms-XXX
;; and the main user-facing utility is:
;;   def-simplified-XXX
;; where XXX is the suffix attached to generated names.

;; Rewriters generated by this tool are defined in :logic mode and are guard-verified.

;; See example in rewriter-basic.lisp.

;; See justification theorems in rewriter-justification.lisp.

;; If you have rules that contain work-hard hyps, consider passing in work-hard
;; as a named rule, to expand it.

;; Consider doing:
;;   (set-evisc-tuple t :iprint nil :sites :gag-mode)
;  when working with
;; calls to make-rewriter-simple, to prevent printing of enormous induction
;; schemes.

;; TODO: Add checks (or guards?) that interpreted-function-alists are complete.

;; TODO: Consider making a separate version for when we are not memoizing, and perhaps
;; when other options, such as hit counting, are turned off.

;; TODO: Consider adding special handling for bv-array-if.

;; TODO: Use native stobj arrays for the DAG, for speed (could be quite a bit of work).

;; TODO: Add more common parameters to the rewrite-stobj instead of passing them around.

;; TODO: Move some of these to the generated encapsulate:
(include-book "rewriter-common")
(include-book "supporting-nodes") ; for drop-non-supporters-array
(include-book "node-replacement-array3")
(include-book "refined-assumption-alists2")
(include-book "tries")
(include-book "kestrel/utilities/print-levels" :dir :system)
(include-book "rule-limits")
;(include-book "rule-alists") ; for get-rules-for-fn
(include-book "make-sublis-var-and-eval-simple")
(include-book "make-subcor-var-and-eval-simple")
;; (include-book "make-instantiation-code-simple")
(include-book "make-instantiation-code-simple-free-vars")
(include-book "make-instantiation-code-simple-no-free-vars2")
(include-book "make-dag-indices")
;(include-book "dag-array-builders")
(include-book "add-and-normalize-expr") ; for XOR normalization
(include-book "memoization")
(include-book "dag-array-printing2")
(include-book "unify-tree-and-dag")
(include-book "unify-term-and-dag-fast")
(include-book "hit-counts")
(include-book "dag-to-term")
(include-book "kestrel/utilities/defconst-computed" :dir :system) ;not strictly needed
;(include-book "def-dag-builder-theorems")
;(include-book "kestrel/utilities/all-vars-in-term-bound-in-alistp" :dir :system)
(include-book "kestrel/utilities/make-event-quiet" :dir :system)
;(include-book "kestrel/typed-lists-light/pseudo-term-listp" :dir :system) ;drop?
(include-book "kestrel/alists-light/strip-cdrs" :dir :system) ;need strip-cdrs-of-append for the generated proofs
(include-book "kestrel/utilities/with-local-stobjs" :dir :system)
(include-book "kestrel/utilities/redundancy" :dir :system) ; for command-is-redundantp
(include-book "kestrel/utilities/strip-stars-from-name" :dir :system) ; for starts-and-ends-with-starsp
(include-book "renumbering-stobj")
(include-book "rewrite-stobj")
(include-book "rewrite-stobj2")
(include-book "cars-increasing-by-1")
(include-book "kestrel/lists-light/reverse-list-def" :dir :system)
(local (include-book "kestrel/lists-light/nth" :dir :system))
(local (include-book "kestrel/lists-light/len" :dir :system))
(local (include-book "kestrel/lists-light/union-equal" :dir :system))
(local (include-book "kestrel/utilities/mv-nth" :dir :system))
(local (include-book "kestrel/typed-lists-light/pseudo-term-listp" :dir :system))

;; TODO: Consider putting these support rules into a book that gets locally included by the encapsulate.

;; Would something like this be helpful?
;; (defthmd quotep-compound-recognizer
;;   (implies (quotep x)
;;            (consp x))
;;   :rule-classes :compound-recognizer)

(defthm trees-to-memoizep-of-cons-if-not-equal-car
  (equal (trees-to-memoizep (cons-if-not-equal-car tree trees))
         (and (tree-to-memoizep tree)
              (trees-to-memoizep trees)))
  :hints (("Goal" :in-theory (enable cons-if-not-equal-car))))

(defthmd <-of-+-of-1-when-natps
  (implies (and (syntaxp (not (quotep y)))
                (natp x)
                (natp y))
           (equal (< x (+ 1 y)) (<= x y))))

;; Axe version, to be kept disabled except in certain Axe proofs
(defthmd <-of-if-arg2-axe
  (equal (< x (if test y z))
         (if test
             (< x y)
           (< x z))))

;; Can't be local, unless we move it into the macro
(defun simplify-trees-and-add-to-dag-induct (trees count)
  (declare (xargs :measure (len trees)))
  (if (or (not (mbt (natp count)))
          (= 0 count))
      (list trees count)
    (if (atom trees)
        (list trees count)
      (simplify-trees-and-add-to-dag-induct (rest trees) (+ -1 count)))))

;; Used in generated proofs. Kept disabled so as not to interfere with anything else.
(defthmd symbol-listp-of-append-disabled
  (equal (symbol-listp (append x y))
         (and (symbol-listp (true-list-fix x))
              (symbol-listp y)))
  :hints (("Goal" :in-theory (enable append symbol-listp true-list-fix))))

;gen
(defthm pseudo-dag-arrayp-of-+-of-1-and-largest-non-quotep-of-car
  (implies (and (bounded-darg-list-listp assumption-arg-lists dag-len)
                (consp assumption-arg-lists)
                (pseudo-dag-arrayp dag-array-name dag-array dag-len))
           (pseudo-dag-arrayp dag-array-name dag-array (+ 1 (largest-non-quotep (car assumption-arg-lists))))))

;; used in generated proofs, to be kept disabled
(defthmd symbolp-when-member-equal-disabled
  (implies (and (member-equal x free)
                (symbol-listp free))
           (symbolp x))
  :hints (("Goal" :in-theory (enable symbol-listp member-equal))))

;; used in generated proofs, to be kept disabled
(defthmd not-equal-when-member-equal-disabled
  (implies (and (syntaxp (quotep y))
                (member-equal x vals)
                (syntaxp (quotep vals))
                (not (member-equal y vals)))
           (not (equal x y))))

;; used in generated proofs, to be kept disabled
(defthmd not-equal-when-member-equal-alt-disabled
  (implies (and (syntaxp (quotep y))
                (member-equal x vals)
                (syntaxp (quotep vals))
                (not (member-equal y vals)))
           (not (equal y x))))

;; ;why is this needed?  the hyp is not being rewritten right during backchaining
;; (defthmd max-key-hack
;;   (equal (if (consp alist) x (< y (max-key alist z)))
;;          (if (consp alist) x (< y z))))

;; (defthmd max-key-hack-2
;;   (equal (if (consp alist) x (< (max-key alist z) y))
;;          (if (consp alist) x (< z y))))

;; used in generated proofs, to be kept disabled
(defthmd integerp-when-natp-disabled
  (implies (natp x)
           (integerp x)))

;; used in generated proofs, to be kept disabled
(defthmd strip-cars-of-append-disabled
  (equal (strip-cars (append x y))
         (append (strip-cars x)
                 (strip-cars y)))
  :hints (("Goal" :in-theory (enable strip-cars))))

;; used in generated proofs, to be kept disabled
(defthmd pseudo-termp-of-car-when-pseudo-term-listp-cheap-disabled
  (implies (pseudo-term-listp terms)
           (pseudo-termp (car terms)))
  :rule-classes ((:rewrite :backchain-limit-lst (0)))
  :hints (("Goal" :in-theory (enable pseudo-term-listp))))

;; used in generated proofs, to be kept disabled
(defthmd pseudo-term-listp-of-cdr-when-pseudo-term-listp-cheap-disabled
  (implies (pseudo-term-listp terms)
           (pseudo-term-listp (cdr terms)))
  :rule-classes ((:rewrite :backchain-limit-lst (0)))
  :hints (("Goal" :in-theory (enable pseudo-term-listp))))

(defthmd axe-treep-when-dag-exprp
  (implies (dag-exprp expr)
           (axe-treep expr))
  :hints (("Goal" :in-theory (enable axe-treep dag-exprp))))

;; used in generated proofs, to be kept disabled
(defthmd not-<-of-0-when-natp-disabled
  (implies (natp x)
           (not (< x 0))))

;; used in generated proofs, to be kept disabled
(defthmd natp-of-+-of--1-when-natp-disabled
  (implies (natp x)
           (equal (natp (+ -1 x))
                  (< 0 x))))

(defthm bounded-axe-treep-when-bounded-dag-exprp
  (implies (and (bounded-dag-exprp bound2 tree)
                (natp bound2)
                (<= bound2 bound))
           (bounded-axe-treep tree bound))
  :hints (("Goal" :in-theory (enable bounded-axe-treep
                                     bounded-dag-exprp
                                     dag-exprp))))

(defthm bounded-axe-treep-of-cdar-when-weak-dagp-aux
  (implies (and (weak-dagp-aux dag)
                (<= (car (car dag)) bound))
           (bounded-axe-treep (cdr (car dag)) bound))
  :hints (("Goal" :in-theory (enable weak-dagp-aux))))

(defthm consp-of-cdr-forward-to-consp
  (implies (consp (cdr x))
           (consp x))
  :rule-classes :forward-chaining)

(defthmd member-equal-when-member-equal-and-subsetp-equal
  (implies (and (member-equal a x2)
                (subsetp-equal x2 x))
           (member-equal a x)))

(defthm alist-suitable-for-hypsp-after-matching-2-special
  (implies (and (alist-suitable-for-hyp-args-and-hypsp alist hyp-args hyps)
                (bounded-darg-listp arg-list (get-dag-len rewrite-stobj2))
                (not (equal :fail (unify-trees-with-dag-nodes hyp-args arg-list (get-dag-array rewrite-stobj2) alist)))
                (pseudo-dag-arrayp 'dag-array (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2))
                (axe-tree-listp hyp-args)
                (symbol-alistp alist))
           (alist-suitable-for-hypsp (unify-trees-with-dag-nodes hyp-args arg-list (get-dag-array rewrite-stobj2) alist)
                                     hyps))
  :hints (("Goal" :use (:instance alist-suitable-for-hypsp-after-matching-2
                                  (dag-len (get-dag-len rewrite-stobj2))
                                  (dag-array (get-dag-array rewrite-stobj2)))
           :in-theory (disable alist-suitable-for-hypsp-after-matching-2))))

(defthm <-of-largest-non-quotep2
  (implies (and (bounded-darg-listp args nodenum)
                (natp nodenum) ; not this
                )
           (< (largest-non-quotep args) nodenum))
  :rule-classes (:rewrite :linear)
  :hints (("Goal" :in-theory (enable largest-non-quotep
                                     bounded-darg-listp))))

;; ;loops with LEN-WHEN-DARGP-LESS-THAN?
;; (defthmd consp-to-len-bound-for-make-rewriter-simple
;;   (equal (consp x) (< 0 (len x)))
;;   :hints (("Goal" :in-theory (e/d (len) (len-of-cdr)))))

;loops with LEN-WHEN-DARGP-LESS-THAN
;; (defthmd len-of-cdr-better-for-make-rewriter-simple
;;   (equal (len (cdr x))
;;          (if (equal 0 (len x))
;;              0 (+ -1 (len x)))))

;; Returns (mv erp negated-assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist), where the NEGATED-ASSUMPTIONS are possibly-negated-nodenums.
(defund negate-assumptions-and-add-to-dag-array (assumptions
                                                 dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist
                                                 acc)
  (declare (xargs :guard (and (pseudo-term-listp assumptions)
                              (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                              (possibly-negated-nodenumsp acc))))
  (if (endp assumptions)
      (mv (erp-nil) (reverse-list acc) dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
    (b* ((assumption (first assumptions))
         ((mv negatedp core-term)
          (if (call-of 'not assumption)
              (mv t (farg1 assumption))
            (mv nil assumption)))
         ;; Merge in the core-term:
         ((mv erp core-term-nodenum-or-quotep dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
          (merge-term-into-dag-array-basic core-term
                                           nil ;var-replacement-alist
                                           dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist 'dag-array 'dag-parent-array
                                           nil ;interpreted-function-alist
                                           ))
         ((when erp) (mv erp nil dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist))
         ((when (consp core-term-nodenum-or-quotep)) ; check for quotep -- todo: handle better ; todo: what if it's an evaluatable ground term?
          (er hard? 'negate-assumptions-and-add-to-dag-array "Assumption ~x0 is a quotep (possibly after stripping a NOT)." assumption)
          (mv :unexpected-quote nil dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist))
         (core-term-nodenum core-term-nodenum-or-quotep) ; it was not a quotep
         (acc (cons (if negatedp
                        ;; it was a call of NOT, and we are negating, so we drop the NOT:
                        core-term-nodenum
                      ;; it was not a call of NOT, and we are negating, so we add a NOT:
                      `(not ,core-term-nodenum))
                    acc)))
      (negate-assumptions-and-add-to-dag-array (rest assumptions)
                                               dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist
                                               acc))))

(defthm negate-assumptions-and-add-to-dag-array-return-type
  (implies (and (pseudo-term-listp assumptions)
                (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                (possibly-negated-nodenumsp acc))
           (mv-let (erp negated-assumptions new-dag-array new-dag-len new-dag-parent-array new-dag-constant-alist new-dag-variable-alist)
             (negate-assumptions-and-add-to-dag-array assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist acc)
             (implies (not erp)
                      (and (possibly-negated-nodenumsp negated-assumptions)
                           (wf-dagp 'dag-array new-dag-array new-dag-len 'dag-parent-array new-dag-parent-array new-dag-constant-alist new-dag-variable-alist)
                           (<= dag-len new-dag-len)))))
  :hints (("Goal" :in-theory (enable negate-assumptions-and-add-to-dag-array))))

(defthm negate-assumptions-and-add-to-dag-array-return-type-corollary
  (implies (and (pseudo-term-listp assumptions)
                (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                (possibly-negated-nodenumsp acc))
           (mv-let (erp negated-assumptions new-dag-array new-dag-len new-dag-parent-array new-dag-constant-alist new-dag-variable-alist)
             (negate-assumptions-and-add-to-dag-array assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist acc)
             (declare (ignore negated-assumptions new-dag-array new-dag-parent-array new-dag-constant-alist new-dag-variable-alist))
             (implies (not erp)
                      (and (natp new-dag-len)))))
  :hints (("Goal" :use negate-assumptions-and-add-to-dag-array-return-type
           :in-theory (disable negate-assumptions-and-add-to-dag-array-return-type))))

;; generalizes the bound
(defthm negate-assumptions-and-add-to-dag-array-return-type-corollary-2
  (implies (and (pseudo-term-listp assumptions)
                (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                (possibly-negated-nodenumsp acc))
           (mv-let (erp negated-assumptions new-dag-array new-dag-len new-dag-parent-array new-dag-constant-alist new-dag-variable-alist)
             (negate-assumptions-and-add-to-dag-array assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist acc)
             (declare (ignore negated-assumptions new-dag-array new-dag-parent-array new-dag-constant-alist new-dag-variable-alist))
             (implies (and (not erp)
                           (natp bound)
                           (<= bound dag-len))
                      (<= bound new-dag-len))))
  :hints (("Goal" :use negate-assumptions-and-add-to-dag-array-return-type
           :in-theory (disable negate-assumptions-and-add-to-dag-array-return-type))))

(defthm negate-assumptions-and-add-to-dag-array-return-type-2
  (implies (and (pseudo-term-listp assumptions)
                (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                (bounded-possibly-negated-nodenumsp acc dag-len))
           (mv-let (erp negated-assumptions new-dag-array new-dag-len new-dag-parent-array new-dag-constant-alist new-dag-variable-alist)
             (negate-assumptions-and-add-to-dag-array assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist acc)
             (declare (ignore new-dag-array new-dag-parent-array new-dag-constant-alist new-dag-variable-alist))
             (implies (not erp)
                      (bounded-possibly-negated-nodenumsp negated-assumptions new-dag-len))))
  :hints (("Goal" :in-theory (enable negate-assumptions-and-add-to-dag-array))))

;generalizes the bound
(defthm negate-assumptions-and-add-to-dag-array-return-type-2-gen
  (implies (and (pseudo-term-listp assumptions)
                (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                (bounded-possibly-negated-nodenumsp acc dag-len))
           (mv-let (erp negated-assumptions new-dag-array new-dag-len new-dag-parent-array new-dag-constant-alist new-dag-variable-alist)
             (negate-assumptions-and-add-to-dag-array assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist acc)
             (declare (ignore new-dag-array new-dag-parent-array new-dag-constant-alist new-dag-variable-alist))
             (implies (and (not erp)
                           (<= new-dag-len bound)
                           (natp bound))
                      (bounded-possibly-negated-nodenumsp negated-assumptions bound))))
  :hints (("Goal" :use negate-assumptions-and-add-to-dag-array-return-type-2
           :in-theory (disable negate-assumptions-and-add-to-dag-array-return-type-2 natp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; the non-polarity version of this causes a key hyp to be rewritten away -- why?!
(defthmd bounded-refined-assumption-alistp-monotone-polarity
  (implies (and (syntaxp (want-to-weaken (bounded-refined-assumption-alistp alist bound))) (bounded-refined-assumption-alistp alist bound2)
                (<= bound2 bound))
           (bounded-refined-assumption-alistp alist bound))
  :hints (("Goal" :in-theory (enable bounded-refined-assumption-alistp))))

;; (defthmd axe-treep-of-cadr-when-axe-smt
;;   (implies (and (axe-treep x)
;;                 (equal 'axe-smt (car x)))
;;            (axe-treep (cadr x)))
;;   :hints (("Goal" :in-theory (enable axe-treep))))

(defthmd pseudo-termp-of-cadr-when-axe-smt
  (implies (and (pseudo-termp x)
                (equal 'axe-smt (car x)))
           (pseudo-termp (cadr x)))
  :hints (("Goal" :in-theory (enable axe-treep))))

(defthmd free-vars-in-term-of-cadr-when-axe-smt
  (implies (and (equal 'axe-smt (car x))
                (equal 1 (len (fargs x)))
                (pseudo-termp x))
           (equal (free-vars-in-term (cadr x))
                  (free-vars-in-term x)))
  :hints (("Goal" :in-theory (enable axe-treep free-vars-in-term free-vars-in-terms))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defthm possibly-negated-nodenumsp-when-contextp
  (implies (contextp x)
           (equal (possibly-negated-nodenumsp x)
                  (not (false-contextp x))))
  :hints (("Goal" :in-theory (enable contextp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; How we use the refined-assumption-alist:
;; - To bind free vars in a hyp (calling lookup-in-refined-assumption-alist on the fn and unifying the hyp's args against each arglist).
;; - When rewriting, a THEN or ELSE branch, if not memoizing, temporarily add info by calling extend-refined-assumption-alist-assuming-node
;;   or extend-refined-assumption-alist-assuming-negation-of-node.

;; How we use the node-replacement-array:
;; - To replace nodenums that are otherwise simplified (e.g., before simplifying function calls applied to them)
;; - To check if a rewritten hyp is known to be non-nil (calling known-true-in-node-replacement-arrayp on its nodenum).
;; - To handle a simplified IF/MYIF/BOOLIF/BVIF test that is known to be non-nil (calling apply-node-replacement-array-bool-to-darg on it).
;; - To handle an argument to NOT that is known to be non-nil (calling apply-node-replacement-array-bool-to-darg on it).
;; - To replace a var (calling apply-node-replacement-array on its nodenum after we add the node to the dag).
;; - To replace a simplified function call (calling apply-node-replacement-array on its nodenum after we add the node to the dag).
;; - When rewriting, a THEN or ELSE branch, if not memoizing, temporarily add info by calling update-node-replacement-array-for-assuming-node or
;;   update-node-replacement-array-for-assuming-negation-of-node and later calling undo-writes-to-node-replacement-array to undo.
;; Advantages: Lookup is very fast
;; Disadvantages: The thing being looked up must already be in the dag.
;; TODO: Consider whether to support chains of replacements, by looking up repeatedly (might loop).
;; TODO: Consider whether to look up unsimplified assumptions.
;; TODO: Consider whether to simplify the RHSes of assumptions (at start, or when used).

;; OLD:
;; How we use the equality-assumption-alist:
;; 1. To replace a term that is a var (calling replace-var-using-equality-assumption-alist).  This may be rare.
;;  TODO: Could this be handled using node-replacement-alist instead, letting us eliminate the :var case?
;; 2. To replace a (simplified) term that is a function call (calling replace-fun-call-using-equality-assumption-alist).

(defconst *used-try-print-threshold* 100)
(defconst *wasted-try-print-threshold* 50)

(defun make-rewriter-simple-fn (suffix ;; gets added to generated names
                                evaluator-base-name
                                syntaxp-evaluator-suffix
                                bind-free-evaluator-suffix
                                smtp)
  (declare (xargs :guard (and (symbolp suffix)
                              (symbolp evaluator-base-name)
                              (symbolp syntaxp-evaluator-suffix)
                              (symbolp bind-free-evaluator-suffix)
                              (booleanp smtp))))
  (let* ((eval-axe-syntaxp-expr-fn (pack$ 'eval-axe-syntaxp-expr- syntaxp-evaluator-suffix)) ; keep in sync with make-axe-syntaxp-evaluator.lisp
         (eval-axe-bind-free-function-application-fn (pack$ 'eval-axe-bind-free-function-application- bind-free-evaluator-suffix)) ; keep in sync with make-axe-bind-free-evaluator.lisp
         (apply-axe-evaluator-to-quoted-args-name (pack$ 'apply- evaluator-base-name '-to-quoted-args))
         (sublis-var-and-eval-name (pack$ 'sublis-var-and-eval- suffix)) ; keep in sync with the name generated by make-sublis-var-and-eval-simple
         (subcor-var-and-eval-name (pack$ 'subcor-var-and-eval- suffix)) ; keep in sync with the name generated by make-subcor-var-and-eval-simple
         ;; (instantiate-hyp-name (pack$ 'instantiate-hyp- suffix)) ; keep in sync with the name generated by make-instantiation-code-simple
         (instantiate-hyp-free-vars-name (pack$ 'instantiate-hyp- suffix '-free-vars)) ; keep in sync with the name generated by make-instantiation-code-simple-free-vars
         (instantiate-hyp-no-free-vars2-name (pack$ 'instantiate-hyp- suffix '-no-free-vars2)) ; keep in sync with the name generated by make-instantiation-code-simple-no-free-vars2
         ;; functions in the mutual-recursion:
         (relieve-free-var-hyp-and-all-others-name (pack$ 'relieve-free-var-hyp-and-all-others- suffix))
         (relieve-rule-hyps-name (pack$ 'relieve-rule-hyps- suffix))
         (try-to-apply-rules-name (pack$ 'try-to-apply-rules- suffix))
         (simplify-fun-call-and-add-to-dag-name (pack$ 'simplify-fun-call-and-add-to-dag- suffix))
         (simplify-if/myif/boolif-tree-and-add-to-dag3-name (pack$ 'simplify-if/myif/boolif-tree-and-add-to-dag3- suffix))
         (simplify-if/myif/boolif-tree-and-add-to-dag2-name (pack$ 'simplify-if/myif/boolif-tree-and-add-to-dag2- suffix))
         (simplify-if/myif-tree-and-add-to-dag-name (pack$ 'simplify-if/myif-tree-and-add-to-dag- suffix))
         (simplify-boolif-tree-and-add-to-dag-name (pack$ 'simplify-boolif-tree-and-add-to-dag- suffix))
         (simplify-bvif-tree-and-add-to-dag3-name (pack$ 'simplify-bvif-tree-and-add-to-dag3- suffix))
         (simplify-bvif-tree-and-add-to-dag2-name (pack$ 'simplify-bvif-tree-and-add-to-dag2- suffix))
         (simplify-bvif-tree-and-add-to-dag1-name (pack$ 'simplify-bvif-tree-and-add-to-dag1- suffix))
         (simplify-bvif-tree-and-add-to-dag-name (pack$ 'simplify-bvif-tree-and-add-to-dag- suffix))
         (simplify-not-tree-and-add-to-dag-name (pack$ 'simplify-not-tree-and-add-to-dag- suffix))
         (simplify-tree-and-add-to-dag-name (pack$ 'simplify-tree-and-add-to-dag- suffix))
         (simplify-trees-and-add-to-dag-name (pack$ 'simplify-trees-and-add-to-dag- suffix))
         ;; functions after the mutual-recursion:
         (simplify-dag-expr-name (pack$ 'simplify-dag-expr- suffix))
         (simplify-dag-nodes-name (pack$ 'simplify-dag-nodes- suffix))
         (simplify-dag-core-name (pack$ 'simplify-dag-core- suffix))
         (simplify-dag-name (pack$ 'simplify-dag- suffix)) ; produces a DAG
         (simplify-dag-with-rule-alists-name (pack$ 'simplify-dag-with-rule-alists- suffix)) ; produces a DAG
         (simplify-term-name (pack$ 'simplify-term- suffix)) ; produces a DAG
         (simplify-term-to-term-name (pack$ 'simplify-term-to-term- suffix)) ; produces a term
         (simplify-terms-to-terms-name (pack$ 'simplify-terms-to-terms- suffix)) ; produces a list of terms
         (def-simplified-fn-core-name (pack$ 'def-simplified-fn-core- suffix))
         (def-simplified-fn-name (pack$ 'def-simplified-fn- suffix))
         (def-simplified-name (pack$ 'def-simplified- suffix))
         ;; for splicing in, to be used with ,@
         (maybe-state (if smtp '(state) nil)) ; really this is "maybe list of state"
         (maybe-new-state (if smtp '(new-state) nil))
         (maybe-stobjs (if smtp '(:stobjs state) nil))
         (maybe-w-unchanged (if smtp '((equal (w new-state) (w state))) nil))

         ;; Keep these in sync with the formals of each function:

         (call-of-relieve-free-var-hyp-and-all-others `(,relieve-free-var-hyp-and-all-others-name
                                                        assumption-arg-lists
                                                        hyp-args
                                                        hyp-num
                                                        other-hyps
                                                        alist
                                                        rule-symbol
                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                        rewrite-stobj count))
         (call-of-relieve-rule-hyps `(,relieve-rule-hyps-name
                                      hyps hyp-num alist rule-symbol
                                      rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                      node-replacement-array node-replacement-count refined-assumption-alist
                                      rewrite-stobj count))
         (call-of-try-to-apply-rules `(,try-to-apply-rules-name
                                       stored-rules
                                       args-to-match
                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                       node-replacement-array node-replacement-count refined-assumption-alist
                                       rewrite-stobj count))
         (call-of-simplify-fun-call-and-add-to-dag `(,simplify-fun-call-and-add-to-dag-name
                                                     fn
                                                     dargs
                                                     trees-equal-to-tree
                                                     rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                     node-replacement-array node-replacement-count refined-assumption-alist
                                                     rewrite-stobj count))
         (call-of-simplify-if/myif/boolif-tree-and-add-to-dag3 `(,simplify-if/myif/boolif-tree-and-add-to-dag3-name
                                                                 fn
                                                                 simplified-test
                                                                 simplified-then-branch
                                                                 else-branch
                                                                 tree
                                                                 trees-equal-to-tree
                                                                 rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                 node-replacement-array node-replacement-count refined-assumption-alist
                                                                 rewrite-stobj count))
         (call-of-simplify-if/myif/boolif-tree-and-add-to-dag2 `(,simplify-if/myif/boolif-tree-and-add-to-dag2-name
                                                                 fn
                                                                 simplified-test
                                                                 then-branch
                                                                 else-branch
                                                                 tree
                                                                 trees-equal-to-tree
                                                                 rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                 node-replacement-array node-replacement-count refined-assumption-alist
                                                                 rewrite-stobj count))
         (call-of-simplify-if/myif-tree-and-add-to-dag `(,simplify-if/myif-tree-and-add-to-dag-name
                                                         tree
                                                         trees-equal-to-tree
                                                         rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                         node-replacement-array node-replacement-count refined-assumption-alist
                                                         rewrite-stobj count))
         (call-of-simplify-boolif-tree-and-add-to-dag `(,simplify-boolif-tree-and-add-to-dag-name
                                                         tree
                                                         trees-equal-to-tree
                                                         rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                         node-replacement-array node-replacement-count refined-assumption-alist
                                                         rewrite-stobj count))
         (call-of-simplify-bvif-tree-and-add-to-dag3 `(,simplify-bvif-tree-and-add-to-dag3-name
                                                       simplified-size
                                                       simplified-test
                                                       simplified-then-branch
                                                       else-branch
                                                       tree
                                                       trees-equal-to-tree
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj count))
         (call-of-simplify-bvif-tree-and-add-to-dag2 `(,simplify-bvif-tree-and-add-to-dag2-name
                                                       simplified-size
                                                       simplified-test ; a nodenum
                                                       then-arg ; unsimplified
                                                       else-arg
                                                       tree
                                                       trees-equal-to-tree
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj count))
         (call-of-simplify-bvif-tree-and-add-to-dag1 `(,simplify-bvif-tree-and-add-to-dag1-name
                                                       size-arg ; unsimplified
                                                       simplified-test ; a nodenum
                                                       then-arg ; unsimplified
                                                       else-arg
                                                       tree
                                                       trees-equal-to-tree
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj count))

         (call-of-simplify-bvif-tree-and-add-to-dag `(,simplify-bvif-tree-and-add-to-dag-name
                                                       tree
                                                       trees-equal-to-tree
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj count))
         (call-of-simplify-not-tree-and-add-to-dag `(,simplify-not-tree-and-add-to-dag-name
                                                     tree
                                                     trees-equal-to-tree
                                                     rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                     node-replacement-array node-replacement-count refined-assumption-alist
                                                     rewrite-stobj count))
         (call-of-simplify-tree-and-add-to-dag `(,simplify-tree-and-add-to-dag-name
                                                 tree
                                                 trees-equal-to-tree
                                                 rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                 node-replacement-array node-replacement-count refined-assumption-alist
                                                 rewrite-stobj count))
         (call-of-simplify-trees-and-add-to-dag `(,simplify-trees-and-add-to-dag-name
                                                  trees
                                                  rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                  node-replacement-array node-replacement-count refined-assumption-alist
                                                  rewrite-stobj count))
         (call-of-simplify-term `(,simplify-term-name term assumptions rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state))
         (call-of-simplify-dag `(,simplify-dag-name dag assumptions rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state))
         (call-of-simplify-dag-with-rule-alists `(,simplify-dag-with-rule-alists-name dag assumptions rule-alists interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state))
         (call-of-simplify-dag-core `(,simplify-dag-core-name dag assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist maybe-internal-context-array rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state))
         )
    `(progn
       (include-book "kestrel/utilities/rational-printing" :dir :system) ; for print-to-hundredths
       (include-book "kestrel/axe/dag-info" :dir :system) ; for print-dag-info
       (include-book "kestrel/axe/pure-dags" :dir :system) ; for dag-is-purep-aux
       ;; (include-book "kestrel/axe/dag-or-term-to-dag-simple" :dir :system)
       ,@(and smtp '((include-book "kestrel/axe/prove-with-stp" :dir :system)))

       (encapsulate ()

         (local (include-book "kestrel/lists-light/cdr" :dir :system))
         (local (include-book "kestrel/lists-light/len" :dir :system))
         (local (include-book "kestrel/lists-light/nth" :dir :system))
         (local (include-book "kestrel/lists-light/true-list-fix" :dir :system))
         (local (include-book "kestrel/lists-light/last" :dir :system))
         (local (include-book "kestrel/lists-light/take" :dir :system))
         (local (include-book "kestrel/lists-light/append" :dir :system))
         (local (include-book "kestrel/lists-light/reverse-list" :dir :system))
         (local (include-book "kestrel/arithmetic-light/plus" :dir :system))
         (local (include-book "kestrel/arithmetic-light/times" :dir :system))
         (local (include-book "kestrel/arithmetic-light/natp" :dir :system))
         (local (include-book "kestrel/arithmetic-light/less-than" :dir :system))
         (local (include-book "kestrel/arithmetic-light/less-than-or-equal" :dir :system))
         (local (include-book "kestrel/arithmetic-light/types" :dir :system))
         (local (include-book "kestrel/utilities/if-rules" :dir :system))
         (local (include-book "kestrel/typed-lists-light/pseudo-term-listp" :dir :system)) ;reduce?
         (local (include-book "kestrel/typed-lists-light/nat-listp" :dir :system))
         (local (include-book "kestrel/axe/rewriter-support" :dir :system))
         (local (include-book "kestrel/acl2-arrays/acl2-arrays" :dir :system)) ; reduce?
         (local (include-book "kestrel/utilities/mv-nth" :dir :system))
         (local (include-book "kestrel/utilities/read-run-time" :dir :system)) ; for get-real-time, below

         (local (in-theory (disable mv-nth
                                    wf-dagp wf-dagp-expander
                                    default-car
                                    default-cdr
                                    axe-treep
                                    axe-treep-when-pseudo-termp
                                    ;; member-of-cons
                                    ;; SUBSETP-CAR-MEMBER
                                    ;;SUBSETP-CONS-2
                                    AXE-TREE-LISTP PSEUDO-TERM-LISTP
                                    DEFAULT-+-1
                                    DEFAULT-+-2
                                    SYMBOLP-OF-CAR-OF-CAR-WHEN-SYMBOL-TERM-ALISTP
                                    symbol-listp
                                    symbol-alistp axe-rule-hyp-listp
                                    EQLABLE-ALISTP ;prevent inductions
                                    member-equal   ; prevent case splitting
                                    strip-cars
                                    nat-listp ; !
                                    weak-dagp-aux
                                    myquotep
                                    dargp-less-than
                                    all-<-when-not-consp
                                    consp-of-car-when-pseudo-dagp
                                    default-<-1
                                    alistp
                                    ;;axe-rule-hypp-when-simple ; caused case splits
                                    assoc-equal
                                    ilks-plist-worldp
                                    ;; for the smtp variant:
                                    w)))

         (local (in-theory (enable ;;consp-of-assoc-equal-when-node-replacement-alistp
                             ;;dargp-of-cdr-of-assoc-equal-when-node-replacement-alistp
                             ;;dargp-less-than-of-cdr-of-assoc-equal-when-node-replacement-alistp
                             ;;myquotep-of-cdr-of-assoc-equal-when-node-replacement-alistp
                             ;;natp-of-cdr-of-assoc-equal-when-node-replacement-alistp
                             strip-cars-of-append-disabled
                             pseudo-termp-of-car-when-pseudo-term-listp-cheap-disabled
                             pseudo-term-listp-of-cdr-when-pseudo-term-listp-cheap-disabled
                             ;;consp-to-len-bound-for-make-rewriter-simple
                             ;;len-of-cdr-better-for-make-rewriter-simple
                             myquotep-when-dag-exprp-and-quote
                             rationalp-of-subtract-tries
                             append-nodenum-dargs-becomes-append-of-keep-nodenum-dargs
                             ;; dargp-of-mv-nth-1-of-add-and-normalize-expr-and-mv-nth-3-of-add-and-normalize-expr
                             )))

         ;; ;;todo: dup!
         ;; (local
         ;;   (defthm nat-listp-of-reverse-list
         ;;     (equal (nat-listp (reverse-list x))
         ;;            (all-natp x))
         ;;     :hints (("Goal" :in-theory (enable nat-listp reverse-list)))))

         (local
           (defthm nat-listp-of-reverse-list
             (equal (nat-listp (reverse-list x))
                    (nat-listp (true-list-fix x)))
             :hints (("Goal" :induct (reverse-list x)
                      :in-theory (enable nat-listp reverse-list)))))

         ;; Make versions of sublis-var-and-eval and subcor-var-and-eval:
         (make-sublis-var-and-eval-simple ,suffix ,evaluator-base-name)
         (make-subcor-var-and-eval-simple ,suffix ,evaluator-base-name)

         ;; Make versions of instantiate-hyp, etc.
         ;; (make-instantiation-code-simple ,suffix ,evaluator-base-name)
         (make-instantiation-code-simple-free-vars ,suffix ,evaluator-base-name)
         (make-instantiation-code-simple-no-free-vars2 ,suffix ,evaluator-base-name)

         ;;
         ;; The mutual-recursion:
         ;;

         ;; TODO: Is the stuff in the dag assumed to be simplified, or not?  Some of those nodes may come from assumptions or even context.

         ;; TODO: It may be possible to avoid checking the count in some functions by using a more complicated measure.

         (mutual-recursion

           ;; Returns (mv erp hyps-relievedp extended-alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array), where extended-alist is irrelevant if hyps-relievedp is nil
           ;; keeps trying ASSUMPTION-ARG-LISTS until it finds a match for HYP-ARGS (thus binding some free vars) for which it can relieve all the OTHER-HYPS (using those variable bindings)
           ;; we need to keep the whole alist in addition to walking down the entry for the current fn
           (defund ,relieve-free-var-hyp-and-all-others-name (assumption-arg-lists ;these are lists of nodenums/quoteps for calls of fn that we can assume (where fn is the top function symbol of the hyp)
                                                              hyp-args ;partially instantiated; any vars that remain must match the assumption
                                                              hyp-num ; only used for printing, we could drop this for speed?
                                                              other-hyps
                                                              alist
                                                              rule-symbol
                                                              rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                              node-replacement-array node-replacement-count refined-assumption-alist
                                                              rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (bounded-darg-list-listp assumption-arg-lists (get-dag-len rewrite-stobj2))
                                         (axe-tree-listp hyp-args)
                                         (posp hyp-num)
                                         (axe-rule-hyp-listp other-hyps)
                                         (symbol-alistp alist)
                                         (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2))
                                         (alist-suitable-for-hyp-args-and-hypsp alist hyp-args other-hyps)
                                         (symbolp rule-symbol)
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :measure (nfix count)
                             :split-types t
                             :verify-guards nil ; done below
                             )
                      (type (unsigned-byte 60) count)
                      (type (integer 1 *) hyp-num) ;; restrict to a fixnum?
                      (type symbol rule-symbol))
             (if (or (not (mbt (natp count))) (= 0 count))
                 (mv :count-exceeded nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
               (if (endp assumption-arg-lists)
                   ;; failed to relieve the hyp:
                   (prog2$ (and (member-eq rule-symbol (get-monitored-symbols rewrite-stobj))
                                (cw "(Failed to relieve free vars in hyp ~x0 of rule ~x1.)~%" hyp-num rule-symbol))
                           (mv (erp-nil) nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                 (b* ((arg-list (first assumption-arg-lists)) ;; args of the assumption we are currently checking for a match
                      (fail-or-extended-alist (unify-trees-with-dag-nodes hyp-args arg-list (get-dag-array rewrite-stobj2) alist)))
                   (if (eq :fail fail-or-extended-alist)
                       ;; this assumption didn't match, so proceed to the next assumption:
                       (,relieve-free-var-hyp-and-all-others-name (rest assumption-arg-lists)
                                                                  hyp-args hyp-num other-hyps
                                                                  alist rule-symbol
                                                                  rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                  node-replacement-array node-replacement-count refined-assumption-alist
                                                                  rewrite-stobj (+ -1 count))
                     ;; this assumption matched, so try to relieve the rest of the hyps using the resulting extension of ALIST:
                     (b* (((mv erp other-hyps-relievedp extended-alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                           (,relieve-rule-hyps-name other-hyps (+ 1 hyp-num)
                                                    fail-or-extended-alist ; matching with the ASSUMPTION caused free vars to be bound here
                                                    rule-symbol
                                                    rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                    node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj (+ -1 count)))
                          ((when erp) (mv erp nil nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                       (if other-hyps-relievedp
                           (mv (erp-nil) t extended-alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                         ;; this assumption matched, but we couldn't relieve the rest of the hyps, so discard the extension of the alist and proceed to the next assumption:
                         (,relieve-free-var-hyp-and-all-others-name (rest assumption-arg-lists)
                                                                    hyp-args hyp-num other-hyps
                                                                    alist ;the original alist
                                                                    rule-symbol
                                                                    rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                    node-replacement-array node-replacement-count refined-assumption-alist
                                                                    rewrite-stobj (+ -1 count)))))))))

           ;; ALIST is the substitution alist so far (it maps vars in the rule to nodenums and quoteps). If alist doesn't bind all the variables in the
           ;; HYP, we'll search for free variable matches in REFINED-ASSUMPTION-ALIST.
           ;; Relieving the hyp through rewriting may cause more nodes to be added to the DAG and more things to be added to memoization, hit-counts, and tries.
           ;; BOZO precompute the list of vars in the hyp?  or maybe just the ones that need to be bound in the alist?
           ;; Returns (mv erp hyps-relievedp alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array), where alist is irrelevant if hyps-relievedp is nil.
           ;; Otherwise, the alist returned may have been extended by the binding of free vars.
           (defund ,relieve-rule-hyps-name (hyps hyp-num alist rule-symbol
                                                 rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                 node-replacement-array node-replacement-count refined-assumption-alist
                                                 rewrite-stobj count)
             (declare (xargs :guard (and (axe-rule-hyp-listp hyps)
                                         (posp hyp-num)
                                         (symbol-alistp alist)
                                         (alist-suitable-for-hypsp alist hyps)
                                         (symbolp rule-symbol)
                                         (wf-rewrite-stobj2p rewrite-stobj2)
                                         (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :measure (nfix count)
                             :split-types t)
                      (type (unsigned-byte 60) count)
                      (type (integer 1 *) hyp-num) ;; restrict to a fixnum?
                      )
             (if (or (not (mbt (natp count)))
                     (= 0 count))
                 (mv :count-exceeded t alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
               (if (endp hyps)
                   ;; all hyps relieved:
                   (mv (erp-nil) t alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                 (b* ((hyp (first hyps))
                      (print (get-print rewrite-stobj))
                      (- (and (eq :verbose! print)
                              (cw "Relieving hyp ~x0 with alist ~x1.~%" hyp alist)))
                      (fn (ffn-symb hyp)) ;; all hyps are conses, fn may be a special keyword tag, like :axe-syntaxp
                      )
                   (case fn
                     (:axe-syntaxp ; (:axe-syntaxp . <expr>)
                      (let* ((syntaxp-expr (cdr hyp)) ;; strip off the :axe-syntaxp
                             (result (,eval-axe-syntaxp-expr-fn syntaxp-expr alist (get-dag-array rewrite-stobj2)) ;could make a version without dag-array (may be very common?).. TODO: use :dag-array?
                                     ))
                        (if result
                            ;;this hyp counts as relieved
                            (,relieve-rule-hyps-name (rest hyps) (+ 1 hyp-num) alist rule-symbol
                                                     rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                     node-replacement-array node-replacement-count refined-assumption-alist
                                                     rewrite-stobj (+ -1 count))
                          (prog2$ (and (member-eq rule-symbol (get-monitored-symbols rewrite-stobj))
                                       ;;is it worth printing in this case?
                                       (progn$ (cw "(Failed to relieve axe-syntaxp hyp ~x0 for ~x1.)~%" syntaxp-expr rule-symbol)
                                               ;; (cw "(Alist: ~x0)~%" alist)
                                               ;; (cw "(DAG:~%")
                                               ;; (print-array 'dag-array dag-array (get-dag-len rewrite-stobj2))
                                               ;; (cw ")~%")
                                               ))
                                  (mv (erp-nil) nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))))
                     (:axe-bind-free ; (:axe-bind-free <expr> . <vars-to-bind>)
                      ;; To evaluate the axe-bind-free hyp, we use alist, which binds vars to their nodenums or quoteps.
                      ;; The soundness of Axe should not depend on what an axe-bind-free function does; thus we cannot pass alist to such a function and trust it to faithfully extend it.  Nor can we trust it to extend the dag without changing any existing nodes. So we require the axe-bind-free-function to return an alist binding exactly certain vars, and we check the keys and vals of that alist.
                      ;;TODO: It might be nice to be able to pass in the assumptions to the axe-bind-free-function? e.g., for finding sizes from unsigned-byte-p assumptions.
                      (let* ((bind-free-expr (cadr hyp)) ;; strip off the :axe-bind-free
                             (result (,eval-axe-bind-free-function-application-fn (ffn-symb bind-free-expr) (fargs bind-free-expr) alist (get-dag-array rewrite-stobj2)) ;could make a version without dag-array (may be very common?).. TODO: use :dag-array?
                                     ))
                        (if result ;; nil to indicate failure, or an alist whose keys should be exactly the vars-to-bind
                            (let ((vars-to-bind (cddr hyp)))
                              (if (not (axe-bind-free-result-okayp result vars-to-bind (get-dag-len rewrite-stobj2)))
                                  (mv (erp-t)
                                      (er hard? ',relieve-rule-hyps-name "Bind free hyp ~x0 for rule ~x1 returned ~x2, but this is not a well-formed alist that binds ~x3." hyp rule-symbol result vars-to-bind)
                                      alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                                ;; this hyp counts as relieved:
                                (,relieve-rule-hyps-name (rest hyps) (+ 1 hyp-num)
                                                         (append result alist) ;; guaranteed to be disjoint given the analysis done when the rule was made and the call of axe-bind-free-result-okayp above
                                                         rule-symbol
                                                         rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                         node-replacement-array node-replacement-count refined-assumption-alist
                                                         rewrite-stobj (+ -1 count))))
                          ;; failed to relieve the axe-bind-free hyp:
                          (prog2$ (and (member-eq rule-symbol (get-monitored-symbols rewrite-stobj))
                                       (cw "(Failed to relieve axe-bind-free hyp ~x0 for ~x1.)~%" bind-free-expr rule-symbol))
                                  (mv (erp-nil) nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))))
                     (:free-vars ; (:free-vars . hyp)
                      ;; can't be a work-hard since there are free vars
                      (b* (;; Partially instantiate the hyp (the free vars will remain free):
                           ;; TODO: Could we just do the matching wrt the alist, and skip this instantiation step?:
                           (partially-instantiated-hyp (,instantiate-hyp-free-vars-name (cdr hyp) ;strip the :free-vars
                                                                                        alist (get-interpreted-function-alist rewrite-stobj)))
                           ((when (eq 'quote (ffn-symb partially-instantiated-hyp))) ;todo: this should not happen since there are free vars (unless perhaps we give special treatment to IFs)
                            (er hard? ',relieve-rule-hyps-name "ERROR: Instantiating a hyp with free vars produced a constant.")
                            (mv :error-instantiating nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                        ;; Some free vars remain in the partially-instantiated-hyp, so we search the REFINED-ASSUMPTION-ALIST for matches to bind them:
                        ;; If the NODE-REPLACEMENT-ARRAY ever contains more information than the REFINED-ASSUMPTION-ALIST, we might need to search it too.
                        ;; The refined-assumptions have been refined so that (equal (pred x) t) becomes (pred x) for better matching.
                        ;; TODO: Should we simplify the terms to which the free vars were bound (in case the assumptions are not simplified)?
                        (,relieve-free-var-hyp-and-all-others-name (lookup-in-refined-assumption-alist (ffn-symb partially-instantiated-hyp) refined-assumption-alist)
                                                                   (fargs partially-instantiated-hyp)
                                                                   hyp-num
                                                                   (rest hyps)
                                                                   alist rule-symbol
                                                                   rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                   node-replacement-array node-replacement-count refined-assumption-alist
                                                                   rewrite-stobj (+ -1 count))))
                     (:axe-binding-hyp ; (:axe-binding-hyp <var> . <expr>)
                      ;; todo: anything to do for work-hard (here and in the binding hyp case for the other rewriters/provers?)
                      (b* ((var (cadr hyp))
                           (expr (cddr hyp))
                           ;; First, we substitute for all the free vars in expr:
                           (instantiated-expr (,instantiate-hyp-no-free-vars2-name expr alist (get-interpreted-function-alist rewrite-stobj)))
                           ;; Now instantiated-hyp is an axe-tree with leaves that are quoteps and nodenums.
                           ;; TODO: Consider adding a special case here to check whether the hyp is a constant (may be very common)?
                           ;; Now rewrite the instantianted expr:
                           (old-try-count tries)
                           ((mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                            (,simplify-tree-and-add-to-dag-name instantiated-expr ; todo: is this known to be a non-var?  if so, take advantage of that fact
                                                                nil ;nothing is yet known to be equal to instantiated-expr
                                                                rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                node-replacement-array node-replacement-count refined-assumption-alist
                                                                rewrite-stobj (+ -1 count)))
                           ((when erp) (mv erp nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                           (- (and old-try-count (let ((try-diff (subtract-tries tries old-try-count)))
                                                   (and (< *used-try-print-threshold* try-diff)
                                                        (cw " (~x0 tries used ~x1:~x2 (binding hyp).)~%" try-diff rule-symbol hyp-num))))))
                        ;; A binding hyp always counts as relieved:
                        (,relieve-rule-hyps-name (rest hyps)
                                                 (+ 1 hyp-num)
                                                 (acons var new-nodenum-or-quotep alist) ; bind the var to the rewritten term
                                                 rule-symbol
                                                 rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                 node-replacement-array node-replacement-count refined-assumption-alist
                                                 rewrite-stobj (+ -1 count))))
                     (otherwise ; normal hyp or a call of axe-smt:
                       (b* ((old-try-count tries) ; might be nil
                            ((mv ?axe-smtp hyp) ; strip but remember a call of axe-smt, if any ; todo: allow args to be passed in for stp as well? ; ? here means axe-smtp is ignorable
                             (if (and (call-of 'axe-smt hyp)
                                      (= 1 (len (fargs hyp)))
                                      (consp (farg1 hyp)) ; a hyp must be a cons
                                      )
                                 (mv t (farg1 hyp))
                               (mv nil hyp)))
                            ((mv erp relievedp rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                             (b* (;; First, substitute in for all the vars in HYP (this also evaluates what it can)
                                  ;; (TODO: Consider not instantiating the hyp but rather simplifying it wrt an alist):
                                  (instantiated-hyp (,instantiate-hyp-no-free-vars2-name hyp alist (get-interpreted-function-alist rewrite-stobj)))
                                  ;; instantiated-hyp is now fully instantiated.  It is an axe-tree with leaves that are quoteps and nodenums (from vars already bound)
                                  ((when (fquotep instantiated-hyp)) ;; we know the instantiated-hyp is a cons, because hyp is
                                   ;; The instantiated-hyp is a quoted constant:
                                   (if (unquote$ instantiated-hyp)
                                       ;; The instantiated-hyp is a non-nil constant, so it counts as relieved:
                                       (mv (erp-nil) t rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                                     ;; The instantiated-hyp is 'nil, so it failed to be relieved:
                                     (progn$ (and (member-eq rule-symbol (get-monitored-symbols rewrite-stobj))
                                                  ;; We don't print much here, because a hyp that turns out to be nil (as opposed to some term for which we need a rewrite rule) is not very interesting:
                                                  (cw "(Failed to relieve hyp ~x0 for ~x1.~% Reason: Instantiated to nil.)~%" hyp rule-symbol))
                                             (mv (erp-nil) nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))))
                                  ;; There are no free vars (see bound-vars-suitable-for-hypp), so we try to relieve the (fully-instantiated) hyp by simplifying it:
                                  ((mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                                   ;; TODO: This tests whether atoms in the instiantiated-hyp are vars, but that seems wasteful because the hyp is fully instantiated):
                                   ;; bozo do we really want to add stupid natp hyps, etc. to the memoization? what about ground terms (most of them will have been evaluated above)?
                                   (,simplify-tree-and-add-to-dag-name instantiated-hyp ; todo: is this known to be a non-var?  if so, take advantage of that fact
                                                                       nil ; nothing is yet known to be equal to instantiated-hyp
                                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                                       rewrite-stobj (+ -1 count)))
                                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                                  ((when (consp new-nodenum-or-quotep)) ;tests for quotep
                                   (if (unquote new-nodenum-or-quotep) ;the unquoted value is non-nil, so the hyp is relieved:
                                       (mv (erp-nil) t rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                                     ;;hyp rewrote to 'nil, so it failed to be relieved:
                                     (progn$ (and (member-eq rule-symbol (get-monitored-symbols rewrite-stobj))
                                                  ;; We don't print much here, because a hyp that turns out to be nil (as opposed to some term for which we need a rewrite rule) is not very interesting:
                                                  (cw "(Failed to relieve hyp ~x0 for ~x1.~% Reason: Rewrote to nil.)~%" hyp rule-symbol))
                                             (mv (erp-nil) nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))))
                                  (new-nodenum new-nodenum-or-quotep) ;; didn't rewrite to a constant, so new-nodenum-or-quotep is a node number
                                  ;; Check whether the rewritten hyp is one of the known assumptions (todo: would be better to rewrite it using IFF).  TODO: Do the other versions of the rewriter/prover do something like this?
                                  ((when ;;(nodenum-equal-to-refined-assumptionp new-nodenum refined-assumption-alist (get-dag-array rewrite-stobj2)) ;todo: only do this if the hyp is not a known-boolean?
                                       (known-true-in-node-replacement-arrayp new-nodenum node-replacement-array node-replacement-count))
                                   ;;hyp rewrote to a known assumption and so counts as relieved:
                                   (mv (erp-nil) t rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                                  (monitoredp (member-eq rule-symbol (get-monitored-symbols rewrite-stobj))) ; todo: pull this out into a subroutine?:
                                  ,@(if smtp
                                        ;; Splice the SMT connection code into the b* bindings:
                                        `(((mv result state)
                                           (if axe-smtp
                                               ;; Tries to prove that the rewriten HYP is true or some assumption is false:
                                               (prove-disjunction-with-stp (cons new-nodenum (get-negated-assumptions rewrite-stobj2))
                                                                           (get-dag-array rewrite-stobj2)
                                                                           (get-dag-len rewrite-stobj2)
                                                                           (get-dag-parent-array rewrite-stobj2)
                                                                           (concatenate 'string "axe-smt-" (symbol-name rule-symbol) "-hyp-" (nat-to-string hyp-num) "-node-" (nat-to-string new-nodenum))
                                                                           :brief
                                                                           *default-stp-max-conflicts*
                                                                           nil ; counterexamplep ; todo: use this to avoid repeated queries that will fail?
                                                                           nil ; print-cex-as-signedp
                                                                           state)
                                             (mv :did-not-call-stp state)))
                                          ((when (eq *error* result))
                                           (mv :error-calling-stp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                                          ((when (eq *valid* result))
                                           (mv (erp-nil) t rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                                          ;; for any other result from STP (like :invalid or :timedout), or for :did-not-call-stp, we just continue:
                                          (- (and axe-smtp ;; monitoredp ;; todo: put back
                                                  (cw "(STP result for hyp ~x0 of rule ~x1: ~x2.)~%" hyp-num rule-symbol result))))
                                      ;; Splice in a possible warning for non-SMT rewriters:
                                      `((- (and axe-smtp (cw "WARNING: The ~x0 rewriter lacks SMT support, but rule ~x1 has an axe-smt hyp.~%" ',suffix rule-symbol)))))
                                  ;; Hyp failed to be relieved:
                                  (- (and monitoredp
                                          (let* ((relevant-nodes (nodenums-in-refined-assumption-alist refined-assumption-alist nil))
                                                 ;; (relevant-nodes (let ((expr (aref1 'dag-array (get-dag-array rewrite-stobj2) new-nodenum)))
                                                 ;;                   (if (and (consp expr)
                                                 ;;                            (not (eq 'quote (ffn-symb expr))))
                                                 ;;                       (append-nodenum-dargs (dargs expr) relevant-nodes)
                                                 ;;                     relevant-nodes)))
                                                 )
                                            (progn$ (cw "(Failed to relieve hyp ~x0 of rule ~x1.~%" hyp rule-symbol)
                                                    (cw "Reason: Rewrote to:~%")
                                                    (print-dag-node-nicely new-nodenum 'dag-array (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2) 200)
                                                    (cw "(Alist: ~x0)~%(Refined assumption alist:~%" alist)
                                                    (print-refined-assumption-alist-elided refined-assumption-alist (get-fns-to-elide rewrite-stobj))
                                                    (cw ")~%")
                                                    (cw "(node-replacement-array: elided)~%") ; todo print (but compactly)! also harvest relevant nodes above
                                                    (cw "(Relevant DAG nodes:~%")
                                                    (if (consp relevant-nodes)
                                                        (print-dag-array-nodes-and-supporters 'dag-array (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2) relevant-nodes)
                                                      (cw "elided"))
                                                    ;; (print-array 'dag-array (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2))
                                                    (cw "))~%"))))))
                               ;; As stated above, hyp failed to be relieved:
                               (mv (erp-nil) nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                            ((when erp) (mv erp nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                            ;; todo: handle monitored rules once, here?  but may need to know whether the hyp rewrote to nil
                            (- (and old-try-count ; todo: pull this out into a subroutine?:
                                    (let ((try-diff (subtract-tries tries old-try-count)))
                                      (if relievedp
                                          (and (< *used-try-print-threshold* try-diff)
                                               (cw " (~x0 tries used ~x1:~x2 (succeeded).)~%" try-diff rule-symbol hyp-num))
                                        (and (< *wasted-try-print-threshold* try-diff) ; todo: just call - on the tries? ; todo: consider distinguishing whether it rewrote to nil
                                             (cw "(~x0 tries wasted ~x1:~x2 (failed).)~%" try-diff rule-symbol hyp-num)))))))
                         (if relievedp
                             (,relieve-rule-hyps-name (rest hyps) (+ 1 hyp-num) alist rule-symbol
                                                      rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj (+ -1 count))
                           (mv (erp-nil) nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))))))))

           ;; Returns (mv erp instantiated-rhs-or-nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array) where rhs-or-nil is (if not nil) an axe-tree representing the instantiated RHS.
           (defund ,try-to-apply-rules-name (stored-rules ;the list of rules for the fn in question
                                             args-to-match
                                             rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                             node-replacement-array node-replacement-count refined-assumption-alist
                                             rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (stored-axe-rule-listp stored-rules)
                                         (bounded-darg-listp args-to-match (get-dag-len rewrite-stobj2)) ;todo: combine with the next one
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (if (or (not (mbt (natp count)))
                     (= 0 count))
                 (mv :count-exceeded nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
               (if (endp stored-rules) ;no rule fired
                   (mv (erp-nil) nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                 (b* ((stored-rule (first stored-rules))
                      (tries (increment-tries tries)) ; does nothing if not counting tries (this adds a try even if the rule-limit will cause us to fail below -- may be ok)
                      ;; Try to match the args-to-match with the args of the LHS of the rule (we want to fail fast, and most rules don't match, so we try matching right away):
                      (alist-or-fail (unify-terms-and-dag-items-fast (stored-rule-lhs-args stored-rule) args-to-match (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2)))
                      ((when (eq :fail alist-or-fail))
                       ;; the rule didn't match, so try the next rule:
                       (,try-to-apply-rules-name (rest stored-rules)
                                                 args-to-match rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj (+ -1 count)))
                      ;; The rule matched, but we need to check whether we've hit the limit for it (rare):
                      (print (get-print rewrite-stobj))
                      ((when (and limits (limit-reachedp stored-rule limits print))) ; todo: just pass in the rule-symbol (extracted below)?
                       ;; the limit for this rule is reached, so try the next rule:
                       (,try-to-apply-rules-name (rest stored-rules)
                                                 args-to-match rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj (+ -1 count)))
                      ;; Limit not reached, so try to relieve the rule's hyps:
                      (- (and (eq print :verbose!) (cw "(Trying to apply ~x0.~%" (stored-rule-symbol stored-rule))))
                      (hyps (stored-rule-hyps stored-rule))
                      ((mv erp hyps-relievedp alist ; alist may get extended by the binding of free vars
                           rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                       (if hyps
                           (let ((rule-symbol (stored-rule-symbol stored-rule)))
                             (,relieve-rule-hyps-name hyps
                                                      1 ;initial hyp number
                                                      alist-or-fail
                                                      rule-symbol
                                                      rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj (+ -1 count)))
                         ;;if there are no hyps, don't even bother: todo: inefficient?:
                         (mv (erp-nil) t alist-or-fail rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                      ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                   (if hyps-relievedp
                       ;; the hyps were relieved, so instantiate the RHS:
                       (prog2$ (and (eq print :verbose!)
                                    (cw "Rewriting with ~x0.)~%" (stored-rule-symbol stored-rule)))
                               (mv (erp-nil)
                                   ;; could use a faster version where we know there are no free vars:
                                   (,sublis-var-and-eval-name alist (stored-rule-rhs stored-rule) (get-interpreted-function-alist rewrite-stobj))
                                   rewrite-stobj2 ,@maybe-state
                                   memoization
                                   ;;no need to assemble the hit-counts if we are not going to print it
                                   (maybe-increment-hit-count (stored-rule-symbol stored-rule) hit-counts)
                                   tries
                                   (and limits (decrement-rule-limit stored-rule limits))
                                   node-replacement-array))
                     ;;failed to relieve the hyps, so try the next rule:
                     (prog2$ (and (eq print :verbose!)
                                  (cw "Failed to apply rule ~x0.)~%" (stored-rule-symbol stored-rule)))
                             (,try-to-apply-rules-name (rest stored-rules)
                                                       args-to-match rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj (+ -1 count))))))))

           ;; Simplifies the application of FN to its simplified DARGS, where FN is a function symbol.
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; No special handling if FN is an IF (of any type).  No evaluation of ground terms.
           (defund ,simplify-fun-call-and-add-to-dag-name (fn ; a function symbol
                                                           dargs ; these are simplified (so these are nodenums or quoteps)
                                                           trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to FN applied to DARGS (to be added to the memoization) ;todo: rename
                                                           rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                           node-replacement-array node-replacement-count refined-assumption-alist
                                                           rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (symbolp fn)
                                         (not (equal 'quote fn))
                                         (bounded-darg-listp dargs (get-dag-len rewrite-stobj2))
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count)))
                   (mv :count-exceeded nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  (expr (cons fn dargs)) ;todo: save this cons, or use below?
                  ;;Try looking it up in the memoization (note that the dargs are now simplified):
                  (memo-match (and memoization (lookup-in-memoization expr memoization))) ; todo: use a more specialized version of lookup-in-memoization, since we know the shape of expr (also avoid the cons for expr here)?
                  ((when memo-match)
                   (let ((memoization (add-pairs-to-memoization trees-equal-to-tree
                                                                memo-match ;the nodenum or quotep they are all equal to
                                                                memoization)))
                     (mv (erp-nil) memo-match rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                  ;; Next, try to apply rules:
                  ((mv erp rhs-or-nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,try-to-apply-rules-name (rule-db-get fn rewrite-stobj) ;; (get-rules-for-fn fn (get-rule-alist rewrite-stobj))
                                             dargs
                                             rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                             node-replacement-array node-replacement-count refined-assumption-alist
                                             rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
               (if rhs-or-nil
                   ;;A rule fired, so simplify the instantiated right-hand-side:
                   ;; This is a tail call, which allows long chains of rewrites:
                   (,simplify-tree-and-add-to-dag-name rhs-or-nil
                                                       ;;in the common case in which simplifying the args had no effect, the car of trees-equal-to-tree will be the same as (cons fn dargs), so don't add it twice
                                                       (and memoization
                                                            (cons-if-not-equal-car expr ;could save this and similar conses in the function
                                                                                   trees-equal-to-tree))
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count))
                 ;; No rule fired, so no simplification can be done.  Add the expression to the dag, but perhaps normalize nests of certain functions:
                 (b* ((- (and (all-consp dargs)
                              (cw "Warning: Unevaluated ground application: ~x0.~%" (cons fn dargs)))) ; todo: add ability to suppress some functions
                      ((mv erp nodenum-or-quotep rewrite-stobj2)
                       (add-and-maybe-normalize-expr fn dargs rewrite-stobj rewrite-stobj2))
                      ((when erp) (mv erp nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                      ;; See if the nodenum returned is equated to anything:
                      ;; Result is not rewritten (we could rewrite all such items (that replacements can introduce) outside the main clique)
                      (new-nodenum-or-quotep (if (consp nodenum-or-quotep) ; check for constant (e.g., if all xors cancelled)
                                                 nodenum-or-quotep
                                               (apply-node-replacement-array nodenum-or-quotep node-replacement-array node-replacement-count))))
                   (mv (erp-nil)
                       new-nodenum-or-quotep
                       rewrite-stobj2 ,@maybe-state
                       (and memoization ; we could save this cons:
                            (add-pairs-to-memoization (cons-if-not-equal-car expr trees-equal-to-tree) ; might be the same as tree if the args aren't simplified?) well, each arg should be simplified and memoed.
                                                      new-nodenum-or-quotep ;the nodenum-or-quotep they are all equal to
                                                      memoization))
                       hit-counts tries limits node-replacement-array)))))

           ;; Helper function for rewriting a tree that is an IF or MYIF or BOOLIF (used for both if/myif and boolif).  This is separate just to keep the caller small.
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; Note that this function does not return node-replacement-count since no nodes have been assumed that are relevant to the caller.
           ;; TODO: Are all elements in the array beyond node-replacement-count nil?
           (defund ,simplify-if/myif/boolif-tree-and-add-to-dag3-name (fn
                                                                       simplified-test ; a nodenum
                                                                       simplified-then-branch
                                                                       else-branch ; unsimplified
                                                                       tree
                                                                       trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                                       rewrite-stobj count)
             (declare (xargs :guard (and (member-eq fn '(if myif boolif))
                                         (wf-rewrite-stobj2p rewrite-stobj2)
                                         (natp simplified-test)
                                         (< simplified-test (get-dag-len rewrite-stobj2))
                                         (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                                         (axe-treep else-branch)
                                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                                         (tree-to-memoizep tree)
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count))) ;; for termination
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Now we rewrite the else-branch.
                  ;; Assume the test false (if not memoizing), step 1:
                  ((mv node-replacement-array node-replacement-count undo-pairs)
                   (if memoization ; can't use context if we are memoizing:
                       (mv node-replacement-array node-replacement-count nil)
                     (update-node-replacement-array-for-assuming-negation-of-node simplified-test node-replacement-array node-replacement-count (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2) (get-known-booleans rewrite-stobj))))
                  ;; Assume the test false (if not memoizing), step 2:
                  (refined-assumption-alist-for-else-branch
                    (if memoization ; can't use context if we are memoizing:
                        refined-assumption-alist
                      (extend-refined-assumption-alist-assuming-negation-of-node refined-assumption-alist simplified-test (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2))))
                  ;; Extend the negated-assumptions to include the test (thus assuming that the test is false), if not memoizing:
                  ,@(and smtp
                         '(((mv old-negated-assumptions rewrite-stobj2)
                            (if memoization  ; can't use context if we are memoizing:
                                (mv nil ; meaningless
                                    rewrite-stobj2)
                              (let* ((old-negated-assumptions (get-negated-assumptions rewrite-stobj2))
                                     (rewrite-stobj2 (put-negated-assumptions (cons simplified-test old-negated-assumptions) rewrite-stobj2)))
                                (mv old-negated-assumptions rewrite-stobj2))))))
                  ;; Rewrite the else-branch:
                  ((mv erp simplified-else-branch rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name else-branch
                                                       nil ;no trees are yet known equal to the else branch
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist-for-else-branch
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Special treatment for BOOLIF: Handle a simplified-else-branch that is known to be :non-nil as if it were 't:
                  (simplified-else-branch (if (eq 'boolif fn)
                                              (apply-node-replacement-array-bool-to-darg simplified-else-branch node-replacement-array node-replacement-count)
                                            simplified-else-branch))
                  ;; Clear the test assumption. node-replacement-array should then be
                  ;; like it was before we set it (except perhaps longer):
                  ;; If memoizing, undo-pairs will be nil:
                  (node-replacement-array (undo-writes-to-node-replacement-array undo-pairs node-replacement-array node-replacement-count (get-dag-len rewrite-stobj2)))
                  ;; Restore the old negated-assumptions:
                  ,@(and smtp
                         '((rewrite-stobj2 (if memoization
                                               rewrite-stobj2 ; we didn't change it above
                                             (put-negated-assumptions old-negated-assumptions rewrite-stobj2))))))
               ;; Now simplify the call of IF/MYIF/BOOLIF (this function takes simplified args and does not handle ifs specially, or else things might loop):
               ;; (We know we don't have a ground term, because simplified-test is not a constant.)
               (,simplify-fun-call-and-add-to-dag-name fn (list simplified-test simplified-then-branch simplified-else-branch)
                                                       (and memoization (cons tree trees-equal-to-tree)) ;the call of FN we are rewriting here is equal to tree
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count
                                                       refined-assumption-alist ; the original one, not extended for the else-branch
                                                       rewrite-stobj (+ -1 count))))

           ;; Helper function for rewriting a tree that is an IF or MYIF or BOOLIF (used for both if/myif and boolif).
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; Note that this function does not return node-replacement-count since no changes have been made that are relevant to the caller.
           (defund ,simplify-if/myif/boolif-tree-and-add-to-dag2-name (fn ; if or myif or boolif
                                                                       simplified-test ; a nodenum
                                                                       then-branch ; to be simplified
                                                                       else-branch ; to be simplified
                                                                       tree ; original tree, to be added to the memoization
                                                                       trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                                       rewrite-stobj count)
             (declare (xargs :guard (and (member-eq fn '(if myif boolif))
                                         (wf-rewrite-stobj2p rewrite-stobj2)
                                         (natp simplified-test)
                                         (< simplified-test (get-dag-len rewrite-stobj2))
                                         (axe-treep then-branch)
                                         (bounded-axe-treep then-branch (get-dag-len rewrite-stobj2))
                                         (axe-treep else-branch)
                                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                                         (tree-to-memoizep tree)
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count))) ;; for termination
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; First, we rewrite the then-branch.
                  ;; Assume the test true (if not memoizing), step 1:
                  ((mv node-replacement-array node-replacement-count undo-pairs)
                   (if memoization ; can't use context if we are memoizing:
                       (mv node-replacement-array node-replacement-count nil)
                     (update-node-replacement-array-for-assuming-node simplified-test node-replacement-array node-replacement-count (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2) (get-known-booleans rewrite-stobj))))
                  ;; Assume the test true (if not memoizing), step 2:
                  (refined-assumption-alist-for-then-branch
                    (if memoization ; can't use context if we are memoizing:
                        refined-assumption-alist
                      (extend-refined-assumption-alist-assuming-node refined-assumption-alist simplified-test (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2))))
                  ;; Extend the negated-assumptions to include the negated test (thus assuming that the test is true -- double negative), if not memoizing:
                  ,@(and smtp
                         '(((mv old-negated-assumptions rewrite-stobj2)
                            (if memoization  ; can't use context if we are memoizing:
                                (mv nil ; meaningless
                                    rewrite-stobj2)
                              (let* ((old-negated-assumptions (get-negated-assumptions rewrite-stobj2))
                                     (rewrite-stobj2 (put-negated-assumptions (cons `(not ,simplified-test) old-negated-assumptions) rewrite-stobj2)))
                                (mv old-negated-assumptions rewrite-stobj2))))))
                  ;; Rewrite the then-branch:
                  ((mv erp simplified-then-branch rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name then-branch
                                                       nil ;no trees are yet known equal to the then-branch
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist-for-then-branch
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Special treatment for BOOLIF: Handle a simplified-then-branch that is known to be :non-nil as if it were 't:
                  (simplified-then-branch (if (eq 'boolif fn)
                                              (apply-node-replacement-array-bool-to-darg simplified-then-branch node-replacement-array node-replacement-count)
                                            simplified-then-branch))
                  ;; Undo the assumption of the test being true.  node-replacement-array should then be
                  ;; like it was before we assumed the test (except perhaps longer):
                  ;; If memoizing, undo-pairs will be nil:
                  (node-replacement-array (undo-writes-to-node-replacement-array undo-pairs node-replacement-array node-replacement-count (get-dag-len rewrite-stobj2)))
                  ;; Restore the old negated-assumptions:
                  ,@(and smtp
                         '((rewrite-stobj2 (if memoization
                                               rewrite-stobj2 ; we didn't change it above
                                             (put-negated-assumptions old-negated-assumptions rewrite-stobj2))))))
               ;; Continue rewriting the IF/MYIF/BOOLIF:
               (,simplify-if/myif/boolif-tree-and-add-to-dag3-name fn
                                                                   simplified-test ; a nodenum
                                                                   simplified-then-branch ; a nodenum or quotep
                                                                   else-branch ; unsimplified
                                                                   tree
                                                                   trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                                   rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                   node-replacement-array node-replacement-count
                                                                   refined-assumption-alist ; the original one, not extended for the then-branch
                                                                   rewrite-stobj (+ -1 count))))

           ;; Rewrite a tree that is an IF or MYIF.
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; This is separate just to keep the main function small.
           (defund ,simplify-if/myif-tree-and-add-to-dag-name (tree ; a call of IF or MYIF
                                                               trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                               rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                               node-replacement-array node-replacement-count refined-assumption-alist
                                                               rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (axe-treep tree)
                                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                                         (consp tree)
                                         (member-eq (ffn-symb tree) '(if myif))
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2)) ;todo: name these 3?
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count))) ;; for termination
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  (args (fargs tree))
                  ((when (not (consp (rest (rest args))))) ;; for guards
                   (mv :bad-arity nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; First, simplify the test (TODO: would like to do this in an iff context):
                  ((mv erp simplified-test rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name (first args) ; the test of the IF or MYIF
                                                       nil ;no trees are yet known equal to the test
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Special treatment for IF/MYIF: Handle a simplified-test that is known to be :non-nil as if it were 't:
                  (simplified-test (apply-node-replacement-array-bool-to-darg simplified-test node-replacement-array node-replacement-count)))
               (if (consp simplified-test) ; tests for quotep (that is, checks whether we resolved the test)
                   ;; Rewrite either the "then" branch or the "else" branch, according to whether the test simplified to nil:
                   (,simplify-tree-and-add-to-dag-name (if (unquote simplified-test) (second args) (third args))
                                                       (and memoization (cons tree trees-equal-to-tree)) ;the thing we are rewriting here is equal to tree
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count))
                 ;; Failed to resolve the test:
                 (progn$
                   ;; If this gets printed too often for known predicates, we can preprocess such things:
                   ;; (and (equal test (second args)) (cw "Unresolved IF test with test same as then-branch (from an OR?): ~x0.~%" test))
                   (,simplify-if/myif/boolif-tree-and-add-to-dag2-name (ffn-symb tree) ; if or myif
                                                                       simplified-test
                                                                       (second args) ; "then" branch
                                                                       (third args) ; "else" branch
                                                                       tree trees-equal-to-tree ; could cons these and pass them together (they will be consed later)
                                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                                       rewrite-stobj (+ -1 count))))))

           ;; Rewrite a tree that is a BOOLIF.
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; This is separate just to keep the main function small
           (defund ,simplify-boolif-tree-and-add-to-dag-name (tree ; a call of BOOLIF
                                                              trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                              rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                              node-replacement-array node-replacement-count refined-assumption-alist
                                                              rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (axe-treep tree)
                                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                                         (consp tree)
                                         (equal 'boolif (ffn-symb tree))
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count)))
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  (args (fargs tree))
                  ((when (not (consp (rest (rest args))))) ;; for guards
                   (mv :bad-arity nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; First, simplify the test (TODO: would like to do this in an iff context):
                  ((mv erp simplified-test rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name (first args) ; the test of the BOOLIF
                                                       nil ;no trees are yet known equal to the test
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Special treatment for BOOLIF: Handle a simplified-test that is known to be :non-nil as if it were 't:
                  ;; skip this if the test is a known boolean??
                  (simplified-test (apply-node-replacement-array-bool-to-darg simplified-test node-replacement-array node-replacement-count)))
               (if (consp simplified-test) ; tests for quotep (that is, checks whether we resolved the test)
                   ;; Rewrite either the "then" branch or the "else" branch, according to whether the test simplified to nil, wrapping the result in bool-fix:
                   ;; TODO: Consider dropping the bool-fix if we have a known boolean:
                   (,simplify-tree-and-add-to-dag-name `(bool-fix$inline ,(if (unquote simplified-test) (second args) (third args))) ;the "then" branch or the "else" branch
                                                       (and memoization (cons tree trees-equal-to-tree)) ;the bool-fix$inline tree we are rewriting here is equal to TREE
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count))
                 ;; Failed to resolve the test (from here on, the process is mostly the same as for IF/MYIF except we pass BOOLIF as the FN):
                 (,simplify-if/myif/boolif-tree-and-add-to-dag2-name 'boolif
                                                                     simplified-test
                                                                     (second args)
                                                                     (third args)
                                                                     tree trees-equal-to-tree ; could cons these and pass them together (they will be consed later)
                                                                     rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                     node-replacement-array node-replacement-count refined-assumption-alist
                                                                     rewrite-stobj (+ -1 count)))))

           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; This is separate just to keep the proofs tractable (avoid too many sequential rewriter calls in one function).
           (defund ,simplify-bvif-tree-and-add-to-dag3-name (simplified-size
                                                             simplified-test ; a nodenum
                                                             simplified-then-branch
                                                             else-branch ; to be simplified
                                                             tree ; original BVIF tree
                                                             trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                             rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                             node-replacement-array node-replacement-count refined-assumption-alist
                                                             rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                                         (natp simplified-test)
                                         (< simplified-test (get-dag-len rewrite-stobj2))
                                         (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                                         (axe-treep else-branch)
                                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                                         (tree-to-memoizep tree)
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count))) ; for termination
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Now we rewrite the else-branch.
                  ;; Assume the test false (if not memoizing), step 1:
                  ((mv node-replacement-array node-replacement-count undo-pairs)
                   (if memoization ; can't use context if we are memoizing:
                       (mv node-replacement-array node-replacement-count nil)
                     (update-node-replacement-array-for-assuming-negation-of-node simplified-test node-replacement-array node-replacement-count (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2) (get-known-booleans rewrite-stobj))))
                  ;; Assume the test false (if not memoizing), step 2:
                  (refined-assumption-alist-for-else-branch
                    (if memoization ; can't use context if we are memoizing:
                        refined-assumption-alist
                      (extend-refined-assumption-alist-assuming-negation-of-node refined-assumption-alist simplified-test (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2))))
                  ;; Extend the negated-assumptions to include the test (thus assuming that the test is false), if not memoizing:
                  ,@(and smtp
                         '(((mv old-negated-assumptions rewrite-stobj2)
                            (if memoization  ; can't use context if we are memoizing:
                                (mv nil ; meaningless
                                    rewrite-stobj2)
                              (let* ((old-negated-assumptions (get-negated-assumptions rewrite-stobj2))
                                     (rewrite-stobj2 (put-negated-assumptions (cons simplified-test old-negated-assumptions) rewrite-stobj2)))
                                (mv old-negated-assumptions rewrite-stobj2))))))
                  ;; Simplify the else-branch
                  ((mv erp simplified-else-branch rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name else-branch
                                                       nil ;no trees are yet known equal to the else branch
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist-for-else-branch
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Clear the test assumption. node-replacement-array should then be
                  ;; like it was before we set it (except perhaps longer):
                  ;; If memoizing, undo-pairs will be nil:
                  (node-replacement-array (undo-writes-to-node-replacement-array undo-pairs node-replacement-array node-replacement-count (get-dag-len rewrite-stobj2)))
                  ;; Restore the old negated-assumptions:
                  ,@(and smtp
                         '((rewrite-stobj2 (if memoization
                                               rewrite-stobj2 ; we didn't change it above
                                             (put-negated-assumptions old-negated-assumptions rewrite-stobj2))))))
               ;; Try to apply rules to the call of BVIF on the simplified args:
               (,simplify-fun-call-and-add-to-dag-name 'bvif (list simplified-size simplified-test simplified-then-branch simplified-else-branch)
                                                       (and memoization (cons tree trees-equal-to-tree)) ; the BVIF call we are rewriting here is equal to TREE
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count
                                                       refined-assumption-alist ; the original one, not extended for the else-branch
                                                       rewrite-stobj (+ -1 count))))

           ;; Continue rewriting a call of BVIF.  This is for the case where we cannot resolve the test.
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; This is separate just to keep the proofs tractable (avoid too many sequential rewriter calls in one function).
           (defund ,simplify-bvif-tree-and-add-to-dag2-name (simplified-size
                                                             simplified-test ; a nodenum
                                                             then-arg ; unsimplified
                                                             else-arg ; unsimplified
                                                             tree ; original BVIF tree
                                                             trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                             rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                             node-replacement-array node-replacement-count refined-assumption-alist
                                                             rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                                         (natp simplified-test)
                                         (< simplified-test (get-dag-len rewrite-stobj2))
                                         (axe-treep then-arg)
                                         (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                                         (axe-treep else-arg)
                                         (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                                         (tree-to-memoizep tree)
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count))) ; for termination
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Next, we rewrite the then-branch.
                  ;; Assume the test true (if not memoizing), step 1:
                  ((mv node-replacement-array node-replacement-count undo-pairs)
                   (if memoization ; can't use context if we are memoizing:
                       (mv node-replacement-array node-replacement-count nil)
                     (update-node-replacement-array-for-assuming-node simplified-test node-replacement-array node-replacement-count (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2) (get-known-booleans rewrite-stobj))))
                  ;; Assume the test true (if not memoizing), step 2:
                  (refined-assumption-alist-for-then-branch
                    (if memoization ; can't use context if we are memoizing:
                        refined-assumption-alist
                      (extend-refined-assumption-alist-assuming-node refined-assumption-alist simplified-test (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2))))
                  ;; Extend the negated-assumptions to include the negation of the test (thus assuming that the test is true -- double negative), if not memoizing:
                  ,@(and smtp
                         '(((mv old-negated-assumptions rewrite-stobj2)
                            (if memoization  ; can't use context if we are memoizing:
                                (mv nil ; meaningless
                                    rewrite-stobj2)
                              (let* ((old-negated-assumptions (get-negated-assumptions rewrite-stobj2))
                                     (rewrite-stobj2 (put-negated-assumptions (cons `(not ,simplified-test) old-negated-assumptions) rewrite-stobj2)))
                                (mv old-negated-assumptions rewrite-stobj2))))))
                  ;; Simplify the then-branch:
                  ((mv erp simplified-then-branch rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name then-arg
                                                       nil ;no trees are yet known equal to the then-branch
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist-for-then-branch
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Undo the assumption of the test being true.  node-replacement-array should then be
                  ;; like it was before we assumed the test (except perhaps longer):
                  ;; If memoizing, undo-pairs will be nil:
                  (node-replacement-array (undo-writes-to-node-replacement-array undo-pairs node-replacement-array node-replacement-count (get-dag-len rewrite-stobj2)))
                  ;; Restore the old negated-assumptions:
                  ,@(and smtp
                         '((rewrite-stobj2 (if memoization
                                               rewrite-stobj2 ; we didn't change it above
                                             (put-negated-assumptions old-negated-assumptions rewrite-stobj2))))))
               (,simplify-bvif-tree-and-add-to-dag3-name simplified-size
                                                         simplified-test
                                                         simplified-then-branch
                                                         else-arg ; unsimplified
                                                         tree ; original bvif tree (bvif applied to the unsimplified args)
                                                         trees-equal-to-tree
                                                         rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                         node-replacement-array node-replacement-count
                                                         refined-assumption-alist  ; the original one, not extended for the then-branch
                                                         rewrite-stobj (+ -1 count))))

           ;; Continue rewriting a call of BVIF.  This is for the case where we cannot resolve the test.
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; This is separate just to keep the proofs tractable (avoid too many sequential rewriter calls in one function).
           ;; todo: renumber functions so this one is number 2
           (defund ,simplify-bvif-tree-and-add-to-dag1-name (size-arg ; unsimplified
                                                             simplified-test ; a nodenum
                                                             then-arg ; unsimplified
                                                             else-arg ; unsimplified
                                                             tree ; original BVIF tree
                                                             trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                             rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                             node-replacement-array node-replacement-count refined-assumption-alist
                                                             rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (axe-treep size-arg)
                                         (bounded-axe-treep size-arg (get-dag-len rewrite-stobj2))
                                         (natp simplified-test)
                                         (< simplified-test (get-dag-len rewrite-stobj2))
                                         (axe-treep then-arg)
                                         (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                                         (axe-treep else-arg)
                                         (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                                         (tree-to-memoizep tree)
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count))) ; for termination
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Simplify the size param:
                  ((mv erp simplified-size rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name size-arg
                                                       nil ;no trees are yet known equal to the the size param
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
               (,simplify-bvif-tree-and-add-to-dag2-name simplified-size
                                                         simplified-test
                                                         then-arg ; unsimplified
                                                         else-arg ; unsimplified
                                                         tree ; original BVIF tree
                                                         trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                         rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                         node-replacement-array node-replacement-count refined-assumption-alist
                                                         rewrite-stobj (+ -1 count))))

           ;; Rewrites TREE, which must be of the form (bvif <size> <test> <then> <else>).
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; This is separate just to keep the main function small.
           (defund ,simplify-bvif-tree-and-add-to-dag-name (tree ; a call of BVIF
                                                            trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                            rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                            node-replacement-array node-replacement-count refined-assumption-alist
                                                            rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (axe-treep tree)
                                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                                         (consp tree)
                                         (equal 'bvif (ffn-symb tree))
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count))) ; for termination
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  (args (fargs tree))
                  ((when (not (consp (rest (rest (rest args)))))) ;; check arity, for guards
                   (mv :bad-arity nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; First, simplify the test of the BVIF:
                  ((mv erp simplified-test rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name (second args) ;the test of the BVIF
                                                       nil ;no trees are yet known equal to the test
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Special treatment for BVIF: Handle a simplified-test that is known to be :non-nil as if it were 't:
                  (simplified-test (apply-node-replacement-array-bool-to-darg simplified-test node-replacement-array node-replacement-count)))
               (if (consp simplified-test) ; tests for quotep
                   ;; test was resolved (todo: do better here, if already a bv??):
                   (,simplify-tree-and-add-to-dag-name `(bvchop
                                                          ,(first args) ; size arg
                                                          ,(if (unquote simplified-test)
                                                               ;; test rewrote to non-nil:
                                                               (third args) ; "then" branch
                                                             ;; test rewrote to nil:
                                                             (fourth args) ; "else" branch
                                                             ))
                                                       (and memoization (cons tree trees-equal-to-tree)) ;the thing we are rewriting here is equal to tree
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count))
                 ;;couldn't resolve the test:
                 (,simplify-bvif-tree-and-add-to-dag1-name (first args) ; size param
                                                           simplified-test
                                                           (third args) ; then-branch
                                                           (fourth args) ; else-branch
                                                           tree trees-equal-to-tree
                                                           rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                           node-replacement-array node-replacement-count refined-assumption-alist
                                                           rewrite-stobj (+ -1 count)))))

           ;; Rewrites a tree that is a NOT.
           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           (defund ,simplify-not-tree-and-add-to-dag-name (tree ; a call of NOT
                                                           trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                           rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                           node-replacement-array node-replacement-count refined-assumption-alist
                                                           rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (axe-treep tree)
                                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                                         (consp tree)
                                         (equal 'not (ffn-symb tree))
                                         (tree-to-memoizep tree)
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (b* (((when (or (not (mbt (natp count))) (= 0 count))) ; for termination
                   (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  (args (fargs tree))
                  ((when (not (consp args))) ; for guards
                   (mv :bad-arity nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; First, rewrite the arg:
                  ((mv erp simplified-arg rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-tree-and-add-to-dag-name (first args) ;the single arg
                                                       nil ;no trees are yet known equal to the test
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj (+ -1 count)))
                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                  ;; Special treatment for NOT: Treat any non-nil arg like t:
                  (simplified-arg (apply-node-replacement-array-bool-to-darg simplified-arg node-replacement-array node-replacement-count)))
               (if (consp simplified-arg) ; tests for quotep
                   (mv (erp-nil)
                       (if (unquote simplified-arg) *nil* *t*) ; negate since we are rewriting a NOT
                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                       node-replacement-array)
                 ;; Arg did not rewrite to a constant, so try to apply rules to the call of NOT on the simplified arg:
                 (,simplify-fun-call-and-add-to-dag-name 'not (list simplified-arg)
                                                         (and memoization (cons tree trees-equal-to-tree)) ;the thing we are rewriting here is equal to tree
                                                         rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                         node-replacement-array node-replacement-count refined-assumption-alist
                                                         rewrite-stobj (+ -1 count)))))

           ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;; Rewrite TREE repeatedly using RULE-ALIST (from rewrite-stobj) and REFINED-ASSUMPTION-ALIST and add the result to the DAG-ARRAY (if not a quote), returning a nodenum or a quotep.
           ;; TREE is an axe-tree (with nodenums and quoteps and variables at the leaves).
           ;; TREES-EQUAL-TO-TREE is a list of terms (not vars) equal to TREE (at the bottom is the original term we are rewriting) - when we get the final result, all these terms will be equal to it - TODO: option to turn this off?

           ;; All nodenums mentioned in the MEMOIZATION must be part of the DAG.
           ;; If we are memoizing, we don't use information from if tests when rewriting then-branches and else-branches (potentially unsound).

           ;; This does not return node-replacement-count, because although some node replacement entries may be set (when processing IFs), they should all be cleared again.

           ;;leaves nodes below dag-len untouched..
           ;;TODO: could put in simple loop checking; check whether TREE is already present in TREES-EQUAL-TO-TREE (maybe only check the first few elements), but TREES-EQUAL-TO-TREE may only be valid if we are memoizing.
           (defund ,simplify-tree-and-add-to-dag-name (tree
                                                       trees-equal-to-tree ;a list of the successive RHSes, all of which are equivalent to tree (to be added to the memoization)
                                                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                       node-replacement-array node-replacement-count refined-assumption-alist
                                                       rewrite-stobj count)
             (declare (xargs :guard (and (axe-treep tree)
                                         (wf-rewrite-stobj2p rewrite-stobj2)
                                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                                         (trees-to-memoizep trees-equal-to-tree)
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :split-types t
                             :measure (nfix count))
                      (type (unsigned-byte 60) count))
             (if (or (not (mbt (natp count))) (= 0 count))
                 (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
               (if (atom tree)
                   (if (symbolp tree)
                       ;; It's a variable (this case may be very rare; can we eliminate it by pre-handling vars in the initial term?):
                       (b* (;; Add it to the DAG:
                            ((mv erp nodenum rewrite-stobj2)
                             (add-variable-to-dag-array-in-stobj tree rewrite-stobj2))
                            ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                            ;; See if the resulting node is known to be equal to something:
                            (new-nodenum-or-quotep (apply-node-replacement-array nodenum node-replacement-array node-replacement-count))
                            ;; (- (cw "Var ~x0 is node ~x1 and becomes node ~x2.~%" tree nodenum new-nodenum-or-quotep))
                            )
                         (mv (erp-nil)
                             new-nodenum-or-quotep
                             rewrite-stobj2 ,@maybe-state
                             (and memoization
                                  (add-pairs-to-memoization trees-equal-to-tree ;the items (TODO: Can this be non-empty?) ; We cannot add a memoization entry for TREE itself, because it is not a function call.
                                                            new-nodenum-or-quotep ;the nodenum-or-quotep they are all equal to
                                                            memoization))
                             hit-counts tries limits
                             node-replacement-array))
                     ;; TREE is a nodenum (because it's an atom but not a symbol):
                     ;; TODO: replacement works best if the nodes in the dag are already rewritten.  but what if this nodenum came from a node-equality assumption? in that case, it may not be rewritten!  Consider always calling simplify-conjunction-xxx to simplify the entries in the node-replacement-array once at the beginning.
                     ;; Apply a replacement from the node-replacement-array, if any:
                     (let* ((tree (apply-node-replacement-array tree node-replacement-array node-replacement-count)))
                       (mv (erp-nil)
                           tree
                           rewrite-stobj2 ,@maybe-state
                           (if (and memoization
                                    ;; todo: drop this check?:
                                    trees-equal-to-tree ; could check just this, but then it *must* always be nil if we are not memoizing
                                    )
                               (add-pairs-to-memoization trees-equal-to-tree ; We cannot add a memoization entry for TREE itself, because it is not a function call.
                                                         tree ; the nodenum to which all the TREES-EQUAL-TO-TREE rewrote
                                                         memoization)
                             memoization)
                           hit-counts tries limits
                           node-replacement-array)))
                 ;; TREE is a cons:
                 (let ((fn (ffn-symb tree)))
                   (if (eq 'quote fn)
                       ;; TREE is a quoted constant:
                       (mv (erp-nil)
                           tree ; return the quoted constant
                           rewrite-stobj2 ,@maybe-state
                           (if (and memoization trees-equal-to-tree)
                               (add-pairs-to-memoization trees-equal-to-tree ; We cannot add a memoization entry for TREE itself, because it is not a function call.
                                                         tree ; the constant to which all the TREES-EQUAL-TO-TREE rewrote
                                                         memoization)
                             memoization)
                           hit-counts tries limits
                           node-replacement-array)
                     ;; TREE is a function call:
                     ;; Try looking it up in memoization (note that the args are not yet simplified):
                     (let ((memo-match (and memoization (lookup-in-memoization tree memoization))))
                       (if memo-match
                           (mv (erp-nil)
                               memo-match ; a darg
                               rewrite-stobj2 ,@maybe-state
                               (add-pairs-to-memoization trees-equal-to-tree ; We don't add a memoization entry for TREE itself, because it already has one.
                                                         memo-match ;the nodenum or quotep to which all the TREES-EQUAL-TO-TREE rewrote
                                                         memoization)
                               hit-counts tries limits
                               node-replacement-array)
                         ;; Handle NOT and the various kinds of IF:
                         (case fn
                           (not ; could perhaps delay special handling for NOT until after the args are simplified
                             (,simplify-not-tree-and-add-to-dag-name tree trees-equal-to-tree
                                                                     rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                     node-replacement-array node-replacement-count refined-assumption-alist
                                                                     rewrite-stobj
                                                                     (+ -1 count) ;could perhaps be avoided with a more complex measure
                                                                     ))
                           ((if myif)
                            (,simplify-if/myif-tree-and-add-to-dag-name tree trees-equal-to-tree
                                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                                        rewrite-stobj
                                                                        (+ -1 count) ;could perhaps be avoided with a more complex measure
                                                                        ))
                           (boolif (,simplify-boolif-tree-and-add-to-dag-name tree trees-equal-to-tree
                                                                              rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                              node-replacement-array node-replacement-count refined-assumption-alist
                                                                              rewrite-stobj
                                                                              (+ -1 count) ;could perhaps be avoided with a more complex measure
                                                                              ))
                           (bvif (,simplify-bvif-tree-and-add-to-dag-name tree trees-equal-to-tree
                                                                          rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                          node-replacement-array node-replacement-count refined-assumption-alist
                                                                          rewrite-stobj
                                                                          (+ -1 count) ;could perhaps be avoided with a more complex measure
                                                                          ))
                           (t
                             ;; It wasn't a NOT or any kind of IF:
                             (b* (;; We are simplifying a call of FN on args that are axe-trees.
                                  ;; First we simplify the args:
                                  ;; TODO: Should we simplify the args earlier? e.g., before looking the term up in the memoization?
                                  ;; TODO: might it be possible to not check for ground-terms because we never build them? -- think about where terms might come from other than sublis-var-simple, which we could change to not build ground terms (of functions we know about)
                                  ;; TODO: maybe we should try to apply rules here (maybe outside-in rules) instead of rewriting the args
                                  ;; TODO: could pass in a flag for the common case where the args are known to be already simplified (b/c the tree is a dag node?)
                                  ;; (- (and (eq :verbose! print) (cw "(Rewriting args of ~x0:~%" fn)))
                                  ((mv erp simplified-args rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                       node-replacement-array)
                                   (,simplify-trees-and-add-to-dag-name (fargs tree)
                                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                                        rewrite-stobj (+ -1 count)))
                                  ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                                  ;; (- (and (eq :verbose! print) (cw "Done rewriting args.)~%")))
                                  )
                               ;; SIMPLIFIED-ARGS is now a list of dargs (nodenums and quoteps). Now we simplify FN applied to SIMPLIFIED-ARGS:
                               (if (consp fn) ;;tests for lambda
                                   ;; It's a lambda, so we beta-reduce and simplify the result:
                                   ;; note that we don't look up lambdas in the assumptions (this is consistent with simplifying first)
                                   ;; TODO: It's possible that we wasted time above simplifying lambda args (some args may be unneeded if the lambda body is a resolvable if), but
                                   ;; I'm not sure how to prevent that (we want to simplify args first because they may be mentioned multiple times in the lambda-body).
                                   (let* ((formals (lambda-formals fn))
                                          (body (lambda-body fn))
                                          (new-expr (,subcor-var-and-eval-name formals simplified-args body (get-interpreted-function-alist rewrite-stobj))))
                                     ;;simplify the result of beta-reducing:
                                     (,simplify-tree-and-add-to-dag-name new-expr
                                                                         (and memoization (cons tree trees-equal-to-tree)) ;we memoize the lambda
                                                                         rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                         node-replacement-array node-replacement-count refined-assumption-alist
                                                                         rewrite-stobj (+ -1 count)))
                                 ;; not a lambda:
                                 (b* (;; handle possible ground term by evaluating (since ,simplify-fun-call-and-add-to-dag-name doesn't handle ground terms):
                                      ;; todo: this code is essentially duplicated in ,simplify-dag-nodes-name:
                                      ((mv erp evaluatedp val)
                                       (if (not (all-consp simplified-args)) ;; test for all quoted constants
                                           ;; not a ground term:
                                           (mv (erp-nil) nil nil)
                                         ;; ground term, so try to evaluate (may fail, but we may have a constant opener rule to apply later):
                                         (b* (((mv erp val)
                                               (,apply-axe-evaluator-to-quoted-args-name fn simplified-args (get-interpreted-function-alist rewrite-stobj))))
                                           (if erp
                                               (if (call-of :unknown-function erp) ; I suppose this could also be a bad arity?
                                                   (progn$ ;; (cw "Warning: Could not evaluate call of ~x0.~%" fn)
                                                           (mv (erp-nil) nil nil) ;no error, but it didn't produce a value
                                                           )
                                                 ;; anything else non-nil is a true error:
                                                 (mv erp nil nil))
                                             ;; normal case:
                                             (mv (erp-nil) t val)))))
                                      ;; I suppose we could suppress any evaluator error here if we choose to (might be a bit faster)?
                                      ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                                   (if evaluatedp
                                       (let ((quoted-val (enquote val)))
                                         (mv (erp-nil)
                                             quoted-val
                                             rewrite-stobj2 ,@maybe-state
                                             (and memoization
                                                  (add-pairs-to-memoization (cons ;todo: we could avoid this cons
                                                                              tree ;; the original tree, with unsimplified args (might be ground, but that might be rare)
                                                                              ;; should we include here fn applied to simplified-args? could use a separate memoization for ground terms
                                                                              trees-equal-to-tree)
                                                                            quoted-val ;the quoted constant to which TREE and all the TREES-EQUAL-TO-TREE rewrote
                                                                            memoization))
                                             hit-counts tries limits
                                             node-replacement-array))
                                     ;; Otherwise, simplify the non-lambda FN applied to the simplified args:
                                     ;; TODO: Perhaps pass in the original tree for use by cons-with-hint:
                                     (,simplify-fun-call-and-add-to-dag-name fn simplified-args
                                                                             (and memoization (cons tree trees-equal-to-tree)) ;the thing we are rewriting is equal to tree
                                                                             rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                             node-replacement-array node-replacement-count refined-assumption-alist
                                                                             rewrite-stobj (+ -1 count)))))))))))))))

           ;; Simplifies all the trees in TREES.
           ;; Returns (mv erp nodenums-or-quoteps rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
           ;;if the items in trees are already all nodenums or quoted constants this doesn't re-cons-up the list
           (defund ,simplify-trees-and-add-to-dag-name (trees
                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                        rewrite-stobj count)
             (declare (xargs :guard (and (wf-rewrite-stobj2p rewrite-stobj2)
                                         (bounded-axe-tree-listp trees (get-dag-len rewrite-stobj2))
                                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                         (hit-countsp hit-counts)
                                         (triesp tries)
                                         (rule-limitsp limits)
                                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                         (natp node-replacement-count)
                                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                         (unsigned-byte-p 60 count))
                             :stobjs (rewrite-stobj rewrite-stobj2 ,@maybe-state)
                             :measure (nfix count)
                             :split-types t)
                      (type (unsigned-byte 60) count))
             (if (or (not (mbt (natp count)))
                     (= 0 count))
                 (mv :count-exceeded trees rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
               (if (atom trees)
                   (mv (erp-nil) trees rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                 (b* ((first-tree (first trees))
                      (rest (rest trees))
                      ;; why do we handle the rest first?
                      ((mv erp rest-result rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                           node-replacement-array)
                       (,simplify-trees-and-add-to-dag-name rest
                                                            rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                            node-replacement-array node-replacement-count refined-assumption-alist
                                                            rewrite-stobj (+ -1 count)))
                      ((when erp) (mv erp trees rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                      ((mv erp first-tree-result rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                       (,simplify-tree-and-add-to-dag-name first-tree
                                                           nil ;; nothing is yet known equal to first-tree
                                                           rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                           node-replacement-array node-replacement-count refined-assumption-alist
                                                           rewrite-stobj (+ -1 count)))
                      ((when erp) (mv erp trees rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                   (mv (erp-nil)
                       (cons-with-hint first-tree-result rest-result trees)
                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))))

           ) ;end mutual-recursion

         ;; Theorems about when the count reaches 0:
         (progn
           (defthm ,(pack$ 'relieve-free-var-hyp-and-all-others- suffix '-of-0)
             (equal ,(subst 0 'count call-of-relieve-free-var-hyp-and-all-others)
                    (mv :count-exceeded nil alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-relieve-free-var-hyp-and-all-others)))))

           (defthm ,(pack$ 'relieve-rule-hyps- suffix '-of-0)
             (equal ,(subst 0 'count call-of-relieve-rule-hyps)
                    (mv :count-exceeded t alist rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-relieve-rule-hyps)))))

           (defthm ,(pack$ 'try-to-apply-rules- suffix '-of-0)
             (equal ,(subst 0 'count call-of-try-to-apply-rules)
                    (mv :count-exceeded nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-try-to-apply-rules)))))

           (defthm ,(pack$ 'simplify-trees-and-add-to-dag- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-trees-and-add-to-dag)
                    (mv :count-exceeded trees rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-trees-and-add-to-dag)))))

           (defthm ,(pack$ 'simplify-fun-call-and-add-to-dag- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-fun-call-and-add-to-dag)
                    (mv :count-exceeded nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-fun-call-and-add-to-dag)))))

           (defthm ,(pack$ 'simplify-tree-and-add-to-dag- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-tree-and-add-to-dag)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-tree-and-add-to-dag)))))

           (defthm ,(pack$ 'simplify-if/myif-tree-and-add-to-dag- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-if/myif-tree-and-add-to-dag)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-if/myif-tree-and-add-to-dag)))))

           (defthm ,(pack$ 'simplify-not-tree-and-add-to-dag- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-not-tree-and-add-to-dag)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-not-tree-and-add-to-dag)))))

           (defthm ,(pack$ 'simplify-if/myif/boolif-tree-and-add-to-dag2- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)))))

           (defthm ,(pack$ 'simplify-if/myif/boolif-tree-and-add-to-dag3- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)))))

           (defthm ,(pack$ 'simplify-boolif-tree-and-add-to-dag- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-boolif-tree-and-add-to-dag)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-boolif-tree-and-add-to-dag)))))

           (defthm ,(pack$ 'simplify-bvif-tree-and-add-to-dag- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-bvif-tree-and-add-to-dag)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-bvif-tree-and-add-to-dag)))))

           (defthm ,(pack$ 'simplify-bvif-tree-and-add-to-dag1- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-bvif-tree-and-add-to-dag1)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-bvif-tree-and-add-to-dag1)))))

           (defthm ,(pack$ 'simplify-bvif-tree-and-add-to-dag2- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-bvif-tree-and-add-to-dag2)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-bvif-tree-and-add-to-dag2)))))

           (defthm ,(pack$ 'simplify-bvif-tree-and-add-to-dag3- suffix '-of-0)
             (equal ,(subst 0 'count call-of-simplify-bvif-tree-and-add-to-dag3)
                    (mv :count-exceeded (get-dag-len rewrite-stobj2) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array))
             :hints (("Goal" :expand ((:free (count) ,call-of-simplify-bvif-tree-and-add-to-dag3)))))
           ) ;end progn

         ;; This may speed things up a bit:
         ;; (defun quick-and-dirty-srs-off (cl1 ac)
         ;;   (declare (ignore cl1 ac)
         ;;            (xargs :mode :logic :guard t))
         ;;   nil)
         ;; (defattach-system quick-and-dirty-srs quick-and-dirty-srs-off)

         (make-flag ,simplify-tree-and-add-to-dag-name)

         (defthm ,(pack$ 'len-of-mv-nth-1-of-simplify-trees-and-add-to-dag- suffix)
           (equal (len (mv-nth 1 ,call-of-simplify-trees-and-add-to-dag))
                  (len trees))
           :hints (("Goal" :expand ((:free (count) ,call-of-simplify-trees-and-add-to-dag))
                    :induct (simplify-trees-and-add-to-dag-induct trees count)
                    :in-theory (enable (:i len)))))

         ;; Everything returns a valid hit-counts:
         (,(pack$ 'defthm-flag-simplify-tree-and-add-to-dag- suffix)
          (defthm ,(pack$ 'hit-countsp-after-relieve-free-var-hyp-and-all-others- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 6 5) ,call-of-relieve-free-var-hyp-and-all-others)))

            :flag ,relieve-free-var-hyp-and-all-others-name)

          (defthm ,(pack$ 'hit-countsp-after-relieve-rule-hyps- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 6 5) ,call-of-relieve-rule-hyps)))
            :flag ,relieve-rule-hyps-name)

          (defthm ,(pack$ 'hit-countsp-after-try-to-apply-rules- suffix)
            (implies (and (stored-axe-rule-listp stored-rules)
                          (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-try-to-apply-rules)))
            :flag ,try-to-apply-rules-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-trees-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-trees-and-add-to-dag)))
            :flag ,simplify-trees-and-add-to-dag-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)))
            :flag ,simplify-if/myif/boolif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)))
            :flag ,simplify-if/myif/boolif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-if/myif-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-if/myif-tree-and-add-to-dag)))
            :flag ,simplify-if/myif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-not-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-not-tree-and-add-to-dag)))
            :flag ,simplify-not-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-boolif-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-boolif-tree-and-add-to-dag)))
            :flag ,simplify-boolif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-bvif-tree-and-add-to-dag3- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-bvif-tree-and-add-to-dag3)))
            :flag ,simplify-bvif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-bvif-tree-and-add-to-dag2- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-bvif-tree-and-add-to-dag2)))
            :flag ,simplify-bvif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-bvif-tree-and-add-to-dag1- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-bvif-tree-and-add-to-dag1)))
            :flag ,simplify-bvif-tree-and-add-to-dag1-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-bvif-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-bvif-tree-and-add-to-dag)))
            :flag ,simplify-bvif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-tree-and-add-to-dag)))
            :flag ,simplify-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'hit-countsp-after-simplify-fun-call-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (hit-countsp hit-counts))
                     (hit-countsp (mv-nth ,(if smtp 5 4) ,call-of-simplify-fun-call-and-add-to-dag)))
            :flag ,simplify-fun-call-and-add-to-dag-name)

          :hints (("Goal" :do-not '(generalize eliminate-destructors)
                   :in-theory (e/d ( ;TAKE-WHEN-<=-OF-LEN
                                    len-of-cadar-when-axe-treep
                                    pseudo-termp-of-cadddr-when-axe-treep
                                    axe-bind-free-result-okayp-rewrite
                                    symbol-alistp-when-alistp
                                    true-listp-of-cdr)
                                   (dargp-less-than
                                    natp
                                    quotep
                                    myquotep))
                   :expand ((:free (memoization count other-hyps alist)
                                   ,call-of-relieve-free-var-hyp-and-all-others)
                            (:free (memoization count)
                                   ,call-of-relieve-rule-hyps)
                            (:free (memoization)
                                   (,relieve-rule-hyps-name nil hyp-num alist rule-symbol
                                                            rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                            node-replacement-array node-replacement-count refined-assumption-alist
                                                            rewrite-stobj count))
                            (:free (memoization count)
                                   (,simplify-trees-and-add-to-dag-name nil
                                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                                        rewrite-stobj count))
                            (:free (memoization count)
                                   ,call-of-simplify-trees-and-add-to-dag)
                            (:free (memoization limits hit-counts tries count)
                                   ,call-of-try-to-apply-rules)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif-tree-and-add-to-dag)
                            (:free (memoization fn count)
                                   ,call-of-simplify-not-tree-and-add-to-dag)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag)
                            (:free (memoization count)
                                   ,call-of-simplify-boolif-tree-and-add-to-dag)
                            (:free (MEMOIZATION count TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-tree-and-add-to-dag)
                            (:free (MEMOIZATION count TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-fun-call-and-add-to-dag)
                            (:free (MEMOIZATION count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag1)
                            (:free (MEMOIZATION count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag2)
                            (:free (MEMOIZATION count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag3)
                            (axe-rule-hyp-listp hyps)))))

         ;; The rule-limits returned are ok:
         (,(pack$ 'defthm-flag-simplify-tree-and-add-to-dag- suffix)
          (defthm ,(pack$ 'rule-limitsp-after-relieve-free-var-hyp-and-all-others- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 8 7) ,call-of-relieve-free-var-hyp-and-all-others)))
            :flag ,relieve-free-var-hyp-and-all-others-name)

          (defthm ,(pack$ 'rule-limitsp-after-relieve-rule-hyps- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 8 7) ,call-of-relieve-rule-hyps)))
            :flag ,relieve-rule-hyps-name)

          (defthm ,(pack$ 'rule-limitsp-after-try-to-apply-rules- suffix)
            (implies (and (stored-axe-rule-listp stored-rules)
                          (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-try-to-apply-rules)))
            :flag ,try-to-apply-rules-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-trees-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-trees-and-add-to-dag)))
            :flag ,simplify-trees-and-add-to-dag-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)))
            :flag ,simplify-if/myif/boolif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)))
            :flag ,simplify-if/myif/boolif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-if/myif-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-if/myif-tree-and-add-to-dag)))
            :flag ,simplify-if/myif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-not-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-not-tree-and-add-to-dag)))
            :flag ,simplify-not-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-boolif-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-boolif-tree-and-add-to-dag)))
            :flag ,simplify-boolif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-bvif-tree-and-add-to-dag3- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-bvif-tree-and-add-to-dag3)))
            :flag ,simplify-bvif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-bvif-tree-and-add-to-dag2- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-bvif-tree-and-add-to-dag2)))
            :flag ,simplify-bvif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-bvif-tree-and-add-to-dag1- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-bvif-tree-and-add-to-dag1)))
            :flag ,simplify-bvif-tree-and-add-to-dag1-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-bvif-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-bvif-tree-and-add-to-dag)))
            :flag ,simplify-bvif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-tree-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-tree-and-add-to-dag)))
            :flag ,simplify-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'rule-limitsp-after-simplify-fun-call-and-add-to-dag- suffix)
            (implies (and (rewrite-stobjp rewrite-stobj)
                          (rule-limitsp limits))
                     (rule-limitsp (mv-nth ,(if smtp 7 6) ,call-of-simplify-fun-call-and-add-to-dag)))
            :flag ,simplify-fun-call-and-add-to-dag-name)

          :hints (("Goal" :do-not '(generalize eliminate-destructors)
                   :in-theory (e/d ( ;TAKE-WHEN-<=-OF-LEN
                                    len-of-cadar-when-axe-treep
                                    pseudo-termp-of-cadddr-when-axe-treep
                                    axe-bind-free-result-okayp-rewrite
                                    symbol-alistp-when-alistp
                                    true-listp-of-cdr)
                                   (dargp-less-than
                                    natp
                                    quotep
                                    myquotep
                                    ))
                   :expand ((:free (memoization count other-hyps alist)
                                   ,call-of-relieve-free-var-hyp-and-all-others)
                            (:free (memoization count)
                                   ,call-of-relieve-rule-hyps)
                            (:free (memoization)
                                   (,relieve-rule-hyps-name nil hyp-num alist rule-symbol
                                                            rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                            node-replacement-array node-replacement-count refined-assumption-alist
                                                            rewrite-stobj count))
                            (:free (memoization count)
                                   (,simplify-trees-and-add-to-dag-name nil
                                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                                        rewrite-stobj count))
                            (:free (memoization count)
                                   ,call-of-simplify-trees-and-add-to-dag)
                            (:free (memoization limits hit-counts tries count)
                                   ,call-of-try-to-apply-rules)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif-tree-and-add-to-dag)
                            (:free (memoization fn count)
                                   ,call-of-simplify-not-tree-and-add-to-dag)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag)
                            (:free (memoization count)
                                   ,call-of-simplify-boolif-tree-and-add-to-dag)
                            (:free (memoization count TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-tree-and-add-to-dag)
                            (:free (memoization count TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-fun-call-and-add-to-dag)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag1)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag2)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag3)
                            (axe-rule-hyp-listp hyps)))))

         ;; The tries returned are ok:
         (,(pack$ 'defthm-flag-simplify-tree-and-add-to-dag- suffix)
          (defthm ,(pack$ 'triesp-after-relieve-free-var-hyp-and-all-others- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 7 6) ,call-of-relieve-free-var-hyp-and-all-others)))
            :flag ,relieve-free-var-hyp-and-all-others-name)

          (defthm ,(pack$ 'triesp-after-relieve-rule-hyps- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 7 6) ,call-of-relieve-rule-hyps)))
            :flag ,relieve-rule-hyps-name)

          (defthm ,(pack$ 'triesp-after-try-to-apply-rules- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-try-to-apply-rules)))
            :flag ,try-to-apply-rules-name)

          (defthm ,(pack$ 'triesp-after-simplify-trees-and-add-to-dag- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-trees-and-add-to-dag)))
            :flag ,simplify-trees-and-add-to-dag-name)

          (defthm ,(pack$ 'triesp-after-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)))
            :flag ,simplify-if/myif/boolif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'triesp-after-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)))
            :flag ,simplify-if/myif/boolif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'triesp-after-simplify-if/myif-tree-and-add-to-dag- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-if/myif-tree-and-add-to-dag)))
            :flag ,simplify-if/myif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'triesp-after-simplify-not-tree-and-add-to-dag- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-not-tree-and-add-to-dag)))
            :flag ,simplify-not-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'triesp-after-simplify-boolif-tree-and-add-to-dag- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-boolif-tree-and-add-to-dag)))
            :flag ,simplify-boolif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'triesp-after-simplify-bvif-tree-and-add-to-dag3- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-bvif-tree-and-add-to-dag3)))
            :flag ,simplify-bvif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'triesp-after-simplify-bvif-tree-and-add-to-dag2- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-bvif-tree-and-add-to-dag2)))
            :flag ,simplify-bvif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'triesp-after-simplify-bvif-tree-and-add-to-dag1- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-bvif-tree-and-add-to-dag1)))
            :flag ,simplify-bvif-tree-and-add-to-dag1-name)

          (defthm ,(pack$ 'triesp-after-simplify-bvif-tree-and-add-to-dag- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-bvif-tree-and-add-to-dag)))
            :flag ,simplify-bvif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'triesp-after-simplify-tree-and-add-to-dag- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-tree-and-add-to-dag)))
            :flag ,simplify-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'triesp-after-simplify-fun-call-and-add-to-dag- suffix)
            (implies (triesp tries)
                     (triesp (mv-nth ,(if smtp 6 5) ,call-of-simplify-fun-call-and-add-to-dag)))
            :flag ,simplify-fun-call-and-add-to-dag-name)

          :hints (("Goal" :do-not '(generalize eliminate-destructors)
                   :in-theory (e/d ( ;TAKE-WHEN-<=-OF-LEN
                                    len-of-cadar-when-axe-treep
                                    pseudo-termp-of-cadddr-when-axe-treep
                                    axe-bind-free-result-okayp-rewrite
                                    symbol-alistp-when-alistp
                                    true-listp-of-cdr)
                                   (dargp-less-than
                                    natp
                                    quotep
                                    myquotep
                                    ))
                   :expand ((:free (memoization count other-hyps alist)
                                   ,call-of-relieve-free-var-hyp-and-all-others)
                            (:free (memoization count)
                                   ,call-of-relieve-rule-hyps)
                            (:free (memoization)
                                   (,relieve-rule-hyps-name nil hyp-num alist rule-symbol
                                                            rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                            node-replacement-array node-replacement-count refined-assumption-alist
                                                            rewrite-stobj count))
                            (:free (memoization count)
                                   (,simplify-trees-and-add-to-dag-name nil
                                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                                        rewrite-stobj count))
                            (:free (memoization count)
                                   ,call-of-simplify-trees-and-add-to-dag)
                            (:free (memoization limits hit-counts tries count)
                                   ,call-of-try-to-apply-rules)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif-tree-and-add-to-dag)
                            (:free (memoization fn count)
                                   ,call-of-simplify-not-tree-and-add-to-dag)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag)
                            (:free (memoization count)
                                   ,call-of-simplify-boolif-tree-and-add-to-dag)
                            (:free (memoization count TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-tree-and-add-to-dag)
                            (:free (memoization count TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-fun-call-and-add-to-dag)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag1)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag2)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag3)
                            (AXE-RULE-HYP-LISTP HYPS)))))

         ;; main return-type theorems about functions in the mutual-recursion:
         (,(pack$ 'defthm-flag-simplify-tree-and-add-to-dag- suffix)
          (defthm ,(pack$ 'theorem-for-relieve-free-var-hyp-and-all-others- suffix)
            (mv-let (erp hyps-relievedp extended-alist new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-relieve-free-var-hyp-and-all-others
              (declare (ignore hyps-relievedp new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (not erp)
                            (axe-tree-listp hyp-args)
                            (alist-suitable-for-hyp-args-and-hypsp alist hyp-args other-hyps)
                            (axe-rule-hyp-listp other-hyps)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                            (symbol-alistp alist)
                            (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2))
                            (bounded-darg-list-listp assumption-arg-lists (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (symbol-alistp extended-alist)
                            (bounded-darg-listp (strip-cdrs extended-alist)
                                                (get-dag-len new-rewrite-stobj2))
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array
                                                             new-node-replacement-array
                                                             (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,relieve-free-var-hyp-and-all-others-name)

          (defthm ,(pack$ 'theorem-for-relieve-rule-hyps- suffix)
            (mv-let (erp hyps-relievedp extended-alist new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-relieve-rule-hyps
              (declare (ignore hyps-relievedp new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (axe-rule-hyp-listp hyps)
                            (alist-suitable-for-hypsp alist hyps)
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                            (symbol-alistp alist)
                            (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (symbol-alistp extended-alist)
                            (bounded-darg-listp (strip-cdrs extended-alist) (get-dag-len new-rewrite-stobj2))
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,relieve-rule-hyps-name)

          (defthm ,(pack$ 'theorem-for-try-to-apply-rules- suffix)
            (mv-let (erp instantiated-rhs-or-nil new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-try-to-apply-rules
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (bounded-darg-listp args-to-match (get-dag-len rewrite-stobj2))
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (stored-axe-rule-listp stored-rules)
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (axe-treep instantiated-rhs-or-nil)
                            (bounded-axe-treep instantiated-rhs-or-nil (get-dag-len new-rewrite-stobj2))
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,try-to-apply-rules-name)

          (defthm ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix)
            (mv-let (erp nodenums-or-quoteps new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-trees-and-add-to-dag
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (bounded-axe-tree-listp trees (get-dag-len rewrite-stobj2))
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (true-listp nodenums-or-quoteps)
                            (bounded-darg-listp nodenums-or-quoteps (get-dag-len new-rewrite-stobj2))
                            ;; implied by the above
                            (darg-listp nodenums-or-quoteps)
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array
                                                             new-node-replacement-array
                                                             (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-trees-and-add-to-dag-name)

          (defthm ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (member-eq fn '(if myif boolif))
                            (natp simplified-test)
                            (< simplified-test (get-dag-len rewrite-stobj2))
                            (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                            (axe-treep else-branch)
                            (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                            (tree-to-memoizep tree)
                            ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (wf-rewrite-stobj2p rewrite-stobj2)
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            ;; (bounded-axe-tree-listp trees-equal-to-tree (get-dag-len rewrite-stobj2))
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array
                                                             (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-if/myif/boolif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (member-eq fn '(if myif boolif))
                            (natp simplified-test)
                            (< simplified-test (get-dag-len rewrite-stobj2))
                            (axe-treep then-branch)
                            (bounded-axe-treep then-branch (get-dag-len rewrite-stobj2))
                            (axe-treep else-branch)
                            (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                            (tree-to-memoizep tree)
                            ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (wf-rewrite-stobj2p rewrite-stobj2)
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            ;; (bounded-axe-tree-listp trees-equal-to-tree (get-dag-len rewrite-stobj2))
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-if/myif/boolif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-if/myif-tree-and-add-to-dag
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (axe-treep tree)
                            (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (consp tree) ; not logically necessary but speeds up the proof
                            (member-eq (ffn-symb tree) '(if myif))
                            ;; (equal 3 (len (fargs tree)))
                            (wf-rewrite-stobj2p rewrite-stobj2)
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-if/myif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'theorem-for-simplify-not-tree-and-add-to-dag- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-not-tree-and-add-to-dag
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (axe-treep tree)
                            (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (consp tree) ; not logically necessary but speeds up the proof
                            (eq (ffn-symb tree) 'not)
                            (wf-rewrite-stobj2p rewrite-stobj2)
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-not-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'theorem-for-simplify-boolif-tree-and-add-to-dag- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-boolif-tree-and-add-to-dag
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (axe-treep tree)
                            (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (consp tree)
                            (equal 'boolif (ffn-symb tree))
                            (wf-rewrite-stobj2p rewrite-stobj2)
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-boolif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-bvif-tree-and-add-to-dag3
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                            (natp simplified-test)
                            (< simplified-test (get-dag-len rewrite-stobj2))
                            (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                            (axe-treep else-branch)
                            (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                            (tree-to-memoizep tree)
                            ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-bvif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-bvif-tree-and-add-to-dag2
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                            (natp simplified-test)
                            (< simplified-test (get-dag-len rewrite-stobj2))
                            (axe-treep then-arg)
                            (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                            (axe-treep else-arg)
                            (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                            (tree-to-memoizep tree)
                            ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-bvif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-bvif-tree-and-add-to-dag1
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (axe-treep size-arg)
                            (bounded-axe-treep size-arg (get-dag-len rewrite-stobj2))
                            (natp simplified-test)
                            (< simplified-test (get-dag-len rewrite-stobj2))
                            (axe-treep then-arg)
                            (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                            (axe-treep else-arg)
                            (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                            (tree-to-memoizep tree)
                            ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-bvif-tree-and-add-to-dag1-name)

          (defthm ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-bvif-tree-and-add-to-dag
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (axe-treep tree)
                            (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (consp tree)
                            (equal 'bvif (ffn-symb tree))
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-bvif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-tree-and-add-to-dag
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (axe-treep tree)
                            (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                            (wf-rewrite-stobj2p rewrite-stobj2)
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'theorem-for-simplify-fun-call-and-add-to-dag- suffix)
            (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits new-node-replacement-array)
              ,call-of-simplify-fun-call-and-add-to-dag
              (declare (ignore new-hit-counts new-tries new-limits))
              (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                            (symbolp fn)
                            (not (equal 'quote fn))
                            (bounded-darg-listp dargs (get-dag-len rewrite-stobj2))
                            (not erp)
                            (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                            (trees-to-memoizep trees-equal-to-tree)
                            (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                            (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                            (rewrite-stobjp rewrite-stobj)
                            (rewrite-stobj2p rewrite-stobj2)
                            (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                       (and (rewrite-stobj2p new-rewrite-stobj2)
                            (wf-rewrite-stobj2p new-rewrite-stobj2)
                            (DARGP-LESS-THAN new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                            (DARGP new-nodenum-or-quotep) ; follows from the above but no free vars
                            (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                            (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                            (iff new-memoization memoization)
                            (<= (alen1 'node-replacement-array node-replacement-array)
                                (alen1 'node-replacement-array new-node-replacement-array))
                            (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                            ,@maybe-w-unchanged)))
            :flag ,simplify-fun-call-and-add-to-dag-name)

          :hints (("Goal" :do-not '(generalize eliminate-destructors)
                   :in-theory ;; (e/d ( ;TAKE-WHEN-<=-OF-LEN
                   ;;       len-of-cadar-when-axe-treep
                   ;;       pseudo-termp-of-cadddr-when-axe-treep
                   ;;       axe-bind-free-result-okayp-rewrite
                   ;;       symbol-alistp-when-alistp
                   ;;       true-listp-of-cdr
                   ;;       symbolp-when-member-equal-disabled
                   ;;       not-equal-when-member-equal-disabled
                   ;;       not-equal-when-member-equal-alt-disabled
                   ;;       <=-transitive-1
                   ;;       <=-transitive-2
                   ;;       symbol-listp-of-append-disabled
                   ;;       member-equal-when-member-equal-and-subsetp-equal)
                   ;;      (dargp-less-than
                   ;;       natp
                   ;;       quotep
                   ;;       myquotep))
                   ;; We use a constant theory here for speed (without it, x86/rewriter-x86.lisp is quite slow)
                   '(car-cons ;; missing from summary!
                     (:compound-recognizer axe-treep-compound-recognizer)
                     (:compound-recognizer natp-compound-recognizer)
                     (:congruence iff-implies-equal-not)
                     (:rewrite add-variable-to-dag-array-in-stobj-return-type)
                     (:rewrite add-variable-to-dag-array-in-stobj-return-type-2)
                     ;; (:definition alistp)
                     (:definition axe-rule-hyp-listp)
                     (:definition eq)
                     (:definition iff)
                     ;; (:definition mv-nth)
                     (:definition not)
                     (:definition pseudo-termp)
                     (:definition ,relieve-free-var-hyp-and-all-others-name)
                     (:definition ,relieve-rule-hyps-name)
                     (:definition ,simplify-boolif-tree-and-add-to-dag-name)
                     (:definition ,simplify-bvif-tree-and-add-to-dag-name)
                     (:definition ,simplify-bvif-tree-and-add-to-dag1-name)
                     (:definition ,simplify-bvif-tree-and-add-to-dag2-name)
                     (:definition ,simplify-bvif-tree-and-add-to-dag3-name)
                     (:definition ,simplify-fun-call-and-add-to-dag-name)
                     (:definition ,simplify-if/myif-tree-and-add-to-dag-name)
                     (:definition ,simplify-if/myif/boolif-tree-and-add-to-dag2-name)
                     (:definition ,simplify-if/myif/boolif-tree-and-add-to-dag3-name)
                     (:definition ,simplify-not-tree-and-add-to-dag-name)
                     (:definition ,simplify-tree-and-add-to-dag-name)
                     (:definition ,simplify-trees-and-add-to-dag-name)
                     (:definition synp)
                     (:definition ,try-to-apply-rules-name)
                     ;; (:definition wf-rewrite-stobj2p)
                     (:rewrite wf-rewrite-stobj2p-conjuncts)
                     (:linear wf-rewrite-stobj2p-conjuncts2)
                     wf-rewrite-stobj2p-of-put-negated-assumptions
                     rewrite-stobj2p-of-put-negated-assumptions
                     bounded-possibly-negated-nodenumsp-of-cons
                     possibly-negated-nodenumsp-of-cons
                     bounded-possibly-negated-nodenump-of-cons-of-not
                     possibly-negated-nodenump-of-cons-of-not
                     get-dag-len-of-put-negated-assumptions
                     possibly-negated-nodenumsp-of-get-negated-assumptions
                     bounded-possibly-negated-nodenump-when-not-consp
                     possibly-negated-nodenump-when-not-consp
                     bounded-possibly-negated-nodenumsp-of-get-negated-assumptions-gen
                     (:executable-counterpart all-natp)
                     (:executable-counterpart axe-rule-hyp-listp)
                     (:executable-counterpart axe-tree-listp)
                     (:executable-counterpart axe-treep)
                     (:executable-counterpart binary-+)
                     (:executable-counterpart car)
                     (:executable-counterpart cdr)
                     (:executable-counterpart darg-listp)
                     (:executable-counterpart equal)
                     (:executable-counterpart len)
                     (:executable-counterpart member-equal)
                     (:executable-counterpart mv-nth)
                     (:executable-counterpart natp)
                     (:executable-counterpart not)
                     (:executable-counterpart pseudo-term-listp)
                     (:executable-counterpart pseudo-termp)
                     (:executable-counterpart strip-cdrs)
                     (:executable-counterpart subsetp-equal)
                     (:executable-counterpart symbol-listp)
                     (:executable-counterpart symbolp)
                     (:executable-counterpart trees-to-memoizep)
                     (:executable-counterpart true-listp)
                     (:executable-counterpart zp)
                     (:forward-chaining axe-bind-free-function-applicationp-forward-to-consp)
                     (:forward-chaining axe-bind-free-function-applicationp-forward-to-not-equal-of-quote-and-car)
                     (:forward-chaining axe-bind-free-function-applicationp-forward-to-pseudo-term-listp-of-cdr)
                     (:forward-chaining axe-bind-free-function-applicationp-forward-to-symbolp-of-car)
                     (:forward-chaining axe-bind-free-function-applicationp-forward-to-true-listp)
                     (:forward-chaining bounded-axe-treep-forward-to-axe-treep)
                     (:forward-chaining bounded-dag-constant-alistp-forward-to-dag-constant-alistp)
                     (:forward-chaining bounded-dag-parent-arrayp-forward-to-bounded-dag-parent-arrayp)
                     (:forward-chaining bounded-dag-variable-alistp-forward-to-dag-variable-alistp)
                     (:forward-chaining bounded-darg-list-listp-forward-to-true-listp)
                     (:forward-chaining bounded-darg-listp-forward-to-true-listp)
                     (:forward-chaining bounded-node-replacement-arrayp-forward-to-array1p)
                     (:forward-chaining consp-forward-to-len-bound)
                     (:forward-chaining consp-of-cdr-forward-to-consp)
                     (:forward-chaining maybe-bounded-memoizationp-forward-to-bounded-memoizationp)
                     (:forward-chaining myquotep-forward-to-consp)
                     (:forward-chaining pseudo-dag-arrayp-forward-chaining)
                     (:forward-chaining pseudo-dag-arrayp-forward-chaining-another)
                     (:forward-chaining pseudo-dag-arrayp-forward-chaining-another-2)
                     (:forward-chaining pseudo-dag-arrayp-forward-to-natp-arg3)
                     (:forward-chaining pseudo-termp-consp-forward)
                     (:forward-chaining stored-axe-rule-listp-forward-to-true-listp)
                     (:forward-chaining symbol-alistp-forward-to-alistp)
                     (:forward-chaining wf-dagp-forward)
                     (:forward-chaining wf-dagp-forward-to-<=-of-len)
                     (:induction ,(pack$ 'flag-simplify-tree-and-add-to-dag- suffix))
                     (:linear bound-on-mv-nth-3-and-mv-nth-1-of-add-function-call-expr-to-dag-array-alt-strong)
                     (:linear bound-on-mv-nth-3-and-mv-nth-1-of-add-variable-to-dag-array)
                     ;; (:linear bound-on-mv-nth-3-of-add-and-normalize-expr-3)
                     (:linear bound-on-mv-nth-3-of-add-function-call-expr-to-dag-array-3)
                     (:linear bound-on-mv-nth-3-of-add-variable-to-dag-array-3)
                     (:rewrite <-of-apply-node-replacement-array-bool-to-darg)
                     ;; (:rewrite <-of-mv-nth-1-of-add-and-normalize-expr-and-mv-nth-3-of-add-and-normalize-expr)
                     (:rewrite <-trans)
                     (:rewrite <-when-bounded-axe-treep)
                     (:rewrite <=-transitive-1)
                     (:rewrite <=-transitive-2)
                     (:rewrite alen1-of-undo-writes-to-node-replacement-array)
                     (:rewrite ,(pack$ 'alist-suitable-for-hyp-args-and-hypsp-after-instantiate-hyp- suffix '-free-vars))
                     (:rewrite alist-suitable-for-hypsp-of-alist-suitable-for-hypsp-of-car)
                     (:rewrite alist-suitable-for-hypsp-of-append-and-cdr-when-axe-bind-free)
                     (:rewrite alist-suitable-for-hypsp-of-cdr-of-car-when-normal)
                     (:rewrite alist-suitable-for-hypsp-of-unify-terms-and-dag-items-fast-when-stored-axe-rulep)
                     (:rewrite alist-suitable-for-hypsp-when-axe-sytaxp-car)
                     (:rewrite alist-suitable-for-hypsp-of-append-and-cdr-when-axe-binding-hyp)
                     ;; (:rewrite ALIST-SUITABLE-FOR-HYPSP-AFTER-MATCHING-2)
                     (:rewrite ALIST-SUITABLE-FOR-HYPSP-AFTER-MATCHING-2-special)
                     (:rewrite subsetp-equal-of-free-vars-in-terms-of-fargs-of-cadr-of-car-when-axe-binding-hyp)
                     (:rewrite alistp-of-cdr)
                     (:rewrite alistp-of-for-unify-trees-with-dag-nodes)
                     (:rewrite all-<-of-nil)
                     (:rewrite all-<-transitive-free-2)
                     (:rewrite append-of-nil-arg2)
                     (:rewrite axe-bind-free-result-okayp-rewrite)
                     (:rewrite axe-rule-hyp-listp-of-stored-rule-hyps)
                     (:rewrite axe-rule-hypp-when-axe-bind-free)
                     (:rewrite axe-rule-hypp-when-free-vars)
                     (:rewrite axe-rule-hypp-when-axe-binding-hyp)
                     (:rewrite axe-rule-hypp-when-simple)
                     (:rewrite axe-tree-listp-of-cdr)
                     (:rewrite axe-tree-listp-of-cdr-2)
                     (:rewrite ,(pack$ 'axe-tree-listp-of-cdr-of-instantiate-hyp- suffix '-free-vars))
                     (:rewrite axe-tree-listp-of-cons)
                     (:rewrite axe-treep-of-car)
                     (:rewrite axe-treep-of-car-when-bounded-axe-tree-listp)
                     (:rewrite axe-treep-of-cons-strong)
                     (:rewrite ,(pack$ 'axe-treep-of-instantiate-hyp- suffix '-no-free-vars2))
                     (:rewrite ,(pack$ 'axe-treep-of-sublis-var-and-eval- suffix))
                     (:rewrite ,(pack$ 'axe-treep-of-subcor-var-and-eval- suffix))
                     (:rewrite axe-treep-when-bounded-axe-treep)
                     (:rewrite axe-treep-when-equal-of-car-and-quote-cheap)
                     (:rewrite axe-treep-when-not-consp-and-not-symbolp-cheap)
                     (:rewrite axe-treep-when-symbolp-cheap)
                     pseudo-termp-of-cadr-when-axe-smt ;axe-treep-of-cadr-when-axe-smt
                     free-vars-in-term-of-cadr-when-axe-smt
                     (:rewrite bounded-axe-tree-listp-mono)
                     (:rewrite bounded-axe-tree-listp-of-cdr)
                     (:rewrite bounded-axe-tree-listp-of-cdr-2)
                     (:rewrite bounded-axe-tree-listp-of-cons)
                     (:rewrite bounded-axe-tree-listp-when-darg-listp)
                     (:rewrite bounded-axe-tree-listp-when-not-consp)
                     (:rewrite bounded-axe-tree-listp-when-pseudo-term-listp)
                     (:rewrite bounded-axe-treep-mono)
                     (:rewrite bounded-axe-treep-of-car)
                     (:rewrite bounded-axe-treep-of-cons)
                     (:rewrite ,(pack$ 'bounded-axe-treep-of-instantiate-hyp- suffix '-no-free-vars2))
                     (:rewrite ,(pack$ 'bounded-axe-treep-of-sublis-var-and-eval- suffix))
                     (:rewrite ,(pack$ 'bounded-axe-treep-of-subcor-var-and-eval- suffix))
                     (:rewrite bounded-axe-treep-when-pseudo-termp)
                     (:rewrite bounded-darg-list-listp-monotone)
                     (:rewrite bounded-darg-list-listp-of-cdr)
                     (:rewrite bounded-darg-list-listp-of-lookup-in-refined-assumption-alist)
                     (:rewrite bounded-darg-listp-monotone)
                     (:rewrite bounded-darg-listp-of-append)
                     (:rewrite bounded-darg-listp-of-car)
                     (:rewrite bounded-darg-listp-of-cons)
                     (:rewrite bounded-darg-listp-of-reverse-list)
                     (:rewrite bounded-darg-listp-of-strip-cdrs-of-unify-terms-and-dag-items-fast)
                     (:rewrite bounded-darg-listp-of-strip-cdrs-of-unify-trees-with-dag-nodes)
                     (:rewrite bounded-darg-listp-when-all-<)
                     (:rewrite bounded-node-replacement-arrayp-monotone-2)
                     (:rewrite bounded-refined-assumption-alistp-monotone)
                     (:rewrite bounded-refined-assumption-alistp-of-extend-refined-assumption-alist-assuming-negation-of-node-gen)
                     (:rewrite bounded-refined-assumption-alistp-of-extend-refined-assumption-alist-assuming-node-gen)
                     (:rewrite bounded-undo-pairsp-of-nil)
                     ;; (:rewrite dag-constant-alistp-mv-nth-5-of-add-and-normalize-expr-and-mv-nth-3-of-add-and-normalize-expr)
                     (:rewrite dag-constant-alistp-of-get-dag-constant-alist)
                     (:rewrite dag-constant-alistp-of-mv-nth-5-of-add-function-call-expr-to-dag-array)
                     ;; (:rewrite dag-variable-alistp-mv-nth-6-of-add-and-normalize-expr-and-mv-nth-3-of-add-and-normalize-expr)
                     (:rewrite dag-variable-alistp-of-get-dag-variable-alist)
                     (:rewrite dag-variable-alistp-of-mv-nth-5-of-add-variable-to-dag-array)
                     (:rewrite darg-listp-of-cons)
                     (:rewrite darg-listp-of-reverse-list)
                     (:rewrite darg-listp-of-strip-cdrs-of-unify-terms-and-dag-items-fast)
                     (:rewrite darg-listp-when-bounded-darg-listp)
                     (:rewrite dargp-less-than-mono)
                     (:rewrite dargp-less-than-of-apply-node-replacement-array)
                     (:rewrite dargp-less-than-of-apply-node-replacement-array-bool-to-darg)
                     (:rewrite dargp-less-than-of-list-of-quote)
                     (:rewrite dargp-less-than-of-lookup-in-memoization-when-bounded-memoizationp)
                     ;; (:rewrite dargp-less-than-of-mv-nth-1-of-add-and-normalize-expr-and-mv-nth-3-of-add-and-normalize-expr-gen)
                     (:rewrite dargp-less-than-of-mv-nth-1-of-add-function-call-expr-to-dag-array-gen-alt)
                     (:rewrite dargp-less-than-when-consp-cheap)
                     (:rewrite dargp-less-than-when-myquotep-cheap)
                     (:rewrite dargp-less-than-when-natp-cheap)
                     (:rewrite dargp-less-than-when-not-consp-cheap)
                     (:rewrite dargp-of-apply-node-replacement-array)
                     ;; (:rewrite dargp-of-mv-nth-1-of-add-and-normalize-expr-and-mv-nth-3-of-add-and-normalize-expr)
                     (:rewrite dargp-of-mv-nth-1-of-add-function-call-expr-to-dag-array)
                     (:rewrite dargp-when-consp-cheap)
                     (:rewrite dargp-when-dargp-less-than)
                     (:rewrite ,(pack$ 'flag-simplify-tree-and-add-to-dag- suffix '-equivalences))
                     (:rewrite set-xor-signature-fields-return-type)
                     (:rewrite get-dag-array-of-put-dag-array)
                     (:rewrite get-dag-constant-alist-of-put-dag-array)
                     (:rewrite get-dag-constant-alist-of-put-dag-constant-alist)
                     (:rewrite get-dag-constant-alist-of-put-dag-len)
                     (:rewrite get-dag-constant-alist-of-put-dag-parent-array)
                     (:rewrite get-dag-constant-alist-of-put-dag-variable-alist)
                     (:rewrite get-dag-len-of-put-dag-array)
                     (:rewrite get-dag-len-of-put-dag-len)
                     (:rewrite get-dag-parent-array-of-put-dag-array)
                     (:rewrite get-dag-parent-array-of-put-dag-len)
                     (:rewrite get-dag-parent-array-of-put-dag-parent-array)
                     (:rewrite get-dag-variable-alist-of-put-dag-array)
                     (:rewrite get-dag-variable-alist-of-put-dag-constant-alist)
                     (:rewrite get-dag-variable-alist-of-put-dag-len)
                     (:rewrite get-dag-variable-alist-of-put-dag-parent-array)
                     (:rewrite get-dag-variable-alist-of-put-dag-variable-alist)
                     (:rewrite len-of-cadar-when-axe-treep)
                     (:rewrite len-of-cdr)
                     (:rewrite ,(pack$ 'len-of-mv-nth-1-of-simplify-trees-and-add-to-dag- suffix))
                     (:rewrite maybe-bounded-memoizationp-monotone)
                     (:rewrite maybe-bounded-memoizationp-of-add-pairs-to-memoization)
                     (:rewrite maybe-bounded-memoizationp-of-nil)
                     (:rewrite member-equal-when-member-equal-and-subsetp-equal)
                     (:rewrite mv-nth-of-cons-safe)
                     (:rewrite mv-nth-of-if)
                     (:rewrite natp-of-apply-node-replacement-array-bool-to-darg)
                     (:rewrite natp-of-get-dag-len)
                     ;; (:rewrite natp-of-mv-nth-1-of-add-and-normalize-expr-and-mv-nth-3-of-add-and-normalize-expr)
                     (:rewrite natp-of-mv-nth-1-of-add-function-call-expr-to-dag-array)
                     (:rewrite natp-of-mv-nth-3-of-add-variable-to-dag-array)
                     (:rewrite node-replacement-arrayp-when-bounded-node-replacement-arrayp)
                     (:rewrite not-<-same)
                     (:rewrite not-equal-when-member-equal-alt-disabled)
                     (:rewrite not-equal-when-member-equal-disabled)
                     (:rewrite pseudo-dag-arrayp-of-+-of-1-and-largest-non-quotep-of-car)
                     (:rewrite pseudo-term-listp-of-stored-rule-lhs-args)
                     (:rewrite pseudo-termp-of-cadddr-when-axe-treep)
                     (:rewrite pseudo-termp-of-stored-rule-rhs)
                     (:rewrite put-dag-constant-alist-of-put-dag-array)
                     (:rewrite put-dag-constant-alist-of-put-dag-len)
                     (:rewrite put-dag-constant-alist-of-put-dag-parent-array)
                     (:rewrite put-dag-len-of-put-dag-array)
                     (:rewrite put-dag-parent-array-of-put-dag-array)
                     (:rewrite put-dag-parent-array-of-put-dag-len)
                     (:rewrite put-dag-variable-alist-of-put-dag-array)
                     (:rewrite put-dag-variable-alist-of-put-dag-constant-alist)
                     (:rewrite put-dag-variable-alist-of-put-dag-len)
                     (:rewrite put-dag-variable-alist-of-put-dag-parent-array)
                     (:rewrite ,(pack$ 'relieve-free-var-hyp-and-all-others- suffix '-of-0))
                     (:rewrite ,(pack$ 'relieve-rule-hyps- suffix '-of-0))
                     (:rewrite reverse-becomes-reverse-list-gen)
                     (:rewrite rewrite-stobj2p-of-put-dag-array)
                     (:rewrite rewrite-stobj2p-of-put-dag-constant-alist)
                     (:rewrite rewrite-stobj2p-of-put-dag-len)
                     (:rewrite rewrite-stobj2p-of-put-dag-parent-array)
                     (:rewrite rewrite-stobj2p-of-put-dag-variable-alist)
                     ;; (:rewrite rule-alistp-of-get-rule-alist)
                     (:rewrite stored-axe-rule-listp-of-rule-db-get)
                     (:rewrite ,(pack$ 'simplify-boolif-tree-and-add-to-dag- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-bvif-tree-and-add-to-dag- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-bvif-tree-and-add-to-dag1- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-bvif-tree-and-add-to-dag2- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-bvif-tree-and-add-to-dag3- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-fun-call-and-add-to-dag- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-if/myif-tree-and-add-to-dag- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-if/myif/boolif-tree-and-add-to-dag2- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-if/myif/boolif-tree-and-add-to-dag3- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-not-tree-and-add-to-dag- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-tree-and-add-to-dag- suffix '-of-0))
                     (:rewrite ,(pack$ 'simplify-trees-and-add-to-dag- suffix '-of-0))
                     (:rewrite stored-axe-rule-listp-of-cdr)
                     (:rewrite stored-axe-rule-listp-of-get-rules-for-fn)
                     (:rewrite stored-axe-rulep-of-car)
                     (:rewrite strip-cdrs-of-acons)
                     (:rewrite strip-cdrs-of-append)
                     (:rewrite strip-cdrs-of-pairlis$-fast-aux)
                     (:rewrite subsetp-equal-of-free-vars-in-term-of-car-and-strip-cars-when-normal)
                     (:rewrite symbol-alistp-of-acons)
                     (:rewrite symbol-alistp-of-append)
                     (:rewrite symbol-alistp-of-unify-terms-and-dag-items-fast)
                     (:rewrite symbol-alistp-when-alistp)
                     (:rewrite symbol-listp-of-strip-cars-of-unify-trees-with-dag-nodes)
                     (:rewrite symbol-listp-of-strip-cars-when-symbol-alistp)
                     (:rewrite symbolp-of-car-when-axe-treep-cheap)
                     (:rewrite symbolp-when-member-equal-disabled)
                     (:rewrite take-does-nothing)
                     (:rewrite tree-to-memoizep-of-cons)
                     (:rewrite tree-to-memoizep-when-axe-treep-and-bounded-axe-treep-cheap-2)
                     (:rewrite trees-to-memoizep-of-cons)
                     (:rewrite trees-to-memoizep-of-cons-if-not-equal-car)
                     (:rewrite true-list-fix-when-true-listp)
                     (:rewrite ,(pack$ 'try-to-apply-rules- suffix '-of-0))
                     ;; (:rewrite type-of-add-and-normalize-expr)
                     (:rewrite add-and-maybe-normalize-expr-return-type)
                     (:rewrite undo-writes-to-node-replacement-array-return-type)
                     (:rewrite update-node-replacement-array-for-assuming-negation-of-node-return-type)
                     (:rewrite update-node-replacement-array-for-assuming-negation-of-node-return-type-alen1-corollary)
                     (:rewrite update-node-replacement-array-for-assuming-negation-of-node-return-type-corollary)
                     (:rewrite update-node-replacement-array-for-assuming-node-return-type)
                     (:rewrite update-node-replacement-array-for-assuming-node-return-type-alen1-corollary)
                     (:rewrite update-node-replacement-array-for-assuming-node-return-type-corollary)
                     (:rewrite wf-dagp-after-add-function-call-expr-to-dag-array)
                     (:rewrite wf-dagp-after-add-variable-to-dag-array)
                     (:type-prescription add-pairs-to-memoization)
                     (:type-prescription alist-suitable-for-hyp-args-and-hypsp)
                     (:type-prescription alist-suitable-for-hypsp)
                     (:type-prescription alistp)
                     (:type-prescription all-consp)
                     (:type-prescription array1p)
                     (:type-prescription axe-bind-free-function-applicationp)
                     (:type-prescription axe-rule-hyp-listp)
                     (:type-prescription axe-tree-listp)
                     (:type-prescription axe-treep)
                     (:type-prescription bounded-axe-tree-listp)
                     (:type-prescription bounded-axe-treep)
                     (:type-prescription bounded-dag-constant-alistp)
                     (:type-prescription bounded-dag-parent-arrayp)
                     (:type-prescription bounded-dag-variable-alistp)
                     (:type-prescription bounded-darg-list-listp)
                     (:type-prescription bounded-darg-listp)
                     (:type-prescription bounded-memoizationp)
                     (:type-prescription bounded-node-replacement-arrayp)
                     (:type-prescription bounded-refined-assumption-alistp)
                     (:type-prescription dag-constant-alistp)
                     (:type-prescription dag-parent-arrayp)
                     (:type-prescription dag-variable-alistp)
                     (:type-prescription dargp-less-than)
                     ;; (:type-prescription integerp-of-mv-nth-3-of-add-function-call-expr-to-dag-array-type)
                     (:type-prescription lambda-free-termp)
                     (:type-prescription len)
                     (:type-prescription limit-reachedp)
                     (:type-prescription maybe-bounded-memoizationp)
                     (:type-prescription member-equal)
                     (:type-prescription myquotep)
                     (:type-prescription natp-of-mv-nth-1-of-add-variable-to-dag-array)
                     ;; (:type-prescription natp-of-mv-nth-3-of-add-and-normalize-expr)
                     (:type-prescription natp-of-mv-nth-3-of-add-function-call-expr-to-dag-array-type)
                     (:type-prescription natp-of-mv-nth-3-of-add-variable-to-dag-array)
                     (:type-prescription posp-of-alen1)
                     (:type-prescription pseudo-dag-arrayp)
                     (:type-prescription pseudo-term-listp)
                     (:type-prescription pseudo-termp)
                     (:type-prescription reverse-list)
                     (:type-prescription rewrite-stobj2p)
                     (:type-prescription rewrite-stobjp)
                     (:type-prescription stored-axe-rule-listp)
                     (:type-prescription strip-cdrs)
                     (:type-prescription symbol-alistp)
                     (:type-prescription symbol-listp)
                     (:type-prescription tree-to-memoizep)
                     (:type-prescription trees-to-memoizep)
                     (:type-prescription ,(pack$ 'true-listp-of-eval-axe-bind-free-function-application- bind-free-evaluator-suffix))
                     (:type-prescription wf-dagp)
                     ;; only needed when smtp:
                     ,@(and smtp '(w-of-mv-nth-1-of-prove-disjunction-with-stp)))
                   :expand ( ;(alist-suitable-for-hypsp alist hyps)
                            (:free (memoization ;count
                                     other-hyps alist)
                                   ,call-of-relieve-free-var-hyp-and-all-others)
                            (:free (memoization ;count
                                     )
                                   ,call-of-relieve-rule-hyps)
                            (:free (memoization)
                                   (,relieve-rule-hyps-name nil hyp-num alist rule-symbol
                                                            rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                            node-replacement-array node-replacement-count refined-assumption-alist
                                                            rewrite-stobj count))
                            (:free (memoization ;count
                                     )
                                   (,simplify-trees-and-add-to-dag-name nil
                                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                                        rewrite-stobj count))
                            (:free (memoization ;count
                                     )
                                   ,call-of-simplify-trees-and-add-to-dag)
                            (:free (memoization limits hit-counts tries ;count
                                                )
                                   ,call-of-try-to-apply-rules)
                            (:free (memoization fn ;count
                                                )
                                   ,call-of-simplify-if/myif-tree-and-add-to-dag)
                            (:free (memoization fn ;count
                                                )
                                   ,call-of-simplify-not-tree-and-add-to-dag)
                            (:free (memoization fn ;count
                                                )
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)
                            (:free (memoization fn ;count
                                                )
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)
                            (:free (memoization ;count
                                     )
                                   ,call-of-simplify-bvif-tree-and-add-to-dag)
                            (:free (memoization ;count
                                     )
                                   ,call-of-simplify-boolif-tree-and-add-to-dag)
                            (:free (memoization ;count
                                     TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-tree-and-add-to-dag)
                            (:free (memoization ;count
                                     TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-fun-call-and-add-to-dag)
                            (:free (memoization ;count
                                     )
                                   ,call-of-simplify-bvif-tree-and-add-to-dag1)
                            (:free (memoization ;count
                                     )
                                   ,call-of-simplify-bvif-tree-and-add-to-dag2)
                            (:free (memoization ;count
                                     )
                                   ,call-of-simplify-bvif-tree-and-add-to-dag3)
                            (axe-rule-hyp-listp hyps)))))

         ;; Now we prove some facts that follow from the main theorem proved about the
         ;; mutual-recursion (e.g., weaker claims that are sometimes needed, or claims
         ;; phrased in a better way for rewriting):

         ;; (defthm ,(pack$ 'theorem-for-try-to-apply-rules- suffix '-corollary)
         ;;   (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
         ;;                 (bounded-darg-listp args-to-match (get-dag-len rewrite-stobj2))
         ;;                 (not (mv-nth 0 ,call-of-try-to-apply-rules))
         ;;                 (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
         ;;                 (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
         ;;                 (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
         ;;                 (stored-axe-rule-listp stored-rules)
         ;;                 (rewrite-stobjp rewrite-stobj)
         ;;                 (rewrite-stobj2p rewrite-stobj2)
         ;;                 (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
         ;;            (dag-constant-alistp (mv-nth 5 ,call-of-try-to-apply-rules)))
         ;;   :hints (("Goal" :use ,(pack$ 'theorem-for-try-to-apply-rules- suffix '-corollary)
         ;;            :in-theory (disable ,(pack$ 'theorem-for-try-to-apply-rules- suffix '-corollary)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-fun-call-and-add-to-dag- suffix)
           (implies (and (<= bound (alen1 'node-replacement-array node-replacement-array))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (symbolp fn)
                         (not (equal 'quote fn))
                         (bounded-darg-listp dargs (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-fun-call-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (<= bound
                        (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-fun-call-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-fun-call-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-fun-call-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-relieve-free-var-hyp-and-all-others- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-relieve-free-var-hyp-and-all-others))
                         (axe-tree-listp hyp-args)
                         (alist-suitable-for-hyp-args-and-hypsp alist hyp-args other-hyps)
                         (axe-rule-hyp-listp other-hyps)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (symbol-alistp alist)
                         (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2))
                         (bounded-darg-list-listp assumption-arg-lists (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 3 ,call-of-relieve-free-var-hyp-and-all-others))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-relieve-free-var-hyp-and-all-others- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-relieve-free-var-hyp-and-all-others- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-relieve-rule-hyps- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (axe-rule-hyp-listp hyps)
                         (alist-suitable-for-hypsp alist hyps)
                         (not (mv-nth 0 ,call-of-relieve-rule-hyps))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (symbol-alistp alist)
                         (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (and (<= x (get-dag-len (mv-nth 3 ,call-of-relieve-rule-hyps)))
                         (darg-listp (strip-cdrs (mv-nth 2 ,call-of-relieve-rule-hyps)))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-relieve-rule-hyps- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-relieve-rule-hyps- suffix)))))

         (defthm ,(pack$ 'corollary-theorem-for-relieve-rule-hyps- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (axe-rule-hyp-listp hyps)
                         (alist-suitable-for-hypsp alist hyps)
                         (not (mv-nth 0 ,call-of-relieve-rule-hyps))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (symbol-alistp alist)
                         (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2)))
                    (darg-listp (strip-cdrs (mv-nth 2 ,call-of-relieve-rule-hyps))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-relieve-rule-hyps- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-relieve-rule-hyps- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-try-to-apply-rules- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (bounded-darg-listp args-to-match (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-try-to-apply-rules))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (stored-axe-rule-listp stored-rules)
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-try-to-apply-rules))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-try-to-apply-rules- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-try-to-apply-rules- suffix)))))

         ;; do we still need this?
         (defthm ,(pack$ 'corollary-theorem-for-try-to-apply-rules- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (bounded-darg-listp args-to-match (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-try-to-apply-rules))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (stored-axe-rule-listp stored-rules)
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (and (maybe-memoizationp (mv-nth ,(if smtp 4 3) ,call-of-try-to-apply-rules))
                         (equal (alen1 'dag-parent-array (get-dag-parent-array (mv-nth 2 ,call-of-try-to-apply-rules)))
                                (alen1 'dag-array (get-dag-array (mv-nth 2 ,call-of-try-to-apply-rules))))
                         (dag-constant-alistp (get-dag-constant-alist (mv-nth 2 ,call-of-try-to-apply-rules)))
                         (bounded-dag-parent-arrayp 'dag-parent-array
                                                    (get-dag-parent-array (mv-nth 2 ,call-of-try-to-apply-rules))
                                                    (get-dag-len (mv-nth 2 ,call-of-try-to-apply-rules)))
                         (dag-parent-arrayp 'dag-parent-array (get-dag-parent-array (mv-nth 2 ,call-of-try-to-apply-rules)))
                         (pseudo-dag-arrayp 'dag-array
                                            (get-dag-array (mv-nth 2 ,call-of-try-to-apply-rules))
                                            (get-dag-len (mv-nth 2 ,call-of-try-to-apply-rules)))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-try-to-apply-rules- suffix))
                    :in-theory (e/d (wf-rewrite-stobj2p)
                                    (,(pack$ 'theorem-for-try-to-apply-rules- suffix)
                                     wf-rewrite-stobj2p-conjuncts)))))

         (defthm ,(pack$ 'pseudo-dag-arrayp-of-mv-nth-2-of-try-to-apply-rules- suffix)
           (implies (and (<= n (get-dag-len (mv-nth 2 ,call-of-try-to-apply-rules)))
                         (natp n)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (bounded-darg-listp args-to-match (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-try-to-apply-rules))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (stored-axe-rule-listp stored-rules)
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (pseudo-dag-arrayp 'dag-array
                                       (get-dag-array (mv-nth 2 ,call-of-try-to-apply-rules))
                                       n))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-try-to-apply-rules- suffix))
                    :in-theory (e/d (wf-rewrite-stobj2p)
                                    (,(pack$ 'theorem-for-try-to-apply-rules- suffix)
                                     wf-rewrite-stobj2p-conjuncts)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-trees-and-add-to-dag- suffix)
           (implies (and (<= x (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (bounded-axe-tree-listp trees (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-trees-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (<= x
                        (get-dag-len (mv-nth 2 ,call-of-simplify-trees-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'corollary-theorem-for-simplify-trees-and-add-to-dag- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (bounded-axe-tree-listp trees (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-trees-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (maybe-memoizationp (mv-nth ,(if smtp 4 3) ,call-of-simplify-trees-and-add-to-dag)))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)
           (implies (and (member-eq fn '(if myif boolif))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                         (axe-treep else-branch)
                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         ;; (bounded-axe-tree-listp trees-equal-to-tree (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)
           (implies (and (member-eq fn '(if myif boolif))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (axe-treep then-branch)
                         (bounded-axe-treep then-branch (get-dag-len rewrite-stobj2))
                         (axe-treep else-branch)
                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         ;; (bounded-axe-tree-listp trees-equal-to-tree (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (consp tree) ; not logically necessary, but included above
                         (member-eq (ffn-symb tree) '(if myif))
                         ;; (equal 3 (len (fargs tree)))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-if/myif-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x
                        (get-dag-len (mv-nth 2 ,call-of-simplify-if/myif-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix))
                    :in-theory (e/d (member-equal ; split into 2 cases
                                     )
                                    (,(pack$ 'theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix))))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-not-tree-and-add-to-dag- suffix)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (consp tree) ; not logically necessary, but included above
                         (eq (ffn-symb tree) 'not)
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-not-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x
                        (get-dag-len (mv-nth 2 ,call-of-simplify-not-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-not-tree-and-add-to-dag- suffix))
                    :in-theory (e/d ( ;member-equal ; split into 2 cases
                                     )
                                    (,(pack$ 'theorem-for-simplify-not-tree-and-add-to-dag- suffix))))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-boolif-tree-and-add-to-dag- suffix)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (consp tree)
                         (equal 'boolif (ffn-symb tree))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-boolif-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-simplify-boolif-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-boolif-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-boolif-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                         (axe-treep else-branch)
                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag3))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-simplify-bvif-tree-and-add-to-dag3))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (axe-treep then-arg)
                         (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                         (axe-treep else-arg)
                         (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag2))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-simplify-bvif-tree-and-add-to-dag2))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (axe-treep size-arg)
                         (bounded-axe-treep size-arg (get-dag-len rewrite-stobj2))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (axe-treep then-arg)
                         (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                         (axe-treep else-arg)
                         (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag1))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-simplify-bvif-tree-and-add-to-dag1))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix)))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-bvif-tree-and-add-to-dag- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (consp tree)
                         (equal 'bvif (ffn-symb tree))
                         (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-simplify-bvif-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'corollary-theorem-for-simplify-tree-and-add-to-dag- suffix)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (and (pseudo-dag-arrayp 'dag-array (get-dag-array (mv-nth '2 ,call-of-simplify-tree-and-add-to-dag)) (get-dag-len (mv-nth '2 ,call-of-simplify-tree-and-add-to-dag)))
                         (array1p 'dag-array (get-dag-array (mv-nth 2 ,call-of-simplify-tree-and-add-to-dag)))
                         (integerp (get-dag-len (mv-nth 2 ,call-of-simplify-tree-and-add-to-dag)))
                         (natp (get-dag-len (mv-nth 2 ,call-of-simplify-tree-and-add-to-dag)))
                         (<= (get-dag-len (mv-nth 2 ,call-of-simplify-tree-and-add-to-dag))
                             (alen1 'dag-array (get-dag-array (mv-nth 2 ,call-of-simplify-tree-and-add-to-dag))))
                         (maybe-memoizationp (mv-nth ,(if smtp 4 3) ,call-of-simplify-tree-and-add-to-dag))
                         (dargp (mv-nth 1 ,call-of-simplify-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (e/d (wf-rewrite-stobj2p)
                                    (,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)
                                     wf-rewrite-stobj2p-conjuncts)))))

         (defthm ,(pack$ 'pseudo-dag-arrayp-of-mv-nth-2-of- simplify-tree-and-add-to-dag-name)
           (implies (and (natp len)
                         (<= len (get-dag-len (MV-NTH 2 ,call-of-simplify-tree-and-add-to-dag)))
                         (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (pseudo-dag-arrayp 'dag-array (get-dag-array (mv-nth '2 ,call-of-simplify-tree-and-add-to-dag)) len))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (e/d (wf-rewrite-stobj2p)
                                    (,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)
                                     wf-rewrite-stobj2p-conjuncts)))))

         (defthm ,(pack$ '<-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
           (implies (and ;(natp bound)
                      (<= (get-dag-len (MV-NTH 2 ,call-of-simplify-tree-and-add-to-dag)) bound)
                      (not (consp (MV-NTH 1 ,call-of-simplify-tree-and-add-to-dag)))
                      (axe-treep tree)
                      (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                      (wf-rewrite-stobj2p rewrite-stobj2)
                      (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                      (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                      (trees-to-memoizep trees-equal-to-tree)
                      (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                      (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                      (rewrite-stobjp rewrite-stobj)
                      (rewrite-stobj2p rewrite-stobj2)
                      (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (< (MV-NTH '1 ,call-of-simplify-tree-and-add-to-dag)
                       bound))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'dargp-less-than-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
           (implies (and (<= (get-dag-len (MV-NTH 2 ,call-of-simplify-tree-and-add-to-dag)) bound)
                         (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (DARGP-LESS-THAN (MV-NTH 1 ,call-of-simplify-tree-and-add-to-dag) bound))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'dargp-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (dargp (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag)))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)
                                        ,(pack$ 'dargp-less-than-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)))))

         ;; Use consp as the normal form
         (defthm ,(pack$ 'natp-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (equal (natp (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag))
                           (not (consp (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag)))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)
                                        ,(pack$ 'dargp-less-than-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
                                        ,(pack$ 'dargp-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)))))

         ;; Use consp as the normal form
         (defthm ,(pack$ 'integerp-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (equal (integerp (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag))
                           (not (consp (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag)))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)
                                        ,(pack$ 'dargp-less-than-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
                                        ,(pack$ 'dargp-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)))))

         ;; Use consp as the normal form
         (defthm ,(pack$ 'myquotep-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (equal (myquotep (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag))
                           (consp (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)
                                        ,(pack$ 'dargp-less-than-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
                                        ,(pack$ 'dargp-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
                                        ))))

         ;; Use consp as the normal form
         (defthm ,(pack$ 'equal-of-car-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name '-and-quote)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (equal (equal (car (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag)) 'quote)
                           (consp (mv-nth '1 ,call-of-simplify-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)
                                        ,(pack$ 'dargp-less-than-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
                                        ,(pack$ 'dargp-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
                                        ,(pack$ 'myquotep-of-mv-nth-1-of- simplify-tree-and-add-to-dag-name)
                                        ))))

         (defthm ,(pack$ 'bound-theorem-for-simplify-tree-and-add-to-dag- suffix)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (get-dag-len rewrite-stobj2)))
                    (<= x (get-dag-len (mv-nth 2 ,call-of-simplify-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'maybe-memoizationp-of-mv-nth-3-of- simplify-fun-call-and-add-to-dag-name)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (symbolp fn)
                         (not (equal 'quote fn))
                         (bounded-darg-listp dargs (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-fun-call-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                    (maybe-memoizationp (mv-nth ,(if smtp 4 3) ,call-of-simplify-fun-call-and-add-to-dag)))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-fun-call-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-fun-call-and-add-to-dag- suffix)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-relieve-free-var-hyp-and-all-others- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-relieve-free-var-hyp-and-all-others))
                         (axe-tree-listp hyp-args)
                         (alist-suitable-for-hyp-args-and-hypsp alist hyp-args other-hyps)
                         (axe-rule-hyp-listp other-hyps)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (symbol-alistp alist)
                         (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2))
                         (bounded-darg-list-listp assumption-arg-lists (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 9 8) ,call-of-relieve-free-var-hyp-and-all-others))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-relieve-free-var-hyp-and-all-others- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-relieve-free-var-hyp-and-all-others- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-relieve-rule-hyps- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (axe-rule-hyp-listp hyps)
                         (alist-suitable-for-hypsp alist hyps)
                         (not (mv-nth 0 ,call-of-relieve-rule-hyps))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (symbol-alistp alist)
                         (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 9 8) ,call-of-relieve-rule-hyps))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-relieve-rule-hyps- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-relieve-rule-hyps- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-try-to-apply-rules- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (bounded-darg-listp args-to-match (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-try-to-apply-rules))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (stored-axe-rule-listp stored-rules)
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-try-to-apply-rules))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-try-to-apply-rules- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-try-to-apply-rules- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-trees-and-add-to-dag- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (bounded-axe-tree-listp trees (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-trees-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-trees-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)
           (implies (and (or (equal fn 'if)
                             (equal fn 'myif))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                         (axe-treep else-branch)
                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)
           (implies (and (or (equal fn 'if)
                             (equal fn 'myif))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (axe-treep then-branch)
                         (bounded-axe-treep then-branch (get-dag-len rewrite-stobj2))
                         (axe-treep else-branch)
                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (consp tree) ; not logically necessary but speeds up the proof
                         (or (eq (ffn-symb tree) 'if)
                             (eq (ffn-symb tree) 'myif))
                         ;; (equal 3 (len (fargs tree)))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-if/myif-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-if/myif-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-not-tree-and-add-to-dag- suffix)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (consp tree) ; not logically necessary but speeds up the proof
                         (eq (ffn-symb tree) 'not)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-not-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-not-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-not-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-not-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-boolif-tree-and-add-to-dag- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (consp tree)
                         (equal 'boolif (ffn-symb tree))
                         (not (mv-nth 0 ,call-of-simplify-boolif-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-boolif-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-boolif-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-boolif-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                         (axe-treep else-branch)
                         (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag3))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-bvif-tree-and-add-to-dag3))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (axe-treep then-arg)
                         (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                         (axe-treep else-arg)
                         (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag2))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-bvif-tree-and-add-to-dag2))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (axe-treep size-arg)
                         (bounded-axe-treep size-arg (get-dag-len rewrite-stobj2))
                         (natp simplified-test)
                         (< simplified-test (get-dag-len rewrite-stobj2))
                         (axe-treep then-arg)
                         (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                         (axe-treep else-arg)
                         (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                         (tree-to-memoizep tree)
                         ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag1))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-bvif-tree-and-add-to-dag1))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-bvif-tree-and-add-to-dag- suffix)
           (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                         (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (consp tree)
                         (equal 'bvif (ffn-symb tree))
                         (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-bvif-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag- suffix)))))

         (defthm ,(pack$ 'node-replacement-array-bound-theorem-for-simplify-tree-and-add-to-dag- suffix)
           (implies (and (axe-treep tree)
                         (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (trees-to-memoizep trees-equal-to-tree)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (<= x (alen1 'node-replacement-array node-replacement-array)))
                    (<= x (alen1 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-tree-and-add-to-dag))))
           :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                    :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)))))

         ;; This next batch shows that node-replacement-arrayp always holds (we known from above that bounded-node-replacement-arrayp holds):
         (progn
           (defthm ,(pack$ 'node-replacement-arrayp-of-relieve-free-var-hyp-and-all-others- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (not (mv-nth 0 ,call-of-relieve-free-var-hyp-and-all-others))
                           (axe-tree-listp hyp-args)
                           (alist-suitable-for-hyp-args-and-hypsp alist hyp-args other-hyps)
                           (axe-rule-hyp-listp other-hyps)
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                           (symbol-alistp alist)
                           (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2))
                           (bounded-darg-list-listp assumption-arg-lists (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 9 8) ,call-of-relieve-free-var-hyp-and-all-others)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-relieve-free-var-hyp-and-all-others- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-relieve-free-var-hyp-and-all-others- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-relieve-rule-hyps- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (axe-rule-hyp-listp hyps)
                           (alist-suitable-for-hypsp alist hyps)
                           (not (mv-nth 0 ,call-of-relieve-rule-hyps))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                           (symbol-alistp alist)
                           (bounded-darg-listp (strip-cdrs alist) (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 9 8) ,call-of-relieve-rule-hyps)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-relieve-rule-hyps- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-relieve-rule-hyps- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-try-to-apply-rules- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (bounded-darg-listp args-to-match (get-dag-len rewrite-stobj2))
                           (not (mv-nth 0 ,call-of-try-to-apply-rules))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (stored-axe-rule-listp stored-rules)
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7),call-of-try-to-apply-rules)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-try-to-apply-rules- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-try-to-apply-rules- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-trees-and-add-to-dag- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (bounded-axe-tree-listp trees (get-dag-len rewrite-stobj2))
                           (not (mv-nth 0 ,call-of-simplify-trees-and-add-to-dag))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-trees-and-add-to-dag)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-trees-and-add-to-dag- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)
             (implies (and (or (equal fn 'if)
                               (equal fn 'myif))
                           (natp simplified-test)
                           (< simplified-test (get-dag-len rewrite-stobj2))
                           (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                           (axe-treep else-branch)
                           (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                           (tree-to-memoizep tree)
                           ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (wf-rewrite-stobj2p rewrite-stobj2)
                           (not (mv-nth 0 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)
             (implies (and (or (equal fn 'if)
                               (equal fn 'myif))
                           (natp simplified-test)
                           (< simplified-test (get-dag-len rewrite-stobj2))
                           (axe-treep then-branch)
                           (bounded-axe-treep then-branch (get-dag-len rewrite-stobj2))
                           (axe-treep else-branch)
                           (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                           (tree-to-memoizep tree)
                           ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (wf-rewrite-stobj2p rewrite-stobj2)
                           (not (mv-nth 0 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-if/myif-tree-and-add-to-dag- suffix)
             (implies (and (axe-treep tree)
                           (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (consp tree) ; not logically necessary but speeds up the proof
                           (or (eq (ffn-symb tree) 'if)
                               (eq (ffn-symb tree) 'myif))
                           ;; (equal 3 (len (fargs tree)))
                           (wf-rewrite-stobj2p rewrite-stobj2)
                           (not (mv-nth 0 ,call-of-simplify-if/myif-tree-and-add-to-dag))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-if/myif-tree-and-add-to-dag)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-if/myif-tree-and-add-to-dag- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-not-tree-and-add-to-dag- suffix)
             (implies (and (axe-treep tree)
                           (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (consp tree) ; not logically necessary but speeds up the proof
                           (eq (ffn-symb tree) 'not)
                           (wf-rewrite-stobj2p rewrite-stobj2)
                           (not (mv-nth 0 ,call-of-simplify-not-tree-and-add-to-dag))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-not-tree-and-add-to-dag)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-not-tree-and-add-to-dag- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-not-tree-and-add-to-dag- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-boolif-tree-and-add-to-dag- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (axe-treep tree)
                           (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (consp tree)
                           (equal 'boolif (ffn-symb tree))
                           (not (mv-nth 0 ,call-of-simplify-boolif-tree-and-add-to-dag))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-boolif-tree-and-add-to-dag)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-boolif-tree-and-add-to-dag- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-boolif-tree-and-add-to-dag- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-bvif-tree-and-add-to-dag3- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                           (natp simplified-test)
                           (< simplified-test (get-dag-len rewrite-stobj2))
                           (dargp-less-than simplified-then-branch (get-dag-len rewrite-stobj2))
                           (axe-treep else-branch)
                           (bounded-axe-treep else-branch (get-dag-len rewrite-stobj2))
                           (tree-to-memoizep tree)
                           ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag3))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-bvif-tree-and-add-to-dag3)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag3- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-bvif-tree-and-add-to-dag2- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (dargp-less-than simplified-size (get-dag-len rewrite-stobj2))
                           (natp simplified-test)
                           (< simplified-test (get-dag-len rewrite-stobj2))
                           (axe-treep then-arg)
                           (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                           (axe-treep else-arg)
                           (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                           (tree-to-memoizep tree)
                           ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag2))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-bvif-tree-and-add-to-dag2)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag2- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-bvif-tree-and-add-to-dag1- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (axe-treep size-arg)
                           (bounded-axe-treep size-arg (get-dag-len rewrite-stobj2))
                           (natp simplified-test)
                           (< simplified-test (get-dag-len rewrite-stobj2))
                           (axe-treep then-arg)
                           (bounded-axe-treep then-arg (get-dag-len rewrite-stobj2))
                           (axe-treep else-arg)
                           (bounded-axe-treep else-arg (get-dag-len rewrite-stobj2))
                           (tree-to-memoizep tree)
                           ;; (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag1))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-bvif-tree-and-add-to-dag1)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag1- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-bvif-tree-and-add-to-dag- suffix)
             (implies (and (wf-rewrite-stobj2p rewrite-stobj2)
                           (axe-treep tree)
                           (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (consp tree)
                           (equal 'bvif (ffn-symb tree))
                           (not (mv-nth 0 ,call-of-simplify-bvif-tree-and-add-to-dag))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-bvif-tree-and-add-to-dag)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-bvif-tree-and-add-to-dag- suffix)))))

           (defthm ,(pack$ 'node-replacement-arrayp-of-simplify-tree-and-add-to-dag- suffix)
             (implies (and (axe-treep tree)
                           (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
                           (wf-rewrite-stobj2p rewrite-stobj2)
                           (not (mv-nth 0 ,call-of-simplify-tree-and-add-to-dag))
                           (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                           (trees-to-memoizep trees-equal-to-tree)
                           (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                           (natp node-replacement-count) (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                           (rewrite-stobjp rewrite-stobj)
                           (rewrite-stobj2p rewrite-stobj2)
                           (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2)))
                      (node-replacement-arrayp 'node-replacement-array (mv-nth ,(if smtp 8 7) ,call-of-simplify-tree-and-add-to-dag)))
             :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
                      :in-theory (disable ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)))))
           )


         ;; ;todo: more like this.  or just add to the corollary theorems above?
         ;; (def-dag-builder-theorems
         ;;   (,simplify-tree-and-add-to-dag-name tree trees-equal-to-tree rewrite-stobj2
         ;;                                  memoization hit-counts tries limits
         ;;                                 rule-alist
         ;;                                 refined-assumption-alist
         ;;
         ;;                                 node-replacement-count
         ;;                                 print
         ;;                                 interpreted-function-alist
         ;;                                 monitored-symbols count)
         ;;   (mv erp new-nodenum-or-quotep rewrite-stobj2 memoization hit-counts tries limits node-replacement-array)
         ;;   :hyps ((axe-treep tree)
         ;;          (bounded-axe-treep tree (get-dag-len rewrite-stobj2))
         ;;          (wf-rewrite-stobj2p rewrite-stobj2)
         ;;          (not (mv-nth 0 (,simplify-tree-and-add-to-dag-name
         ;;                          tree trees-equal-to-tree dag-array (get-dag-len rewrite-stobj2) dag-parent-array
         ;;                          dag-constant-alist dag-variable-alist memoization hit-counts tries limits
         ;;                          rule-alist
         ;;                          refined-assumption-alist
         ;;
         ;;                          node-replacement-count
         ;;                          print
         ;;                          interpreted-function-alist
         ;;                          monitored-symbols count)))
         ;;
         ;;          (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
         ;;          (trees-to-memoizep trees-equal-to-tree)
         ;;
         ;;          (alistp node-replacement-count)
         ;;          (bounded-darg-listp (strip-cdrs node-replacement-count) (get-dag-len rewrite-stobj2))
         ;;          (rewrite-stobjp rewrite-stobj)
         ;;          (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
         ;;          )
         ;;   :hyps-everywhere t
         ;;   :dag-array-name 'dag-array
         ;;   :dag-parent-array-name 'dag-parent-array
         ;;   :hints (("Goal" :use (:instance ,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix))
         ;;            :in-theory (e/d (WF-DAGP) (,(pack$ 'theorem-for-simplify-tree-and-add-to-dag- suffix)))))
         ;;   )

         ;; Show that the dag-len is always a natp:
         (,(pack$ 'defthm-flag-simplify-tree-and-add-to-dag- suffix)
          (defthm ,(pack$ 'natp-of-mv-nth-3-of-relieve-free-var-hyp-and-all-others- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 3 ,call-of-relieve-free-var-hyp-and-all-others))))
            :rule-classes (:rewrite :type-prescription) :flag ,relieve-free-var-hyp-and-all-others-name)

          (defthm ,(pack$ 'natp-of-mv-nth-3-of-relieve-rule-hyps- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 3 ,call-of-relieve-rule-hyps))))
            :rule-classes (:rewrite :type-prescription) :flag ,relieve-rule-hyps-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-try-to-apply-rules- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-try-to-apply-rules))))
            :rule-classes (:rewrite :type-prescription) :flag ,try-to-apply-rules-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-trees-and-add-to-dag- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-trees-and-add-to-dag))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-trees-and-add-to-dag-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-if/myif/boolif-tree-and-add-to-dag3- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-if/myif/boolif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-if/myif/boolif-tree-and-add-to-dag2- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-if/myif/boolif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-if/myif-tree-and-add-to-dag- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-if/myif-tree-and-add-to-dag))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-if/myif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-not-tree-and-add-to-dag- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-not-tree-and-add-to-dag))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-not-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-boolif-tree-and-add-to-dag- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-boolif-tree-and-add-to-dag))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-boolif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-bvif-tree-and-add-to-dag3- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-bvif-tree-and-add-to-dag3))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-bvif-tree-and-add-to-dag3-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-bvif-tree-and-add-to-dag2- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-bvif-tree-and-add-to-dag2))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-bvif-tree-and-add-to-dag2-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-bvif-tree-and-add-to-dag1- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-bvif-tree-and-add-to-dag1))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-bvif-tree-and-add-to-dag1-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-bvif-tree-and-add-to-dag- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-bvif-tree-and-add-to-dag))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-bvif-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-tree-and-add-to-dag- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-tree-and-add-to-dag))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-tree-and-add-to-dag-name)

          (defthm ,(pack$ 'natp-of-mv-nth-2-of-simplify-fun-call-and-add-to-dag- suffix)
            (implies (natp (get-dag-len rewrite-stobj2))
                     (natp (get-dag-len (mv-nth 2 ,call-of-simplify-fun-call-and-add-to-dag))))
            :rule-classes (:rewrite :type-prescription) :flag ,simplify-fun-call-and-add-to-dag-name)

          :hints (("Goal" :do-not '(generalize eliminate-destructors)
                   :in-theory (e/d ( ;TAKE-WHEN-<=-OF-LEN
                                    len-of-cadar-when-axe-treep
                                    pseudo-termp-of-cadddr-when-axe-treep
                                    axe-bind-free-result-okayp-rewrite
                                    symbol-alistp-when-alistp
                                    true-listp-of-cdr)
                                   (dargp-less-than
                                    natp
                                    quotep
                                    myquotep))
                   :expand ((:free (memoization count other-hyps alist)
                                   ,call-of-relieve-free-var-hyp-and-all-others)
                            (:free (memoization count)
                                   ,call-of-relieve-rule-hyps)
                            (:free (memoization)
                                   (,relieve-rule-hyps-name nil hyp-num alist rule-symbol
                                                            rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                            node-replacement-array node-replacement-count refined-assumption-alist
                                                            rewrite-stobj count))
                            (:free (memoization count)
                                   (,simplify-trees-and-add-to-dag-name nil
                                                                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                        node-replacement-array node-replacement-count refined-assumption-alist
                                                                        rewrite-stobj count))
                            (:free (memoization count)
                                   ,call-of-simplify-trees-and-add-to-dag)
                            (:free (memoization limits hit-counts tries count)
                                   ,call-of-try-to-apply-rules)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif-tree-and-add-to-dag)
                            (:free (memoization fn count)
                                   ,call-of-simplify-not-tree-and-add-to-dag)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag2)
                            (:free (memoization fn count)
                                   ,call-of-simplify-if/myif/boolif-tree-and-add-to-dag3)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag)
                            (:free (memoization count)
                                   ,call-of-simplify-boolif-tree-and-add-to-dag)
                            (:free (memoization count TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-tree-and-add-to-dag)
                            (:free (memoization count TREES-EQUAL-TO-TREE)
                                   ,call-of-simplify-fun-call-and-add-to-dag)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag1)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag2)
                            (:free (memoization count)
                                   ,call-of-simplify-bvif-tree-and-add-to-dag3)
                            (axe-rule-hyp-listp hyps)))))

         (verify-guards ,simplify-fun-call-and-add-to-dag-name
           :hints (("Goal" :do-not '(generalize eliminate-destructors)
                    :expand ((axe-bind-free-function-applicationp (nth 1 (car hyps)))
                             (axe-rule-hyp-listp hyps)
                             ;; (axe-treep tree)
                             (myquotep tree)
                             (quotep tree))
                    :in-theory (e/d (true-list-of-car-when-bounded-darg-list-listp
                                     darg-listp-of-car-when-bounded-darg-list-listp
                                     all-myquotep-when-darg-listp
                                     axe-bind-free-result-okayp-rewrite
                                     axe-rule-hypp
                                     integerp-when-dargp
                                     <=-of-0-when-dargp
                                     <-when-dargp-less-than
                                     len-when-dargp
                                     natp-when-dargp
                                     quotep-when-dargp
                                     <-of--1-when-dargp
                                     integerp-of-if
                                     <-of--0-when-dargp
                                     natp-of-+-of-1
                                     <-of-+-of-1-when-integers
                                     ;;symbol-alistp-when-alistp
                                     cadr-becomes-nth-of-1
                                     memoizationp-when-maybe-memoizationp
                                     tree-to-memoizep ;todo
                                     <=-transitive-1  ;drop?
                                     symbolp-when-member-equal-disabled
                                     not-equal-when-member-equal-alt-disabled
                                     not-equal-when-member-equal-disabled
                                     pseudo-termp-of-lambda-body-when-axe-treep
                                     true-listp-of-lambda-formals-when-axe-treep
                                     symbol-listp-of-lambda-formals-when-axe-treep
                                     len-of-lambda-formals-when-axe-treep
                                     len-when-equal-of-car-and-quote-and-axe-treep
                                     consp-of-cdr-when-equal-of-car-and-quote-and-axe-treep
                                     len-of-car-when-axe-treep
                                     member-equal-when-member-equal-and-subsetp-equal
                                     ;all-natp-when-nat-listp
                                     pseudo-termp-of-cadr-when-axe-smt ;axe-treep-of-cadr-when-axe-smt
                                     free-vars-in-term-of-cadr-when-axe-smt
                                     myquotep-when-axe-treep)
                                    (dargp
                                     dargp-less-than
                                     natp
                                     quotep
                                     myquotep
                                     nth-of-cdr
                                     cadr-becomes-nth-of-1)))
                   ;;(and stable-under-simplificationp '(:cases (memoizep)))
                   ))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; Simplifies a single dag-expr, e.g., when traversing all the nodes in a DAG, simplifying each expr.
         ;; Returns (mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array).
         (defund ,simplify-dag-expr-name (expr
                                          old-nodenum ; just for guards
                                          rewrite-stobj2 ,@maybe-state
                                          memoization ; this is over the NEW nodenums (the ones in dag-array)
                                          hit-counts tries limits
                                          node-replacement-array node-replacement-count ; this is over nodes in the NEW dag
                                          refined-assumption-alist
                                          rewrite-stobj
                                          ;; maps nodenums in rev-dag to the dargs (nodenums or quoteps) they rewrote to in dag-array
                                          ;; we could renumber outside this function, but not all nodes may be needed:
                                          renumbering-stobj
                                          )
           (declare (xargs :guard (and (natp old-nodenum)
                                       (bounded-dag-exprp old-nodenum expr)
                                       (wf-rewrite-stobj2p rewrite-stobj2)
                                       (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                       (hit-countsp hit-counts)
                                       (triesp tries)
                                       (rule-limitsp limits)
                                       (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                       (natp node-replacement-count)
                                       (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                       (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                       (< old-nodenum (renumbering-length renumbering-stobj))
                                       (bounded-good-renumbering-stobjp (+ -1 old-nodenum) (get-dag-len rewrite-stobj2) renumbering-stobj))
                           :stobjs (rewrite-stobj renumbering-stobj rewrite-stobj2 ,@maybe-state)
                           :guard-hints (("Goal" :in-theory (e/d (;; todo: simplify this hint
                                                                  integerp-when-dargp
                                                                  rationalp-when-integerp
                                                                  symbolp-of-car-when-dag-exprp
                                                                  axe-treep-when-dag-exprp
                                                                  car-of-cadr-when-cars-increasing-by-1
                                                                  all-myquotep-when-darg-listp
                                                                  consp-of-cdr-when-dargp
                                                                  consp-of-cdr-when-dag-exprp-and-quote
                                                                  not-cddr-when-dag-exprp-and-quotep
                                                                  natp-of-renumber-darg-with-stobj
                                                                  consp-of-dargs-when-dag-exprp-iff
                                                                  true-listp-of-renumber-darg-with-stobj
                                                                  <-of-renumber-darg-with-stobj
                                                                  <-of-if-arg2-axe ; todo: -axe suffix here is confusing (not an axe rule)
                                                                  )
                                                                 (natp dargp dargp-less-than-when-not-consp-cheap dargp-less-than-when-consp-cheap)))))
                    (ignore old-nodenum))
           (if (atom expr)
               ;; EXPR is a variable:
               (b* (;; Add it to the DAG:
                    ((mv erp new-nodenum rewrite-stobj2)
                     (add-variable-to-dag-array-in-stobj expr rewrite-stobj2))
                    ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                    ;; Maybe apply a replacement:
                    (new-nodenum-or-quotep (apply-node-replacement-array new-nodenum node-replacement-array node-replacement-count))
                    ;; (- (cw "Var ~x0 is node ~x1 and becomes node ~x2.~%" expr new-nodenum new-nodenum-or-quotep))
                    )
                 (mv (erp-nil) new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
             (let ((fn (ffn-symb expr)))
               (case fn
                 (quote ; EXPR is a quoted constant (rare):
                   (mv (erp-nil) expr rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                 ;; (if/myif <test> <then> <else>):
                 ;; Functions like simplify-bvif-tree-and-add-to-dag-name are not appropriate here because they take entire trees.
                 ((if myif)
                  (b* ((dargs (dargs expr))
                       ((when (not (consp (rest (rest dargs))))) ; for guards
                        (mv :bad-arity nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                       ;; Renumber the test (then-branch and else-branch get renumbered below only if needed):
                       (renumbered-test-darg (renumber-darg-with-stobj (first dargs) renumbering-stobj))
                       ;; Special treatment for IF (can rewrite the test in an IFF context):
                       (renumbered-test-darg (apply-node-replacement-array-bool-to-darg renumbered-test-darg node-replacement-array node-replacement-count))
                       ;; TODO: Consult the memoization?
                       )
                    (if (consp renumbered-test-darg) ; test for quotep
                        ;; The test was resolved, so the whole node is replaced by one branch:
                        ;; I suppose we could update the memoization here if we wanted to (but remember that it deals in the new nodenums).
                        (mv (erp-nil)
                            (apply-node-replacement-array-to-darg (renumber-darg-with-stobj (if (unquote renumbered-test-darg) (second dargs) (third dargs)) renumbering-stobj) node-replacement-array node-replacement-count)
                            rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                      ;; The test was not resolved, so just try to apply rules:
                      (,simplify-fun-call-and-add-to-dag-name ;; TODO: Perhaps pass in the original expr for use by cons-with-hint?
                       fn (list renumbered-test-darg
                                ;; TODO: Try to apply info from the test to the args here:
                                (apply-node-replacement-array-to-darg (renumber-darg-with-stobj (second dargs) renumbering-stobj) node-replacement-array node-replacement-count)
                                (apply-node-replacement-array-to-darg (renumber-darg-with-stobj (third dargs) renumbering-stobj) node-replacement-array node-replacement-count))
                       nil ; Can't memoize anything about EXPR because its nodenums are in the old dag (but we could cons the new expr?)
                       rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                       node-replacement-array node-replacement-count refined-assumption-alist
                       rewrite-stobj 1000000000))))
                 ;; (not <expr>):
                 (not
                   (b* ((dargs (dargs expr))
                        ((when (not (consp dargs))) ; for guards
                         (mv :bad-arity nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                        ;; Renumber the expr:
                        (renumbered-expr (renumber-darg-with-stobj (first dargs) renumbering-stobj))
                        ;; Special treatment for NOT (can rewrite the arg in an IFF context):
                        (renumbered-expr (apply-node-replacement-array-bool-to-darg renumbered-expr node-replacement-array node-replacement-count))
                        ;; TODO: Consult the memoization?
                        )
                     (if (consp renumbered-expr) ; test for quotep
                         ;; Ground term:
                         ;; I suppose we could update the memoization here if we wanted to (but remember that it deals in the new nodenums).
                         (mv (erp-nil)
                             (if (unquote renumbered-expr) *nil* *t*) ; negate the expr
                             rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                       ;; The expr is not constant, so just try to apply rules:
                       (,simplify-fun-call-and-add-to-dag-name ;; TODO: Perhaps pass in the original expr for use by cons-with-hint?
                        fn (list (apply-node-replacement-array-to-darg renumbered-expr node-replacement-array node-replacement-count))
                        nil ; Can't memoize anything about EXPR because its nodenums are in the old dag (but we could cons the new expr?)
                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array node-replacement-count refined-assumption-alist
                        rewrite-stobj 1000000000))))
                 ;; (boolif <test> <then> <else>):
                 (boolif
                   (b* ((dargs (dargs expr))
                        ((when (not (consp (rest (rest dargs))))) ; for guards
                         (mv :bad-arity nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                        ;; Renumber the test (then-branch and else-branch get renumbered below only if needed):
                        (renumbered-test-darg (renumber-darg-with-stobj (first dargs) renumbering-stobj))
                        ;; Special treatment for BOOLIF (can rewrite the test in an IFF context):
                        (renumbered-test-darg (apply-node-replacement-array-bool-to-darg renumbered-test-darg node-replacement-array node-replacement-count))
                        ;; TODO: Consult the memoization?
                        )
                     (if (consp renumbered-test-darg) ; test for quotep
                         ;; The test was resolved, so the whole node is replaced by (the bool-fix of) one branch:
                         ;; TODO: Do something faster, with no bool-fix, if the selected branch is a known-boolean?
                         (let ((selected-branch
                                 ;; Since this is a boolif, we can rewrite the selected branch in an IFF context:
                                 (apply-node-replacement-array-bool-to-darg
                                   (renumber-darg-with-stobj
                                     (if (unquote renumbered-test-darg)
                                         (second dargs)
                                       (third dargs))
                                     renumbering-stobj)
                                   node-replacement-array node-replacement-count)))
                           (if (consp selected-branch) ; tests for quotep
                               (mv (erp-nil)
                                   (if (unquote selected-branch) *t* *nil*) ; bool-fixes the constant
                                   rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                             (,simplify-fun-call-and-add-to-dag-name 'bool-fix$inline
                                                                     (list selected-branch)
                                                                     nil ; should we pass the tree here (remember that the memoization deals in the new nodenums)?
                                                                     rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                     node-replacement-array node-replacement-count refined-assumption-alist
                                                                     rewrite-stobj 1000000000)))
                       ;; The test was not resolved, so just try to apply rules (can't be a ground term because the test is not a constant):
                       (,simplify-fun-call-and-add-to-dag-name ;; TODO: Perhaps pass in the original expr for use by cons-with-hint?
                        fn (list renumbered-test-darg
                                 ;; Since this is a boolif, we can rewrite the branches in an IFF context:
                                 ;; TODO: Try to apply node replacements using info from the test as well
                                 (apply-node-replacement-array-bool-to-darg (renumber-darg-with-stobj (second dargs) renumbering-stobj) node-replacement-array node-replacement-count)
                                 (apply-node-replacement-array-bool-to-darg (renumber-darg-with-stobj (third dargs) renumbering-stobj) node-replacement-array node-replacement-count))
                        nil ; Can't memoize anything about EXPR because its nodenums are in the old dag (but we could cons the new expr?)
                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array node-replacement-count refined-assumption-alist
                        rewrite-stobj 1000000000))))
                 ;; (bvif <size> <test> <then> <else>):
                 (bvif
                   (b* ((dargs (dargs expr))
                        ((when (not (consp (rest (rest (rest dargs)))))) ; for guards
                         (mv :bad-arity nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array))
                        ;; Renumber the size and test (then-branch and else-branch get renumbered below only if needed):
                        (renumbered-size-darg (renumber-darg-with-stobj (first dargs) renumbering-stobj))
                        (renumbered-size-darg (apply-node-replacement-array-to-darg renumbered-size-darg node-replacement-array node-replacement-count)) ; this usually won't do much
                        (renumbered-test-darg (renumber-darg-with-stobj (second dargs) renumbering-stobj))
                        ;; Special treatment for BVIF (can rewrite the test in an IFF context):
                        (renumbered-test-darg (apply-node-replacement-array-bool-to-darg renumbered-test-darg node-replacement-array node-replacement-count))
                        ;; TODO: Consult the memoization?
                        )
                     (if (consp renumbered-test-darg) ; tests for quotep
                         ;; The test was resolved, so the whole node is replaced by (the bvchop of) one branch:
                         ;; TODO: Do something faster, with no bvchop, if the selected branch is already a BV
                         (let ((selected-branch
                                 (apply-node-replacement-array-to-darg
                                   (renumber-darg-with-stobj
                                     (if (unquote renumbered-test-darg)
                                         (third dargs)
                                       (fourth dargs))
                                     renumbering-stobj)
                                   node-replacement-array node-replacement-count)))
                           (if (and (consp selected-branch) ; tests for quotep
                                    (consp renumbered-size-darg))
                               ;; Ground term:
                               (mv (erp-nil)
                                   (enquote (bvchop-unguarded (unquote renumbered-size-darg) (unquote selected-branch))) ; todo: optimize
                                   rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                             (,simplify-fun-call-and-add-to-dag-name 'bvchop
                                                                     (list renumbered-size-darg selected-branch)
                                                                     nil ; should we pass the tree here (remember that the memoization deals in the new nodenums)?
                                                                     rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                                                     node-replacement-array node-replacement-count refined-assumption-alist
                                                                     rewrite-stobj 1000000000)))
                       ;; The test was not resolved, so just try to apply rules (can't be a ground term because the test is not a constant):
                       (,simplify-fun-call-and-add-to-dag-name ;; TODO: Perhaps pass in the original expr for use by cons-with-hint?
                        fn (list renumbered-size-darg
                                 renumbered-test-darg
                                 ;; TODO: Try to apply node replacements using info from the test as well
                                 (apply-node-replacement-array-to-darg (renumber-darg-with-stobj (third dargs) renumbering-stobj) node-replacement-array node-replacement-count)
                                 (apply-node-replacement-array-to-darg (renumber-darg-with-stobj (fourth dargs) renumbering-stobj) node-replacement-array node-replacement-count))
                        nil ; Can't memoize anything about EXPR because its nodenums are in the old dag (but we could cons the new expr?)
                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array node-replacement-count refined-assumption-alist
                        rewrite-stobj 1000000000))))
                 (t ;; EXPR is some other function call (can't be a lambda application since it is a dag-expr):
                   (b* (;; Renumber the args:
                        (new-dargs (renumber-dargs-with-stobj (dargs expr) renumbering-stobj)) ; todo: have the renumbering function return a groundp flag
                        ;; Apply node-replacements:
                        (new-dargs (apply-node-replacement-array-to-dargs new-dargs node-replacement-array node-replacement-count)) ; todo: return a groundp flag?
                        ;; TODO: Consider consulting the memoization here, now that the nodenums have been renumbered
                        ;; Handle possible ground term by evaluating (since ,simplify-fun-call-and-add-to-dag-name doesn't handle ground terms):
                        ((mv erp evaluatedp val)
                         (if (not (all-consp new-dargs)) ;; test for args being quoted constants
                             ;; not a ground term:
                             (mv (erp-nil) nil nil)
                           ;; ground term, so try to evaluate (may fail, but we may have a constant opener rule to apply later):
                           (b* (((mv erp val)
                                 (,apply-axe-evaluator-to-quoted-args-name fn new-dargs (get-interpreted-function-alist rewrite-stobj))))
                             (if erp
                                 (if (call-of :unknown-function erp)
                                     (mv (erp-nil) nil nil) ;no error, but it didn't produce a value (todo: print a warning?)
                                   ;; anything else non-nil is a true error:
                                   (mv erp nil nil))
                               ;; normal case (evaluated to VAL):
                               (mv (erp-nil) t val)))))
                        ((when erp) (mv erp nil rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)))
                     (if evaluatedp
                         ;; I suppose we could update the memoization here if we wanted to (but remember that it deals in the new nodenums).
                         (mv (erp-nil) (enquote val) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                       ;; Not a ground term we could evaluate, so rewrite the non-lambda FN applied to the simplified args:
                       (,simplify-fun-call-and-add-to-dag-name ;; TODO: Perhaps pass in the original expr for use by cons-with-hint?
                        fn new-dargs
                        nil ; Can't memoize anything about EXPR because its nodenums are in the old dag
                        rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                        node-replacement-array node-replacement-count refined-assumption-alist
                        rewrite-stobj 1000000000))))))))

         (defthm ,(pack$ simplify-dag-expr-name '-return-type)
           (implies (and (natp old-nodenum)
                         (bounded-dag-exprp old-nodenum expr)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (< old-nodenum (renumbering-length renumbering-stobj))
                         (bounded-good-renumbering-stobjp (+ -1 old-nodenum) (get-dag-len rewrite-stobj2) renumbering-stobj))
                    (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits
                                 new-node-replacement-array ; no real change
                                 )
                      (,simplify-dag-expr-name expr
                                               old-nodenum
                                               rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                               node-replacement-array node-replacement-count refined-assumption-alist
                                               rewrite-stobj
                                               renumbering-stobj)
                      (implies (not erp)
                               (and (rewrite-stobj2p new-rewrite-stobj2)
                                    (wf-rewrite-stobj2p new-rewrite-stobj2)
                                    (dargp-less-than new-nodenum-or-quotep (get-dag-len new-rewrite-stobj2))
                                    (dargp new-nodenum-or-quotep) ; implied by dargp-less-than (just above) but matches better
                                    (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2))
                                    (hit-countsp new-hit-counts)
                                    (maybe-memoizationp new-memoization)
                                    (maybe-bounded-memoizationp new-memoization (get-dag-len new-rewrite-stobj2))
                                    (iff new-memoization memoization) ; whether we are memoizing doesn't change
                                    (triesp new-tries)
                                    (rule-limitsp new-limits)
                                    (bounded-node-replacement-arrayp 'node-replacement-array new-node-replacement-array (get-dag-len new-rewrite-stobj2))
                                    (<= (alen1 'node-replacement-array node-replacement-array) (alen1 'node-replacement-array new-node-replacement-array))
                                    ,@maybe-w-unchanged))))
           :hints (("Goal" :in-theory (e/d (,simplify-dag-expr-name
                                            ;; todo: simplify this hint
                                            integerp-when-dargp
                                            rationalp-when-integerp
                                            symbolp-of-car-when-dag-exprp
                                            axe-treep-when-dag-exprp
                                            car-of-cadr-when-cars-increasing-by-1
                                            all-myquotep-when-darg-listp
                                            consp-of-cdr-when-dargp
                                            consp-of-cdr-when-dag-exprp-and-quote
                                            not-cddr-when-dag-exprp-and-quotep
                                            natp-of-renumber-darg-with-stobj
                                            consp-of-dargs-when-dag-exprp-iff
                                            true-listp-of-renumber-darg-with-stobj
                                            <-of-renumber-darg-with-stobj
                                            <-of-if-arg2-axe ; todo: -axe suffix here is confusing (not an axe rule)
                                            not-<-of-nth-of-dargs)
                                           (natp dargp dargp-less-than-when-not-consp-cheap dargp-less-than-when-consp-cheap)))))

         (defthm ,(pack$ simplify-dag-expr-name '-return-type-corollary)
           (implies (and (natp old-nodenum)
                         (bounded-dag-exprp old-nodenum expr)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (< old-nodenum (renumbering-length renumbering-stobj))
                         (bounded-good-renumbering-stobjp (+ -1 old-nodenum) (get-dag-len rewrite-stobj2) renumbering-stobj))
                    (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits
                                 new-node-replacement-array ; no real change
                                 )
                      (,simplify-dag-expr-name expr
                                               old-nodenum
                                               rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                               node-replacement-array node-replacement-count refined-assumption-alist
                                               rewrite-stobj
                                               renumbering-stobj)
                      (declare (ignore new-nodenum-or-quotep new-hit-counts new-tries new-limits ,@maybe-new-state))
                      (implies (not erp)
                               (and ;(rewrite-stobj2p rewrite-stobj2)
                                 (natp (get-dag-len new-rewrite-stobj2))
                                 (node-replacement-arrayp 'node-replacement-array new-node-replacement-array)
                                 (implies (equal memoization nil) (equal new-memoization nil))))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-expr-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-expr-name '-return-type)))))

         (defthm ,(pack$ simplify-dag-expr-name '-return-type-corollary2)
           (implies (and (natp old-nodenum)
                         (bounded-dag-exprp old-nodenum expr)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (< old-nodenum (renumbering-length renumbering-stobj))
                         (bounded-good-renumbering-stobjp (+ -1 old-nodenum) (get-dag-len rewrite-stobj2) renumbering-stobj))
                    (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits
                                 new-node-replacement-array ; no real change
                                 )
                      (,simplify-dag-expr-name expr
                                               old-nodenum
                                               rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                               node-replacement-array node-replacement-count refined-assumption-alist
                                               rewrite-stobj
                                               renumbering-stobj)
                      (declare (ignore new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits))
                      (implies (and (not erp)
                                    (<= bound (alen1 'node-replacement-array node-replacement-array)))
                               (<= bound (alen1 'node-replacement-array new-node-replacement-array)))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-expr-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-expr-name '-return-type)))))

         ;; generalizes the bound
         (defthm ,(pack$ simplify-dag-expr-name '-return-type-corollary3)
           (implies (and (natp old-nodenum)
                         (bounded-dag-exprp old-nodenum expr)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (< old-nodenum (renumbering-length renumbering-stobj))
                         (bounded-good-renumbering-stobjp (+ -1 old-nodenum) (get-dag-len rewrite-stobj2) renumbering-stobj))
                    (mv-let (erp new-nodenum-or-quotep new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts new-tries new-limits
                                 new-node-replacement-array ; no real change
                                 )
                      (,simplify-dag-expr-name expr
                                               old-nodenum
                                               rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                                               node-replacement-array node-replacement-count refined-assumption-alist
                                               rewrite-stobj
                                               renumbering-stobj)
                      (declare (ignore new-nodenum-or-quotep new-memoization new-hit-counts new-tries new-limits new-node-replacement-array ,@maybe-new-state))
                      (implies (and (not erp)
                                    (<= bound (get-dag-len rewrite-stobj2)))
                               (<= bound (get-dag-len new-rewrite-stobj2)))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-expr-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-expr-name '-return-type)))))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; For each node in REV-DAG, fix up its args (if any) according to the renumbering-stobj, then add its simplified form to the dag-array and add its new nodenum or quotep to the renumbering-stobj.
         ;; Returns (mv erp rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array renumbering-stobj). The caller can use the renumbering-stobj to lookup what the old top node rewrote to.
         (defund ,simplify-dag-nodes-name (rev-dag ; the old dag, low nodes come first
                                           rewrite-stobj2 ; the new DAG
                                           ,@maybe-state
                                           maybe-internal-context-array ; if present, old and new dags agree on old nodenums
                                           memoization ; this is over the NEW nodenums (the ones in the dag-array field of rewrite-stobj2)
                                           hit-counts tries limits
                                           node-replacement-array node-replacement-count ; this is over nodes in the NEW dag
                                           refined-assumption-alist ; these are over nodes in the NEW dag
                                           rewrite-stobj
                                           renumbering-stobj ; maps nodenums in the old DAG (rev-dag) to the dargs (nodenums or quoteps) they rewrote to the new DAG
                                           )
           (declare (xargs :guard (and (weak-dagp-aux rev-dag)
                                       (cars-increasing-by-1 rev-dag)
                                       (if (consp rev-dag)
                                           (<= (car (car (last rev-dag))) *max-1d-array-length*) ; todo: why can they be equal?
                                         t)
                                       (wf-rewrite-stobj2p rewrite-stobj2)
                                       (if (consp rev-dag)
                                           (or (null maybe-internal-context-array)
                                               (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car (last rev-dag)))) (get-dag-len rewrite-stobj2)))
                                         t)
                                       (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                                       (not (and memoization maybe-internal-context-array)) ; would be unsound to have both ;; todo: save work below for context stuff when we are memoizing?
                                       (hit-countsp hit-counts)
                                       (triesp tries)
                                       (rule-limitsp limits)
                                       (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                                       (natp node-replacement-count)
                                       (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                                       (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                                       (if (consp rev-dag)
                                           (equal (renumbering-length renumbering-stobj)
                                                  (+ 1 (car (car (last rev-dag))))) ; the highest nodenum
                                         t)
                                       (bounded-good-renumbering-stobjp (if (consp rev-dag)
                                                                           (+ -1 (car (first rev-dag)))
                                                                         -1)
                                                                        (get-dag-len rewrite-stobj2) renumbering-stobj)
                                       ;; Justifies how we use the context info (old nodes and new nodes agree):
                                       ;; todo: lower nodes that we've moved past also agree:
                                       ;; todo: uncomment:
                                       ;; (if maybe-internal-context-array
                                       ;;     (and (all-< (strip-cars rev-dag) (get-dag-len rewrite-stobj2))
                                       ;;          (dag-and-array-agreep-aux rev-dag 'dag-array (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2)))
                                       ;;   t)
                                       )
                           :stobjs (rewrite-stobj renumbering-stobj rewrite-stobj2 ,@maybe-state)
                           :guard-hints (("Goal" ;:expand (WEAK-DAGP-AUX REV-DAG)
                                          :in-theory (e/d (car-of-car-of-last-when-cars-increasing-by-1-linear ; todo: simplify this hint
                                                           ;;maybe-dargp
                                                           integerp-when-dargp
                                                           rationalp-when-integerp
                                                           symbolp-of-car-when-dag-exprp
                                                           ;;tree-to-memoizep
                                                           axe-treep-when-dag-exprp
                                                           car-of-cadr-when-cars-increasing-by-1
                                                           all-myquotep-when-darg-listp
                                                           consp-of-cdr-when-dargp
                                                           consp-of-cdr-when-dag-exprp-and-quote
                                                           not-cddr-when-dag-exprp-and-quotep
                                                           consp-of-car-of-last-when-weak-dagp-aux
                                                           acl2-numberp-of-car-of-car-of-last-when-weak-dagp-aux
                                                           consp-of-dargs-when-dag-exprp-iff)
                                                          (natp dargp dargp-less-than-when-not-consp-cheap dargp-less-than-when-consp-cheap))
                                          :do-not '(generalize eliminate-destructors)))))
           (if (endp rev-dag)
               (mv (erp-nil) rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array renumbering-stobj)
             (b* ((entry (first rev-dag))
                  (nodenum (the (integer 0 1152921504606846974) (car entry))) ; or, since they are consecutive, we could track this numerically.
                  (print (get-print rewrite-stobj))
                  (- (and print (= 0 (mod nodenum 1000)) (cw "Simplifying node ~x0.~%" nodenum)))
                  (context-for-this-node (if maybe-internal-context-array (aref1 'context-array maybe-internal-context-array nodenum) (true-context)))
                  (context-for-this-node (if (false-contextp context-for-this-node)
                                             (prog2$ (cw "WARNING: False context for node ~x0.~%" nodenum)
                                                     (true-context) ; safe
                                                     )
                                           context-for-this-node))
                  ;; (- (cw "Node ~x0 has ~x1 context items (array ~x2).~%" nodenum (len context-for-this-node) maybe-internal-context-array))
                  ;; Temporarily add context info to the node-replacement-array:
                  ((mv node-replacement-array node-replacement-count-for-this-node undo-pairs)
                   (update-node-replacement-array-for-assuming-possibly-negated-nodenums context-for-this-node
                                                                                         node-replacement-array node-replacement-count
                                                                                         (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2)
                                                                                         (get-known-booleans rewrite-stobj)
                                                                                         nil))
                  ;; Temporarily add context info to the assumptions used for free var matching:
                  (context-exprs-for-this-node (context-to-exprs context-for-this-node (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2)))
                  (refined-assumption-alist-for-this-node (extend-refined-assumption-alist context-exprs-for-this-node refined-assumption-alist))
                  ;; Temporarily assume the context info (must negate each node since we are extended the negated-assumptions):
                  ;; Due to the guard, we know there will be no context info if we are memoizing.
                  ,@(and smtp
                         '((old-negated-assumptions (get-negated-assumptions rewrite-stobj2))
                           ;; we could look for contradictions here, I suppose:
                           (rewrite-stobj2 (put-negated-assumptions (negate-possibly-negated-nodenums-and-append context-for-this-node old-negated-assumptions) rewrite-stobj2))))
                  ;; Save the old-memoization for comparison below (see todo below):
                  (old-memoization memoization)
                  ((mv erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                   (,simplify-dag-expr-name (cdr entry) ; the expr
                                            nodenum
                                            rewrite-stobj2 ,@maybe-state
                                            memoization ; this is over the NEW nodenums (the ones in dag-array)
                                            hit-counts tries limits
                                            node-replacement-array node-replacement-count-for-this-node ; this is over nodes in the NEW dag
                                            refined-assumption-alist-for-this-node
                                            rewrite-stobj
                                            renumbering-stobj))
                  ((when erp) (mv erp rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array renumbering-stobj))
                  (memoization (if (null old-memoization) nil memoization)) ;; ensure the memoization did not become non-nil (todo: prove that this is unneeded and drop it)
                  ;; Pop the context (if not using contexts, undo-pairs will be nil):
                  (node-replacement-array (undo-writes-to-node-replacement-array undo-pairs node-replacement-array node-replacement-count-for-this-node (get-dag-len rewrite-stobj2)))
                  ;; Restore the old negated-assumptions:
                  ,@(and smtp
                         '((rewrite-stobj2 (put-negated-assumptions old-negated-assumptions rewrite-stobj2))))
                  ;; Record the fact that NODENUM rewrote to NEW-NODENUM-OR-QUOTEP:
                  (renumbering-stobj (update-renumbering nodenum new-nodenum-or-quotep renumbering-stobj)))
               (,simplify-dag-nodes-name (rest rev-dag)
                                       rewrite-stobj2 ,@maybe-state
                                       maybe-internal-context-array
                                       memoization hit-counts tries limits
                                       node-replacement-array
                                       node-replacement-count-for-this-node ; or just use node-replacement-count, as the relevant entires have been undone?
                                       refined-assumption-alist ; the original one, not the extension for this node
                                       rewrite-stobj
                                       renumbering-stobj))))

         (defthm ,(pack$ simplify-dag-nodes-name '-return-type)
           (implies (and (weak-dagp-aux rev-dag)
                         (cars-increasing-by-1 rev-dag)
                         (if (consp rev-dag)
                             (<= (car (car (last rev-dag))) *max-1d-array-length*)
                           t)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (if (consp rev-dag)
                             (or (null maybe-internal-context-array)
                                 (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car (last rev-dag)))) (get-dag-len rewrite-stobj2)))
                           t)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (if (consp rev-dag)
                             (equal (renumbering-length renumbering-stobj)
                                    (+ 1 (car (car (last rev-dag))))) ; the highest nodenum
                           t)
                         (bounded-good-renumbering-stobjp (if (consp rev-dag)
                                                             (+ -1 (car (first rev-dag)))
                                                           -1)
                                                         (get-dag-len rewrite-stobj2) renumbering-stobj)
                         (renumbering-stobjp renumbering-stobj))
                    (mv-let (erp new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts tries new-limits node-replacement-array new-renumbering-stobj)
                      (,simplify-dag-nodes-name rev-dag
                                              rewrite-stobj2 ,@maybe-state
                                              maybe-internal-context-array memoization hit-counts tries limits
                                              node-replacement-array node-replacement-count refined-assumption-alist
                                              rewrite-stobj
                                              renumbering-stobj)
                      (declare (ignore tries node-replacement-array))
                      (implies (not erp)
                               (and (rewrite-stobj2p new-rewrite-stobj2)
                                    (wf-rewrite-stobj2p new-rewrite-stobj2)
                                    (hit-countsp new-hit-counts)
                                    (maybe-memoizationp new-memoization)
                                    (iff new-memoization memoization)
                                    (rule-limitsp new-limits)
                                    (renumbering-stobjp new-renumbering-stobj)
                                    (bounded-good-renumbering-stobjp (if (consp rev-dag)
                                                                        (car (car (last rev-dag)))
                                                                      -1)
                                                                    (get-dag-len new-rewrite-stobj2)
                                                                    new-renumbering-stobj)
                                    (equal (renumbering-length new-renumbering-stobj) (renumbering-length renumbering-stobj))
                                    (<= (get-dag-len rewrite-stobj2) (get-dag-len new-rewrite-stobj2)) ; the dag doesn't get smaller
                                    ,@maybe-w-unchanged))))
           :hints (("Goal" :induct (,simplify-dag-nodes-name rev-dag
                                                           rewrite-stobj2 ,@maybe-state
                                                           maybe-internal-context-array memoization hit-counts tries limits
                                                           node-replacement-array node-replacement-count refined-assumption-alist
                                                           rewrite-stobj
                                                           renumbering-stobj)
                    :expand ((,simplify-dag-nodes-name rev-dag rewrite-stobj2 ,@maybe-state maybe-internal-context-array memoization hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj renumbering-stobj)
                             (,simplify-dag-nodes-name rev-dag rewrite-stobj2 ,@maybe-state maybe-internal-context-array nil hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj renumbering-stobj)
                             (,simplify-dag-nodes-name rev-dag rewrite-stobj2 ,@maybe-state nil memoization hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj renumbering-stobj)
                             (,simplify-dag-nodes-name rev-dag rewrite-stobj2 ,@maybe-state nil nil hit-counts tries limits node-replacement-array node-replacement-count refined-assumption-alist rewrite-stobj renumbering-stobj))
                    :in-theory (e/d (,simplify-dag-nodes-name
                                     car-of-car-of-last-when-cars-increasing-by-1-linear
                                     ;;maybe-dargp
                                     integerp-when-dargp
                                     rationalp-when-integerp
                                     symbolp-of-car-when-dag-exprp
                                     tree-to-memoizep
                                     axe-treep-when-dag-exprp
                                     car-of-cadr-when-cars-increasing-by-1
                                     all-myquotep-when-darg-listp
                                     consp-of-cdr-when-dargp
                                     consp-of-cdr-when-dag-exprp-and-quote
                                     not-cddr-when-dag-exprp-and-quotep
                                     consp-of-car-of-last-when-weak-dagp-aux
                                     acl2-numberp-of-car-of-car-of-last-when-weak-dagp-aux
                                     natp-of-car-of-car-when-weak-dagp-aux
                                     bounded-refined-assumption-alistp-monotone-polarity ; why?
                                     )
                                    (natp
                                     bounded-refined-assumption-alistp-monotone ; why?
                                     ))
                    :do-not '(generalize eliminate-destructors))))

         ;; A simple consequence of the return type theorem
         (defthm ,(pack$ simplify-dag-nodes-name '-return-type-corollary0)
           (implies (and (weak-dagp-aux rev-dag)
                         (cars-increasing-by-1 rev-dag)
                         (if (consp rev-dag)
                             (<= (car (car (last rev-dag))) *max-1d-array-length*)
                           t)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (if (consp rev-dag)
                             (or (null maybe-internal-context-array)
                                 (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car (last rev-dag)))) (get-dag-len rewrite-stobj2)))
                           t)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (if (consp rev-dag)
                             (equal (renumbering-length renumbering-stobj)
                                    (+ 1 (car (car (last rev-dag))))) ; the highest nodenum
                           t)
                         (bounded-good-renumbering-stobjp (if (consp rev-dag)
                                                             (+ -1 (car (first rev-dag)))
                                                           -1)
                                                         (get-dag-len rewrite-stobj2) renumbering-stobj)
                         (renumbering-stobjp renumbering-stobj))
                    (mv-let (erp new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts tries limits node-replacement-array new-renumbering-stobj)
                      (,simplify-dag-nodes-name rev-dag
                                              rewrite-stobj2 ,@maybe-state
                                              maybe-internal-context-array memoization hit-counts tries limits
                                              node-replacement-array node-replacement-count refined-assumption-alist
                                              rewrite-stobj
                                              renumbering-stobj)
                      (declare (ignore new-memoization new-hit-counts tries limits node-replacement-array new-renumbering-stobj ,@maybe-new-state))
                      (implies (not erp)
                               (and (natp (get-dag-len new-rewrite-stobj2))
                                    (integerp (get-dag-len new-rewrite-stobj2))
                                    ;; (not (< *max-1d-array-length* (get-dag-len new-rewrite-stobj2))) ; todo
                                    ))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-nodes-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-nodes-name '-return-type)))))

         ;; A simple consequence of the return type theorem
         (defthm ,(pack$ simplify-dag-nodes-name '-return-type-corollary)
           (implies (and (weak-dagp-aux rev-dag)
                         (cars-increasing-by-1 rev-dag)
                         (if (consp rev-dag)
                             (<= (car (car (last rev-dag))) *max-1d-array-length*)
                           t)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (if (consp rev-dag)
                             (or (null maybe-internal-context-array)
                                 (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car (last rev-dag)))) (get-dag-len rewrite-stobj2)))
                           t)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (if (consp rev-dag)
                             (equal (renumbering-length renumbering-stobj)
                                    (+ 1 (car (car (last rev-dag))))) ; the highest nodenum
                           t)
                         (bounded-good-renumbering-stobjp (if (consp rev-dag)
                                                             (+ -1 (car (first rev-dag)))
                                                           -1)
                                                         (get-dag-len rewrite-stobj2) renumbering-stobj)
                         (renumbering-stobjp renumbering-stobj))
                    (mv-let (erp new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts tries limits node-replacement-array new-renumbering-stobj)
                      (,simplify-dag-nodes-name rev-dag
                                              rewrite-stobj2 ,@maybe-state maybe-internal-context-array
                                              memoization hit-counts tries limits
                                              node-replacement-array node-replacement-count refined-assumption-alist
                                              rewrite-stobj
                                              renumbering-stobj)
                      (declare (ignore new-memoization new-hit-counts tries limits node-replacement-array new-renumbering-stobj ,@maybe-new-state))
                      (implies (and (not erp)
                                    (<= bound (get-dag-len new-rewrite-stobj2)) ; note this
                                    (natp bound))
                               (pseudo-dag-arrayp 'dag-array (get-dag-array new-rewrite-stobj2) bound))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-nodes-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-nodes-name '-return-type)))))

         ;; A simple consequence of the return type theorem
         (defthm ,(pack$ simplify-dag-nodes-name '-return-type-corollary2)
           (implies (and (weak-dagp-aux rev-dag)
                         (cars-increasing-by-1 rev-dag)
                         (if (consp rev-dag)
                             (<= (car (car (last rev-dag))) *max-1d-array-length*)
                           t)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (if (consp rev-dag)
                             (or (null maybe-internal-context-array)
                                 (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car (last rev-dag)))) (get-dag-len rewrite-stobj2)))
                           t)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (if (consp rev-dag)
                             (equal (renumbering-length renumbering-stobj)
                                    (+ 1 (car (car (last rev-dag))))) ; the highest nodenum
                           t)
                         (bounded-good-renumbering-stobjp (if (consp rev-dag)
                                                             (+ -1 (car (first rev-dag)))
                                                           -1)
                                                         (get-dag-len rewrite-stobj2) renumbering-stobj)
                         (renumbering-stobjp renumbering-stobj)
                         (consp rev-dag) ; note this
                         )
                    (mv-let (erp new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts tries limits node-replacement-array new-renumbering-stobj)
                      (,simplify-dag-nodes-name rev-dag
                                              rewrite-stobj2 ,@maybe-state
                                              maybe-internal-context-array
                                              memoization hit-counts tries limits
                                              node-replacement-array node-replacement-count refined-assumption-alist
                                              rewrite-stobj
                                              renumbering-stobj)
                      (declare (ignore new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts tries limits node-replacement-array ,@maybe-new-state))
                      (implies (and (not erp)
                                    (natp bound)
                                    (<= bound (car (car (last rev-dag)))))
                               (good-renumbering-stobjp bound new-renumbering-stobj))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-nodes-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-nodes-name '-return-type)))))

         ;; A simple consequence of the return type theorem
         (defthm ,(pack$ simplify-dag-nodes-name '-return-type-corollary3)
           (implies (and (weak-dagp-aux rev-dag)
                         (cars-increasing-by-1 rev-dag)
                         (if (consp rev-dag)
                             (<= (car (car (last rev-dag))) *max-1d-array-length*)
                           t)
                         (wf-rewrite-stobj2p rewrite-stobj2)
                         (if (consp rev-dag)
                             (or (null maybe-internal-context-array)
                                 (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car (last rev-dag)))) (get-dag-len rewrite-stobj2)))
                           t)
                         (maybe-bounded-memoizationp memoization (get-dag-len rewrite-stobj2))
                         (hit-countsp hit-counts)
                         (triesp tries)
                         (rule-limitsp limits)
                         (bounded-node-replacement-arrayp 'node-replacement-array node-replacement-array (get-dag-len rewrite-stobj2))
                         (natp node-replacement-count)
                         (<= node-replacement-count (alen1 'node-replacement-array node-replacement-array))
                         (rewrite-stobjp rewrite-stobj)
                         (rewrite-stobj2p rewrite-stobj2)
                         (bounded-refined-assumption-alistp refined-assumption-alist (get-dag-len rewrite-stobj2))
                         (if (consp rev-dag)
                             (equal (renumbering-length renumbering-stobj)
                                    (+ 1 (car (car (last rev-dag))))) ; the highest nodenum
                           t)
                         (bounded-good-renumbering-stobjp (if (consp rev-dag)
                                                             (+ -1 (car (first rev-dag)))
                                                           -1)
                                                         (get-dag-len rewrite-stobj2) renumbering-stobj)
                         (renumbering-stobjp renumbering-stobj)
                         (consp rev-dag) ; note this
                         )
                    (mv-let (erp new-rewrite-stobj2 ,@maybe-new-state new-memoization new-hit-counts tries limits node-replacement-array new-renumbering-stobj)
                      (,simplify-dag-nodes-name rev-dag
                                                rewrite-stobj2 ,@maybe-state
                                                maybe-internal-context-array memoization hit-counts tries limits
                                                node-replacement-array node-replacement-count refined-assumption-alist
                                                rewrite-stobj
                                                renumbering-stobj)
                      (declare (ignore new-memoization new-hit-counts tries limits node-replacement-array ,@maybe-new-state))
                      (implies (and (not erp)
                                    (natp bound)
                                    (<= bound (car (car (last rev-dag))))
                                    (<= (get-dag-len new-rewrite-stobj2) bound2)
                                    (natp bound2)
                                    )
                               (bounded-good-renumbering-stobjp bound bound2 new-renumbering-stobj))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-nodes-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-nodes-name '-return-type)))))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; Returns (mv erp dag-or-quotep limits ,@maybe-state).
         ;; This optionally takes an internal-context-array, but if one is given, memoizep can't be non-nil.
         ;; TODO: Perhaps return hit-counts or tries, to be summed across invocations.
         ;; TODO: Add support for assumptions that come in array form?
         (defund ,simplify-dag-core-name (dag
                                          assumptions
                                          ;; may be pre-loaded with all original nodes, for use with contexts:
                                          dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist
                                          maybe-internal-context-array ; if non-nil the dag-array agrees with the dag, for all nodes in the dag
                                          rule-alist
                                          interpreted-function-alist
                                          known-booleans
                                          normalize-xors
                                          limits
                                          memoizep
                                          count-hits
                                          print
                                          monitored-symbols
                                          fns-to-elide
                                          ,@maybe-state)
           (declare (xargs :guard (and (pseudo-dagp dag)
                                       (< (top-nodenum dag) *max-1d-array-length*)
                                       (pseudo-term-listp assumptions)
                                       (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                                       (or (null maybe-internal-context-array)
                                           (bounded-context-arrayp 'context-array maybe-internal-context-array dag-len dag-len))
                                       (rule-alistp rule-alist)
                                       (interpreted-function-alistp interpreted-function-alist)
                                       (symbol-listp known-booleans)
                                       (normalize-xors-optionp normalize-xors)
                                       (rule-limitsp limits)
                                       (booleanp memoizep)
                                       (not (and memoizep
                                                 (not (null maybe-internal-context-array))))
                                       (count-hits-argp count-hits)
                                       (print-levelp print)
                                       (symbol-listp monitored-symbols)
                                       (symbol-listp fns-to-elide)
                                       ;; Justifies how we use the context info (old nodes and new nodes agree):
                                       (if maybe-internal-context-array
                                           (and (<= (len dag) dag-len)
                                                (dag-and-array-agreep dag 'dag-array dag-array dag-len))
                                         t))
                           ,@maybe-stobjs
                           :guard-hints (("Goal" :do-not '(generalize eliminate-destructors)
                                          :in-theory (e/d (not-<-of-0-when-natp-disabled
                                                           acl2-numberp-when-natp
                                                           natp-of-+-of--1-when-natp-disabled
                                                           ;; natp-when-dargp ; too strong?
                                                           <-of-+-of-1-when-integers
                                                           natp-of-+-of-1
                                                           integerp-of-renumberingi
                                                           natp-of-renumberingi
                                                           len-when-pseudo-dagp
                                                           car-of-nth-when-pseudo-dagp
                                                           ;;wf-rewrite-stobj2p
                                                           )
                                                          (natp ;wf-rewrite-stobj2p-conjuncts
                                                           ))))))
           (b* (;; The guard excludes the error here, but this is critical to soundness, so we check it
                ;; in case this function is called from non-guard-verified code:
                ((when (and memoizep
                            (not (null maybe-internal-context-array))))
                 (er hard? ',simplify-dag-core-name "It is unsound to memoize when using internal contexts.")
                 (mv :unsound nil limits ,@maybe-state))
                ;; Fix some values, so we don't need assumptions about them in later theorems (should have no runtime cost):
                (monitored-symbols (if (mbt (symbol-listp monitored-symbols)) monitored-symbols nil))
                (fns-to-elide (if (mbt (symbol-listp fns-to-elide)) fns-to-elide nil))
                (known-booleans (if (mbt (symbol-listp known-booleans)) known-booleans nil))
                (normalize-xors (if (mbt (normalize-xors-optionp normalize-xors)) normalize-xors nil))
                (print (if (mbt (print-levelp print)) print nil))
                ;;
                (old-top-nodenum (top-nodenum dag))
                (old-len (+ 1 old-top-nodenum))
                ;; Create the refined-assumption-alist and add relevant nodes to the DAG:
                ((mv erp refined-assumption-alist dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
                 ;; TODO: Make a version specialized to these array names:
                 (refine-assumptions-and-add-to-dag-array assumptions
                                                          'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist
                                                          known-booleans))
                ((when erp) (mv erp nil limits ,@maybe-state))
                ;; Create the node-replacement-array and add relevant nodes to the DAG:
                ;; TODO: Consider combining this with the above, in a single pass through the assumptions:
                ((mv erp node-replacement-array node-replacement-count dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
                 (make-node-replacement-array-and-extend-dag assumptions
                                                             dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist
                                                             known-booleans))
                ((when erp) (mv erp nil limits ,@maybe-state))
                ,@(and smtp '(;; Form the negated-assumptions for STP:
                              ;; todo: combine with the above assumption-processing steps, but note that this is conditional on smtp:
                              ((mv erp negated-assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
                               (negate-assumptions-and-add-to-dag-array (keep-smt-assumptions assumptions)
                                                                        dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist nil))
                              ((when erp) (mv erp nil limits state)))))
             (with-local-stobjs
               (renumbering-stobj rewrite-stobj rewrite-stobj2)
               (mv-let (erp new-top-nodenum-or-quotep dag-array
                            ;; dag-len
                            ;; dag-parent-array dag-constant-alist dag-variable-alist
                            memoization hit-counts tries limits
                            renumbering-stobj rewrite-stobj rewrite-stobj2 ,@maybe-state)
                 (b* (;; Initialize rewrite-stobj:
                      (rewrite-stobj (put-monitored-symbols monitored-symbols rewrite-stobj))
                      (rewrite-stobj (put-fns-to-elide fns-to-elide rewrite-stobj))
                      (rewrite-stobj (put-known-booleans known-booleans rewrite-stobj))
                      (rewrite-stobj (put-normalize-xors normalize-xors rewrite-stobj))
                      (rewrite-stobj (put-interpreted-function-alist interpreted-function-alist rewrite-stobj))
                      (rewrite-stobj (load-rule-db rule-alist rewrite-stobj)) ; todo: initialize the hash table directly from stored-rules?
                      (rewrite-stobj (put-print print rewrite-stobj))
                      ;; Initialize rewrite-stobj2 (for now, this just writes to these 5 stobj fields):
                      (rewrite-stobj2 (load-dag dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist rewrite-stobj2))
                      (rewrite-stobj2 (if (eq :compact (get-normalize-xors rewrite-stobj))
                                          (set-xor-signature-fields 0 rewrite-stobj2)
                                        rewrite-stobj2))
                      ,@(and smtp '((rewrite-stobj2 (put-negated-assumptions negated-assumptions rewrite-stobj2))))
                      (renumbering-stobj (resize-renumbering old-len renumbering-stobj))
                      ;; Decide whether to count and print tries:
                      (tries (if (print-level-at-least-verbosep print) (zero-tries) nil)) ; nil means not counting tries
                      ((mv erp rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits
                           & ; node-replacement-array
                           renumbering-stobj)
                       (,simplify-dag-nodes-name (reverse-list dag) ;;we'll simplify nodes from the bottom-up
                                                 rewrite-stobj2 ,@maybe-state
                                                 maybe-internal-context-array
                                                 (and memoizep (empty-memoization)) ; todo: add an option to make this bigger?
                                                 (initialize-hit-counts count-hits)
                                                 tries
                                                 limits
                                                 node-replacement-array node-replacement-count refined-assumption-alist
                                                 rewrite-stobj
                                                 renumbering-stobj))
                      ((when erp) (mv erp nil dag-array ;; dag-len dag-parent-array dag-constant-alist dag-variable-alist
                                      memoization hit-counts tries limits
                                      ;;node-replacement-array
                                      renumbering-stobj rewrite-stobj rewrite-stobj2 ,@maybe-state))
                      ;; See what the top node of the old dag became (after this point, we won't have access to renumbering-stobj anymore, due to with-local-stobj):
                      (new-top-nodenum-or-quotep (renumberingi old-top-nodenum renumbering-stobj)))
                   (mv (erp-nil) new-top-nodenum-or-quotep
                       (get-dag-array rewrite-stobj2) ;; (get-dag-len rewrite-stobj2) (get-dag-parent-array rewrite-stobj2) (get-dag-constant-alist rewrite-stobj2) (get-dag-variable-alist rewrite-stobj2)
                       memoization hit-counts tries limits
                       renumbering-stobj rewrite-stobj rewrite-stobj2 ,@maybe-state))
                 ;; Cannot refer to the stobjs after this point:
                 ;; (declare (ignore dag-len dag-parent-array dag-constant-alist dag-variable-alist node-replacement-array)) ; print some stats from these?
                 (b* (((when erp) (mv erp nil limits ,@maybe-state))
                      ;; todo: do we support both brief hit counting (just the total) and totals per-rule?:
                      (- (maybe-print-hit-counts hit-counts))
                      (- (and tries (cw "~%Total rule tries: ~x0.~%" tries))) ;print these after dropping non supps?
                      (- (and (print-level-at-least-tp print) memoization (print-memo-stats memoization)))
                      ;; todo: print the new len?
                      )
                   (if (quotep new-top-nodenum-or-quotep)
                       (mv (erp-nil) new-top-nodenum-or-quotep limits ,@maybe-state)
                     (mv (erp-nil)
                         (drop-non-supporters-array-with-name 'dag-array dag-array new-top-nodenum-or-quotep nil)
                         limits ,@maybe-state)))))))

         (defthm ,(pack$ simplify-dag-core-name '-return-type)
           (implies (and (pseudo-dagp dag)
                         (< (top-nodenum dag) *max-1d-array-length*)
                         (pseudo-term-listp assumptions)
                         (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                         (or (null maybe-internal-context-array)
                             (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car dag))) dag-len))
                         (rule-limitsp limits)
                         (rule-alistp rule-alist)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (mv-let (erp dag-or-quotep new-limits ,@maybe-new-state)
                      ,call-of-simplify-dag-core
                      (implies (not erp)
                               (and (or (myquotep dag-or-quotep)
                                        (and (pseudo-dagp dag-or-quotep)
                                             (<= (len dag-or-quotep)
                                                 *max-1d-array-length*)))
                                    (rule-limitsp new-limits)
                                    ,@maybe-w-unchanged))))
           :hints (("Goal" :do-not '(generalize eliminate-destructors)
                    :in-theory (e/d (,simplify-dag-core-name
                                     natp-of-renumberingi
                                     integerp-of-renumberingi
                                     <-of-+-of-1-when-integers
                                     len-when-pseudo-dagp
                                     car-of-nth-when-pseudo-dagp
                                     wf-rewrite-stobj2p)
                                    (myquotep natp wf-rewrite-stobj2p-conjuncts)))))

         ;; a rephrasing of one conjunct
         (defthm ,(pack$ simplify-dag-core-name '-return-type-corollary)
           (implies (and (pseudo-dagp dag)
                         (< (top-nodenum dag) *max-1d-array-length*)
                         (pseudo-term-listp assumptions)
                         (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                         (or (null maybe-internal-context-array)
                             (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car dag))) dag-len))
                         (rule-limitsp limits)
                         (rule-alistp rule-alist)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (mv-let (erp dag-or-quotep new-limits ,@maybe-new-state)
                      ,call-of-simplify-dag-core
                      (declare (ignore new-limits ,@maybe-new-state))
                      (implies (and (not erp)
                                    (not (myquotep dag-or-quotep)))
                               (and (pseudo-dagp dag-or-quotep)
                                    (<= (len dag-or-quotep)
                                        *max-1d-array-length*)))))
           :hints (("Goal" :use ,(pack$ simplify-dag-core-name '-return-type)
                    :in-theory (disable ,(pack$ simplify-dag-core-name '-return-type)))))

         ;; rephrase to match the others?
         (defthm ,(pack$ simplify-dag-core-name '-return-type-corollary-linear)
           (implies (and (not (myquotep (mv-nth 1 ,call-of-simplify-dag-core)))
                         (not (mv-nth 0 ,call-of-simplify-dag-core)) ; no error
                         (pseudo-dagp dag)
                         (< (top-nodenum dag) *max-1d-array-length*)
                         (pseudo-term-listp assumptions)
                         (wf-dagp 'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist)
                         (or (null maybe-internal-context-array)
                             (bounded-context-arrayp 'context-array maybe-internal-context-array (+ 1 (car (car dag))) dag-len))
                         (rule-limitsp limits)
                         (rule-alistp rule-alist)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (and (not (< '1152921504606846973 (caar (mv-nth 1 ,call-of-simplify-dag-core))))
                         (<= 0 (caar (mv-nth 1 ,call-of-simplify-dag-core)))))
           :rule-classes :linear
           :hints (("Goal" :use ,(pack$ simplify-dag-core-name '-return-type)
                    :in-theory (e/d (car-of-car-when-pseudo-dagp-cheap) (,(pack$ simplify-dag-core-name '-return-type))))))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; Returns (mv erp dag-or-quotep limits ,@maybe-state).
         ;; TODO: Make a version that returns an array (call crunch-dag instead of drop-non-supporters-array-with-name)?
         ;; Only the first 5 arguments affect soundness.
         (defund ,simplify-dag-name (dag
                                     assumptions
                                     rule-alist
                                     interpreted-function-alist
                                     known-booleans
                                     normalize-xors ; next few args do affect the result
                                     limits
                                     memoizep
                                     count-hits
                                     print
                                     monitored-symbols
                                     fns-to-elide
                                     ;; todo: add context array and other args?
                                     ,@maybe-state)
           (declare (xargs :guard (and (pseudo-dagp dag)
                                       (pseudo-term-listp assumptions)
                                       (rule-alistp rule-alist)
                                       (interpreted-function-alistp interpreted-function-alist)
                                       (symbol-listp known-booleans)
                                       (normalize-xors-optionp normalize-xors)
                                       (rule-limitsp limits)
                                       (booleanp memoizep)
                                       (count-hits-argp count-hits)
                                       (print-levelp print)
                                       (symbol-listp monitored-symbols)
                                       (symbol-listp fns-to-elide))
                           ,@maybe-stobjs
                           :guard-hints (("Goal" ; :do-not '(generalize eliminate-destructors)
                                          :in-theory (e/d (len-when-pseudo-dagp
                                                           car-of-nth-when-pseudo-dagp
                                                           natp-of-+-of-1
                                                           natp-of-car-of-car-when-pseudo-dagp
                                                           integerp-when-natp
                                                           acl2-numberp-when-natp
                                                           rationalp-when-natp
                                                           true-listp-when-pseudo-dagp
                                                           alistp-when-pseudo-dagp
                                                           consp-when-pseudo-dagp
                                                           top-nodenum ; expose car of car
                                                           )
                                                          (natp))))))
           (b* ((top-nodenum (top-nodenum dag))
                ((when (not (< top-nodenum *max-1d-array-length*)))
                 (mv :dag-too-big nil limits ,@maybe-state))
                ;; If we are to memoize, start with a rewrite that memoizes but does not use internal contexts (for soundness):
                ;; This step (with memoization) may be critical to performance.  This steps may return a reduced LIMITS value.
                ((mv erp dag-or-quotep limits ,@maybe-state)
                 (if (not memoizep)
                     (mv (erp-nil) dag limits ,@maybe-state)
                   (b* ((dag-len (+ 1 top-nodenum))
                        (- (and print (cw "(Simplifying DAG with memoization and no internal contexts (~x0 nodes, ~x1 assumptions):~%" dag-len (len assumptions))))
                        (initial-array-size (min *max-1d-array-length* (* 2 dag-len))) ; could make this adjustable
                        ((mv dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
                         (empty-dag-array initial-array-size))
                        ((mv erp dag-or-quotep limits ,@maybe-state)
                         (,simplify-dag-core-name dag assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist
                                                  nil ; no internal-context-array (but see below)
                                                  rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state))
                        ((when erp) (mv erp nil limits ,@maybe-state))
                        (- (and print (cw ")~%"))) ; balances "(Simplifying DAG with memoization ..."
                        )
                     (mv (erp-nil) dag-or-quotep limits ,@maybe-state))))
                ((when erp) (mv erp nil limits ,@maybe-state))
                ((when (myquotep dag-or-quotep)) (mv (erp-nil) dag-or-quotep limits ,@maybe-state))
                (dag dag-or-quotep) ; it was not a quotep, so we rename it
                )
             ;; Continue (usually) with a pass that does use contexts (and does not memoize):
             (if (and memoizep ; means we already simplified above
                      (not (dag-has-internal-contextsp dag)) ; no context info to use
                      )
                 (mv (erp-nil) dag limits ,@maybe-state)
               (b* ((top-nodenum (top-nodenum dag))
                    (dag-len (+ 1 top-nodenum))
                    (- (and print (cw "(Simplifying DAG with internal contexts and no memoization (~x0 nodes, ~x1 assumptions):~%" dag-len (len assumptions))))
                    (initial-array-size (min *max-1d-array-length* (* 2 dag-len))) ; could make this adjustable
                    ;; Start with an array with all the nodes loaded (since we are using contexts):
                    ;; TODO: Opt: Combine these steps?:
                    (dag-array (make-into-array-with-len 'dag-array dag initial-array-size))
                    ;; Make the auxiliary data structures for the DAG:
                    ((mv dag-parent-array dag-constant-alist dag-variable-alist)
                     (make-dag-indices 'dag-array dag-array 'dag-parent-array dag-len))
                    (internal-context-array (make-full-context-array-with-parents 'dag-array dag-array dag-len dag-parent-array))
                    ;; Do the rewriting:
                    ((mv erp dag-or-quotep limits ,@maybe-state)
                     (,simplify-dag-core-name dag assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist internal-context-array rule-alist interpreted-function-alist known-booleans normalize-xors limits
                                              nil ;memoizep (would be unsound)
                                              count-hits print monitored-symbols fns-to-elide ,@maybe-state))
                    ((when erp) (mv erp nil limits ,@maybe-state))
                    (- (and print (cw ")~%"))) ; balances "(Simplifying DAG with internal contexts ..."
                    )
                 (mv (erp-nil) dag-or-quotep limits ,@maybe-state)))))

         (defthm ,(pack$ simplify-dag-name '-return-type)
           (implies (and (pseudo-dagp dag)
                         (pseudo-term-listp assumptions)
                         (rule-limitsp limits)
                         (rule-alistp rule-alist)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (mv-let (erp dag-or-quotep new-limits ,@maybe-new-state)
                      ,call-of-simplify-dag
                      (implies (not erp)
                               (and (or (myquotep dag-or-quotep)
                                        (and (pseudo-dagp dag-or-quotep)
                                             (<= (len dag-or-quotep) *max-1d-array-length*) ;; todo
                                             ))
                                    (rule-limitsp new-limits)
                                    ,@maybe-w-unchanged))))
           :hints (("Goal" :do-not '(generalize eliminate-destructors)
                    :in-theory (e/d (,simplify-dag-name
                                     len-when-pseudo-dagp
                                     car-of-nth-when-pseudo-dagp
                                     natp-of-+-of-1
                                     natp-of-car-of-car-when-pseudo-dagp
                                     integerp-when-natp
                                     acl2-numberp-when-natp
                                     rationalp-when-natp
                                     true-listp-when-pseudo-dagp
                                     alistp-when-pseudo-dagp
                                     consp-when-pseudo-dagp
                                     top-nodenum ; expose car of car
                                     )
                                    (myquotep natp)))))

         (defthm ,(pack$ simplify-dag-name '-return-type-corollary)
           (implies (and (pseudo-dagp dag)
                         (pseudo-term-listp assumptions)
                         (rule-limitsp limits)
                         (rule-alistp rule-alist)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (mv-let (erp dag-or-quotep new-limits ,@maybe-new-state)
                      ,call-of-simplify-dag
                      (declare (ignore new-limits ,@maybe-new-state))
                      (implies (and (not erp)
                                    (not (myquotep dag-or-quotep)) ; got a dag
                                    )
                               (and (pseudo-dagp dag-or-quotep)
                                    (<= (len dag-or-quotep) *max-1d-array-length*) ;; todo
                                    ))))
           :hints (("Goal" :do-not '(generalize eliminate-destructors)
                    :in-theory (e/d (,simplify-dag-name
                                     len-when-pseudo-dagp
                                     car-of-nth-when-pseudo-dagp
                                     natp-of-+-of-1
                                     natp-of-car-of-car-when-pseudo-dagp
                                     integerp-when-natp
                                     acl2-numberp-when-natp
                                     rationalp-when-natp
                                     true-listp-when-pseudo-dagp
                                     alistp-when-pseudo-dagp
                                     consp-when-pseudo-dagp
                                     top-nodenum ; expose car of car
                                     )
                                    (myquotep natp)))))

         ;;rephrase to match the above
         (defthm ,(pack$ simplify-dag-name '-return-type-linear)
           (implies (and (not (myquotep (mv-nth 1 ,call-of-simplify-dag)))
                         (not (mv-nth 0 ,call-of-simplify-dag)) ; no error
                         (pseudo-dagp dag)
                         (pseudo-term-listp assumptions)
                         (rule-limitsp limits)
                         (rule-alistp rule-alist)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (<= (len (mv-nth 1 ,call-of-simplify-dag)) *max-1d-array-length*))
           :rule-classes :linear
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-name '-return-type)))))

         ;; ;; It's a consp either way
         ;; (defthm ,(pack$ simplify-dag-name '-return-type-corollary-1)
         ;;   (implies (and (not (mv-nth 0 ,call-of-simplify-dag)) ; no error
         ;;                 (pseudo-dagp dag)
         ;;                 (< (top-nodenum dag) *max-1d-array-length*)
         ;;                 (pseudo-term-listp assumptions)
         ;;                 (rule-limitsp limits)
         ;;                 (rule-alistp rule-alist)
         ;;                 (count-hits-argp count-hits)
         ;;                 ;; (print-levelp print)
         ;;                 (interpreted-function-alistp interpreted-function-alist)
         ;;                 ;; (symbol-listp known-booleans)
         ;;                 ;; (symbol-listp monitored-symbols)
         ;;                 ;; (normalize-xors-optionp normalize-xors)
         ;;                 (booleanp memoizep))
         ;;            (consp (mv-nth 1 ,call-of-simplify-dag))
         ;;                   )
         ;;   :hints (("Goal" :use (:instance ,(pack$ simplify-dag-name '-return-type))
         ;;            :in-theory (disable ,(pack$ simplify-dag-name '-return-type)))))

         ;; Uses myquotep as the normal form.
         (defthm ,(pack$ simplify-dag-name '-return-type-corollary-2)
           (implies (and (not (mv-nth 0 ,call-of-simplify-dag)) ; no error
                         (pseudo-dagp dag)
                         (pseudo-term-listp assumptions)
                         (rule-limitsp limits)
                         (rule-alistp rule-alist)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (equal (quotep (mv-nth 1 ,call-of-simplify-dag))
                           (myquotep (mv-nth 1 ,call-of-simplify-dag))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-name '-return-type)
                                        ,(pack$ simplify-dag-name '-return-type-corollary)))))

         ;; Uses myquotep as the normal form.
         (defthm ,(pack$ simplify-dag-name '-return-type-corollary-3)
           (implies (and (not (mv-nth 0 ,call-of-simplify-dag)) ; no error
                         (pseudo-dagp dag)
                         (pseudo-term-listp assumptions)
                         (rule-limitsp limits)
                         (rule-alistp rule-alist)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (equal (pseudo-dagp (mv-nth 1 ,call-of-simplify-dag))
                           (not (myquotep (mv-nth 1 ,call-of-simplify-dag)))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-dag-name '-return-type))
                    :in-theory (disable ,(pack$ simplify-dag-name '-return-type)))))


         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; Returns (mv erp dag-or-quotep limits ,@maybe-state).
         ;; TODO: Make a version that returns an array (call crunch-dag instead of drop-non-supporters-array-with-name)?
         ;; Only the first 5 arguments affect soundness.
         (defund ,simplify-dag-with-rule-alists-name (dag
                                                      assumptions
                                                      rule-alists
                                                      interpreted-function-alist
                                                      known-booleans
                                                      normalize-xors ; next few args do affect the result
                                                      limits
                                                      memoizep
                                                      count-hits
                                                      print
                                                      monitored-symbols
                                                      fns-to-elide
                                                      ,@maybe-state)
           (declare (xargs :guard (and (pseudo-dagp dag)
                                       (pseudo-term-listp assumptions)
                                       (rule-alistsp rule-alists)
                                       (interpreted-function-alistp interpreted-function-alist)
                                       (symbol-listp known-booleans)
                                       (normalize-xors-optionp normalize-xors)
                                       (rule-limitsp limits)
                                       (booleanp memoizep)
                                       (count-hits-argp count-hits)
                                       (print-levelp print)
                                       (symbol-listp monitored-symbols)
                                       (symbol-listp fns-to-elide))
                           ,@maybe-stobjs
                           :measure (len rule-alists)))
           (if (endp rule-alists)
               (mv (erp-nil) dag limits ,@maybe-state)
             (b* (((mv erp dag-or-quotep limits ,@maybe-state)
                   (,simplify-dag-name dag assumptions (first rule-alists) interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state))
                  ((when erp) (mv erp dag limits ,@maybe-state))
                  ((when (quotep dag-or-quotep))
                   (mv (erp-nil) dag-or-quotep limits ,@maybe-state))
                  (dag dag-or-quotep) ; it's not a quotep
                  )
               (,simplify-dag-with-rule-alists-name dag assumptions (rest rule-alists) interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state))))

         (defthm ,(pack$ simplify-dag-with-rule-alists-name '-return-type)
           (implies (and (pseudo-dagp dag)
                         (pseudo-term-listp assumptions)
                         (rule-limitsp limits)
                         (rule-alistsp rule-alists)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (mv-let (erp dag-or-quotep new-limits ,@maybe-new-state)
                      ,call-of-simplify-dag-with-rule-alists
                      (implies (not erp)
                               (and (or (myquotep dag-or-quotep)
                                        (and (pseudo-dagp dag-or-quotep)
                                             ;; (<= (len (mv-nth 1 ,call-of-simplify-dag-with-rule-alists))
                                             ;;     *max-1d-array-length*)
                                             ;; todo
                                             ))
                                    (rule-limitsp new-limits)
                                    ,@maybe-w-unchanged))))
           :hints (("Goal" :do-not '(generalize eliminate-destructors)
                    :in-theory (e/d (,simplify-dag-with-rule-alists-name)
                                    (myquotep quotep)))))

         ;; trying without this (since rule-alists might be nil and we just return the dag)
         ;; (defthm ,(pack$ simplify-dag-with-rule-alists-name '-return-type1-linear)
         ;;   (implies (and (not (myquotep (mv-nth 1 ,call-of-simplify-dag-with-rule-alists))) ; we got a dag
         ;;                 (not (mv-nth 0 ,call-of-simplify-dag-with-rule-alists)) ; no error
         ;;                 (pseudo-dagp dag)
         ;;                 (pseudo-term-listp assumptions)
         ;;                 (rule-limitsp limits)
         ;;                 (rule-alistsp rule-alists)
         ;;                 ;; (count-hits-argp count-hits)
         ;;                 ;; (print-levelp print)
         ;;                 (interpreted-function-alistp interpreted-function-alist)
         ;;                 ;; (symbol-listp known-booleans)
         ;;                 ;; (symbol-listp monitored-symbols)
         ;;                 ;; (symbol-listp fns-to-elide)
         ;;                 ;; (normalize-xors-optionp normalize-xors)
         ;;                 ;; (booleanp memoizep)
         ;;                 )
         ;;            (<= (len (mv-nth 1 ,call-of-simplify-dag-with-rule-alists))
         ;;                *max-1d-array-length*))
         ;;   :rule-classes :linear
         ;;   :hints (("Goal" :do-not '(generalize eliminate-destructors)
         ;;            :in-theory (e/d (,simplify-dag-with-rule-alists-name)
         ;;                            (myquotep natp)))))

         ;; Uses myquotep as the normal form.   todo: would quotep or even fquotep be better?
         (defthm ,(pack$ simplify-dag-with-rule-alists-name '-return-type-corollary-1)
           (implies (and (not (mv-nth 0 ,call-of-simplify-dag-with-rule-alists)) ; no error
                         (pseudo-dagp dag)
                         (pseudo-term-listp assumptions)
                         (rule-limitsp limits)
                         (rule-alistsp rule-alists)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (equal (pseudo-dagp (mv-nth 1 ,call-of-simplify-dag-with-rule-alists))
                           (not (myquotep (mv-nth 1 ,call-of-simplify-dag-with-rule-alists)))))
           :hints (("Goal" :use ,(pack$ simplify-dag-with-rule-alists-name '-return-type)
                    :in-theory (disable ,(pack$ simplify-dag-with-rule-alists-name '-return-type)))))

         ;; Uses myquotep as the normal form.
         (defthm ,(pack$ simplify-dag-with-rule-alists-name '-return-type-corollary-2)
           (implies (and (not (mv-nth 0 ,call-of-simplify-dag-with-rule-alists)) ; no error
                         (pseudo-dagp dag)
                         (pseudo-term-listp assumptions)
                         (rule-limitsp limits)
                         (rule-alistsp rule-alists)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp known-booleans)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (booleanp memoizep)
                         )
                    (equal (quotep (mv-nth 1 ,call-of-simplify-dag-with-rule-alists))
                           (myquotep (mv-nth 1 ,call-of-simplify-dag-with-rule-alists))))
           :hints (("Goal" :use ,(pack$ simplify-dag-with-rule-alists-name '-return-type)
                    :in-theory (disable ,(pack$ simplify-dag-with-rule-alists-name '-return-type)
                                         ,(pack$ simplify-dag-with-rule-alists-name '-return-type-corollary-1)))))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; Simplify a term and return an equivalent DAG.  Returns (mv erp dag-or-quotep ,@maybe-state).
         ;; TODO: add support for multiple rule-alists.
         ;; TODO: Factor out the core of this, which returns a dag-array and its various auxiliary indices.
         ;; TODO: Consider what to do in the memoizep case.  Consider making two
         ;; passes when memoizing (one with memo and no contextual info, then
         ;; one without memo but with contextual info), like we do for
         ;; simplify-dag.  The second pass would be on a DAG.
         (defund ,simplify-term-name (term
                                      assumptions
                                      rule-alist
                                      interpreted-function-alist
                                      known-booleans
                                      normalize-xors ; next few args do affect the result
                                      limits
                                      memoizep
                                      count-hits
                                      print
                                      monitored-symbols
                                      fns-to-elide
                                      ;; todo: add context array and other args?
                                      ,@maybe-state)
           (declare (xargs :guard (and (pseudo-termp term)
                                       (pseudo-term-listp assumptions)
                                       (rule-alistp rule-alist)
                                       (interpreted-function-alistp interpreted-function-alist)
                                       (symbol-listp known-booleans)
                                       (normalize-xors-optionp normalize-xors)
                                       (rule-limitsp limits)
                                       (booleanp memoizep)
                                       (count-hits-argp count-hits)
                                       (print-levelp print)
                                       (symbol-listp monitored-symbols)
                                       (symbol-listp fns-to-elide))
                           ,@maybe-stobjs
                           :guard-hints (("Goal" :in-theory (e/d (natp-when-dargp
                                                                  natp-of-+-of-1
                                                                  <-of-+-of-1-when-integers
                                                                  <-OF-+-OF-1-WHEN-natps
                                                                  ;; integerp-when-dargp ;caused problems when natp is known
                                                                  axe-treep-when-pseudo-termp
                                                                  dargp-when-natp
                                                                  <-of-if-arg2-axe
                                                                  wf-rewrite-stobj2p)
                                                                 (natp
                                                                  NATP-WHEN-DARGP ;caused problems when natp is known
                                                                  wf-rewrite-stobj2p-conjuncts))))))
           (b* (;; Fix some values, so we don't need assumptions about them in later theorems (should have no runtime cost):
                (monitored-symbols (if (mbt (symbol-listp monitored-symbols)) monitored-symbols nil))
                (fns-to-elide (if (mbt (symbol-listp fns-to-elide)) fns-to-elide nil))
                (known-booleans (if (mbt (symbol-listp known-booleans)) known-booleans nil))
                (normalize-xors (if (mbt (normalize-xors-optionp normalize-xors)) normalize-xors nil))
                (print (if (mbt (print-levelp print)) print nil))
                ;; Create an empty dag-array:
                (slack-amount 1000000) ;todo: make this adjustable, or just reduce this?
                ((mv dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
                 (empty-dag-array slack-amount))

                ;; Create the refined-assumption-alist and add relevant nodes to the DAG:
                ((mv erp refined-assumption-alist dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
                 ;; TODO: Make a version specialized to these array names:
                 (refine-assumptions-and-add-to-dag-array assumptions
                                                          'dag-array dag-array dag-len 'dag-parent-array dag-parent-array dag-constant-alist dag-variable-alist
                                                          known-booleans))
                ((when erp) (mv erp nil ,@maybe-state))

                ;; Create the node-replacement-array and add relevant nodes to the DAG:
                ;; TODO: Consider combining this with the above, in a single pass through the assumptions:
                ((mv erp node-replacement-array node-replacement-count dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
                 (make-node-replacement-array-and-extend-dag assumptions
                                                             dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist
                                                             known-booleans))
                ((when erp) (mv erp nil ,@maybe-state))
                ,@(and smtp
                       '(;; Form the negated-assumptions for STP:
                         ;; todo: combine with the above assumption-processing steps, but note that this is conditional on smtp:
                         ((mv erp negated-assumptions dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist)
                          (negate-assumptions-and-add-to-dag-array (keep-smt-assumptions assumptions)
                                                                   dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist nil))
                         ((when erp) (mv erp nil state))))
                ;; Call the core term simplification function:
                ((mv erp new-nodenum-or-quotep
                     dag-array
                     & & & & ; dag-len dag-parent-array dag-constant-alist dag-variable-alist
                     memoization hit-counts
                     tries & & ; limits node-replacement-array
                     ,@maybe-state
                     )
                 (with-local-stobjs (rewrite-stobj rewrite-stobj2)
                                    (mv-let (erp new-nodenum-or-quotep dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist memoization hit-counts tries limits node-replacement-array rewrite-stobj rewrite-stobj2 ,@maybe-state)
                                      (let* (;; Initialize rewrite-stobj:
                                             (rewrite-stobj (put-monitored-symbols monitored-symbols rewrite-stobj))
                                             (rewrite-stobj (put-fns-to-elide fns-to-elide rewrite-stobj))
                                             (rewrite-stobj (put-known-booleans known-booleans ;skip if memoizing since we can't use contexts?
                                                                                rewrite-stobj))
                                             (rewrite-stobj (put-normalize-xors normalize-xors rewrite-stobj))
                                             (rewrite-stobj (put-interpreted-function-alist interpreted-function-alist rewrite-stobj))
                                             ;; (rewrite-stobj (put-rule-alist rule-alist rewrite-stobj))
                                             (rewrite-stobj (load-rule-db rule-alist rewrite-stobj))
                                             (rewrite-stobj (put-print print rewrite-stobj))
                                             ;; Initialize rewrite-stobj2:
                                             (rewrite-stobj2 (load-dag dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist rewrite-stobj2))
                                             ;; (rewrite-stobj2 (put-dag-array dag-array rewrite-stobj2))
                                             ;; (rewrite-stobj2 (put-dag-len dag-len rewrite-stobj2))
                                             ;; (rewrite-stobj2 (put-dag-parent-array dag-parent-array rewrite-stobj2))
                                             ;; (rewrite-stobj2 (put-dag-constant-alist dag-constant-alist rewrite-stobj2))
                                             ;; (rewrite-stobj2 (put-dag-variable-alist dag-variable-alist rewrite-stobj2))
                                             (rewrite-stobj2 (if (eq :compact (get-normalize-xors rewrite-stobj))
                                                                 (set-xor-signature-fields 0 rewrite-stobj2)
                                                               rewrite-stobj2))
                                             ,@(and smtp '((rewrite-stobj2 (put-negated-assumptions negated-assumptions rewrite-stobj2))))
                                             ;; Decide whether to count and print tries:
                                             (tries (if (print-level-at-least-verbosep print) (zero-tries) nil)))
                                        (mv-let (erp new-nodenum-or-quotep rewrite-stobj2 ,@maybe-state memoization hit-counts tries limits node-replacement-array)
                                          ;; TODO: Consider making a version of ,simplify-tree-and-add-to-dag-name that applies only to terms, not axe-trees, and calling it here.
                                          ;; TODO: Or consider handling vars separately and then dropping support for vars in ,simplify-tree-and-add-to-dag-name (and in the memoization).
                                          (,simplify-tree-and-add-to-dag-name term
                                                                              nil ;trees-equal-to-tree
                                                                              rewrite-stobj2 ,@maybe-state
                                                                              (if memoizep
                                                                                  (empty-memoization)
                                                                                ;; not memoizing:
                                                                                nil)
                                                                              (initialize-hit-counts count-hits)
                                                                              tries
                                                                              limits
                                                                              node-replacement-array node-replacement-count refined-assumption-alist
                                                                              rewrite-stobj
                                                                              1000000000 ;count
                                                                              )
                                          (mv erp new-nodenum-or-quotep
                                              (get-dag-array rewrite-stobj2) (get-dag-len rewrite-stobj2) (get-dag-parent-array rewrite-stobj2) (get-dag-constant-alist rewrite-stobj2) (get-dag-variable-alist rewrite-stobj2)
                                              memoization hit-counts tries limits node-replacement-array rewrite-stobj rewrite-stobj2 ,@maybe-state)))
                                      (mv erp new-nodenum-or-quotep dag-array dag-len dag-parent-array dag-constant-alist dag-variable-alist memoization hit-counts tries limits node-replacement-array ,@maybe-state) ; no rewriter stobjs
                                      )))
                ((when erp) (mv erp nil ,@maybe-state))
                (- (maybe-print-hit-counts hit-counts))
                (- (and tries (cw "~%Total rule tries: ~x0.~%" tries)))
                (- (and nil ;; change to t to print info on the memoization
                        memoization
                        (print-memo-stats memoization))))
             (if (consp new-nodenum-or-quotep) ;check for quotep
                 (mv (erp-nil) new-nodenum-or-quotep ,@maybe-state)
               (mv (erp-nil) (drop-non-supporters-array-with-name 'dag-array dag-array new-nodenum-or-quotep nil) ,@maybe-state))))

         (defthm ,(pack$ simplify-term-name '-return-type)
           (implies (and (pseudo-termp term)
                         (pseudo-term-listp assumptions)
                         (rule-alistp rule-alist)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (booleanp memoizep)
                         ;; (print-levelp print)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (count-hits-argp count-hits)
                         ;; (symbol-listp known-booleans)
                         (rule-limitsp limits))
                    (mv-let (erp dag-or-quotep ,@maybe-new-state)
                      ,call-of-simplify-term
                      (implies (not erp)
                               (and (or (myquotep dag-or-quotep)
                                        (and (pseudo-dagp dag-or-quotep)
                                             (<= (len dag-or-quotep) *max-1d-array-length*)))
                                    ,@maybe-w-unchanged))))
           :hints (("Goal" :in-theory (e/d (,simplify-term-name
                                            axe-treep-when-pseudo-termp
                                            natp-of-+-of-1
                                            ;;natp-of-max-key-2
                                            ;<-of-if-arg1
                                            ;;max-key-hack
                                            ;;max-key-hack-2
                                            <-OF-+-OF-1-WHEN-INTEGERS
                                            integerp-when-natp-disabled
                                            <-of-if-arg2-axe
                                            wf-rewrite-stobj2p)
                                           (natp wf-rewrite-stobj2p-conjuncts)))))

         ;; Uses myquotep as the normal form.
         ;drop?
         ;; (defthm ,(pack$ 'consp-of-cdr-of-mv-nth-1-of- simplify-term-name '-when-quotep)
         ;;   (implies (and (myquotep (mv-nth 1 ,call-of-simplify-term))
         ;;                 (not (mv-nth 0 ,call-of-simplify-term)) ; no error
         ;;                 (pseudo-termp term)
         ;;                 (pseudo-term-listp assumptions)
         ;;                 (rule-alistp rule-alist)
         ;;                 (interpreted-function-alistp interpreted-function-alist)
         ;;                 ;; (symbol-listp monitored-symbols)
         ;;                 ;; (symbol-listp fns-to-elide)
         ;;                 ;; (booleanp memoizep)
         ;;                 ;; (print-levelp print)
         ;;                 ;; (normalize-xors-optionp normalize-xors)
         ;;                 ;; (count-hits-argp count-hits)
         ;;                 ;; (symbol-listp known-booleans)
         ;;                 (rule-limitsp limits))
         ;;            (consp (cdr (mv-nth 1 ,call-of-simplify-term))))
         ;;   :hints (("Goal" :use ,(pack$ simplify-term-name '-return-type)
         ;;            :in-theory (disable ,(pack$ simplify-term-name '-return-type)))))

         ;; Uses myquotep as the normal form.
         (defthm ,(pack$ 'quotep-of-mv-nth-1-of- simplify-term-name '-when-quotep)
           (implies (and (not (mv-nth 0 ,call-of-simplify-term)) ; no error
                         (pseudo-termp term)
                         (pseudo-term-listp assumptions)
                         (rule-alistp rule-alist)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (booleanp memoizep)
                         ;; (print-levelp print)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (count-hits-argp count-hits)
                         ;; (symbol-listp known-booleans)
                         (rule-limitsp limits))
                    (equal (quotep (mv-nth 1 ,call-of-simplify-term))
                           (myquotep (mv-nth 1 ,call-of-simplify-term))))
           :hints (("Goal" :use ,(pack$ simplify-term-name '-return-type)
                    :in-theory (disable ,(pack$ simplify-term-name '-return-type)))))

         ;; Uses myquotep as the normal form.
         (defthm ,(pack$ 'pseudo-dagp-of-mv-nth-1-of- simplify-term-name)
           (implies (and (not (myquotep (mv-nth 1 ,call-of-simplify-term))) ;not a constant
                         (not (mv-nth 0 ,call-of-simplify-term)) ; no error
                         (pseudo-termp term)
                         (pseudo-term-listp assumptions)
                         (rule-alistp rule-alist)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (booleanp memoizep)
                         ;; (print-levelp print)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (count-hits-argp count-hits)
                         ;; (symbol-listp known-booleans)
                         (rule-limitsp limits))
                    (and (pseudo-dagp (mv-nth 1 ,call-of-simplify-term))
                         (<= (len (mv-nth 1 ,call-of-simplify-term)) *max-1d-array-length*)))
           :hints (("Goal" :use ,(pack$ simplify-term-name '-return-type)
                    :in-theory (disable ,(pack$ simplify-term-name '-return-type)))))

         ;; Uses myquotep as the normal form.
         (defthm ,(pack$ 'myquotep-of-mv-nth-1-of- simplify-term-name)
           (implies (and (not (mv-nth 0 ,call-of-simplify-term)) ; no error
                         (pseudo-termp term)
                         (pseudo-term-listp assumptions)
                         (rule-alistp rule-alist)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (booleanp memoizep)
                         ;; (print-levelp print)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (count-hits-argp count-hits)
                         ;; (symbol-listp known-booleans)
                         (rule-limitsp limits))
                    (equal (pseudo-dagp (mv-nth 1 ,call-of-simplify-term))
                           (not (myquotep (mv-nth 1 ,call-of-simplify-term)))))
           :hints (("Goal" :use ,(pack$ simplify-term-name '-return-type)
                    :in-theory (disable ,(pack$ simplify-term-name '-return-type)))))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; Simplify a term and return a term (not a DAG).  Returns (mv erp term ,@maybe-state).
         ;; WARNING: The term returned might be huge!
         (defund ,simplify-term-to-term-name (term
                                              assumptions
                                              rule-alist
                                              interpreted-function-alist
                                              known-booleans
                                              normalize-xors
                                              limits
                                              memoizep
                                              count-hits
                                              print ;; todo: add context array and other args?
                                              monitored-symbols
                                              fns-to-elide
                                              ,@maybe-state)
           (declare (xargs :guard (and (pseudo-termp term)
                                       (pseudo-term-listp assumptions)
                                       (rule-alistp rule-alist)
                                       (interpreted-function-alistp interpreted-function-alist)
                                       (symbol-listp known-booleans)
                                       (normalize-xors-optionp normalize-xors)
                                       (rule-limitsp limits)
                                       (booleanp memoizep)
                                       (count-hits-argp count-hits)
                                       (print-levelp print)
                                       (symbol-listp monitored-symbols)
                                       (symbol-listp fns-to-elide))
                           ,@maybe-stobjs))
           (b* (((mv erp dag ,@maybe-state) (,simplify-term-name term
                                                   assumptions
                                                   rule-alist
                                                   interpreted-function-alist
                                                   known-booleans normalize-xors limits memoizep
                                                   count-hits print monitored-symbols fns-to-elide ,@maybe-state))
                ((when erp) (mv erp nil ,@maybe-state)))
             (mv (erp-nil)
                 (if (quotep dag)
                     dag
                   (dag-to-term dag))
                 ,@maybe-state)))

         (defthm ,(pack$ simplify-term-to-term-name '-return-type)
           (implies (and (pseudo-termp term)
                         (pseudo-term-listp assumptions)
                         (rule-alistp rule-alist)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (booleanp memoizep)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (symbol-listp known-booleans)
                         (rule-limitsp limits))
                    (mv-let (erp term ,@maybe-new-state)
                      (,simplify-term-to-term-name term assumptions rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state)
                      (implies (not erp)
                               (and (pseudo-termp term)
                                    ,@maybe-w-unchanged))))
           :hints (("Goal" :use (:instance ,(pack$ simplify-term-name '-return-type))
                    :do-not '(generalize eliminate-destructors)
                    :do-not-induct t
                    :in-theory (e/d (,simplify-term-to-term-name) (,(pack$ 'pseudo-dagp-of-mv-nth-1-of- simplify-term-name))))))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; Simplify a list of terms, returning a list of the simplified terms (not
         ;; DAGs).  Returns (mv erp new-terms ,@maybe-state), where the new-terms correspond 1-to-1
         ;; to the original TERMS.
         ;; WARNING: The terms returned might be huge!
         (defun ,simplify-terms-to-terms-name (terms
                                               assumptions
                                               rule-alist
                                               interpreted-function-alist
                                               known-booleans
                                               normalize-xors
                                               limits
                                               memoizep
                                               count-hits
                                               print
                                               monitored-symbols
                                               fns-to-elide
                                               ;; todo: add context array and other args?
                                               ,@maybe-state)
           (declare (xargs :guard (and (pseudo-term-listp terms)
                                       (pseudo-term-listp assumptions)
                                       (rule-alistp rule-alist)
                                       (interpreted-function-alistp interpreted-function-alist)
                                       (symbol-listp known-booleans)
                                       (normalize-xors-optionp normalize-xors)
                                       (rule-limitsp limits)
                                       (booleanp memoizep)
                                       (count-hits-argp count-hits)
                                       (print-levelp print)
                                       (symbol-listp monitored-symbols)
                                       (symbol-listp fns-to-elide))
                           ,@maybe-stobjs))
           (if (endp terms)
               (mv (erp-nil) nil ,@maybe-state)
             (b* (((mv erp first-res ,@maybe-state)
                   (,simplify-term-to-term-name (first terms) assumptions rule-alist interpreted-function-alist
                                                known-booleans normalize-xors limits memoizep
                                                count-hits print monitored-symbols fns-to-elide ,@maybe-state))
                  ((when erp) (mv erp nil ,@maybe-state))
                  ((mv erp rest-res ,@maybe-state)
                   (,simplify-terms-to-terms-name (rest terms) assumptions rule-alist interpreted-function-alist
                                                  known-booleans normalize-xors limits memoizep
                                                  count-hits print monitored-symbols fns-to-elide ,@maybe-state))
                  ((when erp) (mv erp nil ,@maybe-state)))
               (mv (erp-nil)
                   (cons first-res rest-res)
                   ,@maybe-state))))

         (defthm ,(pack$ simplify-terms-to-terms-name '-return-type)
           (implies (and (pseudo-term-listp terms)
                         (pseudo-term-listp assumptions)
                         (rule-alistp rule-alist)
                         (interpreted-function-alistp interpreted-function-alist)
                         ;; (symbol-listp monitored-symbols)
                         ;; (symbol-listp fns-to-elide)
                         ;; (booleanp memoizep)
                         ;; (count-hits-argp count-hits)
                         ;; (print-levelp print)
                         ;; (normalize-xors-optionp normalize-xors)
                         ;; (symbol-listp known-booleans)
                         (rule-limitsp limits))
                    (mv-let (erp new-terms ,@maybe-new-state)
                      (,simplify-terms-to-terms-name terms assumptions rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state)
                      (implies (not erp)
                               (and (pseudo-term-listp new-terms)
                                    ,@maybe-w-unchanged))))
           :hints (("Goal" :induct (,simplify-terms-to-terms-name terms assumptions rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state)
                    :in-theory (enable ,simplify-terms-to-terms-name))))

         (defthm ,(pack$ 'true-listp-of-mv-nth-1-of- simplify-terms-to-terms-name)
           (true-listp (mv-nth 1 (,simplify-terms-to-terms-name terms assumptions rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state)))
           :rule-classes :type-prescription
           :hints (("Goal" :induct (,simplify-terms-to-terms-name terms assumptions rule-alist interpreted-function-alist known-booleans normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide ,@maybe-state)
                    :in-theory (enable ,simplify-terms-to-terms-name))))

         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

         ;; Core function of def-simplified-fn-xxx.  Unlike its wrapper, this function is in :logic mode.
         ;; Returns (mv erp event ,@maybe-state).
         ;; TODO: Perhaps add an option to take a rule-alist, or a sequence of rule-alists.
         (defund ,def-simplified-fn-core-name (defconst-name ; the name of the constant to create
                                               dag-or-term
                                               assumptions
                                               rules
                                               interpreted-function-alist
                                               normalize-xors
                                               limits
                                               memoizep ; we use the name memoizep internally for the :memoize argument
                                               count-hits
                                               print
                                               monitored-symbols
                                               fns-to-elide
                                               whole-form
                                               state ; This one always takes state, even in the non-smt variant
                                               )
           (declare (xargs :guard (and (symbolp defconst-name)
                                       (or (pseudo-dagp dag-or-term)
                                           (pseudo-termp dag-or-term))
                                       (pseudo-term-listp assumptions)
                                       (symbol-listp rules)
                                       (interpreted-function-alistp interpreted-function-alist)
                                       (normalize-xors-optionp normalize-xors)
                                       (rule-limitsp limits)
                                       (booleanp memoizep)
                                       (count-hits-argp count-hits)
                                       (print-levelp print)
                                       (symbol-listp monitored-symbols)
                                       (symbol-listp fns-to-elide)
                                       (ilks-plist-worldp (w state)))
                           :stobjs state
                           :guard-hints (("Goal" :in-theory (disable w)))))
           (b* (((when (not (starts-and-ends-with-starsp defconst-name))) ; todo: stricter check?
                 (er hard? ',def-simplified-fn-core-name "The name ~x0 is not a legal constant name." defconst-name)
                 (mv :bad-name nil state))
                ((when (getpropc defconst-name 'const nil (w state))) ; todo: factor out
                 (er hard? ',def-simplified-fn-core-name "The name ~x0 is already in use as a constant." defconst-name)
                 (mv :name-in-use nil state))
                ((mv start-time state) (get-real-time state))
                (- (cw "~%(Creating ~x0:~%" defconst-name))
                (known-booleans (known-booleans (w state)))
                ((mv erp rule-alist) (make-rule-alist rules (w state)))
                ((when erp) (mv erp nil state))
                ;; Simplify the DAG or term:
                ((mv erp dag-or-quotep ,@maybe-state) ; todo: use the limits?
                 (if (pseudo-dagp dag-or-term) ; todo: cheaper test!
                     (mv-let (erp dag-or-quotep limits ,@maybe-state)
                       (,simplify-dag-name dag-or-term
                                           assumptions
                                           rule-alist
                                           interpreted-function-alist
                                           known-booleans
                                           normalize-xors
                                           limits
                                           memoizep
                                           count-hits
                                           print
                                           monitored-symbols
                                           fns-to-elide
                                           ,@maybe-state)
                       (declare (ignore limits)) ; use somehow?
                       (mv erp dag-or-quotep ,@maybe-state))
                   ;; Seems best to operate on the term, instead of converting to a DAG first, since
                   ;; rewriting the term will use full context information.
                   (,simplify-term-name dag-or-term
                                        assumptions
                                        rule-alist
                                        interpreted-function-alist
                                        known-booleans
                                        normalize-xors
                                        limits
                                        memoizep
                                        count-hits
                                        print
                                        monitored-symbols
                                        fns-to-elide
                                        ,@maybe-state)))
                ((when erp) (mv erp nil state))
                ((mv end-time state) (get-real-time state))
                ;; Print info about the DAG:
                (- (print-dag-info dag-or-quotep defconst-name nil))
                ;; (- (if (myquotep dag-or-quotep)
                ;;        nil ; skip the purity check if we have constant
                ;;      (if (dag-is-purep-aux dag-or-quotep :all t) ; prints any non-pure nodes
                ;;          (cw "~x0 is a pure dag.~%" defconst-name)
                ;;        (cw "~%WARNING: ~x0 is not a pure dag (see above)!~%" defconst-name))))
                (- (progn$ (cw "~%SIMPLIFICATION FINISHED (")
                           (print-to-hundredths (- end-time start-time))
                           (cw "s).)~%") ; s = seconds, second paren matches "(Creating ..." above
                           )))
             (mv (erp-nil)
                 `(progn (defconst ,defconst-name ',dag-or-quotep)
                    (with-output :off :all (table ,',(pack$ def-simplified-name '-table) ',whole-form ':fake))
                    (value-triple ',defconst-name) ; print the name
                    )
                 state)))

         ;; Macro helper function for ,def-simplified-name.  This does the
         ;; translation (requires :program mode), but then calls the :logic mode core
         ;; function to do most of the work.
         ;; Returns (mv erp event state).
         ;; TODO: Perhaps add an option to take a rule-alist.
         (defund ,def-simplified-fn-name (defconst-name ; the name of the constant to create
                                          dag-or-term
                                          assumptions
                                          rules
                                          interpreted-function-alist
                                          normalize-xors
                                          limits
                                          memoizep ; we use the name memoizep internally for the :memoize argument
                                          count-hits
                                          print
                                          monitored-symbols
                                          fns-to-elide
                                          whole-form
                                          state)
           (declare (xargs :guard (and (symbolp defconst-name)
                                       ;; dag-or-term is a dag or an (untranslated) term
                                       ;; assumptions are (untranslated) terms
                                       (symbol-listp rules)
                                       (interpreted-function-alistp interpreted-function-alist)
                                       (normalize-xors-optionp normalize-xors)
                                       (rule-limitsp limits)
                                       (booleanp memoizep)
                                       (count-hits-argp count-hits)
                                       (print-levelp print)
                                       (symbol-listp monitored-symbols)
                                       (symbol-listp fns-to-elide)
                                       (consp whole-form)
                                       (symbolp (car whole-form))
                                       (ilks-plist-worldp (w state)))
                           :stobjs state
                           :mode :program ; because this calls translate
                           :guard-hints (("Goal" :in-theory (disable w)))))
           (b* (((when (command-is-redundantp whole-form state)) ; will check the table named (pack$ def-simplified-name '-table)
                 (mv nil '(value-triple :invisible) state))
                ;; Translate the assumptions:
                (assumptions (translate-terms assumptions ',def-simplified-fn-name (w state)))
                ;; Translates, if a term:
                (dag-or-term
                  (if (pseudo-dagp dag-or-term)
                      dag-or-term
                    ;; it's a term, so translate it:
                    (translate-term dag-or-term ',def-simplified-fn-name (w state)))))
             (,def-simplified-fn-core-name defconst-name dag-or-term assumptions rules interpreted-function-alist normalize-xors limits memoizep count-hits print monitored-symbols fns-to-elide whole-form state)))

         ;; A utility to simplify a DAG or term and create a constant to hold the resulting DAG.
         ;; Creates a constant named DEFCONST-NAME, whose value is a DAG representing the simplified form of DAG-OR-TERM.
         ;; See also def-simplified.lisp (todo: get rid of that?).
         ;; All arguments except defconst-name are evaluated.
         (defmacro ,def-simplified-name (&whole whole-form
                                                defconst-name ;; The name of the dag to create
                                                dag-or-term
                                                &key
                                                (assumptions 'nil) ; a list of untranslated terms
                                                (rules 'nil)
                                                (interpreted-function-alist 'nil)
                                                (normalize-xors 'nil)
                                                (limits 'nil)
                                                (memoize 't) ; not memoizep, since this is user-facing
                                                (count-hits 'nil)
                                                (print ':brief)
                                                (monitor 'nil)
                                                (fns-to-elide 'nil))
           `(make-event-quiet (,',def-simplified-fn-name ',defconst-name ,dag-or-term ,assumptions ,rules ,interpreted-function-alist ,normalize-xors ,limits ,memoize ,count-hits ,print ,monitor ,fns-to-elide ',whole-form state)))
         )) ; end generated encapsulate and progn
    ))

;; Makes a version of the (simple) Axe Rewriter, given an evaluator, a syntaxp evaluator, and an axe-bind-free evaluator.
(defmacro make-rewriter-simple (suffix ; added to the end of each generated function/macro name
                                evaluator-base-name
                                syntaxp-evaluator-suffix ;as given to make-axe-syntaxp-evaluator
                                bind-free-evaluator-suffix ;as given to make-axe-bind-free-evaluator
                                &key
                                (smt 'nil))
  (make-rewriter-simple-fn suffix
                           evaluator-base-name
                           syntaxp-evaluator-suffix
                           bind-free-evaluator-suffix
                           smt))
