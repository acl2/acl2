; Copyright (C) 2025 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Grant Jurgensen (grant@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "TREESET")

(include-book "std/util/bstar" :dir :system)
(include-book "std/util/define" :dir :system)

(include-book "kestrel/utilities/shuffle-list" :dir :system)

(include-book "../set-defs")
(include-book "../in-defs")
(include-book "../cardinality-defs")
(include-book "../insert-defs")
(include-book "../to-oset-defs")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program)

(make-event (er-progn (set-check-invariant-risk nil)
                      (value '(value-triple :success))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define random-boolean
  ((prob rationalp) ;; prob = chance of t
   state)
  :guard (and (<= 0 prob)
              (<= prob 1))
  :returns (mv (bool booleanp)
               state)
  (b* (((when (= prob 0))
        (mv nil state))
       ((when (= prob 1))
        (mv t state))
       (numer (numerator prob))
       (denom (denominator prob))
       ((mv rand-val state)
        (random$ denom state)))
    (mv (< rand-val numer)
        state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO: switch from word to ufixnum

(define mk-random-nat-set-acc
  ((cardinality natp)
   (max posp)
   (acc acl2-number-setp)
   state)
  :returns (mv (tree acl2-number-setp)
               state)
  (b* (((when (int= (cardinality acc) cardinality))
        (mv acc state))
       ((mv nat state)
        (random$ max state)))
    (mk-random-nat-set-acc cardinality
                           max
                           (insert nat acc :test =)
                           state)))

(define mk-random-nat-set
  ((cardinality natp)
   (max posp)
   state)
  :returns (mv (tree acl2-number-setp)
               state)
  (mk-random-nat-set-acc cardinality max (empty) state))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define mk-random-nat-oset
  ((cardinality natp)
   (max posp)
   state)
  :returns (mv (tree acl2-number-setp)
               state)
  (b* (((mv set state)
        (mk-random-nat-set cardinality max state)))
    (mv (to-oset set)
        state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define mk-nat-list-not-in-acc
  ((length natp)
   (max posp)
   (set acl2-number-setp)
   (acc nat-listp)
   state)
  :returns (mv (list nat-listp)
               state)
  (b* (((when (int= (len acc) length))
        (mv acc state))
       ((mv nat state)
        (random$ max state)))
    (mk-nat-list-not-in-acc length
                            max
                            set
                            (if (in nat set :test =)
                                acc
                              (cons nat acc))
                            state)))

(define mk-nat-list-not-in
  ((length natp)
   (max posp)
   (set acl2-number-setp)
   state)
  :returns (mv (list nat-listp)
               state)
  (mk-nat-list-not-in-acc length max set nil state))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define set-shuffled-elements
  ((set setp)
   state)
  :returns (mv (list true-listp)
               state)
  (b* ((list (to-oset set)))
    (acl2::shuffle-list list state)))

(define get-nat-not-in
  ((max posp)
   (set acl2-number-setp)
   state)
  :returns (mv (nat natp)
               state)
  (b* (((mv nat state)
        (random$ max state)))
    (if (in nat set :test =)
        (get-nat-not-in max set state)
      (mv nat
          state))))

(define get-nat-in
  ((shuffled nat-listp))
  :guard (consp shuffled)
  :returns (mv (nat natp)
               (shuffled$ nat-listp))
  (mv (first shuffled)
      (rest shuffled)))

(define mk-nat-list-in-prob-acc
  ((count natp)
   (max posp)
   (prob rationalp)
   (set acl2-number-setp)
   (shuffled nat-listp)
   (acc nat-listp)
   state)
  :guard (and (<= count (- (cardinality set) (len acc)))
              (<= 0 prob)
              (<= prob 1))
  :returns (mv (list nat-listp)
               state)
  (b* (((when (int= count 0))
        (mv acc state))
       ((mv in state) (random-boolean prob state))
       ((mv nat shuffled state)
        (if in
            (b* (((mv nat shuffled) (get-nat-in shuffled)))
              (mv nat shuffled state))
          (b* (((mv nat state) (get-nat-not-in max set state)))
            (mv nat shuffled state)))))
    (mk-nat-list-in-prob-acc (- count 1)
                             max
                             prob
                             set
                             shuffled
                             (cons nat acc)
                             state)))

(define mk-nat-list-in-prob
  ((length natp)
   (max posp)
   (prob rationalp)
   (set acl2-number-setp)
   state)
  :guard (and (<= length (cardinality set))
              (<= 0 prob)
              (<= prob 1))
  :returns (mv (list nat-listp)
               state)
  (b* (((mv shuffled state)
        (set-shuffled-elements set state)))
    (mk-nat-list-in-prob-acc length max prob set shuffled nil state)))
