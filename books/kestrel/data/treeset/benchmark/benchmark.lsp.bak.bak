; Copyright (C) 2025 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Author: Grant Jurgensen (grant@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "TREESET")

(include-book "std/util/bstar" :dir :system)
(include-book "std/util/define" :dir :system)

(include-book "../set-defs")
(include-book "../in-defs")
(include-book "../cardinality-defs")
(include-book "../insert-defs")

(include-book "random")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defttag :benchmarking)
(set-raw-mode t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "COMMON-LISP")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun mk-random-nat-set (cardinality max)
  (multiple-value-bind
   (set state)
   (treeset::mk-random-nat-set cardinality max acl2::state)
   set))

(defun mk-random-nat-oset (cardinality max)
  (multiple-value-bind
   (set state)
   (treeset::mk-random-nat-oset cardinality max acl2::state)
   set))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun measure (fn)
  (let ((start (get-internal-real-time)))
    (funcall fn)
    (/ (- (get-internal-real-time) start)
       internal-time-units-per-second)))

;; (defun benchmark (fn &key (iterations 100))
;;   (let ((times (sort
;;                 (loop repeat iterations
;;                       collect (funcall fn))
;;                 #'<)))
;;     (nth (floor iterations 2) times)))
;;
;; (defun benchmark-measure (fn &key (iterations 100))
;;   (benchmark (lambda () (measure (funcall fn)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun get-random-in (vec length)
  (aref vec (random length)))

(defun get-random-nat-not-in (set max)
  (let ((nat (random max)))
    (if (treeset::in nat set)
        (get-random-nat-not-in max set)
      nat)))

(defun get-random-not/in (list-length set max prob)
  (let* ((vec (coerce (treeset::to-oset set) 'vector))
         (set-length (length vec)))
    (loop repeat list-length
          collect (if (cond ((= prob 0) nil)
                            ((= prob 1) t)
                            (t (< (random 1.0) prob)))
                      (get-random-in vec set-length)
                      (get-random-nat-not-in set max)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun format-duration (seconds)
  (cond ((>= seconds 1)
         (format nil "~,4Fs" seconds))
        ((>= seconds 1/1000)
         (format nil "~,4Fms" (* seconds 1000)))
        ((>= seconds 1/1000000)
         (format nil "~,4FÂµs" (* seconds 1000000)))
        (t
         (format nil "~,4Fns" (* seconds 1000000000)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun benchmark-in-=-nat-set (max length prob iterations)
  (let* ((_ (format t "Generating set.~%"))
         ;; Generating the set takes a *long* time.
         (set (mk-random-nat-set length max))
         (_ (format t "Done generating set. Generating elements.~%"))
         (elems (get-random-not/in iterations set max prob))
         (_ (format t "Done generating elements (prob = ~,2F). ~
                       Running benchmark.~%"
                    prob))
         (start (get-internal-real-time))
         (metrics
           (loop for elem in elems
                 ;; collect (measure (lambda () (treeset::in elem set :test =)))))
                 collect (treeset::in elem set :test =)))
         (end (get-internal-real-time))
         (total (/ (- end start) internal-time-units-per-second))
         (time-per (/ total iterations))
         (_ (format t "Done running benchmark.~%"))
         (_ (format t "Total time: ~A~%" (format-duration total)))
         (_ (format t "Average time: ~A~%" (format-duration time-per)))
         )
    nil))

(benchmark-in-=-nat-set (expt 2 60) 100 0 1000000)
(benchmark-in-=-nat-set (expt 2 60) 100 0.5 1000000)
(benchmark-in-=-nat-set (expt 2 60) 100 1 1000000)

(benchmark-in-=-nat-set (expt 2 60) 1000 0 1000000)
(benchmark-in-=-nat-set (expt 2 60) 1000 0.5 1000000)
(benchmark-in-=-nat-set (expt 2 60) 1000 1 1000000)

(benchmark-in-=-nat-set (expt 2 60) 10000 0 1000000)
(benchmark-in-=-nat-set (expt 2 60) 10000 0.5 1000000)
(benchmark-in-=-nat-set (expt 2 60) 10000 1 1000000)

(benchmark-in-=-nat-set (expt 2 60) 100000 0 1000000)
(benchmark-in-=-nat-set (expt 2 60) 100000 0.5 1000000)
(benchmark-in-=-nat-set (expt 2 60) 100000 1 1000000)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun benchmark-insert-=-nat-set (max length prob iterations)
  (let* ((_ (format t "Generating set.~%"))
         ;; Generating the set takes a *long* time.
         (set (mk-random-nat-set length max))
         (_ (format t "Done generating set. Generating elements.~%"))
         (elems (get-random-not/in iterations set max prob))
         (_ (format t "Done generating elements (prob = ~,2F). ~
                       Running benchmark.~%"
                    prob))
         (start (get-internal-real-time))
         (metrics
           (loop for elem in elems
                 ;; collect (measure (lambda () (treeset::in elem set :test =)))))
                 collect (treeset::insert elem set :test =)))
         (end (get-internal-real-time))
         (total (/ (- end start) internal-time-units-per-second))
         (time-per (/ total iterations))
         (_ (format t "Done running benchmark.~%"))
         (_ (format t "Total time: ~A~%" (format-duration total)))
         (_ (format t "Average time: ~A~%" (format-duration time-per)))
         )
    nil))

(benchmark-insert-=-nat-set (expt 2 60) 100 0 1000000)
(benchmark-insert-=-nat-set (expt 2 60) 100 0.5 1000000)
(benchmark-insert-=-nat-set (expt 2 60) 100 1 1000000)

(benchmark-insert-=-nat-set (expt 2 60) 1000 0 1000000)
(benchmark-insert-=-nat-set (expt 2 60) 1000 0.5 1000000)
(benchmark-insert-=-nat-set (expt 2 60) 1000 1 1000000)

(benchmark-insert-=-nat-set (expt 2 60) 10000 0 1000000)
(benchmark-insert-=-nat-set (expt 2 60) 10000 0.5 1000000)
(benchmark-insert-=-nat-set (expt 2 60) 10000 1 1000000)

(benchmark-insert-=-nat-set (expt 2 60) 100000 0 1000000)
(benchmark-insert-=-nat-set (expt 2 60) 100000 0.5 1000000)
(benchmark-insert-=-nat-set (expt 2 60) 100000 1 1000000)
